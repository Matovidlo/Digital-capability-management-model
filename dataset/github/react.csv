Issue id,Status,Summary,Issue Type,Created,Author,Resolution,Resolved,Description,Creator,Labels
21224,OPEN,React-refresh not apply updates to the umd bundled library,Status: Unconfirmed,2021-04-09 21:19:19 +0000 UTC,yekver,,"In my case an application is based on micro-frontends solution and all updates related to the host application are applies successfully. Unfortunately, plugin application (bundled as a `umd` library) unable to apply any updates related to the react components scope. It should be noticed that `css` styles and code located outside the react component declaration scope are applied without any problems.

In the network tab I can see that all changes were successfully received and console notifies me that changes are applied and `App is up to date!`, unfortunately there is no visual or logic changes and UI keeps the stale state. Only full reload can fix the situation.

Some architecture details:
Host and Plugin apps are served on different ports. Host app provides exposed to `global` scope instances of `react` / `react-dom` and `react-refresh`. All of these packages are in the same bundle. Plugin app use [externals](https://webpack.js.org/configuration/externals/) property to get all the exposed react stuff. `react-refresh-webpack-plugin` and `react-refresh/babel` are defined in both Plugin and Host app webpack configs.

Packages version:
```
react-refresh-webpack-plugin: 0.5.0-beta.1
react-refresh: 0.9.0
react: 16.13.1
webpack: 5.27.2
webpack-dev-server: 4.0.0-beta.2
```
",,
21220,OPEN,Extending useState result with getState,,2021-04-10 16:12:38 +0000 UTC,YuriGor,,"Hi, it's an often case when we cannot rely on current state value given by useState, e.g. if we need this current value inside some function - it will be 'stale'. 
One of the ways to really get latest state is to call setState method given by useState and pass callback as an argument to the setState, so this callback will receive up to date state value. 
For myself I created a wrapper for useState, which is giving third result array element, and this element is getState function:

```js
import { useState } from 'react';

export default function useGetState(defaultState) {
  const [state, setState] = useState(defaultState);
  return [
    state,
    setState,
    () => {
      let value;
      setState((old) => {
        value = old;
        return old;
      });
      return value;
    },
  ];
}
```

usage example:
```js
const [state, setState, getState] = useGetState(111);
function(){
   const latestState = getState();
}
```

As you see this getState function is just non-mutating call of setState just to grab the fresh state value.

It would be great to extend the original useState hook in a similar, but, maybe, a bit more efficient way, 
because I believe original setState makes some extra stuff not needed if we only need to get state and nothing more.",,
21218,OPEN,"Error: ""Cannot read property 'replace' of undefined""",Component: Developer Tools; Resolution: Needs More Information; Status: Unconfirmed,2021-04-09 14:01:43 +0000 UTC,mikethejet,,"Describe what you were doing when the bug occurred:
1.  run expo app in a web browser
2. it uses WebView component
3. WebView not loaded so i look to console..

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.10.1-f160547f47

Call stack: at formatSourceForDisplay (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32085:27)
    at Source (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32123:6)
    at Hh (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:12807:7)
    at mk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:16012:11)
    at lk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15459:11)
    at kk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15451:23)
    at ck (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15435:5)
    at Wj (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15047:105)
    at I (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17261:17)
    at MessagePort.Q.port1.onmessage (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17300:7)

Component stack: at Source (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32105:3)
    at div
    at InspectedElementView_InspectedElementView (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:31992:3)
    at div
    at InspectedElementWrapper (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32192:50)
    at Suspense
    at NativeStyleContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:31435:3)
    at div
    at div
    at InspectedElementContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28921:3)
    at OwnersListContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:27558:3)
    at SettingsModalContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28206:3)
    at Components_Components (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:33383:52)
    at ErrorBoundary_ErrorBoundary (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29219:5)
    at PortaledContent (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29336:32)
    at div
    at div
    at ProfilerContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32934:3)
    at TreeContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24322:3)
    at SettingsContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24811:3)
    at ModalDialogContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29404:3)
    at DevTools_DevTools (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:36207:3)",,
21213,OPEN,React Developer Tools chrome extension not detecting react,Component: Developer Tools; Resolution: Needs More Information,2021-04-09 03:17:51 +0000 UTC,arcman7,,"Google Chrome
Version 89.0.4389.114 (Official Build) (x86_64)

macOS Big Sure
Version: 11.2.3 (20D91)

I'm developing on localhost. All-access, including file-urls and incognito mode, are allowed. 

Weird thing is the redux tool seems to be working just fine.

EDIT: I just realized that having a particular URL pattern breaks the react detection:
`http://localhost:3000/fakeframe/?link=http://localhost:3000/some/feature-im-working-on`
It's not using an iframe or anything, just a particular URL format used when doing certain things on our app. 

My problem is solved, but I'll leave this open for bug exposure in case anyone else runs into this.",,
21212,OPEN,Bug: iOS VoiceOver announces stale content in headings,Component: DOM; Status: Unconfirmed; Type: Needs Investigation,2021-04-09 16:24:07 +0000 UTC,JeffreyATW,,"1. Go to https://jeffreyatw.com/static/voiceover-react using iOS, enable VoiceOver
2. Swipe to first ""Not clicked"" h2, observe VoiceOver reads content correctly
3. Click the first ""click me"" button
4. Move VoiceOver's focus back to first h2, which is now ""Clicked""
5. VoiceOver **incorrectly** reads it as ""Not clicked, heading level 2""
6. Swipe to the second ""Not clicked"" h2, observe VoiceOver reads content correctly
7. Click the second ""click me"" button
8. Move VoiceOver's focus back to second h2, which is now ""Clicked""
9. VoiceOver correctly reads it as ""Clicked, heading level 2""

<!--



  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://jeffreyatw.com/static/voiceover-react

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
VoiceOver reads the first h2 as ""Not clicked, heading level 2"". See attached video for more details:
https://user-images.githubusercontent.com/266170/114103859-b4b51680-987e-11eb-82b9-0d785442c3ae.mp4

## The expected behavior
VoiceOver should read the first h2 as ""Clicked, heading level 2""
",,
21206,OPEN,Cannot Found Out The Error,Resolution: Needs More Information; Status: Unconfirmed,2021-04-09 17:13:57 +0000 UTC,Rajan-max,,"I have already tried all the solutions mentioned still none of them works.Neither the reasons are matching with my error..Please Help
![Screenshot (6)](https://user-images.githubusercontent.com/51814768/114024440-c8b74300-9893-11eb-8633-2cd949e4cd3c.png)

",,
21190,OPEN,Community creation,,2021-04-08 01:30:06 +0000 UTC,gustavochermout,,"Hello, I would like to know if I need any authorization from facebook or anyone can create a new community to discuss react topics, be it creating a website, using discord, instagram posts, podcasts...

In the issue #12570, it was said that the React logo is licensed under **Creative Commons Attribution 4.0**. Therefore, I am in doubt as to whether I can use it as logo of community due to the license's trademark restrictions.

Thanks! :)",,
21181,OPEN,Bug: [Refresh] Default exported unnamed functions are ignored,Status: Unconfirmed,2021-04-06 07:36:06 +0000 UTC,davidbonnet,,"React version: 17.0.2
React-refresh version: 0.10.0

This issue is similar to #21179, but ignores default exported unnamed functions instead.

As a code comment suggests, this is a known limitation:
https://github.com/facebook/react/blob/a817840ea7d3818c0590cccb9159b13220f4fdb4/packages/react-refresh/src/ReactFreshBabelPlugin.js#L437-L438

Would a fix be considered?

## Steps To Reproduce

Given the following files, making changes to `Component.js` doesn't trigger a re-render.

`main.js` module:
```jsx
import React from 'react'
import { render } from 'react-dom'

import Component from './Component.js'

function App() {
  return <main><Component /></main>
}

render(<App />, window.document.getElementById('root'))
```

`Component.js` module:
```jsx
import React from 'react'

export default ({ value = ""Hello"" }) => (<div>{value}</div>)
```


## The current behavior

Making changes to `Component.js` does not re-render the element in `main.js`.
The transformed `Component.js` module does not register the `Component` for refresh.


## The expected behavior

Making changes to `Component.js` does re-render the element in `main.js`.",,
21179,OPEN,Bug: [Refresh] Components resulting of HOCs composition immediately applied to render functions are ignored,Status: Unconfirmed,2021-04-05 20:57:58 +0000 UTC,davidbonnet,,"React version: 17.0.2
React-refresh version: 0.10.0

## Steps To Reproduce

Given the following files, making changes to `Component.js` doesn't trigger a re-render.

`main.js` module:
```jsx
import React from 'react'
import { render } from 'react-dom'

import { Component } from './Component.js'

function App() {
  return <main><Component /></main>
}

render(<App />, window.document.getElementById('root'))
```

`Component.js` module:
```jsx
import React, { memo } from 'react'
import { compose, withProps } from 'recompose'

export const Component = compose(memo, withProps({ value: 'Hello' }))(({ value }) => (<div>{value}</div>))
```


## The current behavior

Making changes to `Component.js` does not re-render the element in `main.js`.
The transformed `Component.js` module does not register the `Component` for refresh.


## The expected behavior

Making changes to `Component.js` does re-render the element in `main.js`.",,
21175,OPEN,Bug: unable to see the components in the components tab,Component: Developer Tools; Resolution: Needs More Information; Status: Unconfirmed,2021-04-08 18:06:35 +0000 UTC,plegault3397,,"
Installed the react development tools to chrome Version 89.0.4389.114 (Official Build) (64-bit)
Open my development version of my react app localhost:3000 with several components and I see the react icon
![image](https://user-images.githubusercontent.com/7073595/113520660-a1463a80-9562-11eb-9b6d-82919344c146.png)
Go to the inspect and component to and nothing is showing
![image](https://user-images.githubusercontent.com/7073595/113520674-ccc92500-9562-11eb-87d0-5068abc150e1.png)

I'm using this chode https://codesandbox.io/s/react-devtools-dk9gj?fontsize=14
and when you open this in chrome it works.
I open it from localhost and it does not work.
![image](https://user-images.githubusercontent.com/7073595/113520835-d2733a80-9563-11eb-88cb-7bb6d6b30ade.png)




    ""react"": ""16.8.6"",
    ""react-dom"": ""16.8.6"",
    ""react-scripts"": ""^4.0.3""
npm --version 7.6.3
nodejs v14.16.0


## Steps To Reproduce

1.
2.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior


## The expected behavior
",,
21159,OPEN,Bug: getting console error for live grid randomly,Status: Unconfirmed,2021-04-01 09:46:40 +0000 UTC,pankaj247software,,"
while working with live grid using react js, giving console error randomly and in that, log mentions,  issue might be at react js file and issue
so could you please help that what is meaning of that or how to fix that

**console error shows as follow,

Invariant Violation: Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.**

",,
21158,OPEN,Bug: react-test-renderer: Cannot read property 'removeEventListener' of null on snapshot,Status: Unconfirmed,2021-04-01 01:39:39 +0000 UTC,chrys-exaucet,,"
I havethis stack trace while taking a snap of a custom file reader:. The componet is working well execpt in this snapshot that involves react-test-render. It throws this error:



`  console.error
    Error: Uncaught [TypeError: Cannot read property 'removeEventListener' of null]`





Here is my stack

jest@26.6.0
react-router@6.0.0-beta.0
react-router-dom@6.0.0-beta.0
react@17.0.1
typescript@4.2.3

## Steps To Reproduce

```js

// component

import React from 'react';
import { CSVReader } from 'react-papaparse';


interface CustomtReaderProps {
  onFileLoaded?: ((data: any, file?: any) => void) | undefined;
}

export const CustomtReader: React.FC<OffreTransportReaderProps> = (props: CustomtReaderProps) => {

  const { onFileLoaded } = props;
  return (
    <CSVReader
      onFileLoad={onFileLoaded}
      accept='text/csv, .csv'
    >
      <span>{label}</span>
    </CSVReader>
  );

};

```

```` js


// test

describe('OffreTransportReader', () => {


  it('should match snapshot', () => {

    /* FIXME: in the renderer:  Uncaught [TypeError: Cannot read property 'addEventListener' of null]
                                Stacktrace:    Error: Uncaught [TypeError: Cannot read property 'addEventListener' of null]
                                hint: possibly due to the renderer method of  @react-test-render
 */


    const handleFileUploaded = jest.fn().mockImplementation();

    const tree = renderer
      .create(     // <--------------- **_error : TypeError: Cannot read property 'removeEventListener' of null_**
        <CustomtReader
          onFileLoaded={handleFileUploaded}
          label='Chargez votre offre'
        />,
      )
      .toJSON();
    expect(tree).toMatchSnapshot();
  });
});


````

## The current behavior
Error: Uncaught [TypeError: Cannot read property 'addEventListener' of null]

## The expected behavior

Test passes
",,
21139,OPEN,[Fast Refresh] Don’t Scan the Tree,Component: Fast Refresh; Difficulty: challenging; React Core Team; Resolution: Backlog,2021-03-30 12:17:44 +0000 UTC,gaearon,,"We had a conversation with @sebmarkbage about https://github.com/facebook/react/issues/20417. He had a different implementation idea that should resolve such issues. I probably won't do this now but I want to write it down for future reference.

Currently, after we gather a list of types that need to be updated in the tree, we scan the tree and tag Fibers to be updated. This happens [here](https://github.com/facebook/react/blob/0853aab74dc8285401e62d1e490551ba3c96fd64/packages/react-reconciler/src/ReactFiberHotReloading.new.js#L267-L339). But like https://github.com/facebook/react/issues/20417 shows, this doesn't work if the type is not in the tree. E.g. if the function we changed is only being called directly, and its ""type"" is not the actual wrapper that exists in the tree.

An alternative implementation could instead inject a special Hook call into each registered component. For example by generating a wrapper. That Hook would return the latest actual implementation, _and_ schedule updates on itself when it changes. Which means there would be no need to scan the tree at all. Instead, each component would register itself for updates. For false positives outside of React rendering, the Hook would just be callthrough so it wouldn't break anything.

This seems like a pretty significant change to the implementation so I'm probably not going to work on this now. Maybe we could consider it next time we need to change the implementation details. Or maybe somebody sufficiently motivated wants to hack on this. I can provide some code pointers but it’s not a beginner-friendly issue.",,
21137,OPEN,Another Fiber structure without return pointer.,Status: Unconfirmed,2021-03-30 07:16:53 +0000 UTC,yisar,,"https://twitter.com/acdlite/status/1369894466308497411

This is a tweet from @acdlite , which I think is worth thinking about and recording

The current react fiber linked list structure does limit the implementation of few algorithms, such as the right to left diff algorithm based on the longest incremental subsequence.

Is there a new structure that doesn't need a return pointer? What should it look like?

It's easy to delete alternative pointer, but what about the return pointer? Is there a new structure to replace it?",,
21128,OPEN,Remove DevTools dependency on host node internalInstanceKey,Component: Developer Tools,2021-03-29 18:24:13 +0000 UTC,bvaughn,,"React uses a pseudo-randomly-generated `internalInstanceKey` key field is used to store a reference on a host node (e.g. `HTMLDivElement`) to the Fiber that created it:
https://github.com/facebook/react/blob/634cc52e6174b506dee79d908f50ce1ee19f4fbf/packages/react-dom/src/client/ReactDOMComponentTree.js#L56-L61

This pointer in turn is used by a few things:
* Event propagation: Will not be necessary if event listeners are added directly to the host node rather than the root.
* Partial hydration: Unsure (unfamiliar with this code.
* DevTools host element inspection: See below.

The DevTools dependency is on `getClosestInstanceFromNode`:
https://github.com/facebook/react/blob/634cc52e6174b506dee79d908f50ce1ee19f4fbf/packages/react-dom/src/client/ReactDOMComponentTree.js#L75-L155

This could be removed if DevTools implemented its own `precacheFiberNode` behavior when Fibers mounted and unmounted. The trick would be walking the host component tree if a DOM node wasn't directly owned by React. Fortunately HTML elements have `parentNode` pointers which would make this trivial (at least for the web extension).

The standalone DevTools (in the case of React Native) would not be able to support this, but standalone doesn't support this mode of inspection anyway, so we should be clear to remove this dependency.",,
21094,OPEN,Bug: Radio/Checkbox inputs not triggered when setting state in listener on a parent element,Component: DOM; Status: Unconfirmed; Type: Bug,2021-04-06 20:19:38 +0000 UTC,kotliluk,,"Hello

I wanted to highlight a div after clicking on it (and hide the highlight after clicking anywhere else). So in componentDidMount, I added two event listeners (on the div and on the window object).
The problem is kind of wild: when I use setState in a listener added in componentDidMount, radio buttons are not triggered.
When the listener does not use setState or uses setTimeout(() => this.setState(...), 0), radio buttons works expectedly.
When creating a code example, I also tried checkboxes, and they do not work as well. BUT, for example, button inputs work expectedly.

React version: 16.13.1 (in my app), 17.0.2 (in code sand box) - issue is in both of them

## Steps To Reproduce

You can use this prepared code example: https://codesandbox.io/s/react-setstate-listener-input-bug-wjsdk
The example also shows other listeners set ups which work expectedly.

## Current possible workaround

As mentioned earlier, we can use setTimeout(() => this.setState(...), 0) to gain expected behavior, but it is not a bug fix.",,
21091,OPEN,Bug: The invalid value warning was showed when adding functions to object prototype,Status: Unconfirmed,2021-03-25 06:36:01 +0000 UTC,virtuous-code,,"While adding a function to Object.prototype in React project anywhere, react while showing the Warning: Invalid value for prop \`xxx\` on tag. And an uncaught TypeError.

React version: 17.0.2

## Steps To Reproduce

1. Create a react project with create-react-app
2. Put the following code anywhere in the project: `Object.prototype.test = function () {}`
<img width=""876"" alt=""图片"" src=""https://user-images.githubusercontent.com/9192537/112427671-f02aed80-8d74-11eb-8b23-8f5fa9683d2d.png"">

## The current behavior
Getting the warning
![图片](https://user-images.githubusercontent.com/9192537/112427330-64b15c80-8d74-11eb-9c24-5b7eff138ca9.png)
Also the Uncaught TypeError: renderer.setTraceUpdatesEnabled is not a function.
![图片](https://user-images.githubusercontent.com/9192537/112429126-35501f00-8d77-11eb-8361-28ac8db8a7fe.png)

## The expected behavior
Expected nether warning nor error.",,
21078,OPEN,Bug: Incorrect error message,Status: Unconfirmed,2021-04-01 08:57:17 +0000 UTC,toschlog,,"I'm getting this error message:

  React Hook ""useStyles"" is called conditionally. React Hooks must be called in the exact same order in every component render

However, I'm pretty darn sure that I'm not actually calling useStyles conditionally.  Also, the error messages come and go if I comment out unrelated code.

React version: 17.0.1

## Steps To Reproduce

1. Attempt to run my app

Unfortunately this error only happens with one particular big source file.  I don't see an easy way to show it to you without sending my whole project.  I don't mind doing that, however.
",,
21059,OPEN,Bug: Nondeterministic first render,Status: Unconfirmed,2021-04-07 16:37:02 +0000 UTC,bennettdams,,"It is possible that this is not a bug, but rather expected - I couldn't find any material on the internet for this particular use case though.

React version: v17.0.1

*TL;DR   React sometimes renders a loading state and sometimes not, without changes in the UI. Maybe this has something to do with [batched updates][1], where the initial state and the next state are batched?*


## Steps To Reproduce

[![See on CodeSandbox](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/react-nondeterministic-rendering-vh47i?file=/src/App.tsx)

[![enter image description here][3]][3]

Here's the setup, a chart that takes a *long* time to render. So long that the render is blocking. There are three different ways to render the chart here:

 1. the ""normal"" way
 2. with a ""mounted"" render hack
 3. with the same ""mounted"" render hack, but with an additional `setTimeout`

Option 2 & 3 both have a small `useState` to check whether they've been mounted. I do this to show a ""Loading"" state conditionally:


```tsx
function ChartWithMountHack({ data }: { data: Data }) {
  // initially not mounted
  const [isMounted, setIsMounted] = useState<boolean>(false);

  useEffect(() => {
    // ""Now I've been mounted!""
    setIsMounted(true);
  }, []);

  return !isMounted ? <p>Loading</p> : <Chart data={data} />;
}
```
I did this, because I want to show a ""Loading"" state instead of a blocking render, so e.g. page switches or ternary rendering (e.g. `hasData ? <p>No data</p> : <Chart />`) are shown immediately, instead of blocking. **(If there are better ways, please let me know!)**



## The current behavior

Now, each button will render one of the three options/charts. Again, the second and third chart have a small hack to check whether they're mounted or not.

Try clicking on the first button and the second button back & forth quickly.
You will see that sometimes the ""Chart with mount hack"" will (""correctly"") render the ""Loading"" state, but sometimes it just doesn't render the ""Loading"" - instead it blocks the render up until the chart is finished rendering (skips the ""Loading"" state).

I think this is due to the render cycles and whether you get the two updates in one cycle of the batching. (first: `isMounted === false` -> second: `isMounted === true`)

I can't really tell how to reproduce this, hence the ""nondeterministic"" in the title. Sometimes you also have to click on ""Regenerate data"" and click back & forth after that. 

## The expected behavior


Option 3 (""Chart with mount hack with timeout"") ALWAYS gives me the ""Loading"" state, which is exactly what I want. The only difference to option 2 is using a `setTimeout` in the `useEffect` where `isMounted` is set to true. [`setTimeout` is used here to break out of the update batching.][2]

Is there a better way to opt-out of the batching, so `isMounted` will always render with its initial value (`false`)?  


Shouldn't the first render and its initial values be outside of the batched updates? If not, how can I tell React to do so (given that stuff like async/`setTimeout`/.. are just ""hacks"" to circumvent that right now)?


  [1]: https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973
  [2]: https://github.com/facebook/react/issues/14259#issuecomment-439632622
  [3]: https://i.stack.imgur.com/2opgKm.png
",,
21057,OPEN,Bug: useState with class as initial state throws an error,Status: Unconfirmed; Type: Discussion,2021-03-31 02:37:37 +0000 UTC,jneuendorf,,"Using a JavaScript class as initial state in `useState` throws an error. This is because `mountState` check if the initial state is a function by `typeof initialState === 'function'` and classes are technically functions. However since ES6+, I feel like most developers don't consider classes functions because of the less prototype-inheritance feel since ES6 and the `class` keyword.


React version: 17.0.2


## Steps To Reproduce

1. Define an ES6 class
2. Use the class as `initialState` argument to `useState`

Code example:

```jsx
import { useState } from ""react"";
import ReactDOM from ""react-dom"";

class A {}

function App() {
  const [cls, setCls] = useState(A);
  return <h2>{cls.name}</h2>;
}

ReactDOM.render(<App />, document.body);
```

## The current behavior

```
TypeError: Cannot call a class as a function
    at _classCallCheck (eval at z (eval.js:42), <anonymous>:3:11)
    at A (VM302 index.js:19)
    at mountState (react-dom.development.js:10436)
    at Object.useState (react-dom.development.js:10919)
    at useState (react.development.js:954)
    at App (VM302 index.js:25)
```

Alternatively, the error can be `TypeError: Class constructor X cannot be invoked without 'new'`.


## The expected behavior

As mentioned in the description above, I would 

- either expect classes to work
- or mention this caveat in the docs.

I guess checking, if the initial state is actually a non-class function, could cause instances of subclasses of functions not to work (depending how the check is done).
",,
21049,OPEN,Bug: `onMouseEnter` triggered twice on target when there's space around it; and ReactDOM.createPortal is used to render something else,Component: DOM; Status: Unconfirmed,2021-03-23 11:40:47 +0000 UTC,benoitgrelard,,"React version: 17

## Steps To Reproduce

1. Hover the button
2. Note the double log produced

Link to code example: https://codesandbox.io/s/react-mouseenter-bug-uyswr?file=/src/App.js

## The current behavior

The `onMouseEnter` is triggered twice.

## The expected behavior

The `onMouseEnter` should be triggered only once.

---

A few more notes:
- I've tested on React 16.14 and it seems that bug only appeared in 17. (I can see it in the first ever 17 rc as well).
- It's specifically when something happens to be portalled on the page too (you'll see if you don't render in a portal, no issue)
- It is also linked to the fact there's space around the target that gets moused over. You'll notice that if you comment out the heading below for example and you mouse-enter coming from the bottom, the bug won't be there. But it will be at the top. Similarly if we you keep the headings rendered, but override their margins to be 0 such that there's no gap between the heading and the button, it won't happen either.

I'm conscious this is all really odd but I haven't been able to find out exactly what's happening here…
",,
21043,OPEN,Feature request: Consider supporting AbortSignal/AbortController for cleanup,Status: Unconfirmed,2021-04-09 13:59:18 +0000 UTC,benjamingr,,"Hey, I've recently worked on adding support for `AbortController/AbortSignal` in a bunch of Node.js APIs and some DOM ones and I think it would be really cool if React added support to the web platform's cancellation standard primitive.

Basically the ask is:

```js
//before
useEffect(() => {
  const ac = new AbortController();
  (async () => {
    const data = await fetch('./api', { signal: ac.signal }).then(x => x.json());
    setData(data);
  })();
  return () => ac.abort();
});
//after
useEffect(async (signal) => {
  const data = await fetch('./api', { signal }).then(x => x.json());
  setData(data);
});
```

Or with events:
```js
//before
useEffect(() => {
   const listener = (message) => setMessage(process(message));
   myApi.addEventListener(""message"", listener);
   return () => myApi.removeEventListener(""message"", listener);
});
//after
useEffect(async (signal) => {
  myApi.addEventListener(""message"", (message) => setMessage(process(message)), { signal });
});
```

I can bring in more examples. It's also possible to keep the API compatible with the existing API or create the AbortSignal lazily to minimize performance impact.

Apologies if I opened this in the incorrect place :)",,
21035,OPEN,Bug: aria-description is a valid ARIA property,Component: DOM; Status: Unconfirmed,2021-04-03 18:30:36 +0000 UTC,nordfjord,,"1. `render(<div aria-description=""Description"" />)`

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
[flems link](https://flems.io/#0=N4IgZglgNgpgziAXAbVAOwIYFsZJAOgAsAXLKEAGhAGMB7NYmBvAHgBMIA3AAgjYF4AOiAwAHUcIB8gtN24yWAeg6dJlEHBixqxCPQSIQARkQAmEAF8K6bLkP4AVgip0GTYngBKMDDoAiAPIAsvgATkxsMKEAFOxc3BihEBgAtJFw1EmiuvRCIH7wmRDZemjC3IqSFAniAJTqdFii0FF4AEYYbVqW1iCYOHj41HDONPSMzIaWALpUUBBoANYGqH22eOG+xPiRnFq0ojgMjqMArqHkhiTEonCIioqnaKKLAOZDtFiKmzoAAkYAdnwAAZ8EZHlg2N8fDodjA9lADkdtk51MQAJ6iOwaIrZHo2AaGH7ENKfOEIpHuE7qc6XEDXW73R7PN4fL7E0lYf5A0Hg06Q6FbTnk-aHKmoqgYrF4DJZDwWaYWIA)

## The current behavior
```
warning: Invalid aria prop `aria-description` on <div> tag
```

## The expected behavior
Nothing. It's part of WAI-ARIA 1.3

https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Annotations",,
21031,OPEN,Bug: Creating a portal within a shadow root breaks event handlers,Status: Unconfirmed,2021-03-18 11:47:37 +0000 UTC,ablamunits,,"React version: 16.14.0

## Steps To Reproduce

https://codesandbox.io/s/stupefied-heyrovsky-3i59t?file=/src/index.tsx

1. Open the link above and click the button that will render an input field. This will render the input elsewhere within the shadow dom.
2. Blur the input field. It is expected that `OK` is logged to the console, but nothing is logged.

A few things I noticed that would resolve the issue:

1. Removing the portal will result in `OK` being logged correctly on blur.
2. Adding an `<input hidden />` that otherwise does nothing will result in `OK` being logged correctly on blur.
3. Removing the use of `useState` will result in `OK` being logged correctly on blur.
4. Removing the shadow dom
5. Upgrading to React 17

Link to code example:

https://codesandbox.io/s/stupefied-heyrovsky-3i59t?file=/src/index.tsx

## The current behavior

Event handlers break when using a portal within the shadow dom in certain (quite sneaky) circumstances.

## The expected behavior

The events should work correctly within the shadow dom when using portals
",,
21025,OPEN,Bug: HTMLSelectElement.value doesn't update to defaultValue on form reset,Status: Unconfirmed,2021-03-23 03:55:20 +0000 UTC,cl8n,,"For uncontrolled inputs, [docs here](https://github.com/facebook/react/blob/master/fixtures/dom/src/components/fixtures/text-inputs/README.md#form-reset-events) say that `reset()`ing a form should change all inputs' `value`s to `defaultValue`. This doesn't seem to be working for `HTMLSelectElement`.

React version: 17.0.1

## Steps To Reproduce

1. Set a `defaultValue` on \<select\> to some variable that can be changed later
2. Pick a different option
3. Change the value of variable from step 1
4. `reset()` the form containing the \<select\>

Link to code example: <https://codesandbox.io/s/cocky-curran-365wd?file=/src/App.js>

## The current behavior

The \<select\>'s value resets to its *initial* `defaultValue`, not the updated one.

In my codesandbox.io example you can see that it always resets to ""Zero"", regardless of how you update the `defaultValue`.

## The expected behavior

The \<select\>'s value should update to its current `defaultValue`.",,
21023,OPEN,react-devtools-inline package now has react@experimental dependency,Component: Developer Tools; Type: Bug,2021-03-18 14:39:10 +0000 UTC,bvaughn,,"I recently updated DevTools to use the new, experimental `getCacheForType` API (#20548) which works well for the browser and standalone extension versions, because they bundle their own version of React (the experimental release). This has left the `react-devtools-inline` package (used by e.g. Code Sandbox) in an unreleasable state though until the new Suspense APIs are released as stable.

Perhaps I could go back to the last commit prior to #20548 and do one final release, but then I will be blocked.",,
21002,OPEN,Bug: Unsupported HTML entities,Status: Unconfirmed,2021-03-17 07:29:51 +0000 UTC,fast-reflexes,,"Many of the HTML entities presented at https://dev.w3.org/html5/html-author/charref are not supported by React, why is this?

## Steps To Reproduce

Check https://codesandbox.io/s/react-unsupported-html-entities-yr9rj

## The current behavior

React recognizes some entities as string literals which may cause problems when the browser in question in fact supports the entity but React tricks the browser into thinking that it is a string, just because React doesn't seem to recognize it.

## The expected behavior

The symbol that the entity should yield.
",,
20990,OPEN,Bug: performing input.select() in IE11 throws a React error,Browser: IE; Status: Unconfirmed; Type: Bug,2021-03-17 00:01:42 +0000 UTC,Dremora,,"The example below is extracted from the app with a spreadsheet-like UI, where cells become editable upon focus (can be achieved either by tabbing into the cells or clicking). The text in such cell immediately becomes selected.

The bug occurs only in IE11, as the user navigates from one such cell to another by clicking.
Likely related to https://github.com/facebook/react/pull/19664.

React version: 17.0.1

## Steps To Reproduce

1. Clone https://github.com/Dremora/react-i11-input-focus-bug
2. Install dependencies (`yarn`) and start the app (`yarn start`)
3. Open http://localhost:3000 in IE11
4. Click on the text saying `hello`
5. Click on the text saying `world`

Link to code example: https://github.com/Dremora/react-i11-input-focus-bug/blob/master/src/App.js

## The current behavior
`Unspecified error` gets logged to the console, followed a few other errors, one of them being `Should not already be working` error. As this is a React internals error, application stops working. Nothing gets thrown in the user-land code.

## The expected behavior
`world` text gets selected.",,
20981,OPEN,"Bug: Error message prints ""Warning: ..."" instead of ""Error: ...""",Status: Unconfirmed,2021-03-31 05:57:09 +0000 UTC,kokushkin,,"1. Go at https://codesandbox.io/s/warning-issue-formik-v2-tutorial-start-forked-lwtxx?file=/src/index.js and type something in the Tool ID field. This reproduces one of these errors-warnings..
2. Take a look in the console and you will see an Error but.. a Warning, or Error (in fact it's considered to be an error)... , which is simply confusing. 
![image](https://user-images.githubusercontent.com/9853656/110771670-6f8fcb80-8263-11eb-9f85-60026f9c52b0.png)


<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

## Link to code example: https://codesandbox.io/s/warning-issue-formik-v2-tutorial-start-forked-lwtxx?file=/src/index.js

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
prints: ""Warning: A component is changing an uncontrolled...""

## The expected behavior
should be ""Error: A component is changing an uncontrolled..."" here and in all such cases.



I've initially created #20912 (everything ok there) , but now I've dived deeper in this, I've read this #16753 and understand the concept. So now, the solution (that would be in alignment with #16753 by the way) would be simply to make minor changes here https://github.com/facebook/react/blob/master/packages/shared/consoleWithStackDev.js
![Expression-4 (1)](https://user-images.githubusercontent.com/9853656/110778391-f5fbdb80-826a-11eb-810a-1bcae85ace18.jpg)


and then run test and update  the red tests. Also, maybe in the consoleWithStackDev.www.js .. 

By the way, what is this about? (RN?))
> // Careful: RN currently depends on this prefix

Maybe this is why it wasn't done before?) 

Seems like a very obvious thing and I surprised nobody raised an issue (or maybe did but I could not find it).

Anything opposing these changes?


",,
20977,OPEN,Provide a way to propagate tracing context to async tasks,Status: Unconfirmed,2021-03-11 07:51:42 +0000 UTC,sfishel-splunk,,"Disclaimer: sorry for the overloaded terminology, the ""context"" I'm referring to here is tracing context (e.g. from OpenTelemetry), not React context.

My team is working on adding OpenTelemetry tracing to a React application. We have a working strategy for propagating the tracing context to hooks that don't do any asynchronous work, illustrated [here](https://gist.github.com/sfishel-splunk/17807939801054eb96a1d1a2b39f5d46#file-tracingexample-jsx). However, for hook logic that makes use of asynchronous flow - like `useEffect` - the tracing context does not propagate correctly, illustrated [here](https://gist.github.com/sfishel-splunk/17807939801054eb96a1d1a2b39f5d46#file-tracingexamplewithuseeffect-jsx).

We have a work-around to propagate the tracing context to `useEffect` callbacks, which looks something like this:

```js
useEffect(context.bind(() => {
  // context is now correctly propagated here
}), []);
```

This works, but it requires us to explicitly instrument all usage of asynchronous hooks like `useEffect` and `useLayoutEffect`, and it means that we can't propagate tracing context through hook logic in external libraries.

Ideally, we would be able to configure React to do this automatically, something along the lines of:

```js
React.addEffectProcessor(effect => context.bind(effect));
```

Thanks very much!",,
20966,OPEN,Bug: React test triggers mouseout event for disabled button,Component: DOM; Type: Bug,2021-03-12 00:15:38 +0000 UTC,tulsidaskhatri,,"1. Create a test file in a react project, and paste the following code.
2. Run the test
3. The test for onMouseLeave event fails.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

```javascript
import { act } from ""react-dom/test-utils"";
import React, { useState } from ""react"";
import ReactDOM from ""react-dom"";

const Counter = () => {
  const increaseCount = () => {
    setCount((prev) => prev + 1);
  };
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>You clicked {count} times</p>
      <button
        disabled
        onClick={increaseCount}
        onMouseEnter={increaseCount}
        onMouseLeave={increaseCount}
      >
        Click me
      </button>
    </div>
  );
};

describe(""button with react test-utils"", () => {
  let container;

  beforeEach(() => {
    container = document.createElement(""div"");
    document.body.appendChild(container);
  });

  afterEach(() => {
    document.body.removeChild(container);
    container = null;
  });

  it(""should not trigger onClick when button is disabled"", () => {
    act(() => {
      ReactDOM.render(<Counter />, container);
    });
    const button = container.querySelector(""button"");
    const label = container.querySelector(""p"");

    act(() => {
      button.dispatchEvent(new MouseEvent(""click"", { bubbles: true }));
    });

    expect(label.textContent).toBe(""You clicked 0 times"");
  });
  it(""should not trigger onMouseEnter when button is disabled"", () => {
    act(() => {
      ReactDOM.render(<Counter />, container);
    });
    const button = container.querySelector(""button"");
    const label = container.querySelector(""p"");

    act(() => {
      button.dispatchEvent(new MouseEvent(""mouseover"", { bubbles: true }));
    });

    expect(label.textContent).toBe(""You clicked 0 times"");
  });
  it(""should not trigger onMouseLeave when button is disabled"", () => {
    act(() => {
      ReactDOM.render(<Counter />, container);
    });
    const button = container.querySelector(""button"");
    const label = container.querySelector(""p"");

    act(() => {
      button.dispatchEvent(new MouseEvent(""mouseout"", { bubbles: true }));
    });

    expect(label.textContent).toBe(""You clicked 0 times"");
  });
});

```

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->


## The current behavior
<img width=""664"" alt=""Screenshot 2021-03-09 at 21 45 13"" src=""https://user-images.githubusercontent.com/2574511/110506309-c9d44380-8120-11eb-9164-ce2ae7316889.png"">


## The expected behavior
All tests should pass",,
20951,OPEN,Bug: React Dev tools keys not showing last letter in FF,Component: Developer Tools; Status: Unconfirmed; good first issue (taken),2021-04-01 17:22:00 +0000 UTC,bushblade,,"The FireFox dev tools crop off the last letter of the keys in state/props as you can see here.
![Screenshot_2021-03-08_08-13-36](https://user-images.githubusercontent.com/21976188/110293584-a907d300-7fe6-11eb-89dc-eb709ab31fdd.png)
This doesn't happen in the Chrome extension 
![Screenshot_2021-03-08_08-14-18](https://user-images.githubusercontent.com/21976188/110293623-b91fb280-7fe6-11eb-90ee-b9cbe550147b.png)
",,
20946,OPEN,Bug: error in effect cleanup function no longer catchable,Component: Reconciler; Type: Bug,2021-03-07 09:33:00 +0000 UTC,eps1lon,,"
1. Throw in an effect cleanup 
2. Try to catch it when wrapped in `act()`

Link to code example:
[React 16](https://codesandbox.io/s/react-16-throw-in-effect-destory-kdeij)
[React 17](https://codesandbox.io/s/react-17-throw-in-effect-destory-forked-5n864)

I also tested it locally and jest and couldn't catch the error as well.

## The current behavior

The error is uncatchable and does not include the component stack (""The above error occurred"").

## The expected behavior

The error is catchable and does include the component stack i.e. React 16 behavior.

## Context

I understand that the cleanup is now async but it's still flushed in `act()` so I would expect that an error thrown is catchable.

Originally reported in https://github.com/testing-library/react-testing-library/issues/874
",,
20923,OPEN,umd distribution for jsx-runtime,Status: Unconfirmed,2021-03-03 10:33:23 +0000 UTC,WGroenestein,,"Our module infrastructure relies on 3rd party dependencies to be available as global variables which we internally map in our module system. We are currently looking into updating to 17.x and utlize the new JSX Transform, however we noticed that there is no umd distribution for the jsx-runtime resulting in that we are not able to map this new dependency into our module system.

The reason why we have not switched over to a modern module/build system is that we are still in the progress of migrating (over time) our stack to be on top of react and in the current version (16.x) using the ""old"" JSX Transform we are able to achieve this through the provided umd distribution.

We could of course stick to 16.x or 17.x with the ""old"" JSX Transform, however with the rebase to react we kind of want to be future proof at the same time, so being on the new Transform would be preferred imo.

I do understand this might be a bit of a far reach due to the proprietary module infrastructure, but I think more people could benefit from having the jsx-runtime at hand as umd distribution.",,
20920,OPEN,Bug: onChange of input field firing twice on Android devices based on special conditions,Status: Unconfirmed,2021-04-06 09:12:24 +0000 UTC,bisho1995,,"In mobiles websites (tested on Android) and webviews, the `onChange` method of the input field is getting fired twice if 
1. The value of the input is updated in the store/state after some time interval, for example
```
handleChange = (val) => {
    setTimeout(() => {
      this.setState({ val });
    }, 20);
  };
```
2. The input value has two consecutive same numbers followed by a different number, for example
```
A112
```

So for the case of `A112`, it becomes `A11A112`

React version: Tested on 16.13.0 and 17.0.1

## Steps To Reproduce

Link to demo: https://gblww.csb.app/
Link to code example: https://codesandbox.io/s/input-field-bug-report-gblww
Demo video: https://user-images.githubusercontent.com/12195877/109746806-00c7c800-7bfc-11eb-90ea-0f5b469c5ddd.mp4




## The current behavior
The input field characters are repeating based on the above conditions

## The expected behavior
The input field characters should not repeat.",,
20904,OPEN,Bug: ESLint react-hooks/exhaustive-deps false positive on useCallback wrapped in function defined outside component scope,Component: ESLint Rules; Status: Unconfirmed,2021-03-01 15:26:17 +0000 UTC,lexanth,,"eslint-plugin-react-hooks version 4.2.0

## Steps To Reproduce

```
const fn = (someVariable) => () => {...}

const MyComponent = ({ someVariable }) => {
  const handleSomething = useCallback(fn(someVariable), [someVariable])

  ...
}
```
This gives ""React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead""

As noted [here](https://github.com/facebook/react/issues/19173), one could do:
```
const handleSomething = useCallback(() => fn(someVariable)(), [someVariable])
```

which keeps the linter happy. However, if `fn` was e.g. a debounce wrapper, that behaviour would be different.
```
const handleSomething = useCallback(debounce(() => doSomething(someVariable)), [someVariable])
// vs
const handleSomething = useCallback(() => debounce(() => doSomething(someVariable))(), [someVariable])
```

If `fn` is defined outside the component scope, it can't depend on anything else inside the component scope, so we should be safe to exclude it? I believe the linter uses a similar heuristic with ignoring variables defined outside the component scope, so I think this logic just needs adding to the special case for `useCallback` receiving a non-inline function.

Link to code example:
https://codesandbox.io/s/angry-greider-bq69s?file=/src/App.js

## The current behavior
useCallback with non-inline function declared outside function scope is a warning/error

## The expected behavior
useCallback with non-inline function declared outside function scope passes",,
20901,OPEN,Bug: Event handling with portals is broken,Status: Unconfirmed,2021-03-15 03:43:44 +0000 UTC,sag-tobias-frey,,"Event handling with portals is broken in the newest version when placing non-react event handlers BETWEEN other react event handlers. With the following setup **outer react event handler with stopPropagation** > **non-react event handler** > **inner react event handler (in portal)**. Doing the same without portals works correctly. 

React version: 17.0.1

## Steps To Reproduce
### With portal (not working)
1. https://stackblitz.com/edit/ag-grid-react-hello-world-gwuhed?devtoolsheight=33&file=index.js
2. Click on the div
3. Only inner and outer event handlers are called

### Without portal (working)
1. https://stackblitz.com/edit/ag-grid-react-hello-world-gwuhed?devtoolsheight=33&file=index.js
2. Comment out the portal code and comment in the non-portal code (line 24 / 25)
3. Click on the div
4. All three event handlers are triggered

Link to code example: https://stackblitz.com/edit/ag-grid-react-hello-world-gwuhed?devtoolsheight=33&file=index.js

## The current behavior

Non-react event handlers are not called when the initial event is initiated from a portal component and an outer react event handler calls stop propagation. This works correctly without portals.

## The expected behavior

The non-react event handler should also be called when a portal component initiates the event.",,
20895,OPEN,Bug: React roots are announced as clickable to screen readers,Component: DOM; Status: Unconfirmed,2021-02-26 13:50:25 +0000 UTC,TwoLaid,,"1. Activate your screen reader
   1. I used [NVDA](https://www.nvaccess.org/), but [JAWS](https://www.freedomscientific.com/products/software/jaws/) would also work
   1. This will not work with VoiceOver because it does not have the same heuristic about elements with click handlers
2. Go to a page that has one or more React 17 root nodes. For example: https://qc9xj.csb.app/
3. Use the regular navigation of your screen reader to explore the page
   1. In the case of NVDA, this would be using Arrow keys up and down
4. Hear your screen reader announcing the H2 as ""clickable""

Link to code example: https://codesandbox.io/s/epic-babbage-qc9xj (https://qc9xj.csb.app/)


## The current behavior

Here is the log of what NVDA says as I'm navigating the page:

> content info landmark    heading    level 1  This is a static HTML footer
>     _(I press Arrow Down)_
> clickable  heading    level 2  This is a heading within a React application.
>     _(I press Arrow Down)_
> banner landmark    heading    level 1  This is a static HTML header

## The expected behavior

It should not announce the heading as clickable/interactive. Here is what it would sound like without React on the page:

> content info landmark    heading    level 1  This is a static HTML footer
>     _(I press Arrow Down)_
> heading    level 2  This is a heading within a React application.
>     _(I press Arrow Down)_
> banner landmark    heading    level 1  This is a static HTML header

It should be noted that this is how it used to work in React 16 because the delegation of events was done on the `document` node, not the React root node.


## Notes
* Some screen readers like JAWS and NVDA use the presence of a `click` handler on a node as an indicator that they are interactive
* Because of React's event delegation, all synthetic events are handled at one central node. In React 16 it's the `document` and in React 17 it's the root node.
* The example shows that it's announced as clickable even when there is no interactive content inside. But even if the React node contained interactive content, the parent container should not be announced as interactive - because it is not.
* This is also called out by the Accessibility Inspector in the Firefox DevTools:
  * ""Does not meet WCAG standards for accessibility. Clickable elements must be focusable and should have interactive semantics. [Learn more](https://developer.mozilla.org/en-US/docs/Web/Accessibility/Understanding_WCAG/Keyboard#clickable_elements_must_be_focusable_and_should_have_interactive_semantics)""
* While this is already an issue with just one React root on the page, this problem will get increasingly worse and annoying for the user when there are multiple React roots on the page
    * This could easily happen on pages that are constructed with micro frontend frameworks or widgets",,
20891,OPEN,Possible Bug: interplay between reconcilliation algorithm and DOM manipulations via refs,Status: Unconfirmed,2021-02-26 07:43:18 +0000 UTC,fast-reflexes,,"## Introduction
I'm working with a library that performs DOM manipulations via `ref`s in `useEffect`s after React has rendered. 

## Background
My understanding of the reconciliation algorithm is that it compares subsequently rendered virtual DOMs and only perform the necessary updates on the real DOM when necessary according to this comparison. For this reason, the following example will continue to show a `div` with a green background throughout subsequent rerenderings, even though the `render` method returns a `div` with a blue background:
```
export default function App() {
  const [num, setNum] = useState(10);
  const ref = useRef();

  useEffect(() => {
    console.log(""effect ran"");
    if (ref.current) {
      ref.current.style.backgroundColor = ""green"";
    }
  }, []);

  console.log(""rendered"");

  return (
    <div ref={ref} style={{ backgroundColor: ""blue"", padding: num + ""px"" }}>
      <button onClick={() => setNum((num) => num + 10)}>Rerender</button>
    </div>
  );
}
```
(Sandbox link: https://codesandbox.io/s/festive-leavitt-n44hs?file=/src/App.js)
React is simply unaware of the change done directly via the `ref` and so the comparison between subsequent virtual DOMs only indicate that the `padding` must be updated.

## Problem
This is all fine when it comes to properties, but as far as children are concerned, the behaviour is slightly more obscure and inconsistent (perhaps due to children seemingly being something in between a prop on the parent element and distinct other elements?).

Consider the following toy example where a wrapper component performs an update (replaces `0`s with `9`s) on the content of its DOM children via `ref`s after rendering. Remember that this is a toy example and I know that the results in this example can be acquired in a much simpler (better!) way in React.

```
export default function App() {
  const [num, setNum] = useState(10);

  return (
    <div>
      <WrapperComponent id=""first"">
        <span /*key={ Date.now() }*/>10 - {num}</span>
      </WrapperComponent>
      <WrapperComponent id=""second"">
        <span /*key={ Date.now() }*/>10 -</span>
        <span /*key={ Date.now() + 1 }*/>{num}</span>
      </WrapperComponent>
      <button onClick={() => setNum((num) => num + 10)}>Rerender</button>
    </div>
  );
}

const WrapperComponent = (props) => {
  const ref = useRef();

  console.log(props.id + "": render"");
  console.log(props.children);

  useEffect(() => {
    if (ref.current) {
      ref.current.style.backgroundColor = ""green"";
      console.log(props.id + "": pre-alter"");
      console.log(ref.current.innerHTML);
      for (let i = 0; i < ref.current.children.length; ++i) {
        let el = ref.current.children[i];
        if (el.children.length === 0)
          el.innerHTML = el.innerHTML.replaceAll(""0"", ""9"");
      }
      //ref.current.innerHTML = ""Altered HTML""
      console.log(props.id + "": post-alter"");
      console.log(ref.current.innerHTML);
    }
  });

  return (
    <div
      ref={ref}
      style={{ margin: ""20px"", color: ""white"", backgroundColor: ""blue"" }}
    >
      {props.children}
    </div>
  );
};
```
(Sandbox link: https://codesandbox.io/s/cranky-blackwell-xqbkx?file=/src/App.js)

Depending on the structure of the children, the results differ:
* **Setup 1**: In the unaltered version above, render once and then clear the console. Click the button to render again and note that the logged children of the `WrapperComponent`s contain the updated number correctly in the `render` printout. Then note that in the `useEffect` when inspecting the `ref`s, React has changed the content of the second `WrapperComponent` in the real DOM to reflect the update in the child components in the virtual DOM whereas the child of the first has not been updated (see `pre-alter` printout). As a result, the changes (in the first `WrapperComponent`) are not reflected in the UI and the `useEffect` has nothing new to process.
* **Setup2**: Comment out the `for` loop in the `useEffect` of the `WrapperComponent` and uncomment the row below it. Refresh the UI and press the button. With this version, React doesn't update the real DOM at all (can be seen in the `pre-alter` printout) even though the children are still correct in the `render` printout.
* **Setup3**: Uncomment the `key` props in the `span`s and restore the `for` loop in `WrapperComponent` and comment out the row below it again. Update the UI and hit the button repeatedly and note that now it works perfectly. React updates the DOM as expected and this is reflected in both `pre-alter` printouts.

React version: 17.0

## Steps To Reproduce

See previous section

Link to code example:

See previous section

## The current behavior

See previous section

## The expected behavior

* **Setup2**: Given that the comparison between virtual DOMs indicate that only the content of the `span`s has changed, it is reasonable that React tries to update only that and bails out silently when it can no longer find those nodes in the real DOM. One could reason that React should reinsert them but I still think this behaviour is consistent.
* **Setup3**: Comparisons of virtual DOMs indicate that completely new children are to be inserted in the `WrapperComponent`s and so the old ones are thrown out and the new ones are added. Everything works as desired.
* **Setup1**: The `WrapperComponent`s only update the content of the `span`s and so React should be able to map content change in the virtual DOMs to these very same `span`s. It manages to do so for the second `WrapperComponent` but not the first, despite the changed content.

*I would expect this behaviour to be more consistent and not depend on the structure of the children like this. My suspicion is that it seems to be related to how React maps virtual DOM nodes with mixed content (expressions and literal text) to real DOM nodes but I can't see how, where and why. Hopefully this is not a bug in which case I am sorry for wasting your time.*
",,
20884,OPEN,Bug: React DevTools fails when using React Native + Hermes,Component: Developer Tools; Type: Bug,2021-03-01 14:11:53 +0000 UTC,helixbass,,"
1. `npx react-native init MyApp --template react-native-template-typescript`
2. set `enableHermes: true` in `android/app/build.gradle`
3. start Metro bundler via `yarn start`
4. launch app in Android emulator via `yarn android`
5. launch React DevTools
6. reload Metro bundler
7. click on any element in the React DevTools components view
8. right React DevTools panel is stuck on ""Loading..."" and Metro bundler logs `ERROR [TypeError: undefined is not a function]`:
<img width=""297"" alt=""Screen Shot 2021-02-25 at 5 56 13 PM"" src=""https://user-images.githubusercontent.com/440230/109231116-f76dd400-7793-11eb-8b7c-4c40a7eaee3a.png"">


<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://github.com/helixbass/HermesDevToolsIssueExample

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

React DevTools fails to load element props, styles etc


## The expected behavior

React DevTools should load element props, styles etc
",,
20882,OPEN,React throws many fake errors when warnings are issued,Type: Discussion,2021-02-26 16:46:21 +0000 UTC,markboyall,,"In describeNativeComponentFrame, the component rendering is intentionally failed so that we can gather details from the stack trace for some warnings. The Chrome dev tools will break on every single one of these, sometimes more than once. We have many, many components in our call stack before the warning is triggered, throwing many false errors, making it very difficult for us to use the dev tools to investigate unrelated errors when the warnings are present.

React version: 17.0.1

1. Create a simple minimal React page.
2. Render a simple ""hello world"" component with a warning.
3. Open the Chrome dev tools, click break on all exceptions with caught exceptions, and then reload the page.

Link to code example:

https://github.com/markboyall/react-break-example

The current behaviour is that it breaks once per component in the stack frame, causing an unmanageable number of fake breaks. The expected behaviour is that React does not interfere with the browser dev tools can be used to debug our own code.

Previous versions of React could issue warnings with one break at the warning site only at most, which was an acceptable tradeoff.",,
20881,OPEN,Component summary view by type,Component: Developer Tools; Type: Feature Request,2021-03-25 14:23:50 +0000 UTC,bvaughn,,"A DevTools user has requested the following feature (reworded by me):
Expose an ordered table of all component types (names) along with the number of instances currently mounted. This would help identify the most impactful components to examine for memory related optimizations.

The Profiler isn't very useful in this scenario because it's too CPU-centric.

cc @yungsters",,
20863,OPEN,Issue: `useEffect` executed before browser can paint DOM update,Status: Unconfirmed,2021-03-29 08:06:51 +0000 UTC,limekiln,,"To my understanding, `useEffect` should always run after the browser acutally did paint any updates. This way, I tried to ensure that a loading indicator is rendered after a user submits data but before a blocking function execution (e.g. a fetch operation where the data is waited on) is executed. The code looks somewhat like the following:

Wrapper component to which a loading indicator can be passed:
```javascript
export const LoadingWrapper = ({ callback, children}) => {
  useEffect(() => {
      if (typeof callback === ""function"") callback();
  }, [])

  return <React.Fragment> {children} </React.Fragment>
}
```

Usage:
```javascript
const [loading, setLoading] = useState(false);

const blockingFunction = () => {
    // some functionaliy which blocks painting updates
}

return (
    // some kind of input elements which change the `loading` state on submit
    
    { loading &&
        <LoadingWrapper callback={blockingFunction}>
            <div> Loading! </div>
        </LoadingWrapper>
)
```

I would expect from the documentation that the `callback` function is executed *after* the ""Loading"" div is rendered on the screen, but that is actually not the case. The new div appears after the blocking call is completely resolved.

To get it working, I acutally have to use a local state variable in addition to trigger the effect:
```javascript
export const LoadingWrapper = ({ callback, children}) => {
    const [isMounted, setIsMounted] = useState(false)

    useEffect(() => {
        setIsMounted(true);
    }

    useEffect(() => {
        if (isMounted && typeof callback === ""function"") callback();
    }, [isMounted]

    return <React.Fragment> {children} </React.Fragment>
}
```
Using this, I also observed some strange browser dependent behaviour. If input changes (which lead `loading` being set to `true`) are submitted `onBlur` of the input, it works fine in Chrome as well as in Firefox. Submitting these changes `onKeyPress` (while checking if the pressed key was the `Enter` key), it works in Firefox, but *not* in Chrome.

Does anyone have an idea what exactly is going on here or do I miss something important?


UPDATE:
I added a code sandbox: https://codesandbox.io/s/effectrendering-umtwo

The behaviour is quite strange:
In Chrome, triggering `onBlur` works (almost) always, sometimes it seems to bug out. Triggering `onKeyPress` will never trigger the spinner, *except* when `onBlur` was triggered before with the exact same input string (even though this string should have no influence at all here). 
In Firefox, neither `onBlur` nor `onKeyPress` will trigger the spinner for me.

Tested versions:
Chrome 88.0.4324.150 (64-Bit)
Firefox 85.0.2 (64-Bit)

",,
20854,OPEN,Bug: Dropdowns in React Dev Tools are unclickable in Firefox,Component: Developer Tools; Status: Unconfirmed,2021-04-01 06:47:52 +0000 UTC,adityavm,,"## Steps To Reproduce

1. Open Web Inspector in Firefox on a page that includes React
2. Go to ""Components"" tab (dev tools)
3. Click on gear icon to open settings
4. Attempt to click on any dropdown / select input

https://user-images.githubusercontent.com/80849/108611236-b9d61780-7430-11eb-8a4f-a046ba45035f.mov

## The current behavior

None of the select inputs / dropdowns respond to clicks.

## The expected behavior

Select inputs / dropdowns should expand and allow options to be selected / changed.
",,
20838,OPEN,Impact: Removal of `function.displayName` in Chromium,Type: Discussion,2021-02-24 20:05:19 +0000 UTC,chybie,,"Chromium plan to [remove the non-standard property `fn.displayName` property](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64). How would this impact React [`component.displayName`](https://reactjs.org/docs/react-component.html#displayname)?

Links:
- Chromium: [Remove non-standard fn.displayName support](https://docs.google.com/document/d/1_GxIGRvv8ATp3GMhA3jUfVFxGKMWEkFWvtqsSS7QQ2M/edit#heading=h.7nki9mck5t64)
- React: [Component.displayName](https://reactjs.org/docs/react-component.html#displayname)

#### TL;DR;

Chromium has traditionally supported the non-standard `fn.displayName` property as a way to provide developer-controlled debug names for functions that show up in `error.stack` and in `DevTools` stack traces. 

With ES6, `fn.name` is configurable as a standard, which is a portable replacement for `fn.displayName`. Also, V8 added logic to automatically infer good function names from the source code. 




",,
20830,OPEN,"Error: ""Cannot read property 'concat' of undefined""",Component: Developer Tools; Resolution: Needs More Information,2021-03-12 18:15:15 +0000 UTC,AlanH3160,,"Describe what you were doing when the bug occurred:
1. 
2. 
3. 

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.10.1-f160547f47

Call stack: at updateTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19702:53)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19574:26)
    at ProfilingCache_ProfilingCache.getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:20115:11)
    at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:34161:33)
    at Hh (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:12807:7)
    at qi (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13457:7)
    at mk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:16074:86)
    at lk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15459:11)
    at kk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15451:23)
    at ck (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15435:5)

Component stack: at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:34144:50)
    at div
    at div
    at div
    at SettingsModalContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28206:3)
    at Profiler_Profiler (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:35772:50)
    at ErrorBoundary_ErrorBoundary (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29219:5)
    at PortaledContent (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29336:32)
    at div
    at div
    at ProfilerContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32934:3)
    at TreeContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24322:3)
    at SettingsContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24811:3)
    at ModalDialogContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29404:3)
    at DevTools_DevTools (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:36207:3)",,
20822,OPEN,Feat: Some type of way to merge key prop and useOpaqueIdentifier result,Status: Unconfirmed,2021-02-19 14:50:38 +0000 UTC,SoAsEr,,"Currently, the expected way to handle an unknown at compile time number of labels is to put them each in their own component. However, when creating tables, this causes a mess of callbacks, as the only way to do it (that I can think of anyway) is to pass a callback into the table header components, have them create their own unique identifier, and then use a useEffect to give the parent those identifiers, have the parent pass those identifiers to the rows, and then have each row generate its opaque own unique identifiers and pass both to the cells. Note that this doesn't work currently because of these two bugs:
https://github.com/facebook/react/issues/18594
https://github.com/facebook/react/issues/20127

However, react already has a way to differentiate items in loops: the key prop. To me, it would make sense to provide a function which merges a key prop with a unique identifier. This would allow the parent to generate the unique identifiers and pass them to the children, rather than having callbacks which cause a rerender. It would even make https://github.com/facebook/react/issues/20127 less relevant because there would be fewer motivating reasons to do so.

mergeOpaqueIdentifierAndKey is very wordy, but describes exactly what's going on. I don't have any particular preference about the name.",,
20819,OPEN,When you pass object instance into React Component props; object instance is never cleared from memory.,,2021-02-15 11:36:27 +0000 UTC,czmok,,"Hi, 
I have an issue with passing object reference into React Component props. I pass `example` into `prop1` of `TestReactComponent`. Then, in `removeInstance` method I clear the object instance. After setting it to `null` object instance shouldn't be visible in memory.
Example code: 
```
function App() {
  let example = new ExampleClassInstance();
  const key = Math.random();
  const removeInstance = () => {
    unmountComponentAtNode(document.getElementById('example-wrap'))
    example = null;
  }
  return (
    <div className=""App""  id=""example-wrap"">
      <div >
        <TestReactComponent  key={key} prop1={example} ></TestReactComponent>
      </div>
      <button onClick={()=> removeInstance()}>remove</button>
    </div>
  );
}
export default App;
```

After setting `example` to null (after calling `removeInstance` method) I expect not to have an object instance in memory, but unfortunately it still exists. After recording Heap Snapshot from Memory tab I see result: 
```
ExampleClassInstance | 9 | 560 % | 2440 %
prop1 in Object@591215🗖 | 8 | 120 % | 5600 % |  
      -- | -- | -- | -- | --
              memoizedProps in FiberNode@591281🗖react-dom.development.js:24666 | 7 | 1400 % | 1880 % |  
              returninFiberNode@591301🗖react-dom.development.js:24666 | 6 | 1400 % | 1880 % |  
              __reactFiber$lwytjywp7qinText@317739🗖

```
Snapshot says :  `memoizedProps in FiberNode`. 
PS I don't use `memo` function for the component.

After setting `example` to `null` I expect don't see object instance in memory anymore.

Please for help. If something is not clear please ask.








",,
20787,OPEN,Bug: Safari div contentEditable，onMouseUp trigger before onMouseDown,Status: Unconfirmed,2021-02-15 14:12:45 +0000 UTC,SmallComfort,,"React version: 17.0.1

## Steps To Reproduce

1. Mac OS Big Sur version 11.2，Safari  version 14.0.3 
2. set div contentEditable
3. div addEventListener onMouseUp and onMouseDown
4. onMouseUp trigger before onMouseDown

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
```
<div
  onMouseDown={() => {console.log('mouse down')}}
  onMouseUp={() => {console.log('mouse up')}}
  suppressContentEditableWarning
  contentEditable>
  Test ContentEditable In Safari
</div>
```

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

onMouseUp trigger before onMouseDown

## The expected behavior

onMouseUp trigger after onMouseDown
",,
20779,OPEN,Scheduling profiler feedback,Component: Developer Tools; Type: Feature Request,2021-02-09 23:04:38 +0000 UTC,bvaughn,,"Some of this might not be possible or might be prohibitively difficult, but this was some user feedback/requests for the scheduling profiler:
* Show lane labels instead of bitmap index
* On hover for a batch of render work highlight update events that were related to that render batch
* Show when tasks are scheduled (in the scheduler, any JavaScript, not just React
* Find-in-page that shows number of results like Chrome and updates as you zoom and scroll
* Show lane(s) state update get associated with in chart tooltip
* Highlight batched updates on hover (hovering one item would update others)",,
20770,OPEN,Bug: Disabled button state update prevents `scrollIntoView`,Component: DOM; Type: Bug,2021-03-19 19:13:02 +0000 UTC,jjenzz,,"I have a `button` that triggers `scrollIntoView` for a node when clicked. It also updates some state which subsequently disables that button in certain cases. If the button becomes disabled, the `scrollIntoView` execution is exited.

This seems to only happen in Chrome/Brave.

React version: 17.0.1

## Steps To Reproduce

See steps to reproduce in sandbox.

https://codesandbox.io/s/goofy-curie-yts68?file=/src/App.js

## The current behavior

Described above.

## The expected behavior

The state update should not prevent `scrollIntoView`.
",,
20755,OPEN,Feature Suggestion: Add `ignoreMemberCallExpression` option for `exhaustive-deps` lint rule,Component: ESLint Rules; Type: Enhancement,2021-02-17 13:13:42 +0000 UTC,chayeoi,,"## As-is

When only referring to object's member properties, `exhaustive-deps` lint rule does not show a warning.

However, **when calling object's member property, this rule shows a warning.**

```tsx
function Password() {
  const verifyPassword = useMutation(apis.verifyPassword);

  useEffect(() => {
    verifyPassword.mutate;
  }, [verifyPassword.mutate]); // PASS

  useEffect(() => {
    verifyPassword.mutate();
  } ,[verifyPassword.mutate]); // React Hook useEffect has a missing dependency: 'verifyPassword'. Either include it or remove the dependency array.
} 
```

I saw [Dan's comment](https://github.com/facebook/react/issues/14920#issuecomment-467494468) on this behavior.

> This is because technically props.foo() passes props itself as this to foo call. So foo might implicitly depend on props. We'll need a better message for this case though. The best practice is always destructuring.

It is fully understood.

However, **when the entire object is included as a dependency, the following problem can occur.**
Take a look at the following code.

```tsx
const verifyPassword = useMutation(apis.verifyPassword); // `verifyPassword` equals to `{ isLoading: boolean; mutate: Function }`

// `verifyPassword(password)` sets `isLoading` to `true` and causes `useEffect` hook that depends on `verifyPassword` objects to be re-excuted. This eventually leads to an infinite loop.
useEffect(() => {
  if (password === PASSWORD_LENGTH) {
    verifyPassword.mutate(password);
  } 
  
}, [password, verifyPassword]);
```

**There are two ways to avoid this problem.**

```tsx
// 1. Use destructuring
const { mutate } = useMutation(apis.verifyPassword);

useEffect(() => {
  if (password === PASSWORD_LENGTH) {
    verifyPassword.mutate(password);
  }
}, [password, mutate]);

// 2. Assign member property to other variable
useEffect(() => {
  const mutate = verifyPassword.mutate;

  mutate();
}, [verifyPassword.mutate]);
```

## To-be

In many cases, it is not common to refer to other members through `this`.

And as in the example above, it is a good idea to use namespace to avoid name conflicts. (https://github.com/facebook/react/issues/16265#issuecomment-587977285)

So, I would like to suggest an **option to set not to warn about _member call expresion_ when using the `exhaustive-deps` rule.**

```tsx
// 'react-hooks/exhaustive-deps': ['warn', { ignoreMemberCallExpression: true }]
useEffect(() => {
  verifyPassword.mutate();
}, [verifyPassword.mutate]); // PASS
```",,
20754,OPEN,Change default branch name to “main”. Currently is “master”,,2021-02-07 15:01:13 +0000 UTC,samarmohan,,The word main is more inclusive than master. Master refers to slavery and makes some people feel lesser. Changing the branch name is a small but important gesture.,,
20750,OPEN,Bug: react-hooks/exhaustive-deps false positive when function is casted with TypeScript,Component: ESLint Rules; Status: Unconfirmed; Type: Bug,2021-04-05 07:46:10 +0000 UTC,0x24a537r9,,"React version: 17.0.1

### Steps To Reproduce
Setup eslint with @typescript-eslint/parser as parser
Cast a function passed to `useEffect`

```
import {useCallback, useEffect} from 'react';

type F = (...args: unknown[]) => void;

function MyComp() {
	const foo = useCallback(() => {}, []);

	// OK
	useEffect(() => {
		foo();
	}, [foo]);

	// WARNS?
	useEffect((() => {
		foo();
	}) as F, [foo]);

	return 'Hello, world'
}
```

Link to code example: https://github.com/0x24a537r9/exhaustive-deps-bug

### The current behavior
The following error was reported

```
  14:2  warning  React Hook useEffect received a function whose dependencies are unknown. Pass an inline function instead  
```

### The expected behavior
The rule should interpret the function argument correctly and know that it is already inline.",,
20741,OPEN,Bug: Nested form elements not firing onSubmit,Component: DOM; Status: Unconfirmed,2021-02-24 08:59:45 +0000 UTC,zediah,,"React version: 17.0.1

## Steps To Reproduce

1. Create a nested form element with an onsubmit handler
2. The onSubmit handler will not be called

In the example, click the ""Submit child"" button and will see the page reload/no console.logs. However, the expected actions occur for both parent and neighbouring forms.

Link to code example:
https://codesandbox.io/s/zen-hoover-6wit3?file=/src/App.js


## The current behavior
The attached onSubmit handler on a nested form element is not being called/fired.

## The expected behavior
Expect the onsubmit handler to be called.

I'm aware that nesting forms is not valid - but it was working react 16. I'm hoping to not get ""you're doing it wrong"" responses - but if there is no intention to support this situation the future I would really appreciate an explanation for it :) I've got a bunch of legacy code here that I'd rather not have to go through and refactor and/or not upgrade to react 17.",,
20738,OPEN,Feature Request: render React *to* a node; not *in* a node.,Status: Unconfirmed,2021-03-24 17:38:45 +0000 UTC,ccorcos,,"When using React with other libraries, I'm often forced to deal with DOM nodes directly to change their style or content. However, `ReactDOM.render` will always create content inside the provided DOM node rather than use the given DOM node as the element to mutate.

```ts
// Suppose this span is given in a function argument for some other frontend library.
const span = document.createElement('span') 

// I want to mutate this element using React's utilities
ReactDOM.render(<span style={{color: 'blue'}}>Hello</span>, span)
```

So maybe this functionality will not be called with `ReactDOM.render`, but it would be great if the internal tools for updating DOM nodes were exposed so I can keep using React when interfacing with external libraries.

Thanks!",,
20716,OPEN,Bug: react-test-renderer working with a mix of react renderers,Status: Unconfirmed,2021-03-05 10:15:50 +0000 UTC,joshuaellis,,"1. yarn install
2. yarn test:watch

Link to code example: https://github.com/joshuaellis/react-three-testing-library
look at the `root-issue` branch, it's cleaner and explains the problem a lot easier.

## The current behaviour
I'm currently working on a testing library for `react-three-fiber`. I have to wrap the passed scene in r3f's `Canvas` component so it can access the hooks in r3f. When I create my rendering instance and call `toJSON()` the response I get is:
```shell

{
  type: 'div',
  props: {
    style: {
      position: 'relative',
      width: '100%',
      height: '100%',
      overflow: 'hidden'
    }
  },
  children: [ { type: 'canvas', props: [Object], children: null } ]
}
```

I imagine this is expected because the r3f components render at a different root(?). When I call `toTree()` I can begin to drill down to r3f components. Consider this scene:

```js
renderScene(
  <mesh position={position}  onPointerDown={() => console.log('hello')}>
    <boxBufferGeometry args={[1, 1, 1]} />
    <meshBasicMaterial />
    <mesh>
      <boxBufferGeometry args={[1, 1, 1]} />
      <meshBasicMaterial userData={{
        testId: 'material'
      }} />
    </mesh>
  </mesh>
)
```

this renders as expected in and drilling to find the first `mesh` I get the response:
```shell
{
  '$$typeof': Symbol(react.element),
  type: 'mesh',
  key: null,
  ref: null,
  props: {
    position: Vector3 { x: 1, y: 1, z: 1 },
    onPointerDown: [Function: onPointerDown],
    children: [ [Object], [Object], [Object] ]
  },
  _owner: null,
  _store: {}
}
```

However, wrapping the scene above in a component like so:

```js
  const TestComponent = () => {
    const geomRef = React.useRef<THREE.BoxBufferGeometry>(null!)
    const handlePointerDown = () => {
      geomRef.current.scale(10, 10, 10)
    }
    return (
      <mesh onPointerDown={handlePointerDown} userData={{ testId: 'mesh' }}>
        <boxBufferGeometry ref={geomRef} args={[1, 1, 1]} />
        <meshBasicMaterial />
      </mesh>
    )
  }

  it(""should render my component of r3f compoennts"", () => {
    const { scene } = renderScene(
      <TestComponent />
    )

    expect(scene).toBeTruthy()
  })
```

and drilling to the same point as before I get the response:

```shell
{
  '$$typeof': Symbol(react.element),
  type: [Function: TestComponent],
  key: null,
  ref: null,
  props: {},
  _owner: null,
  _store: {}
}
```

And I can't drill any further to find the `mesh` component inside `TestComponent`

## The expected behaviour

I'm not sure what the expected behaviour is supposed to be. But my thought is if the first scene can render and I can drill correctly, then `TestComponent` should ""render"" correctly so I can drill into it and find `mesh`. Maybe the first test shouldn't have rendered at all and that's the bug because `react-three-fiber` render's it's own component at a new root?

It's probably easier to play around with the repo I've attached.
",,
20711,OPEN,Feature request: custom error handlers in ReactPartialRenderer,,2021-02-26 15:34:26 +0000 UTC,yepitschunked,,"I'd like the option to pass a custom error handler for ReactPartialRenderer. The custom handler should be able to specify whether we:
  - throw and abort the render (basically same as existing behavior)
  - return a substitute element
  - pause the render at the erroring element; the next read() call will resume and effectively retry rendering the element. Return the output buffer up to the point where we paused.

I have two use cases:

1. Returning a substitute element could be an alternative to the ErrorBoundary in SSR. I understand why ErrorBoundary doesn't work due to in-order streaming issues (e.g https://github.com/facebook/react/issues/10442#issuecomment-321904824) - we can't replace the entire tree up to the parent, but a custom handler could at least render a placeholder error div or something. Would be useful in dev. 
2. Implementing a poor-man's Suspense by pausing the render. More below...

It seems like the intended design direction for Suspense is to skip suspended components on the server and render fallbacks. I'd like to instead stream HTML up until hitting an async dependency, and block there until the dependency is resolved. Having an official custom error handler API would let me implement this outside of React.

I was able to hack together a quick example in this sandbox link: https://codesandbox.io/s/node-js-forked-5lzro?file=/src/index.js

Most of the complexity comes from catching the error, cleaning up state, and returning the in-flight output buffer contents; the rest of the logic (e.g resuming the stream after promises have been resolved) can be handled in client code outside of React.

I realize this sounds a lot like the use-case for Suspense. However, it seems like Suspense is mostly client-focused, and many of the problems with concurrency, etc. are avoidable on the server, which doesn't have these problems. Adopting Suspense with a legacy codebase is hard due to concurrent mode restrictions. We can't really take advantage of reduced restrictions on the server, since there's no way to only opt into Suspense on the server. 




",,
20707,OPEN,Bug: Iterator as JSX children doesn't work right,Status: Unconfirmed,2021-03-02 18:59:02 +0000 UTC,Jack-Works,,"```js
function App() {
    const x = [<h1>a</h1>, <h2>a</h2>].values()
    return <div>{x}</div>
}
```

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

https://codesandbox.io/s/react-playground-forked-jv4p5?fontsize=14&hidenavigation=1&theme=dark

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

Nothing rendered.

React consumes the iterator twice so the items are gone. The first consume is to validate the JSX, the second consume is collecting them as children.

## The expected behavior

Render JSX items in the list.

Why I'm considering this case is because I'm investigating how React will work with the ES Number.range proposal.

It seems like they can work in this way:

```js
function App() {
return <>{Number.range(0, 10).map(x => <h1>{x}</h1>)}</>
}
```

Without appending `.toArray()`(iterator helper proposal) to the end. It seems like React does support iterators but used it in the wrong way.",,
20701,OPEN,Powerful Feature - SSR async fetching for resources via lifecycle method,Status: Unconfirmed,2021-02-15 21:47:59 +0000 UTC,onzag,,"When doing SSR it's very hard to fetch resources that are dynamic, and while you have been trying to introduce the quite complex suspense API, I had to come with a simpler solution for my use case.

Simply adding a lifecycle method that executes only during SSR via react-dom, that is async (which makes the whole renderToString) method async indeed; which allows to update the initial state, it's extremely simple, and it works (I have tested it).

Let me make an example to illustrate this further suppose we have a component named `ResourceFetcher` which does what it claims and fetches a resource, now let's suppose our react developer simply would use it like this.

```
<ResourceFetcher resource=""data.json"">
  {(data) => (
    <ResourceFetcher resource={data.secondaryResource}>
       {(secondaryData) => (
          <div>HERE I DISPLAY THE DATA</div>
       )}
    </ResourceFetcher>
  )}
</ResourceFetcher>
```

Imagine the nightmare that it would be to setup this with SSR, specially when the resource fetcher can be used arbitrarily, we would have to duplicate the logic to collect the data when we know we are at the right url where that would be rendered; it can simply be quite hard and it has to be done with each page, and with routes on the mix, dynamic paths, query strings that affect what is required, the server side logic becomes overwhelming.

Now let's imagine we now have a `<ResolverContext>` that sits above all our app, this provides an instance into our resource fetcher that specifies how it is to resolve using the resource fetcher, it also contains a cache that the resource fetcher can use.

So what the resouce fetcher is doing is on the `constructor` it will try to load a value from the cache and on `componentDidMount` if it is not loaded (because it was not found in the cache) it will run a fetch request.

Now imagine we have a method called `beforeServerSideRender` that is async and executes right before render on server side only, and it prepares the state on this case, on constructor our cache is indeed empty, but then `beforeServerSideRender` triggers, and we can ""resolve"" these resources that we need, in the case of the server side, the resolver is not fetch, it simply reads from disk; the server can then have a form of collector, and sets the variable `window.CACHE = ` so that the client can setup its initial cache in the context.

The result is that you have a very easy to setup SSR that can work with basically anything that requires no configuration once your environment is dialed, I managed to create extremely rich dinamically loaded SSR pages with that method with very little fuzz, I don't need to make a list per page of what I need, it is just done on the fly.

What I did was the following:

```
react-dom/src/server/ReactDOMNodeStreamRenderer.js

-  _read(size) {
+  async _read(size) {

-      this.push(this.partialRenderer.read(size));
+      this.push(await this.partialRenderer.read(size));

react-dom/src/server/ReactDOMStringRenderer.js

-export function renderToString(element, options?: ServerOptions) {
+export async function renderToString(element, options?: ServerOptions) {

-    const markup = renderer.read(Infinity);
+    const markup = await renderer.read(Infinity);

-export function renderToStaticMarkup(element, options?: ServerOptions) {
+export async function renderToStaticMarkup(element, options?: ServerOptions) {

-    const markup = renderer.read(Infinity);
+    const markup = await renderer.read(Infinity);

react-dom/src/server/ReactPartialRenderer.js

-function resolve(
+async function resolve(

-    processChild(element, Component);
+    await processChild(element, Component);

-  function processChild(element, Component) {
+  async function processChild(element, Component) {

+
+    if (inst.beforeServerSideRender) {
+      await inst.beforeServerSideRender();
+    }
     child = inst.render();

-  read(bytes: number): string | null {
+  async read(bytes: number): string | null {

-          outBuffer += this.render(child, frame.context, frame.domNamespace);
+          outBuffer += await this.render(child, frame.context, frame.domNamespace);

-  render(
+  async render(

-      ({child: nextChild, context} = resolve(child, context, this.threadID));
+      ({child: nextChild, context} = await resolve(child, context, this.threadID));
```

And that was it, with that I had given superpowers to SSR, no longer I needed lists to specify what resources I needed ahead of time, I could just get that when react was rendering; it did not affect anything else than the server side if they had that lifecycle function, but everything worked normally.

Not just that but with this method, if the SSR crashed for some reason, it still worked!... I'd just be served the default version with an empty cache since the collection failed, and the resources will be fetched on mount; just that the initial page will be, without proper SSR, but no fuzz, it still worked; so it is crash resistant.

There seem to be a problem with the development mode, it works but doesn't take much pressure as it cannot overlap renders in the async mode, but works in production builds. This is why I make this issue and not a PR.

Just that simple lifecycle function adds way too much power and it's a very simple change, I think it should be implemented, specially because we don't have suspense, and some people don't feel comfortable with the idea of suspense; this solution is extremely simple, but it works.

https://www.npmjs.com/package/@onzag/react-dom",,
20700,OPEN,Bug: react-hooks/rules-of-hooks should support compound component pattern,Status: Unconfirmed,2021-04-05 22:37:20 +0000 UTC,wildfrontend,,"this is a sample issue :

```
150:20  error    React Hook ""useDispatch"" is called in function ""PageHome.Layout"" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter  react-hooks/rules-of-hooks
```

i think maybe hook rule can support compound component pattern",,
20696,OPEN,Bug: React Dev Tools fail to show component updates with memoized components.,Component: Developer Tools; Status: Unconfirmed; Type: Bug,2021-04-01 13:18:16 +0000 UTC,lifeiscontent,,"1. run the project: https://github.com/lifeiscontent/immutable-todo
2. open react dev tools and set the highlight updates when components render option.
3. add changes to the todos
4. see no updates are displayed via React dev tools

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

https://github.com/lifeiscontent/immutable-todo

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

currently, updates are only displayed if the react component is not memoized.


## The expected behavior

all react components should show their updates regardless of memoization. 
",,
20684,OPEN,DevTools: Re-think errors/warnings that do not have a 1:1 component mapping,Component: Developer Tools,2021-01-28 21:46:10 +0000 UTC,bvaughn,,"#20463 added an option to display errors and warnings related to React components directly within the DevTools Components tree. The mechanism for associating an error or warning with a React component was to check if any Fiber was currently being rendered.

However this doesn't work for all types of warnings. For example, many [strict mode warnings](https://reactjs.org/docs/strict-mode.html) are not logged during render (per component), but instead are coalesced and logged as a group when the render work is committed. This was done to reduce the number of warnings React logged to the console. A side effect of this though is that DevTools isn't able to associate the warning with any components and so it does not get surfaced in the UI.

We should come up with a design that is able to handle errors/warnings that have a 1:many component mapping (like strict mode), as well as ones that might not even make sense to show in the Components tree at all (like hydration errors).",,
20682,OPEN,Bug: <img> within a <picture> is being requested twice in Firefox,Component: DOM; Status: Unconfirmed,2021-02-15 10:44:46 +0000 UTC,cherouvim,,"When I have an `<img>` within a `<picture>` element, e.g for implementing [responsive images](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture), then Firefox requests that image file twice. Some of the times the first request to the image will stop with an `NS_BINDING_ABORTED`, it'll always return receive 0 bytes, and the server will log a 499 response (client closed request) or a 200. Removing the `<picture>` element and simply leaving `<img>` in the JSX, solves the problem, but of course I do need the `<picture>`. This happens in Firefox 84 and 85 (private mode, no extensions), and does not happen in Chrome.

An important detail is that this only happens when rendering through react, either in dev mode or build mode (in create-react-app). If I save the generated HTML and render it without any JavaScript, then the double request never happens again.

React version: 17.0.1 (happens in 16 too)

JS:
```js
import React from ""react"";
import ReactDOM from ""react-dom"";
ReactDOM.render(
  <picture>
    <img src=""https://via.placeholder.com/300x300?text=JPG"" alt=""JPG"" width=""300"" height=""300"" />
  </picture>,
  window.document.getElementById(""root"")
);
```

HTML:
```html
<!doctype html>
<html>
  <body>
    <div id=""root""></div>
  </body>
</html>
```

Live example: https://luues.csb.app/

Result screenshot of network tab:
![<image> within a <picture> is being requested twice in Firefox](https://i.imgur.com/1sa5Vmx.png ""<image> within a <picture> is being requested twice in Firefox"")

In case it helps, note that in the following example, the first (broken) request will be for the jpg image, and then another for the correct webp one:
```js
<picture>
    <source srcSet=""https://via.placeholder.com/300x300?text=WEBP"" type=""image/webp"" />
    <img src=""https://via.placeholder.com/300x300?text=JPG"" alt=""JPG"" width=""300"" height=""300"" />
</picture>
```",,
20661,OPEN,propagateContextChange visits all child fibers,,2021-03-05 17:23:14 +0000 UTC,intellild,,"`propagateContextChange` in the current context implementation visits all child fibers rather than fibers that have dependency on the context.
In my case, there may be thousands of child components and 99% of them don't have dependency on the context, which causes `propagateContextChange` spends a lot of scripting time but eventually does 'nothing'.",,
20638,OPEN,Bug: no way to reset a react.lazy cache,Status: Unconfirmed,2021-01-21 20:11:18 +0000 UTC,paztis,,"
React version: 16.14

## Steps To Reproduce

1.
2.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior


## The expected behavior
",,
20636,OPEN,Bug: `react-dom@17.x` event delegation issue,Status: Unconfirmed,2021-01-25 11:46:32 +0000 UTC,linde12,,"This is pretty much a duplicate of https://github.com/tannerlinsley/react-table/issues/3002

React version: 17.x

**Bug description**
As i was developing i forgot to memoize some mocked data before passing it to react-table's `useTable` hook and encountered an interesting bug, which led me down a rabbit hole instead of actually seeing the problem (missed useMemo on my data)

It only happens when you use `useTable` combined with `useSortBy`, and only with `react-dom@17.x` (event delegation rewrite release), e.g `react-dom@16.x` works fine.

It is hard to put to words, but i have attached a minimal example (codesandbox) and will try my best to explain. In the codesandbox i have three components:
- `Modal` which has a `useEffect`  that adds a click event listener to `document`. This listener acts like a backdrop (where if i click the backdrop the ""modal"" should close. Rendered by App.
- `Table` which is the component that calls `useTable` (but doesn't use anything it returns) - also rendered by App.
- `App` which is the main application and controls the state that decides whether `Modal` is rendered or not. Here i actively ""forgot"" to use `useMemo` on my data.

What happens is that when you click ""Open Modal"" using `react-dom@17.x` the callback to `document.addEventListener('click', ..)` is called, but this element shouldn't have been rendered yet at the point when the click event from the button was fired. The result is that you never, or very briefly, see the ""modal"". Doing the same using `react-dom@16.x` (you can change in the sandbox) results in the expected behavior of the ""modal"" actually showing.

**Codesandbox example**
https://codesandbox.io/s/react-table-react-17-5nw4d?file=/src/App.js

**Steps To Reproduce**
Steps to reproduce the behavior:

1. Go to https://codesandbox.io/s/react-table-react-17-5nw4d?file=/src/App.js
2. See `react-dom` version is `17.0.1`
3. Press ""Open Modal"" button
4. Nothing happens
5. Change version of `react-dom` to 16.14.0 for example.
6. Press ""Open Modal"" button
7. See the modal get opened as expected.

**Expected behavior**
Obviously i can't expect the react-table library to work properly, but i would not expect it to have the weird observed undefined behavior. I also would not expect this to have different behaviors across `react-dom` versions, even if it is a major release.

**Additional context**
I am _very_ curious to what is actually going on and whether this is a bug of `react-dom` or `react-table` or a combination of both. I've been debugging to try and find the root cause, but unfortunately i'm not very familiar with the code of either repos and i believe there are things happening asynchronously which is very hard for me to follow.

It would be nice if anyone wanted to help me debug this issue, so we can get to the root of the problem and perhaps have a more minimal example.",,
20631,OPEN,Bug: ComponentDidCatch will not catch the same child component twice,Status: Unconfirmed,2021-01-20 18:24:38 +0000 UTC,overly-engineered,,"We have a container element which is used to render children of different types. These children are specified by the user and can contain errors or bugs, we, therefore, have a fallback hierarchy which will fall back to the next child in a specified list and attempts to render that. This works fine as a solution until a user attempts to use the same component twice in a different configuration the second time which also fails. The parent component cannot catch the same child erroring twice but will catch multiple different children failing one after the other.

React version: At least v16.14.0+,

Reproduced on v16.14.0 and v17.0.1

## Steps To Reproduce

1. Main renders the child component.
2. Child component throws an error.
3. Main catches that error and attempts to render child component again
4. Child throws another error.
5. Main fails to catch the error a second time.

Link to code example:
https://codesandbox.io/s/busy-waterfall-1u0fc?file=/src/App.js

## The current behavior

Parent component is only capable of catching the same child once.

## The expected behavior

Parent component would catch child component however many times it throws an error occurs.

I'm aware that we may well not be using the componentDidCatch method properly in this instance, but it worked as a really easy way to provide this fallback behaviour.",,
20628,OPEN,[react-devtools-inline] Same-origin domain element inspection problem,Status: Unconfirmed,2021-01-20 15:28:27 +0000 UTC,dmtrKovalenko,,"## Steps To Reproduce

Due to its pretty hard to get the exact time point when the iframe is ready but react code not executed it is easier to just run cypress with devtools for reproduction 

1.`git clone git://github.com/cypress-io/cypress.git`
2. `git checkout 725e335e246a61b5bd5e2d19e0c70776d5ee2324`
3. `yarn`
4. `cd npm/react` 
5. `yarn cy:open`


## The current behavior

When iframe is **same origin** and devtools initialization happens in the top window element highlighting is completely broken when initialized not inside the iframe. 
![image](https://user-images.githubusercontent.com/16926049/105191541-e0f2ae00-5b3f-11eb-8dba-1a719cca58d2.png)

It happens because the [overlay tooltip](https://github.com/facebook/react/blob/3e94bce765d355d74f6a60feb4addb6d196e3482/packages/react-devtools-shared/src/backend/views/Highlighter/Overlay.js#L87) calculate node position and render the tooltip itself in the outer window (not inside the iframe). 

![Screenshot 2021-01-20 at 16 55 19](https://user-images.githubusercontent.com/16926049/105192025-62e2d700-5b40-11eb-96f1-c3a9a5dc2ec4.png)

UPD: 
As you can see here OverlayTip class gets incorrect document (root) in the constructor
![image](https://user-images.githubusercontent.com/16926049/105196109-f669d700-5b43-11eb-871e-c4d174f4eff1.png)

## Workaround

And so I noticed a workaround to manually pass `window.__REACT_DEVTOOLS_TARGET_WINDOW__ = contentWindow`, which is not documented solution and must be at least mentioned in the readme

## The expected behavior

For reference, here is the correct solution where used sandbox version and tooltips rendered inside the iframe (codesandbox): 

![Screenshot 2021-01-20 at 16 58 11](https://user-images.githubusercontent.com/16926049/105192498-d5ec4d80-5b40-11eb-9894-b04a6b104073.png)
",,
20613,OPEN,"Bug: devtools may crash when custom hook has the name ""useState""",Component: Developer Tools; Type: Bug,2021-03-25 14:23:16 +0000 UTC,avkonst,,"1. clone repo: https://github.com/avkonst/react-devtools-crash-demo
2. yarn start
3. open the browser of the started app
4. open devtools
5. click Counter component in the components tab of the development tools
6. Watch it not loading anything and unhandled exception dumped to the console log

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://github.com/avkonst/react-devtools-crash-demo

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

Devtools crash when I click on the following component in the development tools:

```tsx
import React from 'react';

function useState() {
    React.useState(0);
    React.useEffect(() => () => {});
}

function Counter() {
	useState();
	React.useState(0);
	return <div>Open React Dev Tools Components panel,
		click on Counter component and
		observe the crash in the logging console.</div>;
}

export default Counter;
```

## The expected behavior

No crash and the development tools show hooks used.
",,
20586,OPEN,Bug: CRA 4; React 17.0.1 new jsx not umd; React CDN can not work,Status: Unconfirmed,2021-01-14 09:55:56 +0000 UTC,ickeep,,"
### Describe the bug

externals React, CDN loading React error.

### Environment

System:
    OS: macOS 11.1
    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz
  Binaries:
    Node: 14.15.1 - /usr/local/bin/node
    Yarn: Not Found
    npm: 6.14.10 - /usr/local/bin/npm
  Browsers:
    Chrome: 87.0.4280.141
    Edge: Not Found
    Firefox: Not Found
    Safari: 14.0.2
  npmPackages:
    react: Not Found
    react-dom: Not Found
    react-scripts: Not Found
  npmGlobalPackages:
    create-react-app: Not Found

### Steps to reproduce
1.  Create project
```  
npx create-react-app my-app --template typescript
``` 
2. [Use craco](https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#installation)
``` diff
/* package.json */
""scripts"": {
-   ""start"": ""react-scripts start"",
+   ""start"": ""craco start"",
-   ""build"": ""react-scripts build"",
+   ""build"": ""craco build""
-   ""test"": ""react-scripts test"",
+   ""test"": ""craco test""
}
```
3. Create craco.config.js
``` javascript
module.exports = {
  webpack: {
    configure: (webpackConfig, { env, paths }) => {
      webpackConfig.externals = {
        react: {
          root: ""React"",
          commonjs2: ""react"",
          commonjs: ""react"",
          amd: ""react""
        },
        'react-dom': {
          root: ""ReactDOM"",
          commonjs2: ""react-dom"",
          commonjs: ""react-dom"",
          amd: ""react-dom""
        }
      }
      return webpackConfig;
    }
  }
}
```
4. edit public/index.html
``` diff
<div id=""root""></div>
+ <script src=""https://cdnjs.cloudflare.com/ajax/libs/react/17.0.1/umd/react.<%=  process.env.NODE_ENV==='development'?'development':'production' %>.min.js""></script>
+ <script src=""https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.1/umd/react-dom.<%= process.env.NODE_ENV==='development'?'development':'production' %>.min.js""></script>
</body>
</html>
  ```
5.  npm run start
6. React is mounted
![image](https://user-images.githubusercontent.com/9164133/104183735-604ff580-544d-11eb-9512-510b4bd137cb.png)

### Expected behavior

Render the page normally

### Actual behavior

![image](https://user-images.githubusercontent.com/9164133/104183141-7610eb00-544c-11eb-86e5-f2589ce8d585.png)



",,
20583,OPEN,Bug: Property length undefined in Profiler,Component: Developer Tools; Resolution: Needs More Information; Status: Unconfirmed,2021-01-22 18:35:55 +0000 UTC,itsezc,,"React version:  17.0.1

Error happens while trying to use the profiler on my React app on Chrome

## The current behavior
```
Call stack: at getChartData (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19767:32)
at ProfilingCache_ProfilingCache.getFlamegraphChartData (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19992:11)
at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:34007:32)
at Hh (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:12871:7)
at qi (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13521:7)
at nk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:16162:86)
at mk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15541:11)
at lk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15533:23)
at dk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15517:5)
at Xj (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15129:105)

Component stack: at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:33986:50)
at div
at div
at SettingsModalContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28048:3)
at Profiler_Profiler (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:35614:50)
at ErrorBoundary_ErrorBoundary (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29061:5)
at PortaledContent (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29178:32)
at div
at ProfilerContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32776:3)
at TreeContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24164:3)
at SettingsContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24653:3)
at ModalDialogContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29246:3)
at DevTools_DevTools (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:36049:3)
```

Worked absolutely fine on older versions of the Chrome extension.",,
20580,OPEN,Bug: [eslint-plugin-react-hooks]: exhaustive-deps not triggered if namespace is not 'React',Status: Unconfirmed,2021-01-13 10:27:16 +0000 UTC,jvdsande,,"When using `eslint-plugin-react-hooks`, and more precisely `react-hooks/exhaustive-deps`, hooks are not picked up if they are prefixed by a namespace that is _not_ React.

This happened in a project where I consolidated all my hooks (React's + custom from third-party libraries + my own custom hooks) into a single namespace that I can import everywhere.

## Steps To Reproduce

1. Configure ESLint to use `eslint-plugin-react-hooks`
2. Re-export React hooks under a new namespace
3. Create a component using `useEffect` through this namespace, with a missing dependency

Link to code example: https://codesandbox.io/s/react-hooks-namespace-9fu76

## The current behavior

Taking the following component:

```
import Hooks from './hooks'

function MyComponent(props) {
  const [state] = Hooks.useState(true);

  Hooks.useEffect(() => {
    console.log(state);
  }, []);
}
```

`eslint-plugin-react-hooks` won't trigger the `react-hooks/exhaustive-deps` for the missing `state` dependency. Looking at `eslint-plugin-react-hooks` source code, when accessed through a namespace, there is a hard-coded check for the namespace to be `""React""`.

The same problem occurs for `useState` hooks, where setter is not detected as invariant if `useState` is called from another namespace.

## The expected behavior

`react-hooks/exhaustive-deps` should not care about the namespace. If the hook name matches, then it should trigger the rule. This would be more consistent, as _destructuring from the namespace_ makes the rules work again anyway, as can be seen in the CodeSandbox.

If namespace checks have been added to protect against false-positives, maybe add an option such as `additionalHooksNamespace`  allowing users to choose their own namespace for hooks.",,
20568,OPEN,Bug: False-positive `Warning: An update to Link inside a test was not wrapped in act(...)` after upgrading React to 17.0.1?,Resolution: Needs More Information; Status: Unconfirmed,2021-01-11 10:31:52 +0000 UTC,Vadorequest,,"
1. I upgraded React and react-test-renderer to 17.0.1 (I upgraded other packages as well, but believe it's related to those)
2. Ran tests `yarn test`

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

PR: https://github.com/UnlyEd/next-right-now/pull/248

Reproducing: 

1. `git clone https://github.com/UnlyEd/next-right-now.git next-right-now`
1. `cd next-right-now && git checkout react-link-jest-act-repro`
1. `cp .env.local.example .env.local` - Uses the default ENV variables when running locally
1. `yarn`
1. `yarn test` (then type ""a"" to run them all)

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Using the following code, **all tests pass locally (but fail on Vercel)** (and were passing prior upgrading react packages), but I get tons of warning no, such as `Warning: An update to Link inside a test was not wrapped in act(...).` and those warnings are new, and I couldn't get rid of them:

`I18nLink.test.tsx`:
```tsx
import React from 'react';
import TestRenderer from 'react-test-renderer';
import { NavLink } from 'reactstrap';

import i18nContext from '../../stores/i18nContext';
import I18nLink from './I18nLink';

/**
 * @group unit
 * @group components
 */
describe('I18nLink', () => {
  const I18nLinkTest = (props) => {
    const { locale = 'en', href, text = 'Text', ...rest } = props;

    return (
      <i18nContext.Provider value={{ lang: null, locale: locale }}>
        <I18nLink
          href={href}
          {...rest}
        >
          {text}
        </I18nLink>
      </i18nContext.Provider>
    );
  };

  describe('should properly render', () => {
    test('when going to homepage, it should redirect to i18n homepage', () => {
      const renderer = TestRenderer.create(<I18nLinkTest href={'/'} />);
      const link: any = renderer.toJSON();

      expect(link.type).toEqual('a');
      expect(link.children).toEqual(['Text']);
      expect(link.props.href).toEqual('/en');
      expect(link).toMatchSnapshot();
    });
  });
});
```

`I18nLink` component:

```tsx
import isArray from 'lodash.isarray';
import isEmpty from 'lodash.isempty';
import map from 'lodash.map';
import NextLink from 'next/link';
import React from 'react';

import useI18n, { I18n } from '../../hooks/useI18n';
import {
  I18nRoute,
  resolveI18nRoute,
} from '../../utils/app/router';

type ParamValueToForward = string | number | Array<string | number>;

type Props = {
  as?: string;
  children: React.ReactNode;
  className?: string;
  href: string;
  locale?: string; // The locale can be specified, but it'll fallback to the current locale if unspecified
  params?: { [key: string]: ParamValueToForward };
  passHref?: boolean;
  prefetch?: boolean;
  query?: { [key: string]: ParamValueToForward };
  replace?: boolean;
  scroll?: boolean;
  shallow?: boolean;
  wrapChildrenAsLink?: boolean; // Helper to avoid writing redundant code
};

/**
 * Wrapper around the native Next.js <Link> component. Handles localised links.
 *
 * Use the current active locale by default
 *
 * @example Recommended usage
 *  <I18nLink href={`/`}>Homepage</I18nLink>
 *  <I18nLink href={`/`} className=""customClassName"">Homepage</I18nLink>
 *
 * @example When specifying the locale to use (overrides default)
 *  <I18nLink href={`/`} locale={'fr-FR'}>Homepage in ""fr-FR"" locale</I18nLink>
 *
 * @example The recommended usage is equivalent to this (wrapChildrenAsLink is true, by default)
 *  <I18nLink href={`/`} wrapChildrenAsLink={false}><a>Homepage</a></I18nLink>
 *  <I18nLink href={`/`} wrapChildrenAsLink={false}><a className=""customClassName"">Homepage</a></I18nLink>
 *
 * @example When using children that use a <a> tag, you must set wrapChildrenAsLink to false to avoid using a link within a link
 *   <I18nLink
 *     href={`/`}
 *     wrapChildrenAsLink={false}
 *   >
 *      <NavLink>Homepage</NavLink>
 *   </I18nLink>
 *
 * @example When using route params (other than ""locale""). Ex: /products/5
 *   <I18nLink
 *     href={'/products/[id]'}
 *     params={{
 *       id: 5,
 *     }}
 *   >
 *      Go to product 5
 *   </I18nLink>
 *
 * @example When using route query params. Ex: /products/5?userId=1
 *   <I18nLink
 *     href={'/products/[id]'}
 *     params={{
 *       id: 5,
 *     }}
 *     query={{
 *       userId: 1
 *     }}
 *   >
 *      Go to product 5 with userId 1
 *   </I18nLink>
 *
 * @param props
 */
const I18nLink: React.FunctionComponent<Props> = (props): JSX.Element => {
  const { locale: currentLocale }: I18n = useI18n();
  const {
    as,
    children,
    className,
    href,
    locale = currentLocale,
    params,
    passHref = true,
    query,
    wrapChildrenAsLink = true,
    ...rest // Should only contain valid next/Link props
  } = props;
  let {
    i18nHref, // eslint-disable-line prefer-const
    i18nAs,
  }: I18nRoute = resolveI18nRoute({ as, href, locale });

  if (!isEmpty(params)) {
    // If any params are provided, replace their name by the provided value
    map(params, (value: ParamValueToForward, key: string | number) => {
      if (isArray(value)) {
        value = value.join(',');
      }
      i18nAs = i18nAs.replace(`[${key}]`, value as string);
    });
  }

  if (!isEmpty(query)) {
    // If any query params are provided, append it to `as`, so it gets forwarded;
    const queryParamsString = Object.keys(query)
      .map((k) => {
        if (isArray(k)) {
          k = k.join(',');
        }
        return `${k}=${query[k]}`;
      })
      .join('&');
    i18nHref += `?${queryParamsString}`;
    i18nAs += `?${queryParamsString}`;
  }

  return (
    <NextLink
      href={i18nHref}
      as={i18nAs}
      {...rest}
      passHref={passHref}
    >
      {wrapChildrenAsLink ? (
        // eslint-disable-next-line jsx-a11y/anchor-is-valid
        <a className={className}>{children}</a>
      ) : (
        React.cloneElement(children as React.ReactElement)
      )}
    </NextLink>
  );
};

export default I18nLink;

```

## The expected behavior

The current code shouldn't yield any warning. It's mistakenly reporting warnings thinking the tests update the react state, but we don't. We simply render a React component, without interacting with it, therefore the react state shouldn't change. I believe this is a false-positive warning.",,
20503,OPEN,React needs some way to fuzz setState timing/usage,,2020-12-23 00:10:15 +0000 UTC,ariccio,,"It seems kinda obvious to me now that I think about it. One of the more common problems people have with setState is stale refs or other timing and concurrency mistakes. For native code, we have things like Application Verifier's concurrency fuzzer, which can randomly delay some APIs to see if user code correctly handle uncommon timing issues.


So, why don't we have something like that for React APIs like setState? Randomly delay them for a set time? It looks like there's some internal fuzzing to test React's own correctness, but I don't see anything that I could enable to fuzz my React code.",,
20497,OPEN,Bug: CSS variables can't be a space character,Component: DOM; Status: Unconfirmed; Type: Bug,2021-01-09 21:31:14 +0000 UTC,madou,,"1. https://codesandbox.io/s/empty-css-value-jmbfl?file=/src/App.js
2. Notice the ""should be black border"" has a pink border
3. Dangerously setting inner HTML works because it doesn't go through reacts `trim()` flow
4. I've tracked the suspect code to here https://github.com/facebook/react/blob/6cbb9394d1474e3a728b49dc7f3a11d61a421ce3/packages/react-dom/src/shared/dangerousStyleValue.js#L44

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/empty-css-value-jmbfl?file=/src/App.js

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

CSS variables have their value trimmed - resulting in `' '` become `''` which then removes the CSS variable from the browser.

![image](https://user-images.githubusercontent.com/6801309/102850783-52bad780-446e-11eb-8cd3-222061febb48.png)

## The expected behavior

The `' '` value should not be trimmed.

![image](https://user-images.githubusercontent.com/6801309/102850909-944b8280-446e-11eb-9a88-9660469faf3e.png)

One potential option is to, for any custom properties that have a space value, don't trim.

```js
if (isCustomProperty && value === ' ') {
   return value;
}

return ('' + value).trim();
```

I'm happy to do the bug fix. I would also love for this to get released on v16.

---

Found a work around:

https://codesandbox.io/s/empty-css-value-forked-g5jud?file=/src/App.js

```js
style={{ ""--border-color"": ""var(--, )"" }}
```",,
20494,OPEN,Replace DevTools mutable Suspense cache with newer Cache API,Status: Unconfirmed,2020-12-21 15:59:41 +0000 UTC,bvaughn,,"Follow up to PR #20463 and 5d10e41

It would be nice to replace the outdated cache API currently used in DevTools with a newer one that's compatible with APIs like `useTransition`. This would allow DevTools to better handle UX like clearing errors/warnings for the inspected element without needing to immediately poll for new data. (Currently it's either that or show an awkward second or two delay after you click the button before anything appears to happen.)",,
20492,OPEN,Bug: BigInt does not get toString()'d when rendered,Component: DOM; Status: Unconfirmed; Type: Feature Request,2020-12-22 09:45:07 +0000 UTC,andyboyne,,"<div>{1n}</div> should render 1. Instead it renders ''.  

It looks like 'bigint' just needs adding here: https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ToStringValue.js#L26. 

Happy to raise a PR or take guidance on a better approach.

React version: all

## Steps To Reproduce
Link to code example: https://codepen.io/boyne/pen/vYXJWVr


## The current behavior
Renders """"


## The expected behavior
Renders 1
",,
20491,OPEN,New JSX runtime advice for package authors?,Status: Unconfirmed,2020-12-21 19:37:48 +0000 UTC,rafgraph,,"I'm wondering if you have any advice around using the new JSX runtime in packages with `react` as a peer dependency?

For compatibility reasons it seems like packages shouldn’t use the JSX runtime (at least not yet) because then the package would only be compatible with versions of React that include the new JSX runtime (but in time this compatibility reason will fade).

If a package did use the new JSX runtime, I think it could only be used in the ESM and CJS builds. The UMD build would still need to use `createElement` as the UMD version of React doesn't include the JSX runtime.

Curious if you could provide some insight on the plan for the JSX runtime in peer dependency packages? Will the JSX runtime eventually be part of the React UMD build? Does tooling need to support using the JSX runtime in ESM and CJS builds, while always using `createElement` in the UMD build? Thanks.

I ran into this issue when creating [Rollpkg](https://github.com/rafgraph/rollpkg), a zero config build tool to create packages with Rollup and TypeScript.

Thanks for all your work on React, I've really enjoyed using it the past several years!",,
20483,OPEN,Bug: React onMouseEnter; onMouseOver and onMouseLeave not firing as expected (Chrome),Status: Unconfirmed,2021-03-12 17:47:31 +0000 UTC,tseveenganbold,,"React is not firing onMouseLeave, onMouseOver, onMouseEnter events on images.(Chrome)

React version:
17.0.1

Code example: 
![carbon](https://user-images.githubusercontent.com/67759816/102604550-a2269e00-4124-11eb-8641-dbb3c0305d7d.png)


## The current behavior
Only changing the state when clicked

## The expected behavior
Changing the state when hovered",,
20476,OPEN,Bug: onChange event is fired twice when replacing selected text,Status: Unconfirmed,2020-12-16 20:02:16 +0000 UTC,perenstrom,,"React version: 17.0.1

## Steps To Reproduce

1. Add an `onChange` handler to an `input[type=text]` field, logging the `event.target.value`
2. Write a letter in the input (see that it fires an event)
3. Select all text
4. Type a new letter, thus replacing the previous letter
5. This will trigger two events on some device setups, one with blank input, and one with the new letter.

**Link to code example**: https://codesandbox.io/s/react-input-event-twice-4dh59

## The current behavior
On some devices the replacement of a selection fires twice, first with empty input and second with the typed letter.

![mobile-chrome-onchange](https://user-images.githubusercontent.com/765759/102398261-58806b00-3fdf-11eb-99bb-1290abe54af0.jpg)

## The expected behavior
Only one input event should be fired, with the new letter.

![Screenshot 2020-12-16 at 20 40 58](https://user-images.githubusercontent.com/765759/102398307-659d5a00-3fdf-11eb-8839-c1ea5a85e0d9.png)

## Devices/browsers tested:
**Two events (bug):**
* OnePlus 5, Android OxygenOS 9.0.9, Chrome 87.0.4280.101
* OnePlus 3T, Android OxygenOS 9.0.6, Chrome 87.0.4280.101

**One events (working as intended):**
* MacOS 10.14.6, Firefox 83.0
* MacOS 10.14.6, Chrome 87.0.4280.88
* iPhone X, iOS 14.2, Chrome 87.0.4280.77
* Pixel 2, Android 8.0.0, Chrome 87.0.4280.101 (however this test person experienced the bug earlier, but might have been an in app browser somewhere)

## Related:
* https://github.com/facebook/react/issues/8531 IE10 triggers onChange twice when replacing a text selection",,
20464,OPEN,Bug: Setting up environment and build to contribute,Status: Unconfirmed,2020-12-25 15:27:38 +0000 UTC,matheushf,,"1. Fork & Clone repository
2. `yarn`
3. `yarn build react/index,react-dom/index,scheduler --type=NODE`

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
```
.../react/scripts/rollup/build.js:44
  throw err;
  ^

Error: Command failed: npm pack build/node_modules/jest-react

    at ChildProcess.exithandler (child_process.js:308:12)
    at ChildProcess.emit (events.js:315:20)
    at maybeClose (internal/child_process.js:1048:16)
    at Process.ChildProcess._handle.onexit (internal/child_process.js:288:5) {
  killed: false,
  code: 243,
  signal: null,
  cmd: 'npm pack build/node_modules/jest-react'
}
```

With only `yarn build` it fails on `Error: Command failed: npm pack build/node_modules/react-reconciler`

## The expected behavior
Build without problems",,
20446,OPEN,Using dangerouslySetInnerHTML with <Script> Tag?,,2020-12-20 05:07:30 +0000 UTC,iwantHD,,"Backend return an html type string and I want render in react through

<div dangerouslySetInnerHTML ={{__html : html}}></div>

however, html contains the JS code that dynamically add data to <Table> Tag and it does not render any data in my page
the table is empty

How could solve this problem?

Thanks for any ideas

",,
20435,OPEN,Feature Request(devtools): `launch-editor` for selected component,Component: Developer Tools; Type: Feature Request,2021-02-24 05:47:00 +0000 UTC,Airkro,,"### Why: 

User can open the source file in editor/ide by one-click.

It' is a useful feature in `vue-devtools`.

---

### How: 

Add a click event on here:

https://github.com/facebook/react/blob/cdfde3ae110844baf068706e7ed3fe97ec15f1d7/packages/react-devtools-shared/src/devtools/views/Components/InspectedElementView.js#L226-L228

call ```fetch(`/__open-in-editor?file=${fileName}:${lineNumber}`)```

Add [launch-editor-middleware](https://github.com/yyx990803/launch-editor) to dev-server(or any scaffold handle by himself)

---

Before anyone(maybe me) sends a PR, I want to know how do the react-team thinks about it?",,
20431,OPEN,"Error: ""Commit tree does not contain fiber 5766. This is a bug in React DevTools.""",Component: Developer Tools; Type: Bug,2021-03-11 19:40:21 +0000 UTC,dixitk13,,"Describe what you were doing when the bug occurred:
1. Profiling [recharts library](https://recharts.org/en-US/api/LineChart)
2. Filtered on commits greater than 3s 
3. Walking through the commits doing a next > next 

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.10.1-f160547f47

Call stack: at updateTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19729:21)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19594:26)
    at ProfilingCache_ProfilingCache.getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:20115:11)
    at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:34161:33)
    at Hh (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:12807:7)
    at qi (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13457:7)
    at mk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:16074:86)
    at lk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15459:11)
    at kk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15451:23)
    at ck (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:15435:5)

Component stack: at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:34144:50)
    at div
    at div
    at div
    at SettingsModalContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28206:3)
    at Profiler_Profiler (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:35772:50)
    at ErrorBoundary_ErrorBoundary (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29219:5)
    at PortaledContent (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29336:32)
    at div
    at div
    at ProfilerContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32934:3)
    at TreeContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24322:3)
    at SettingsContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:24811:3)
    at ModalDialogContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:29404:3)
    at DevTools_DevTools (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:36207:3)",,
20377,OPEN,CRA: Fast Refresh breaks embedded DevTools backend,Component: Developer Tools; Component: Fast Refresh; Type: Discussion,2020-12-14 14:53:53 +0000 UTC,sonium0,,"`TypeError: undefined is not a function (near '...e.sub...')
(anonymous function)
src/backend/index.js:26
  23 |   // DevTools didn't get injected into this page (maybe b'c of the contentType).
  24 |   return () => {};
  25 | }
> 26 | const subs = [
     | ^  27 |   hook.sub(
  28 |     'renderer-attached',
  29 |     ({
View compiled
(anonymous function)
src/backend.js:179
  176 |   hook.emit('shutdown');
  177 | });
  178 | 
> 179 | initBackend(hook, agent, window);
      | ^  180 | 
  181 | // Setup React Native style editor if the environment supports it.
  182 | if (resolveRNStyle != null || hook.resolveRNStyle != null) {`
React version:

## Steps To Reproduce

1. create-react-app
2. yarn add react-devtools
3. in index.js add import 'react-devtools' on first line
4. start react-devtools
4. start create-react-app devserver
6. go to localhost:3000
7. crash


Link to code example:

add react-devtools on first line of vanilla 'create-react-app'

## The current behavior

<img width=""941"" alt=""devtools"" src=""https://user-images.githubusercontent.com/5372632/101188389-f24a2e80-3655-11eb-9a6b-239ac8742eb1.png"">

## The expected behavior

Debug-Session



",,
20368,OPEN,Bug: Memory Leak when rendering arrays,Resolution: Needs More Information,2020-12-02 14:31:12 +0000 UTC,angeloocana,,"## Steps To Reproduce

1. Open the code sandbox https://codesandbox.io/s/cool-kalam-77v5m?file=/src/App.js
2. Click ""Add "" button to render the list
3. Click ""Remove"" button to remove the list
4. Force Garbage Collection in Chrome Memory Dev tools (click the trash icon)
5. Run in the console ""memoryLeaksDebugger.check()""

![react_bug](https://user-images.githubusercontent.com/5487699/100877970-8ca04b80-3477-11eb-9e2f-c943c5b4077d.gif)


<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://codesandbox.io/s/cool-kalam-77v5m?file=/src/App.js

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Any child of a component that is rendered inside a `.map` stays alive in memory when the components are unmounted.

## The expected behavior
No components should stay in memory when they are unmounted.
",,
20359,OPEN,TypeError: Cannot read property 'setExtraStackFrame' of undefined,Type: Discussion,2020-12-30 03:17:26 +0000 UTC,IMMC,,"I try Upgrade to the New JSX Transform in my project.(According to the official tutorial.)
I used production react  in development  environment，I see this error.
but, if used development react in  development  environment， every thing is ok.

React version:
17.0.1
## The current behavior
TypeError: Cannot read property 'setExtraStackFrame' of undefined

## Additional information
  react.production.min.js:22 Uncaught TypeError: Cannot read property 'setExtraStackFrame' of undefined
    at setCurrentlyValidatingElement (react-jsx-runtime.development.js:574)
    at checkPropTypes (react-jsx-runtime.development.js:618)
    at validatePropTypes (react-jsx-runtime.development.js:1072)
    at jsxWithValidation (react-jsx-runtime.development.js:1192)
    at jsxWithValidationDynamic (react-jsx-runtime.development.js:1209)
    at PartPage (PartPage.js:161)
    at Le (react-dom.production.min.js:100)
    at Re (react-dom.production.min.js:113)
    at Pj (react-dom.production.min.js:232)
    at di (react-dom.production.min.js:168)",,
20356,OPEN,Feature Suggestion: use a function to clone from current to workInProgress.alternate.,,2020-11-30 23:47:57 +0000 UTC,jacty,,"
https://github.com/facebook/react/blob/3f73dcee374732a331b7e72c88ff6dd3b7116a42/packages/react-reconciler/src/ReactFiber.new.js#L302-L308

when we have many properties to clone from current to workInProgress.alternate, I am not sure if we should use a function  to clone to make it easier and clearer? Personally and semantically, I feel using a function will make our target here clearer. 
",,
20349,OPEN,The interface(Children.map) has no iteration object returned by the recursive call function,Status: Unconfirmed,2020-11-29 07:26:27 +0000 UTC,tsinglemon,,"```js
import {React, Children} from 'react'
export function(){

  const iterationObj = new Set();

  const result = Children.map('some text', () => {

    iterationObj.add('one element');
    iterationObj.add('two element');
    return iterationObj;

  })

  // The iteration object is returned, and there are no child elements in the flat iteration object
  console.log('result', result)  // [Set(2)]

  return <div>placeholder</div>

}
```
## Expect
```JS
console.log(result) // ['one element', 'two element']
```
![image](https://user-images.githubusercontent.com/23120174/100535784-eb3aaf00-3256-11eb-8c65-de1b08f12f15.png)

",,
20342,OPEN,[eslint-plugin-react-hooks]: Can't use hooks in static class methods,Status: Unconfirmed,2020-11-29 21:45:56 +0000 UTC,d07RiV,,"As title implies, eslint believes that using a react hook in a static method of a class not derived from anything is an attempt to call it in a class component.

    class Foo {
      // this is in fact a custom react hook
      static useSomething() {
        const [value, setValue] = React.useState(); // error: React Hook ""React.useState"" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook
        // ... some logic
      }
    }

## The expected behavior

There are no class components involved, so the error makes no sense.",,
20339,OPEN,"Improved ""memory leak"" warning",Status: Unconfirmed,2020-12-04 08:44:59 +0000 UTC,Aprillion,,"Dear React Maintainers,

My proposal to improve the [""memory leak"" warning](https://github.com/facebook/react/blob/e6a0f276307fcb2f1c5bc41d630c5e4c9e95a037/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L3096) has quite a long background, so let me first thank you for keeping React alive and well. You are all fabulous 🎉

### TL;DR

A Promise is not cancellable, so there is 90% chance that no memory leaks will be fixed when a user applies a ""solution"" to this warning from the internet. This warning encourages a pit of failure (more complex code without removing actual memory leaks) and I argue the detection of memory leaks should be changed.

Table of contents: <a href=""#good"">The good</a> (<a href=""#solutions"">Intended Solutions</a>) - <a href=""#bad"">The bad</a> - <a href=""#uncanny"">The uncanny</a> - <a href=""#proposal"">Proposal</a>

# The good <a name=""good""></a>

> Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.

There were, obviously, good reasons to introduce this warning in the first place. React can't detect memory leaks directly, so this was the next best thing to detect forgotten imperatively attached DOM event handlers or uncancelled WebAPIs. The warning itself does not list any examples, so let me illustrate with [my own bad example](https://codesandbox.io/s/immutable-sun-fo3nt?file=/src/App.js):

```js
const [tick, setTick] = useState(0)
useEffect(() => {
  setInterval(() => setTick(t => t+1), 1000)
}, [])
```

And the intention of the warning is to gently guide the developer to figure out, on their own, what cleaning up means. 

## Intended Solutions <a name=""solutions""></a>

Let me list a few ideas how I think the memory leaks should be solved.

For the *setInterval* (or *setTimeout*):

```js
const [tick, setTick] = useState(0);
useEffect(() => {
  const interval = setInterval(() => setTick(t => t + 1), 1000)
  return () => clearInterval(interval)
}, []);
```

*Aborting a fetch*:

```js
const [data, setData] = useState(null);
useEffect(() => {
    const {signal, abort} = new AbortController()
    fetch('...', {signal}).then(r => r.json()).then(setData)
    return abort
}, []);
```

Replacing closure references to the dispatch function inside `.then(...)` when *dealing with an uncancellable Promise*:

```js
const [data, setData] = useStateIfMounted(null)
useEffect(() => {
  myGenericPromise.then(setData)
}, [])

...

function useStateIfMounted(initialValue) {
  const [state, setState] = useState(initialValue)
  const setterRef = useRef(setState)
  const setterIfMounted = useCallback((...args) => setterRef.current(...args), [])
  useEffect(() => {
    return () => {
      setterRef.current = () => undefined
    }
  }, [])

  return [state, setterIfMounted]
}
```

Note the last one is basically recreating the `no-op` done internally by React (if my understanding is in the right ballpark).

# The bad <a name=""bad""></a>

Now, the same buggy code causes a [completely different warning in tests](https://github.com/facebook/react/blob/e6a0f276307fcb2f1c5bc41d630c5e4c9e95a037/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L3354) (at least in most cases I checked, not sure if always):

>  Warning: An update to MyComponent inside a test was not wrapped in act(...).

Let's ignore that for a second and try to analyze the solutions that developers can find for the ""memory leak"" problem on the internet. 

1.) `isMounted` variants, like in most of the top answers on [StackOverflow](https://stackoverflow.com/search?tab=votes&q=%22perform%20a%20React%20state%20update%20on%20an%20unmounted%20component%22) or various learning materials such as Kent's [useSafeDispatch](https://github.com/kentcdodds/advanced-react-hooks/blob/560980b10fd10e66fcf5e4f5b4b90bf46cb5fc7b/src/utils.js#L3)

=>❌ These solutions only address the warning, not solving any memory leaks (presumably, they focus on making the warning go away if it's a false positive). The code is more complex without any benefit. An example of shutting up the warning without solving the leak:

```js
const [tick, setTick] = useState(0)
const isMounted = useRef(true)
useEffect(() => {
  setInterval(() => isMounted && setTick(t => t+1), 1000) // ❌ please don't run infinite intervals at home
  return () => isMounted.current = false
}, [])
```

2.) fake cancellation like at the end of [isMounted is an Antipattern](https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html) or the cancel method from the [react-async library](https://github.com/async-library/react-async/blob/129385c7477c9c6b5ad9c4ea96220779478a1ff6/packages/react-async/src/useAsync.tsx#L230-L231)

=>❌ These look like valid solutions on a first look, but they actually leave the closure references untouched, so not solving any memory leaks either. JS Promise is simply not cancellable (yet?), and no amount of sophistication will allow garbage collection of closures of the function used for the `.then(...)` callback while the Promise is still pending - it is not possible to modify the original Promise, only to create a new Promise. The code is much more complex without any benefit. (see <a href=""#uncanny"">The uncanny</a> section for details)

3.) real cancellation like https://stackoverflow.com/a/54964237/1176601

=>✔ Aborting a fetch request and other operations that enable garbage collection.
=>❌ But it's very hard to figure it out from the available advice - ""memory leaks"" is not the best documented topic for JavaScript...

# The uncanny <a name=""uncanny""></a>

My statement about fake cancellations (2. above) could be controversial, so let me elaborate:

As far as I can tell, the `makeCancellable` utility from the end of https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html as well as _all_ proposed solutions in https://github.com/facebook/react/issues/5465 , https://github.com/reactjs/reactjs.org/issues/1082 and https://github.com/facebook/react/issues/15006 suffer from the same memory leaks as a naive solution would:

```js
// naive
const [value, setValue] = useState()
useEffect(() => {
  myPromise.then(setValue)
}, [])
```

This naive solution can trigger the warning (as a race condition during unmount), while the complicated solutions won't. Both leak the exact same amount of memory references - functions that we know will never be used but the JS engine cannot garbage collect - because a closure reference to them still exists.

Let me illustrate on a modified example that can be executed in the console => the `cancelablePromise` will be rejected after 2 seconds, so the reference from `then` to the function that was a value of the `setValue` variable will exist for exactly as long as in the naive solution:

```js
const cancelablePromise = makeCancelable(
  new Promise(r => setTimeout(r, 2000))
);
const setValue = () => undefined

cancelablePromise
  .promise
  .then(setValue)
  .catch((reason) => console.log('isCanceled', reason.isCanceled));

cancelablePromise.cancel(); // Cancel the promise

function makeCancelable(promise) {
  let hasCanceled_ = false;

  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(
      val => hasCanceled_ ? reject({isCanceled: true}) : resolve(val),
      error => hasCanceled_ ? reject({isCanceled: true}) : reject(error)
    );
  });

  return {
    promise: wrappedPromise,
    cancel() {
      hasCanceled_ = true;
    },
  };
};
```

As for the `cancel` method in https://github.com/async-library/react-async/blob/129385c7477c9c6b5ad9c4ea96220779478a1ff6/packages/react-async/src/useAsync.tsx#L230-L231, that is even more complicated, but my intuition says that a reference to `dispatch` will continue to exist after `cancel()` as long as the `promiseFn` is pending - because the `cancel` function does not clear `lastPromise.current`...

# Proposal <a name=""proposal""></a>

## Option 1: small tweak

How about flipping [this condition](https://github.com/facebook/react/blob/e6a0f276307fcb2f1c5bc41d630c5e4c9e95a037/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L3121) `if (didWarnStateUpdateForUnmountedComponent.has(componentName)) return;` the other way round? If some code tries to update the state of an unmounted component just once, ignore it.

Sweep the little insignificant memory leak under the carpet (remember, I argue that it is more likely that an attempt to fix the warning will NOT fix any memory leaks, so remaining quiet is not such a bad option and the memory will be freed at the same time with or without this warning - but the user code will be much simpler if they don't attempt to fix this warning).

On the other hand, if the state update happens repeatedly after the unmounting (e.g. setInterval or observable stream), that is a very clear signal that the memory leak is more serious => the warning is much more useful in this situation. It might require some re-wording + a link to examples how to fix it correctly.

However, I am not sure about the related `not wrapped in act(...)` warning in tests. Changes to one warning might require synchronization of both warnings for consistency...

## Option 2: detect the memory leaks in Dev Tools

In an ideal world, it should be possible to trigger browser garbage collection from inside React Dev Tools code in all supported browsers. That might not be the case in the real world, but please stay with me for 1 more minute: both supported browsers are open source and they both expose the tools to trigger garbage collection in GUI => some API must exist and it should be possible to expose it in a browser extension.

Now, if React Profiler could trigger GC reliably after pressing the stop profiling button, then we can use an array of [WeakRef](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)s to find all references to the dispatchers (or other objects) of unmounted components that leaked in some closure somewhere. Pseudocode:

```js
const zombies = []

function unmountComponent(node) {
  dispatchZombies.push(new WeakRef(node))
}

function stopProfiling() {
  gc()
  warningAboutZombies.nodes = zombies.map((ref => ref.deref()).filter(Boolean)
}
```

## Option 3: React.getZombies()

Expose some method to get a list of ""undead zombie references"" in tests, that would be available when running in Node with the `--expose-gc` flag...",,
20332,OPEN,Bug: React's batching makes state comparison checks unreliable,Status: Unconfirmed,2020-11-27 18:11:40 +0000 UTC,benoitgrelard,,"It seems that in some situations React's batching makes comparison to change in state unreliable.
In the provided example, focus/blur handlers produce different outcomes:
- when triggered via **tabbing**
- vs. when **manually focusing on keydown**

React version: 17.0.0

## Steps To Reproduce

1. Open the provided codesandbox
2. Focus the 2 inputs back and forth by tabbing
3. Note the `onChange` logs correspond to the updates and are in sync with the UI
4. Now instead, focus an input then press the **down arrow** to programmatically focus back and forth between the 2 inputs
5. Note the `onChange` logs are now wrong and inconsistent with the UI (initially `true` and then `false` forever)

Link to code example: https://codesandbox.io/s/react-staleness-ishfn?file=/src/App.js

## The current behavior

### When tabbing through this is the output I get:

onChange `true`
onChange `false`
onChange `true`
onChange `false`
onChange `true`
onChange `false`

### When pressing arrow down to focus the inputs back and forth I get:

onChange `true`
onChange `false`
onChange `false`
onChange `false`
onChange `false`
onChange `false`

> Note that if you check the ""Prevent React from batching updates?"" checkbox, both examples behave the same. The only difference is that in this case, we wrap the `.focus()` calls in a `setTimeout()` to avoid batching.

## The expected behavior

We would expect the 2 examples to behave the same.
",,
20330,OPEN,Bug: onLoadStart is not passed to img,Component: DOM; Status: Unconfirmed,2020-11-27 15:53:54 +0000 UTC,keul,,"Although it seem a valid event, and it works using vanilla HTML/JS (at least **Firefox**, Chrome still have an open bug https://bugs.chromium.org/p/chromium/issues/detail?id=458851), it seems that using and `onLoadStart` event on an `img` is not working in react.

React version: 17.0.0

## Steps To Reproduce

1. With **Firefox** open browser development tools
2. Disable browser's cache
3. Using Firefox go to https://ukpcn.csb.app/
4. Check the console

Link to code example: https://codesandbox.io/s/onloadstart-issue-ukpcn

## The current behavior

The console shown:

```
Vanilla img loading
Vanilla img loaded
React img loaded
```

Seems that the `onLoadStart` is not working.

## The expected behavior

The `onLoadStart` function should be executed, so logging also `React img loading`",,
20327,OPEN,Bug: [react-reconciler] Impossible to import react-reconciler correctly in typescript library without setting esModuleInterop:true in tsconfig.,Component: Reconciler; Status: Unconfirmed,2020-11-24 09:20:17 +0000 UTC,JustFly1984,,"React version: not relevant

## Steps To Reproduce

1. fork `react-three-fiber` at this commit https://github.com/pmndrs/react-three-fiber/commit/3e55c9a7b960d7c9596cdc988fb9a7bf33a8c4f9
2. run `yarn` to install deps
3. open src/renderer.tsx
4. run `yarn dev` to test changes.

## The current behavior

I have all consumer typescript projects setup with `esModuleInterop: false`, and then I check types, I check all types including dependencies, I often see warnings about some imports being required to use with `esModuleInterop: true`, but enabling the rule to true leads to other unwanted consequences.

My last issue was with `react-three-fiber`, do I got it forked, and disabled `esModuleInterop`, fixed a lot of types issues until I have stumbled into `react-reconciler`

It is exporting a function as CJS module with `export =`, and I can't import it correctly as `import * as Reconciler from 'react-reconciler`, cos the default can't b function and app is crashing with no TS errors.

On other hand, if I `import Reconciler from 'react-reconciler'`, I got no app crashing, but typescript error, and forced to `// @ts-ignore` it. It works fine, but looses type safety, and breaks the build for consumers using rollup for build.

## The expected behavior

Add possibility to `import { Reconciler } from 'react-reconciler'`",,
20311,OPEN,Feature Request: useComponent Hook,,2020-11-27 08:31:58 +0000 UTC,myckhel,,"I would like to propose a feature to be implemented in react based on this library https://github.com/myckhel/react-use-component

The `react-use-component` was created to limit the use of memoised callback hooks and to create `Object Oriented` functional `Components`.

I would like the react team to look into the concept of this `API` and consider its benefits to the amazing `React` framework. 

Thanks for your review. ",,
20294,OPEN,Bug: function in useState hook; setting different value,Resolution: Needs More Information; Status: Unconfirmed,2020-11-19 10:06:51 +0000 UTC,psyKressX,," useState hook telling me one value then setting another, understand its recommended to use useReducer when working with data structures but i still dont understand why this is happening, this is code block
```
const onAdd = (id, amount = 1) => {
   setItems(old => {
      const idx = old.findIndex(i => i.product_id === id)
      console.log(old[idx].value, amount)
      old[idx].value += amount;
      console.log(""after"", old[idx].value)
      return [...old]
   })
```
value starts at 0, the console logs are as follows

<img width=""461"" alt=""log"" src=""https://user-images.githubusercontent.com/50396417/99610540-24f50400-2a66-11eb-82eb-0c5f3637a825.png"">

the state ""adds"" double what ever the amount is, for the case above, 2, the console logs only run once so the function isnt running twice and it also works fine the non-useEffect safe way below

```
const old = [...items]
const idx = old.findIndex(i => i.product_id === id)
old[idx].value += amount;
setItems(old)
```

React version: react-dom@17.0.1

",,
20262,OPEN,Bug: react-hooks/exhaustive-deps false postive when given undefined as deps,Component: ESLint Rules; Type: Bug,2020-11-20 19:39:35 +0000 UTC,sQVe,,"const allIds = useMemo(() => Object.keys(byId), undefined)
```

This is clearly noticeable together with TypeScript as it does not allow omitting the second `deps` parameter, with the following typings:
```typescript
// allow undefined, but don't make it optional as that is very likely a mistake
function useMemo<T>(factory: () => T, deps: DependencyList | undefined): T;
```

Note here that `deps` must be either a `DependencyList` or `undefined`. It is not listed as optional.

React version: 17.0.1

## Steps To Reproduce

1. Install `""eslint-plugin-react-hooks"": ""^4.1.0""` and extend it with `'plugin:react-hooks/recommended'`
2. Write a hook that required a dependency list, input `undefined`.

## The current behavior
Gives false positive when given `undefined` for `deps`.

## The expected behavior
Should allow `deps` to be set to undefined.",,
20261,OPEN,Bug: Components tab goes blank with React 16.8.0,Component: Developer Tools; Status: Unconfirmed; Type: Needs Investigation,2021-03-08 14:55:08 +0000 UTC,abelardolg,,"
1. Build a hello world with any component
2. Open React Dev Tools.
3. Choose components tab.
4. Nothing will be seen.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Tab ""Component"" is blank

## The expected behavior
Tab ""Component"" should show React components

FYI: I installed Material UI library.
Chrome: Versión 86.0.4240.183 (Build oficial) (64 bits) Ubuntu 18.04.
Tested today.
Versión
4.10.0 (11/12/2020)
Actualizado
13 de noviembre de 2020",,
20258,OPEN,Issue regarding ESLint react-hooks - 'exhaustive-deps' rule,Component: ESLint Rules; Status: Unconfirmed,2020-11-22 16:54:43 +0000 UTC,a-tonchev,,"I read in detail the following issue: https://github.com/facebook/react/issues/14920#issuecomment-467212561

As suggested in the last comment of gaearon I file a new issue because I could not find solution of my cases.

I read really a lot online and in detail about useEffect in general and the exhaustive-deps rule, but somehow there is still a lot of walking in a circle. So I would be very thankful for better suggestion or clarifying how to handle this issues:

It looks that it confuses also a lot of developers and it is quite difficult to write work-arounds for the most common use-cases:

https://github.com/facebook/react/issues/14920

Here I provide few examples that really are not easy to be set-up with this rule:

**Example 1**: Initialization of app - or check cookies/localstorage once the application loads, and set them in the context:

    import React, { useState, createContext, useEffect } from 'react';
    import { useTranslation } from 'react-i18next';
    import CookieHandler from '../helpers/CookieHandler';
    import Loading from '../components/common/Loading';
    
    const defaultValues = {
      authorization: {
        loggedIn: false,
        isAdmin: false,
      },
      dispatchAuthorization: () => {},
    };
    
    const LoginContext = createContext(defaultValues);
    
    const reducer = (state, authorization = { loggedIn: false, isAdmin: false }) => {
      const { loggedIn, isAdmin } = authorization;
      return { loggedIn: !!loggedIn, isAdmin: !!isAdmin };
    };
    
    const LoginContextProvider = ({ children }) => {
      const [authorization, dispatchAuthorization] = React.useReducer(reducer, defaultValues.authorization);
      const [mounted, setMounted] = useState(false);
      const { i18n } = useTranslation();
    
      const setLoginData = (token, isAdmin) => {
        if (token) {
          dispatchAuthorization({
            loggedIn: true,
            isAdmin: isAdmin,
          });
        }
        setMounted(true);
      };
    
      const setLanguage = (language) => {
        i18n.changeLanguage(language);
        CookieHandler.setLanguage(language);
      };
    
      const loginUser = data => {
        CookieHandler.setToken(data.token);
        CookieHandler.setAdmin(data.isAdmin);
        setLoginData(data.token, data.isAdmin);
      };
    
      const removeLoginData = () => {
        CookieHandler.logout();
        dispatchAuthorization({
          loggedIn: false,
          isAdmin: false,
        });
      };
    
      useEffect(() => {
        const token = CookieHandler.getToken();
        const isAdmin = CookieHandler.getAdmin();
        const language = CookieHandler.getLanguage();
    
        if (token) {
          setLoginData(token, isAdmin);
        } else if (authorization.loggedIn || authorization.isAdmin) removeLoginData();
    
        if (language) setLanguage(language);
        setMounted(true);
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);
    
      if (!mounted) return <Loading />;
    
      return (
        <LoginContext.Provider
          value={{
            authorization,
            dispatchAuthorization,
            setLoginData,
            loginUser,
            setLanguage,
            logoutUser: removeLoginData,
          }}
        >
          {children}
        </LoginContext.Provider>
      );
    };
    
    const LoginContextConsumer = LoginContext.Consumer;
    
    export { LoginContext, LoginContextProvider, LoginContextConsumer };


Here I want that the `useEffect` is called really **once** the application is loaded, and never again. But according to eslint I should add the authorization variable in the dept array, but that is something I really don't want to do. Because each time there is a change in the authorization, the whole INIT-Prozess will start over and over again. I think an init-functionality that fires once the component/or application starts is quite needed, without thinking of changing in variables later?

**Example 2:** Use of functions that are comming from hooks. An example with **react-i18next**:

    ...
    import { useTranslation } from 'react-i18next';
    ...
    
    const MyComponent = ({ someId }) => {
     const { t } = useTranslation();
     const [data, setData] = useState(null);
      useEffect(() => {
        const someAsyncFetch = async () => {
      try {
        const data = await asyncFetchData({
          someId,
        });
        setData(data);
        toastr.success(t('your.data.was.fetched.successfully'));
      } catch (e) {
        console.log(e);
        toastr.error(t('your.data.can.not.be.fetched'));
      }
     };
        someAsyncFetch();
      }, [someId]);
    }

In this example, I want to get all the data when my component gets rendered, or when the someId is changed. When data is loaded or error comes - I fire toastr message with the translation function **t** that I get in a hook. But I don't want to get new data each time the user switch his language. But eslint want me to put t in the deps array, which causes to re-render component and load new data each time the user switch the language. And moreover, we should expect that more and more such hook-functions will come in future, which we eventually may want to use in the useEffects.

**Example 3:** One variable is depending on other variables

      useEffect(() => {
        if (error === null) {
          const data = doSomethingWithMyValue(value1);
          setMyData(data);
        } else {
          showSomeErrorText(); //or do nothing
        }
      }, [value1]);

If I want that only when value1 changes, the function doSomethingWithMyValue will be fired, but not when error changes. When we put error inside the `useEffects` deps array then the whole logic is broken, because useEffect will be fired each time error changes. And this is something I don't want. 

I tried also to make some kind of workaround with a mounted variable, and `useCallback`, but it looks for me that `useEffect` fires unnecessary many times, and somehow the whole thing is slower.

So is there somewhere a logic-catch or we really need to use all this memo and `useCallbacks` etc. to prevent some serious issue?

Thanks for any feedback!",,
20248,OPEN,Bug: [eslint-plugin-react-hooks] Constructions should be caught in default props/args,Component: ESLint Rules; Type: Enhancement,2020-12-15 13:55:24 +0000 UTC,nstepien,,"1. ```js
   function useMyHook1(arr = []) {
     useEffect(() => {
       console.log(arr);
     }, [arr]);
   }

    function useMyHook2({ arr = [] }) {
     useEffect(() => {
       console.log(arr);
     }, [arr]);
   }

   function MyComponent({ arr = [] }) {
     useEffect(() => {
       console.log(arr);
     }, [arr]);

     return null;
   }
   ```

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: --

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
No warning appears for `arr` being potentially constructed on every render.

## The expected behavior
Should warn that `arr` can be constructed on each render.
The lint rules already warn for the following, so this is just an extension of the existing behavior:
```js
const arr = props.arr ?? []; // The 'arr' logical expression could make the dependencies of useEffect Hook (at line 54) change on every render. Move it inside the useEffect callback. Alternatively, wrap the initialization of 'arr' in its own useMemo() Hook.
```
Reference: https://github.com/facebook/react/pull/19590",,
20237,OPEN,Bug: v16.14.0 tag is incorrectly shows v17-alpha,Status: Unconfirmed,2020-11-12 17:11:45 +0000 UTC,ktalebian,,"The tag on GitHub does not match the version of the package:

https://github.com/facebook/react/blob/v16.14.0/packages/react-test-renderer/package.json

This is v16.14.0, but the package is of version `17.0.0-alpha.0`.

Same goes for https://github.com/facebook/react/blob/v16.13.1/packages/react-test-renderer/package.json",,
20236,OPEN,"DevTools: Flag ""nested updates"" in the Profiler UI",Component: Developer Tools,2020-11-13 14:12:30 +0000 UTC,bvaughn,,"PR #20163 added a new (not yet released) phase to the Profiler API: `""nested-update""`. This phase is different from a regular `""update""` because of the performance implications (see PR description for more background info).

Would be nice if we could also flag these in the DevTools UI somehow.",,
20235,OPEN,Bug: Cannot import 'react/jsx-runtime' from esm node/webpack 5,Resolution: Needs More Information; Status: Unconfirmed,2020-12-24 15:38:44 +0000 UTC,nstepien,,"1. Create a new directory, `cd` to it.
2. Run `npm i react@17 webpack@5 webpack-cli@4`
3. Create `index.mjs` with the following content:
   ```js
   import * as jsx from 'react/jsx-runtime';
   console.log(jsx);
   ```
4. Run `node index.mjs`
5. Run `npx webpack-cli path/to/index.mjs`
   - I had to use an absolute path on my machine or webpack-cli wouldn't find `index.mjs`, don't know why.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: --

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
```
> node index.mjs
node:internal/process/esm_loader:74
    internalBinding('errors').triggerUncaughtException(
                              ^

Error [ERR_MODULE_NOT_FOUND]: Cannot find module 'D:\repos\jsx\node_modules\react\jsx-runtime' imported from D:\repos\jsx\index.mjs
Did you mean to import react/jsx-runtime.js?
    at new NodeError (node:internal/errors:277:15)
    at finalizeResolution (node:internal/modules/esm/resolve:307:11)
    at moduleResolve (node:internal/modules/esm/resolve:742:10)
    at Loader.defaultResolve [as _resolve] (node:internal/modules/esm/resolve:853:11)
    at Loader.resolve (node:internal/modules/esm/loader:85:40)
    at Loader.getModuleJob (node:internal/modules/esm/loader:229:28)
    at ModuleWrap.<anonymous> (node:internal/modules/esm/module_job:51:40)
    at link (node:internal/modules/esm/module_job:50:36) {
  code: 'ERR_MODULE_NOT_FOUND'
}
```
```
> npx webpack-cli D:\repos\jsx\index.mjs
[webpack-cli] Compilation finished
assets by status 264 bytes [cached] 1 asset
./index.mjs 64 bytes [built] [code generated]

ERROR in ./index.mjs 1:0-41
Module not found: Error: Can't resolve 'react/jsx-runtime' in 'D:\repos\jsx'
Did you mean 'jsx-runtime.js'?
BREAKING CHANGE: The request 'react/jsx-runtime' failed to resolve only because it was resolved as fully specified
(probably because the origin is a '*.mjs' file or a '*.js' file where the package.json contains '""type"": ""module""').
The extension in the request is mandatory for it to be fully specified.
Add the extension to the request.

webpack 5.4.0 compiled with 1 error in 150 ms
npm ERR! code 1
```

## The expected behavior
No issues importing `react/jsx-runtime` with no file extensions.

I can think of two solutions:
- Fix babel, typescript, and all the other tools that automatically add the import to add the file extension.
  - That ship has sailed though, I don't think this is right thing to do.
- Add the `exports` field in react's `package.json`.
  - This could also open the door to supporting prod/dev builds without depending on `process.env.NODE_ENV` for bundlers.
  - More discussion here: https://github.com/facebook/react/issues/11503#issuecomment-717589904
  - https://nodejs.org/dist/latest/docs/api/packages.html
  - https://webpack.js.org/guides/package-exports/",,
20222,OPEN,Refactor: Can I use mountReducer to refactor mountState?,Status: Unconfirmed,2021-03-13 08:41:15 +0000 UTC,sweetliquid,,"I noticed that `updateState` uses `updateReducer` internally like this:

https://github.com/facebook/react/blob/12627f93b5357032881412abcc014da53a0b70f8/packages/react-reconciler/src/ReactFiberHooks.old.js#L1139-L1143

but in `mountState`, it was reimplemented:

https://github.com/facebook/react/blob/12627f93b5357032881412abcc014da53a0b70f8/packages/react-reconciler/src/ReactFiberHooks.old.js#L1114-L1137

Can I refactor `mountState` to use `mountReducer`?

```javascript
function mountState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }

  return mountReducer(basicStateReducer, initialState);
}
```",,
20205,OPEN,Feature suggestion: Allow custom list of hooks to ignore on exhaustive-deps,Component: ESLint Rules; Type: Feature Request,2021-03-07 00:48:00 +0000 UTC,LucasPickering,,"The `exhaustive-deps` lint rule doesn't require setters from `useState`, dispatch from `useReducer`, and refs from `useRef` in dependencies, because we know for sure those will never change. I'd like to be able to add additional custom hooks to that ""safe list"". I understand this is potentially very dangerous, but we have a handful of hooks that simply wrap `useRef` with some logic. The returned result is essentially just a `useRef` result, so it's perfectly safe to ignore as a dependency.

I'm imagining something like this in the eslint config:

```
{
  ""rules"": {
    // ...
    ""react-hooks/exhaustive-deps"": [""warn"", {
      ""safeHooks"": ""(useRefWrapper|useOtherRefWrapper)""
    }]
  }
}
```

Where `useRefWrapper` might look like so:

```
const useRefWrapper = () => {
  const ref = useRef();
  if (ref.current) {
    console.log('hi!');
  }
  return ref;
}
```

Does this seem like a reasonable option, assuming the documentation has a clear caveat mentioning the dangers? If so, I'm happy to work on implementation.",,
20196,OPEN,"Bug: eslint-plugin-react-hooks doesn't report conditional typescript ""?."" hooks",Component: ESLint Rules; Type: Bug,2020-11-09 14:10:42 +0000 UTC,exapsy,,"**React plugin version:** 
eslint-plugin-react: ""^7.19.0""
typescript: 4.0+ (must include ?. operator)

## Steps To Reproduce

```tsx
// Just a demonstration example, obviously this is not ideal use of classes
class Dog {
	public useDogWoof() {
		useEffect(() => {
			console.log(""woof"")
		}])
	}
}

const DogWoof = ({dog}: {dog?: Dog) => {
	dog?.useDogWoof() // Should print conditional hook error
	return (
		//
	)
}
```

## The current behavior

Typescript has the new 4.0 operator `?.` in case an object is undefined. But, this doesn't quite work along with hooks, as when the object is undefined, the hook is not called, thus the React Renderer complains that the amount of hooks is not the same or even worse untraceable type errors that I had. `eslint-plugin-react-hooks` is expected to be able to guard against that as well to prevent nasty errors with this new typescript operator.

## The expected behavior

Currently, `eslint-plugin-react-hooks` doesn't take care of the typescript operator and thinks that nothing's wrong with using along one with a react hook.",,
20186,OPEN,Distribute source maps for easier debugging in Chrome's Performance tab,Type: Discussion,2020-11-10 08:51:47 +0000 UTC,astoilkov,,"~~I want to propose the addition of a new file in the `react-dom` npm package called `react-dom.production.js` — a non-minified version of `react-dom` production build.~~

Edit: After some discussion(see below) it seems that distributing source maps makes more sense. Source maps will help you see the real function names and explore them. (The points below apply for source maps as well.)

## Why?

There are a few ways to profile React's performance — none of them provide a low-level view of what's happening. I believe the best way to profile React is using Chrome's Performance tab using a non-minified production build. Here's why:
- **Familiar.** People use the Performance tab for every other performance profiling so they are familiar with how to use it.
- **Powerful.** The Performance tab is extremely powerful. Years of engineering have been put into developing it.
- **Better understanding.** When using the React DevTools profiler I have a common problem – I see a component being rendered slowly but I don't know what is causing it. In order to understand I need a more low-level view. Here are some questions that can be answered only with the Chrome Performance tab:
    - What's the balance between the app's code and React execution times? Should I implement some frequently updated components using custom non-React implementation?
    - What time is spend on setting attribute values, setting `innerHTML` and adding and removing listeners?
    - What time is spent on disposing effects? Is there a specific dispose function that is taking more than usual?
    - What time is spent on mounting effects? Is there a specific effect mount that is taking more than usual?

## Disadvantages

As with every solution, there are some drawbacks to using this approach:
- **Documentation needed.** In order to make sense of what's happening you will need some knowledge of the core functions in React. A little guide with the names of the functions for mount/unmount, effects, and DOM manipulations will be useful. This of course can be done by the community(you are already linking to some community posts in React's documentation).
- **Requires more skill.** This isn't for everybody. It's aimed at more experienced developers. This type of profiling is a lot more overwhelming than the current approach.
- **May not fit your principles.** Maybe it's not part of your principles to introduce and promote such a complicated solution. Maybe you are more interested in searching for a more elegant and minimal solution.",,
20178,OPEN,Bug: devtools the expanded state and the state object are out of sync,Component: Developer Tools; Status: Unconfirmed; Type: Bug; Type: Needs Investigation,2020-11-21 14:59:20 +0000 UTC,a-c-sreedhar-reddy,,"1. Have a Switch with state in react native and toggle the switch by opening devtools and using the checkbox provided for the state.
2. Now toggle the switch using UI. the state object gets updated but not the expanded one.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Allergies state is true on the top but on expanded state it is false.
![Screenshot from 2020-11-06 16-48-37](https://user-images.githubusercontent.com/16081083/98360786-7bb71280-2050-11eb-8a52-0944a6b70c26.png)


## The expected behavior
Both must be in sync",,
20176,OPEN,Feature Suggestion: Improvement on fast return in markUpdateLaneFromFiberToRoot(),,2020-11-30 23:34:49 +0000 UTC,jacty,,"When node.tag is not HostRoot, it should be unnecessary to run other code in this function. So why don't we check the tag at the beginning of this function, and at the end we can just return root. 
`if(node.tag !==HostRoot){
  return null;
}`

https://github.com/facebook/react/blob/6b28eb6175e5251b31507749b79c55c0e389b6ef/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L637-L642",,
20162,OPEN,Bug: react-hooks/exhaustive-deps false positive when deps is defined with typescript const typing,Status: Unconfirmed,2020-11-05 12:21:38 +0000 UTC,tranvansang,,"React version: 17.0.1

## Steps To Reproduce

1. Setup eslint with `@typescript-eslint/parser` as parser
2. Add `as const` to the deps array

```
function MyComp() {
	const [state, setState] = useState()
	useEffect(() => {
		console.log(state)
	}, [state] as const)
	return 'Hello, world'
}
```

Link to code example: https://github.com/tranvansang/exhaustive-deps-bug-1


## The current behavior

The following errors were reported

```
  5:5  warning  React Hook useEffect was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies  react-hooks/exhaustive-deps
  5:5  warning  React Hook useEffect has a missing dependency: 'state'. Either include it or remove the dependency array  
```

## The expected behavior

The rule should interpret the deps argument correctly.

## _

Why do I need to add `as const` to the deps array?

I build my own custom effect hook (with the `additionalHooks` option in .eslintrc), in which a tuple typing gives more type hint to the code.
",,
20161,OPEN,Bug: Input minLength not working after type changed,Browser: Safari; Component: DOM; Type: Bug,2020-11-05 14:52:38 +0000 UTC,Vandoct,,"I have an input with type password with minLength 8, and i have a toggle to change the type to text (password toggle).
when i type with length < 8 and press submit, it prevent to submit. but, when i toggle the password so it change the type to text and submit the form, it can submitted. btw i using useRef()

React version:
react: ^17.0.1
react-dom: ^17.0.1

## Steps To Reproduce

1. type character < minLength
2. submit form
3. toggle form type
4. submit form

Link to code example: [DEMO](https://codesandbox.io/s/young-shape-4tciw)

## The current behavior
The form get submitted even when it under minLength

## The expected behavior
The form not get submitted when it under minLength
",,
20160,OPEN,Bug: react-hooks/exhaustive-deps false positive on additionalHooks' definition,Status: Unconfirmed,2021-03-12 18:07:29 +0000 UTC,tranvansang,,"React version: 17.0.1

## Steps To Reproduce

1. in `.eslintrc` add the following configuration

```
	""rules"": {
		""react-hooks/exhaustive-deps"": [
			""warn"", {
				""additionalHooks"": ""(useAsyncEffect)""
			}
		]
	}
```

2. Type the following code

```
export const useAsyncEffect = (effect, deps) => useEffect(
	() => void (async () => {
		try {
			await effect()
		} catch (e) {
			// report error
			console.error(e)
		}
	})(),
	deps
)
```

Link to code example: https://github.com/tranvansang/exhaustive-deps-bug

## The current behavior

- The following errors are printed

```
  10:2  warning  React Hook useEffect was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies                                                         react-hooks/exhaustive-deps
  10:2  warning  React Hook useEffect has a missing dependency: 'effect'. Either include it or remove the dependency array. If 'effect' changes too often, find the parent component that defines it and wrap that definition in useCallback  react-hooks/exhaustive-deps

✖ 2 problems (0 errors, 2 warnings)
```

## The expected behavior

In the additional hooks' definition, the following patterns should be accepted as the dependence for the `effect` function (i.e., the first argument of the additional hook).

- Pattern 1: `useEffect(() => {effect()}, deps)`
- Pattern 2: `useEffect(() => {effect()}, [...deps])`",,
20159,OPEN,Bug: can not pass some special custom attribute such as `size`,Component: DOM; Status: Unconfirmed; Type: Discussion,2020-11-20 18:32:06 +0000 UTC,MHA15,,"As we know after react 16 we can use any custom attributes in dom elements 
but there is a bug which some special attributes (such as `size`) are not forwarding to dom element

![screenshot](https://user-images.githubusercontent.com/30382711/98168556-f91f3d80-1eff-11eb-8518-5647cd854e00.png)


React version: 16.13 & 17.0

## Steps To Reproduce

1. render a dom element with some custom attributes including `size`
2. inspect output and you will see your custom attributes but size

Link to code example:
https://codesandbox.io/s/setting-size-as-custom-attr-hdom2?file=/src/App.js

## The current behavior
`size` attribute will not show in output

## The expected behavior
`size` should be in output
",,
20144,OPEN,React Developer Tools triggers console error in Firefox for protected URLs,Component: Developer Tools,2020-11-12 21:31:22 +0000 UTC,SimonSiefke,,"![Screenshot from 2020-11-02 08-34-31](https://user-images.githubusercontent.com/23744935/97845488-ea147180-1cec-11eb-853a-0b6e3c176903.png)

## Steps To Reproduce

1. Install React Devtools extension for Firefox
2. Go to ""about:neterror?e=connectionFailure""

## The current behavior

Firefox shows this error in the console: ""The extension ""React Developer Tools"" is not allowed to access about:neterror?e=connectionFailure""


## The expected behavior

Firefox shows no error in the console",,
20141,OPEN,Bug: Warning: unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering if debugger present,Status: Unconfirmed; Type: Needs Investigation,2021-03-30 20:13:54 +0000 UTC,SangeetAgarwal,," If a debugger is present in the main body of a functional component then on hitting the debugger and proceeding from there an unstable_flushDiscreteUpdates warning is thrown.

React version: ^16.13.1

## Steps To Reproduce

1. Clone [https://github.com/kentcdodds/bookshelf](https://github.com/kentcdodds/bookshelf)
2. Put a `debugger` right above the `React.useEffect()` in the `DiscoverBooksScreen` Component
3. Hit the `debugger` break point and resume execution of code
4. unstable_flushDiscreteUpdates warning is thrown in the console.

Link to code example:
[https://github.com/kentcdodds/bookshelf](https://github.com/kentcdodds/bookshelf)


## The current behavior
unstable_flushDiscreteUpdates warning is thrown in the console

## The expected behavior
unstable_flushDiscreteUpdates warning should not be thrown in the console


![Untitled](https://user-images.githubusercontent.com/2169707/97805936-0fd74300-1c27-11eb-9f58-9799b262805e.png)
![Untitled2](https://user-images.githubusercontent.com/2169707/97805947-1e255f00-1c27-11eb-802e-c154b039482b.png)
",,
20139,OPEN,"Bug: Usage of ""React.forwardRef"" in ""React.memo"" distorts profiling report",Component: Developer Tools; Status: Unconfirmed,2021-04-03 06:19:01 +0000 UTC,vasilii-kovalev,,"Hello!

When I was working with [this workshop](https://github.com/kentcdodds/react-performance), especially with [this exercise part](https://github.com/kentcdodds/react-performance/blob/main/src/final/06.extra-3.js#L108-L117) (the goal there is to create a convenient, reusable HOC), I found that wrapping a component in `React.forwardRef` and then in `React.memo` distorts profiling report (when using `Profiler` tab of React Developer Tools).

For demonstration purposes I removed unrelated stuff and now the application looks like this:
![image](https://user-images.githubusercontent.com/10310491/97773045-b6571180-1b5d-11eb-9025-8f1dcd26f821.png)
When you click on a cell, the number inside changes to another one.

React version: 17.0.0
React Developer Tools: 4.9.0

## Steps To Reproduce
1. Start profiling the app (using `Profiler` tab of React Developer Tools).
2. Click on a cell.
3. Stop profiling the app and check re-rendered components.
4. Wrap `Wrapper` component in `forwardRef` (see the code in the repo below) and repeat steps 1-3.

Link to code example: https://codesandbox.io/s/usage-of-reacforwardref-in-reactmemo-81cuh?file=/src/App.js

## The current behavior
Without `forwardRef`: according to the profiling report, all the cells re-render.
![image](https://user-images.githubusercontent.com/10310491/97772842-c4a42e00-1b5b-11eb-9b49-8d2bd6f122aa.png)
![image](https://user-images.githubusercontent.com/10310491/97772848-d4bc0d80-1b5b-11eb-8f41-9378bc7418ba.png)

With `forwardRef`: according to the profiling report, only the changed cell re-renders.
![image](https://user-images.githubusercontent.com/10310491/97772866-fcab7100-1b5b-11eb-9de9-c4aa34b48299.png)
![image](https://user-images.githubusercontent.com/10310491/97772876-07fe9c80-1b5c-11eb-8038-aa9a0ffce473.png)

## The expected behavior
There should be no difference in the reports. I added some `console.log`-s and they demonstrate that adding `forwardRef` doesn't improve performance/reduce re-renders, which seems correct.

CC @kentcdodds",,
20135,OPEN,react-devtools-inline: How to remount/reuse DevTools frontend after unmount,Component: Developer Tools; Type: Discussion,2020-11-10 08:15:22 +0000 UTC,sean9keenan,,"DevTools closes the bridge whenever it is unmounted [(Link to relevant code)](https://github.com/facebook/react/blob/master/packages/react-devtools-shared/src/devtools/views/DevTools.js#L172-L181). In the case of the chrome extension this is fine because the node is never unmounted, but in use cases with `react-devtools-inline` (eg: codesandbox), where you are only given one <DevTools/> instance this causes the bridge to be closed, and never recreated if for whatever reason <DevTools/> is unmounted (which happens when switching tabs).

I am willing to submit a PR, but wanted to discuss the fix before making it - the fix I see is adding a flag to <DevTools/> to not close the bridge on unmount, and making it an opt-in flag users of <DevTools/> (recommended in the case of react-devtools-inline). Adding an ability to manually access the bridge would then let the developer manually control the lifecycle - but I'm unsure the risk/issue of keeping a dangling bridge open, so I don't see this as strictly necessary.

React version: N/A
React-devtools-inline: 4.9.0

## Steps To Reproduce

1.  Create a code-sandbox React environment
2. Open React DevTools tab
3. Switch to Problems tab (or any other tab)
4. Switch back to React DevTools tab
5. Bridge has been closed, `index.js:55 Cannot send message ""highlightNativeElement"" through a Bridge that has been shutdown.` is printed in console. New react nodes can not be inspected.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: N/A
Code example isn't relevant, any CodeSandbox will reproduce this. (even with no additional code)

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Inspecting elements that haven't previously been inspected will fail because bridge communication fails if the <DevTools/> ever unmounts and remounts

## The expected behavior
The bridge doesn't close even on unmount when using `react-devtools-inline`, or an option is available when mounting <DevTools/> to not automatically close the bridge.",,
20127,OPEN,Bug: Can't hydrate useOpaqueIdentifier generated object in another component,Component: DOM; Type: Bug,2020-10-29 12:40:06 +0000 UTC,diegohaz,,"The way it's implemented is that each item registers its id into a state up in the tree so the container element can get the active id and render it on the `aria-activedescendant` prop.

## Steps To Reproduce

1. Create a simple server rendered app (for example, using Next.js).
2. Create a component that uses `React.unstable_useOpaqueIdentifier` and passes the generated object to a component up in the tree through callbacks.
3. Try to render the generated ID to a prop in the ancestor component. 

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

https://codesandbox.io/s/react-useopaqueidentifier-aria-activedescendant-bug-geutb?file=/pages/index.js:0-412

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

It throws an error:

```
Unhandled Runtime Error
Error: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.

Call Stack
Object.readValue
node_modules/react-dom/cjs/react-dom.development.js (16555:0)
diffProperties
node_modules/react-dom/cjs/react-dom.development.js (9475:0)
prepareUpdate
node_modules/react-dom/cjs/react-dom.development.js (10352:0)
updateHostComponent$1
node_modules/react-dom/cjs/react-dom.development.js (20070:0)
completeWork
node_modules/react-dom/cjs/react-dom.development.js (20236:0)
completeUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js (23738:0)
performUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js (23710:0)
workLoopSync
node_modules/react-dom/cjs/react-dom.development.js (23618:0)
renderRootSync
node_modules/react-dom/cjs/react-dom.development.js (23577:0)
performConcurrentWorkOnRoot
node_modules/react-dom/cjs/react-dom.development.js (22968:0)
workLoop
node_modules/scheduler/cjs/scheduler.development.js (590:0)
flushWork
node_modules/scheduler/cjs/scheduler.development.js (545:0)
MessagePort.performWorkUntilDeadline
node_modules/scheduler/cjs/scheduler.development.js (157:0)
```

I believe it's triggered here: https://github.com/facebook/react/blob/993ca533b42756811731f6b7791ae06a35ee6b4d/packages/react-dom/src/client/ReactDOMComponent.js#L786-L789

## The expected behavior

It works well when not using SSR:

https://codesandbox.io/s/react-useopaqueidentifier-aria-activedescendant-y3f22",,
20123,OPEN,Bug: Should have a queue,Component: Reconciler; Type: Discussion,2020-10-29 14:41:23 +0000 UTC,shadowvzs,,"```
react-dom.development.js:89 Warning: React has detected a change in the order of Hooks called by wrappedComponent. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
1. useState                   useState
2. useCallback                useCallback
3. useRef                     useRef
4. useDebugValue              useDebugValue
5. useEffect                  useEffect
6. useLayoutEffect            useState
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    in wrappedComponent (created by ApprovalManageView)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalManageView)
    in ApprovalManageView (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in div (created by Transition)
    in div (created by Transition)
    in div (created by Transition)
    in Transition (created by ForwardRef(Collapse))
    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))
    in WithStyles(ForwardRef(Collapse)) (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in wrappedComponent (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in wrappedComponent (created by ApprovalsSidebar)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)
    in ApprovalsSidebar (created by Context.Consumer)
    in ApprovalsSidebarWrapper (created by ContentSidebarContent)
    in ContentSidebarContent (created by SidebarDesktop)
    in div (created by SidebarDesktop)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)
    in ErrorBoundary (created by SidebarDesktop)
    in SidebarDesktop (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(AccordionDetails))
    in ForwardRef(AccordionDetails) (created by WithStyles(ForwardRef(AccordionDetails)))
    in WithStyles(ForwardRef(AccordionDetails)) (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(Accordion))
    in div (created by Transition)
    in div (created by Transition)
    in div (created by Transition)
    in Transition (created by ForwardRef(Collapse))
    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))
    in WithStyles(ForwardRef(Collapse)) (created by ForwardRef(Accordion))
    in div (created by ForwardRef(Paper))
    in ForwardRef(Paper) (created by WithStyles(ForwardRef(Paper)))
    in WithStyles(ForwardRef(Paper)) (created by ForwardRef(Accordion))
    in ForwardRef(Accordion) (created by WithStyles(ForwardRef(Accordion)))
    in WithStyles(ForwardRef(Accordion)) (created by ContentEditViewUnstyled)
    in span (created by ForwardRef(Badge))
    in ForwardRef(Badge) (created by WithStyles(ForwardRef(Badge)))
    in WithStyles(ForwardRef(Badge)) (created by ContentEditViewUnstyled)
    in SidebarStoreProvider (created by Sidebar)
    in Sidebar (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)
    in SidebarStoreProvider (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)
    in SidebarStoreProvider (created by ContentEditViewUnstyled)
    in ContentEditViewUnstyled (created by WithStyles(ContentEditViewUnstyled))
    in WithStyles(ContentEditViewUnstyled) (created by WithSizeDelayed)
    in div (created by WithSizeDelayed)
    in WithSizeDelayed (created by WithSize(WithStyles(ContentEditViewUnstyled)))
    in WithSize(WithStyles(ContentEditViewUnstyled)) (created by Context.Consumer)
    in form (created by Context.Consumer)
    in FormClassValidator (created by ContentEditForm)
    in ContentEditForm (created by ContentEditFormLoaderUnstyled)
    in div (created by ContentEditFormLoaderUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)
    in ContentEditFormLoaderUnstyled (created by WithStyles(ContentEditFormLoaderUnstyled))
    in WithStyles(ContentEditFormLoaderUnstyled) (created by WithWidth(WithStyles(ContentEditFormLoaderUnstyled)))
    in WithWidth(WithStyles(ContentEditFormLoaderUnstyled)) (created by LoadableComponent)
    in LoadableComponent (created by ContentEditViewPage)
    in ContentEditViewPage (created by react2angular(ContentEditViewPage))
    in Suspense (created by react2angular(ContentEditViewPage))
    in DropContextProvider
    in Unknown (created by DragDropContext(Component))
    in DragDropContext(Component) (created by Providers)
    in SnackbarProvider (created by Providers)
    in MuiPickersUtilsProvider (created by Providers)
    in ThemeProvider (created by AppThemeProvider)
    in AppThemeProvider (created by Providers)
    in Providers (created by SubProviders)
    in SubProviders (created by react2angular(ContentEditViewPage))
    in react2angular(ContentEditViewPage)
    in Unknown (created by HotExportedComponent)
    in AppContainer (created by HotExportedComponent)
    in HotExportedComponent
printWarning @ react-dom.development.js:89
error @ react-dom.development.js:61
warnOnHookMismatchInDev @ react-dom.development.js:14738
updateHookTypesDev @ react-dom.development.js:14697
useState @ react-dom.development.js:15967
useState @ react.development.js:1497
(anonymous) @ ContentApprovalStatusView.tsx:38
(anonymous) @ mobxreactlite.esm.js:344
(anonymous) @ mobxreactlite.esm.js:306
trackDerivedFunction @ mobx.module.js:761
./node_modules/mobx/lib/mobx.module.js.Reaction.track @ mobx.module.js:1795
useObserver @ mobxreactlite.esm.js:304
(anonymous) @ mobxreactlite.esm.js:343
renderWithHooks @ react-dom.development.js:14826
updateFunctionComponent @ react-dom.development.js:17059
updateSimpleMemoComponent @ react-dom.development.js:16997
beginWork @ react-dom.development.js:18721
beginWork$1 @ react-dom.development.js:23211
performUnitOfWork @ react-dom.development.js:22189
workLoopSync @ react-dom.development.js:22162
performSyncWorkOnRoot @ react-dom.development.js:21788
(anonymous) @ react-dom.development.js:11112
unstable_runWithPriority @ scheduler.development.js:643
runWithPriority$1 @ react-dom.development.js:11062
flushSyncCallbackQueueImpl @ react-dom.development.js:11107
flushSyncCallbackQueue @ react-dom.development.js:11095
batchedUpdates$1 @ react-dom.development.js:21894
reactionScheduler @ mobx.module.js:1905
runReactions @ mobx.module.js:1881
endBatch @ mobx.module.js:1581
_endAction @ mobx.module.js:967
executeAction @ mobx.module.js:921
updateApproval @ mobx.module.js:901
(anonymous) @ ApprovalManageView.tsx:334
(anonymous) @ tslib.es6.js:74
__awaiter @ tslib.es6.js:70
onApprovalEditFormSubmit @ ApprovalManageView.tsx:268
(anonymous) @ FormClassValidator.tsx:266
Promise.then (async)
onSubmit @ FormClassValidator.tsx:262
onClick @ ApprovalEditView.tsx:1487
callCallback @ react-dom.development.js:189
invokeGuardedCallbackDev @ react-dom.development.js:238
invokeGuardedCallback @ react-dom.development.js:293
invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:307
executeDispatch @ react-dom.development.js:390
executeDispatchesInOrder @ react-dom.development.js:415
executeDispatchesAndRelease @ react-dom.development.js:3279
executeDispatchesAndReleaseTopLevel @ react-dom.development.js:3288
forEachAccumulated @ react-dom.development.js:3260
runEventsInBatch @ react-dom.development.js:3305
runExtractedPluginEventsInBatch @ react-dom.development.js:3515
handleTopLevel @ react-dom.development.js:3559
batchedEventUpdates$1 @ react-dom.development.js:21903
batchedEventUpdates @ react-dom.development.js:1061
dispatchEventForLegacyPluginEventSystem @ react-dom.development.js:3569
attemptToDispatchEvent @ react-dom.development.js:4268
dispatchEvent @ react-dom.development.js:4190
unstable_runWithPriority @ scheduler.development.js:643
runWithPriority$1 @ react-dom.development.js:11062
discreteUpdates$1 @ react-dom.development.js:21919
discreteUpdates @ react-dom.development.js:1072
dispatchDiscreteEvent @ react-dom.development.js:4169
Show 8 more frames
react-dom.development.js:15066 Uncaught Error: Should have a queue. This is likely a bug in React. Please file an issue.
    at updateReducer (react-dom.development.js:15066)
    at updateState (react-dom.development.js:15260)
    at Object.useState (react-dom.development.js:15972)
    at Object.useState (react.development.js:1497)
    at ContentApprovalStatusView.tsx:38
    at mobxreactlite.esm.js:344
    at mobxreactlite.esm.js:306
    at trackDerivedFunction (mobx.module.js:761)
    at Reaction../node_modules/mobx/lib/mobx.module.js.Reaction.track (mobx.module.js:1795)
    at useObserver (mobxreactlite.esm.js:304)
updateReducer @ react-dom.development.js:15066
updateState @ react-dom.development.js:15260
useState @ react-dom.development.js:15972
useState @ react.development.js:1497
(anonymous) @ ContentApprovalStatusView.tsx:38
(anonymous) @ mobxreactlite.esm.js:344
(anonymous) @ mobxreactlite.esm.js:306
trackDerivedFunction @ mobx.module.js:761
./node_modules/mobx/lib/mobx.module.js.Reaction.track @ mobx.module.js:1795
useObserver @ mobxreactlite.esm.js:304
(anonymous) @ mobxreactlite.esm.js:343
renderWithHooks @ react-dom.development.js:14826
updateFunctionComponent @ react-dom.development.js:17059
updateSimpleMemoComponent @ react-dom.development.js:16997
beginWork @ react-dom.development.js:18721
callCallback @ react-dom.development.js:189
invokeGuardedCallbackDev @ react-dom.development.js:238
invokeGuardedCallback @ react-dom.development.js:293
beginWork$1 @ react-dom.development.js:23235
performUnitOfWork @ react-dom.development.js:22189
workLoopSync @ react-dom.development.js:22162
performSyncWorkOnRoot @ react-dom.development.js:21788
(anonymous) @ react-dom.development.js:11112
unstable_runWithPriority @ scheduler.development.js:643
runWithPriority$1 @ react-dom.development.js:11062
flushSyncCallbackQueueImpl @ react-dom.development.js:11107
flushSyncCallbackQueue @ react-dom.development.js:11095
batchedUpdates$1 @ react-dom.development.js:21894
reactionScheduler @ mobx.module.js:1905
runReactions @ mobx.module.js:1881
endBatch @ mobx.module.js:1581
_endAction @ mobx.module.js:967
executeAction @ mobx.module.js:921
updateApproval @ mobx.module.js:901
(anonymous) @ ApprovalManageView.tsx:334
(anonymous) @ tslib.es6.js:74
__awaiter @ tslib.es6.js:70
onApprovalEditFormSubmit @ ApprovalManageView.tsx:268
(anonymous) @ FormClassValidator.tsx:266
Promise.then (async)
onSubmit @ FormClassValidator.tsx:262
onClick @ ApprovalEditView.tsx:1487
callCallback @ react-dom.development.js:189
invokeGuardedCallbackDev @ react-dom.development.js:238
invokeGuardedCallback @ react-dom.development.js:293
invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:307
executeDispatch @ react-dom.development.js:390
executeDispatchesInOrder @ react-dom.development.js:415
executeDispatchesAndRelease @ react-dom.development.js:3279
executeDispatchesAndReleaseTopLevel @ react-dom.development.js:3288
forEachAccumulated @ react-dom.development.js:3260
runEventsInBatch @ react-dom.development.js:3305
runExtractedPluginEventsInBatch @ react-dom.development.js:3515
handleTopLevel @ react-dom.development.js:3559
batchedEventUpdates$1 @ react-dom.development.js:21903
batchedEventUpdates @ react-dom.development.js:1061
dispatchEventForLegacyPluginEventSystem @ react-dom.development.js:3569
attemptToDispatchEvent @ react-dom.development.js:4268
dispatchEvent @ react-dom.development.js:4190
unstable_runWithPriority @ scheduler.development.js:643
runWithPriority$1 @ react-dom.development.js:11062
discreteUpdates$1 @ react-dom.development.js:21919
discreteUpdates @ react-dom.development.js:1072
dispatchDiscreteEvent @ react-dom.development.js:4169
Show 9 more frames
react-dom.development.js:19561 The above error occurred in the <wrappedComponent> component:
    in wrappedComponent (created by ApprovalManageView)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalManageView)
    in ApprovalManageView (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in div (created by Transition)
    in div (created by Transition)
    in div (created by Transition)
    in Transition (created by ForwardRef(Collapse))
    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))
    in WithStyles(ForwardRef(Collapse)) (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in wrappedComponent (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by wrappedComponent)
    in wrappedComponent (created by ApprovalsSidebar)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ApprovalsSidebar)
    in ApprovalsSidebar (created by Context.Consumer)
    in ApprovalsSidebarWrapper (created by ContentSidebarContent)
    in ContentSidebarContent (created by SidebarDesktop)
    in div (created by SidebarDesktop)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by SidebarDesktop)
    in ErrorBoundary (created by SidebarDesktop)
    in SidebarDesktop (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(AccordionDetails))
    in ForwardRef(AccordionDetails) (created by WithStyles(ForwardRef(AccordionDetails)))
    in WithStyles(ForwardRef(AccordionDetails)) (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(Accordion))
    in div (created by Transition)
    in div (created by Transition)
    in div (created by Transition)
    in Transition (created by ForwardRef(Collapse))
    in ForwardRef(Collapse) (created by WithStyles(ForwardRef(Collapse)))
    in WithStyles(ForwardRef(Collapse)) (created by ForwardRef(Accordion))
    in div (created by ForwardRef(Paper))
    in ForwardRef(Paper) (created by WithStyles(ForwardRef(Paper)))
    in WithStyles(ForwardRef(Paper)) (created by ForwardRef(Accordion))
    in ForwardRef(Accordion) (created by WithStyles(ForwardRef(Accordion)))
    in WithStyles(ForwardRef(Accordion)) (created by ContentEditViewUnstyled)
    in span (created by ForwardRef(Badge))
    in ForwardRef(Badge) (created by WithStyles(ForwardRef(Badge)))
    in WithStyles(ForwardRef(Badge)) (created by ContentEditViewUnstyled)
    in SidebarStoreProvider (created by Sidebar)
    in Sidebar (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)
    in SidebarStoreProvider (created by ContentEditViewUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditViewUnstyled)
    in SidebarStoreProvider (created by ContentEditViewUnstyled)
    in ContentEditViewUnstyled (created by WithStyles(ContentEditViewUnstyled))
    in WithStyles(ContentEditViewUnstyled) (created by WithSizeDelayed)
    in div (created by WithSizeDelayed)
    in WithSizeDelayed (created by WithSize(WithStyles(ContentEditViewUnstyled)))
    in WithSize(WithStyles(ContentEditViewUnstyled)) (created by Context.Consumer)
    in form (created by Context.Consumer)
    in FormClassValidator (created by ContentEditForm)
    in ContentEditForm (created by ContentEditFormLoaderUnstyled)
    in div (created by ContentEditFormLoaderUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)
    in div (created by ForwardRef(Grid))
    in ForwardRef(Grid) (created by WithStyles(ForwardRef(Grid)))
    in WithStyles(ForwardRef(Grid)) (created by ContentEditFormLoaderUnstyled)
    in ContentEditFormLoaderUnstyled (created by WithStyles(ContentEditFormLoaderUnstyled))
    in WithStyles(ContentEditFormLoaderUnstyled) (created by WithWidth(WithStyles(ContentEditFormLoaderUnstyled)))
    in WithWidth(WithStyles(ContentEditFormLoaderUnstyled)) (created by LoadableComponent)
    in LoadableComponent (created by ContentEditViewPage)
    in ContentEditViewPage (created by react2angular(ContentEditViewPage))
    in Suspense (created by react2angular(ContentEditViewPage))
    in DropContextProvider
    in Unknown (created by DragDropContext(Component))
    in DragDropContext(Component) (created by Providers)
    in SnackbarProvider (created by Providers)
    in MuiPickersUtilsProvider (created by Providers)
    in ThemeProvider (created by AppThemeProvider)
    in AppThemeProvider (created by Providers)
    in Providers (created by SubProviders)
    in SubProviders (created by react2angular(ContentEditViewPage))
    in react2angular(ContentEditViewPage)
    in Unknown (created by HotExportedComponent)
    in AppContainer (created by HotExportedComponent)
    in HotExportedComponent

React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.
```
React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.

React version:

## Steps To Reproduce

1. use condition before hooks

```typescript
    const [state, setState] = React.useState<State>({...defaultState});
    const actions = store.isBulk ? {} : store.getActions(entity, switchView);

   // this line if it is below the onToggle then everything fine and have no error
    if (!approval) { return null; }

    const onToggle = React.useCallback((ev: React.MouseEvent<HTMLDivElement, MouseEvent>) => {
        const collapsibleName = ev.currentTarget.dataset.type + 'Open';
        const value = !state[collapsibleName];
        setState({ ...state, ...defaultState, [collapsibleName]: value });
    }, [state]);

```

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
crash the rendeing

## The expected behavior
it should have an error message which localize better where the error was if cannot be fixed this issue :)",,
20120,OPEN,Bug: React DevTools failing silently on Debian,Component: Developer Tools,2021-01-07 15:29:25 +0000 UTC,Delfshkrimm,,"
<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

## The current behavior
The command fails silently and nothing happens.

## The expected behavior
React DevTools should start and connect to app.

I am not sure this is the right place to post this, but since I know how to fix this issue and I think other people might face it, I'm opening this thread to also post the solution.

I run into this issue on Linux (debian bullseye with kernel 5.7.0). The main problem is connected to Electron (afaik since version 5) not being able to launch without binary being owned by root and chmod 4755. The issue is with the new sandbox and the priviledges it requires to launch. 

There is also another workaround I found some months ago on the dedicated thread from Electron's GH (since this is a common issue for Linux users of all Electron applications) that works for every packaged Electron app and binary.
Instead of modifying the electron binary permissions, you can instead tweak an option of your running kernel by doing: 
```
sudo sysctl kernel.unprivileged_userns_clone=1
``` 

Then your Electron apps will launch, and thus so will React DevTools.

Feel free to close this if it isn't relevant here (since not really an issue with devtools itself, rather with Electron x Debian), but I haven't found anything regarding this matter and I think someone might encounter this issue in the future (hoping I'm not totaly mistaken about this to begin with :smile:)",,
20111,OPEN,Question: using setState to access latest state in event handler,,2021-03-13 19:17:52 +0000 UTC,832bb9,,"Is it bad to use setState for getting current state in async event handlers?

![25C4002A-8A34-49CA-A3EE-898419EF98DF](https://user-images.githubusercontent.com/31843788/97357104-eecac700-18a1-11eb-9af9-ddcd04d9c2be.jpeg)

 It works good but feels wrong, so you might say why it is wrong. I know recommended approach is to use refs, but why have redundant work with sync ref and state. If it is safe to access current state due function updater for setState so you can omit unnecessary state deps for callback, why it might be not safe to get current state in async handler?

Example:
You have “follow” user button. When you click it update local state optimistically and make server request. While server request pending you might click again and change local state, but prevent making new requests. When request is resolved you need to compare latest local state and expected server state and repeat request if they aren’t equal.
",,
20095,OPEN,Bug: react-devtools prints too many logs of WS failed,Component: Developer Tools,2020-10-29 02:09:58 +0000 UTC,Jack-Works,,"We're following this to set up react-devtools.

> If your app is inside an iframe, a Chrome extension, React Native, or in another unusual environment, try the standalone version instead. Chrome apps are currently not inspectable.

The standalone version works well, but if the standalone version is not started, `react-devtools` will try to connect `ws://localhost:8097/` and prints too many logs.

![image](https://user-images.githubusercontent.com/5390719/97136626-9c4cb600-178e-11eb-9d7a-ffd5dc9d99f8.png)

## The expected behavior

I hope react-devtools can only print 1 error message if it is not connected to the standalone version.",,
20088,OPEN,Bug: Input leaks fiber nodes in recent versions of chromium,Type: Needs Investigation,2020-10-26 06:08:10 +0000 UTC,msjabarr,,"1. Mount an input component
2. Type anything
3. Unmount input component

Small code sample:

```
const InputWrapper = () => {
  const Siblings = React.useMemo(() => new Array(1000).fill(1).map((_,i) => <div key={i}/>), []);
  return (
    <div>
      <input />
      {Siblings}
    </div>
  );
};
export const Demo = () => {
  const [show, setShow] = React.useState(false);

  const handleShow = React.useCallback(() => {
    setShow((prev) => !prev);
  }, []);

  const closeRef = React.useRef<number>(0);
  
  const handleShowMany = React.useCallback(() => {
    closeRef.current = 0;
    const id = setInterval(() => {
      setShow(prev => !prev);
      if (closeRef.current++ > 10000) {
        clearInterval(id);
      }
    }, 1);
  }, [setShow])

  return (
    <div>
      <button onClick={handleShow}>{show ? ""hide"" : ""show""}</button>
      <button onClick={handleShowMany}>{closeRef.current}</button>
      {show && <InputWrapper />}
    </div>
  );
};
``` 

## The current behavior
Currently when mounting the input controller for the first time, a small increase in fiber nodes occurs, and after typing in the input box, seemingly the entire React fiber tree is leaked. When mounting/unmounting the input again, there is no clean up (even after thousands of iterations).

## The expected behavior
The fiber nodes to be cleaned up after unmounting the input element.

Comparison memory+fiber nodes on Chrome 69 vs Chrome 86:

**Chrome 69**:
![image](https://user-images.githubusercontent.com/54151393/97064044-3e368d80-1558-11eb-8676-3ee913542cc5.png)

**Chrome 86**:
![image](https://user-images.githubusercontent.com/54151393/97064051-4db5d680-1558-11eb-834b-04a26f4c507a.png)

**Note the 600kb increase in memory per scenario in Chrome 86, vs the <100KB in Chrome 69, as well as the difference in Fiber nodes**

**The final number of fiber nodes in the Chome 69 snapshot is the same as the initial count of fiber nodes in Chrome 86 after mounting the input element for the first time:**
![image](https://user-images.githubusercontent.com/54151393/97064148-ca48b500-1558-11eb-9b41-ca397b1156a7.png)
",,
20085,OPEN,Feature Request: Adding filter (search) to react DevTools Profiler,Component: Developer Tools; Type: Feature Request,2020-12-10 16:15:50 +0000 UTC,M-Izadmehr,,"A few months ago, we added a tooltip to react DevTools Profiler (cc @bvaughn), so that for very small components, without clicking on them it is possible to see an overview of why they are re-rendered.
However, still, for a not very big page, there can be tens of re-renders, so it is hard to find the component that you are looking for.

An easy solution for this to add some search bar, where the user can type down the name of the component, and find the component. 

If this is something that you think we care about, I can pick it up and add the search field. 

<img src=""https://user-images.githubusercontent.com/28848972/97014068-25bf7680-154a-11eb-8ba3-a07dd7a45d45.png"" width=""250"">

",,
20068,OPEN,Feature request: A useLayoutEffect with read/write batching across a tree,Component: Hooks; Component: Reconciler; Type: Feature Request,2020-10-22 08:01:07 +0000 UTC,mattgperry,,"Today, `useLayoutEffect` can be used for synchronous read/writes across the DOM.

```javascript
useLayoutEffect(() => {
  // Write
  ref.current.style.transform = """"

  // Read
  const box = ref.current.getBoundingClientRect()
})
```

For a single instance of a single component, this works well. But if this code is repeated or reused anywhere in the tree, we trigger  [layout thrashing](https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing). The severity of the layout thrashing scales linearly with the number of hooks/components featuring either this code or code like it.

Hooks and components are designed to be composable, yet it's this trivial to write one that isn't. 

Instead, what I'd like is a batched version of `useLayoutEffect` that provides `read` and `write` callbacks. These schedule callbacks that will be called:

1. Synchronously before paint
2. In ""parallel"" in reads/writes/reads etc
3. After all child components in the tree have run `useLayoutEffect` - including those entering the tree (currently these don't mount until after other `useLayoutEffect`s have been called)

It could look like this, though I'm more interested in the above specs than actual API:

```javascript
useBatchedLayoutEffect((read, write) => {
  write(() =>  {
    ref.current.style.transform = """"
  })

  read(() => {
    const box = ref.current.getBoundingClientRect()
  })
})
```

Then, adhering the 3 specifications above, these callbacks are executed in order, so all `read`s from across the tree, then all `write`s, then all `read`s etc. There is no upper limit for the number of permitted ping-ponged reads/writes IMO as the amount of layout thrashing you could possibly suffer will never be worse than the single hungriest hook. In my experience I've never needed more than a read/write/read/write.

## Measurement accuracy

In the given example, we're measuring a component after first resetting its `transform` because we want to snapshot its actual bounding box without any transforms applied. But if this component is [nested in itself](https://codesandbox.io/s/dazzling-varahamihira-2qiyw?file=/src/App.js), so both a parent and child are performing the same type of animation, we want to unset all the transforms before measuring any of the elements, otherwise the resulting measurements will be incorrect.

## What about `requestAnimationFrame`?

Theoretically it could be possible to implement this ourselves in userland by creating a batcher that executes on the next available frame. Sadly this isn't possible in practise. For whatever browser-internal reason it is necessary to run these reads and writes synchronously to prevent flashes of incorrectly-styled components.

If you play with this very simple layout animation implementation by clicking on the red box you'll see it suffers no flashes:

https://codesandbox.io/s/broken-star-cycfz?file=/src/App.js:528-537

But if you uncomment the wrapping `requestAnimationFrame` within the `useLayoutEffect` you'll see it does randomly flash with the undesired styles.",,
20065,OPEN,Bug: onCompositionEnd not called,Component: DOM; Status: Unconfirmed; Type: Needs Investigation,2020-12-08 16:56:35 +0000 UTC,iWuzhi,,"## Steps To Reproduce

1. Switch input method to Chinese
2. Type 1 to the input

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:  https://codepen.io/Eoyd/pen/KKMgMzz?editors=0011

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
When setting the formatted value in the render function, if the formatted return is a string, the combined input will not trigger onCompositionEnd

## The expected behavior
onCompositionEnd should be called
",,
20052,OPEN,"Misspelled ""Escape"" event type in Focus.js",Type: Bug,2020-10-19 14:21:22 +0000 UTC,aMarCruz,,"Is the correct word ""Escape"" ?

https://github.com/facebook/react/blob/dfb6a403357d5ac2c0ea87aa6e5a4f947de342f8/packages/react-interactions/events/src/dom/create-event-handle/Focus.js#L72",,
20047,OPEN,Clarify SSR expectations/contract,Type: Discussion,2020-10-17 17:33:35 +0000 UTC,Andarist,,"I've been asked about the safety of a certain pattern and I'd like to clarify this with you (the React team). 

In my opinion - the actual SSRed output and the hydrating tree **do not have to match**. This is, of course, a weird space of things and one should understand how things work together to even think about it, but there is no technical aspect forbidding this now. Question is - is it safe to assume that such a ""use case"" will stay supported in the future. I believe it is because the only thing that is used as an input to the rehydration is the current HTML structure and the React team doesn't intend to ship any extra metadata in the SSRed output about the actual render tree that was used to render it.

This can be a little bit of a vague question - so let's take a look at an example. Emotion does 2 things on the server differently than on the client:
1. it does not use `React.forwardRef` (refs are useless on the server, so we don't see a need to grow the render tree rather significantly by using it)
2. we render `<style>` elements ""inline"", together with other elements. This is an example SSRed output:
```html
<div id=""react-root"">
  <style data-emotion-css=""bjcoli"">
    .css-bjcoli{color:green;}
  </style>
  <div class=""css-bjcoli"">
    <style data-emotion-css=""ihiui2"">
      .css-ihiui2{color:hotpink;}
    </style>
    <div class=""css-ihiui2"">
    </div>
    <div class=""css-ihiui2"">
    </div>
  </div>
</div>
```

On the client we:
- use `React.forwardRef` as it's important to do so
- we **move** `<style>` elements to the `<head>` **before** rehydration can even be called

This makes the HTML structure **identical** to what React sees during the first render so there is **no SSR mismatch**, even though initially there kinda is one.

We totally understand this is a gray area and trickery - question is: do u plan to make things like this break in the future? I totally would understand the answer being ""we can't guarantee that"", but at the same time it would be great if it would be accompanied by ""probably not, this is _safe_ to do and there are no plans to make this break now""

cc @eps1lon ",,
20031,OPEN,Suggestion: transforming jsx to jsx-runtime without `createElement` fallback,Status: Unconfirmed,2020-10-18 08:24:52 +0000 UTC,morlay,,"Current code transform rule is not friendly for custom `jsx-runtime` or react-like lib.

```js
// have to re export the `createElement`
import { createElement } from ""@emotion/core""

import { jsx, jsxs, Fragment } from ""@emotion/core/jsx-runtime""
```

Could we follow rules like below, could got same behavior.

* `<span key={key} {...obj} />` => `jsx(""span"", obj, key)`
* `<span {...obj} key={key} />` => `jsx(""span"", {...obj, key}, key)`

https://github.com/babel/babel/issues/12177
https://github.com/microsoft/TypeScript/pull/39199",,
19991,OPEN,Bug: Infinite rendering resulting in freezing of tab/browser,,2020-11-30 12:46:51 +0000 UTC,palerdot,,"- The documentation of  `useEffect` does not have a single reference to this gotcha - guarding against passing object/array to the dependency array, since reference of the object/array is being checked, not a deep comparison value. Some solutions already exist like https://github.com/kentcdodds/use-deep-compare-effect, https://stackoverflow.com/questions/54095994/react-useeffect-comparing-objects/63965274#63965274. But, only people who are aware of this behaviour of `useEffect` will reach out to these solutions (or they might manually deep compare with their own custom hook as some people do in the linked stackoverflow link)

It would also be helpful if `useEffect` includes a helpful option like 
```javascript
useEffect(() => {
 // myArray, myObject gets new reference on evey render
}, [myArray, myObject], {
   deepCompare: true/false // it would be helpful to have this instead of reaching for custom hooks/npm packages
})
```

React version:
`16.12.x` (any latest version)

## Steps To Reproduce

1. Click the `codesandbox` link - https://codesandbox.io/s/apollo-client-uselazyquery-example-forked-kmc1u?file=/src/App.js. 
2. Click `Topics` link and then select `Countries` link. 

`Warning`: Please be aware that tab/browser will freeze. It is better to open the console before hand, so that you can see the looping from console logs.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

[CodeSandbox reproduction](https://codesandbox.io/s/apollo-client-uselazyquery-example-forked-kmc1u?file=/src/App.js)

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

Current behavior:
- React does not prevent infinite loop/rendering. Browser tab freezes, and the end user has no idea that the tab has freezed. They have to force quit the tab.


Expected behavior:
- React should give a helpful warning that an infinite render/loop is going on.
- React should pinpoint the exact issue - the array/object passed to `useEffect` dependency is triggering infinite rendering
",,
19976,OPEN,"Error: ""Electron failed to install correctly; please delete node_modules/electron and try installing again""",Component: Developer Tools,2020-10-08 18:27:07 +0000 UTC,romaniv1024,,"When I try to start program using command
```sudo npx react-devtools```
I get error
```
/usr/local/lib/node_modules/react-devtools/node_modules/electron/index.js:14
    throw new Error('Electron failed to install correctly, please delete node_modules/electron and try installing again')
    ^

Error: Electron failed to install correctly, please delete node_modules/electron and try installing again
    at getElectronPath (/usr/local/lib/node_modules/react-devtools/node_modules/electron/index.js:14:11)
```
Even I install react-devtools localy by `sudo npm install -g react-devtools` and after start program by `sudo react-devtools`, get the same error. 

Any idea how to fix this?

---
Linux Mint 20 Cinnamon
",,
19968,OPEN,Bug: Fast memory leaks on simple React App,Status: Unconfirmed,2020-10-28 19:16:11 +0000 UTC,druzhchenko,,"I have created simple test React application where browser tab and JS memory grow fast and don't clear. It is three tabs with same form which contains some count (1000-2000) generated input field. Browser is Edge based on chromium engine and memory report provide browser task monitor. Note: Chrome has same results
React version: 16.13.1

## Steps To Reproduce
Recursively:
1. Enter text on anyone input field.
2. Click to some other inactive tab.

After 5 minutes memory size of browser tab grows from 70mb to > 500mb and JS from 7mb to > 120mb, and stay there forever.

Link to code example: [GitHub](https://github.com/druzhchenko/react-memory-test)
My question on:  [StackOverflow](https://stackoverflow.com/questions/64225283/why-browser-tab-and-js-memory-leak-on-clear-react-app)
",,
19963,OPEN,eslint-plugin-react-hooks: New rule to require useState updater.,,2020-10-07 01:27:36 +0000 UTC,jsphstls,,"`const [state] = useState()`

Calling `useState` without assigning the second array value should be flagged.",,
19932,OPEN,Better support <template> tags,,2020-10-17 05:43:31 +0000 UTC,manuel-mauky,,"HTML [`<template>` tag]() is used to pass reusable templates to web components.
However, at the moment this doesn't work with React in a way that is useful to users.

### Context: Basic usage of `<template>`


If you have HTML like this:

```html
<template>
	<p>Some Text</p>
</template>
```

You can then use this template with pure JS like this:

```js
const template = document.querySelector(""template"")

const node = template.content.cloneNode(true)

document.append(node)
```
The important part here is the `content` property of the template.

### Whats the problem?

Writing the template code in HTML is OK. However, if you create the template DOM nodes with JS like this, it won't work:

```js
const template = document.createElement(""template"")
const p = document.createElement(""p"")
p.textContent = ""Some Text""
template.appendChild(p)
```

In this case, the `content` property of the template will be empty. Instead, one would have to do either of these:

```js
const template = document.createElement(""template"")
template.innerHTML = ""<p>Some Text</p>""
```

or

```js
const template = document.createElement(""template"")
const p = document.createElement(""p"")
p.textContent = ""Some Text""
template.content.appendChild(p) // notice `content`
```

The first does work because there is a special case in `innerHTML` for template tags (see [mdn](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#Operational_details)).
The second example works because the `<p>` DOM node is added directly to the `content` of the template.

### What does this has to do with React?

When using React to create the template, React is appending the generated DOM nodes directly to the template node and not to the `content` property of the template node. For this reason at the moment you can't really use template tags in React apps.

I have the impression that this is not the fault of React as the same problem exists for angular and most likely other spa frameworks too. Instead this looks like a misconception of the `template` tag to me (mayby I'm wrong on this and there is a good reason for this behavior). 
However, maybe React could do something to make this usecase less anoying? A possible solution could be to detect if the parent node is a `template` and to add the child nodes to the `content` property instead of the node itself. But I'm not sure if there would be any negative side-effects of this.


 





",,
19927,OPEN,"Error: ""Cannot read property 'isCollapsed' of undefined""",Component: Developer Tools; Type: Needs Investigation,2020-09-30 07:14:35 +0000 UTC,jellydn,,"Describe what you were doing when the bug occurred:
1. Open React Devtool
2. Select the Component tab
3. Got below error

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.8.2-fed4ae024

Call stack: at Store.getElementAtIndex (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19359:35)
    at Store.getElementIDAtIndex (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:19376:26)
    at chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:26594:18
    at List.render (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:21229:18)
    at li (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:11802:76)
    at ki (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:11793:10)
    at ck (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:14433:86)
    at bk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13779:11)
    at ak (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13768:5)
    at Sj (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13750:7)

Component stack: at List (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:20924:30)
    at div
    at AutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:2786:5)
    at div
    at div
    at Tree_Tree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:26368:45)
    at div
    at div
    at InspectedElementContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:26848:23)
    at OwnersListContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:25520:23)
    at SettingsModalContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:26139:23)
    at Components_Components (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:30926:50)
    at ErrorBoundary (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:27172:5)
    at PortaledContent (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:27303:32)
    at div
    at div
    at ProfilerContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:30463:23)
    at TreeContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:22538:23)
    at SettingsContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:23040:27)
    at ModalDialogContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28328:23)
    at DevTools_DevTools (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:33797:21)",,
19925,OPEN,Bug: useDeferredValue with a value that is new every render hangs browser,Component: Concurrent Mode; Type: Needs Investigation,2020-09-30 14:38:28 +0000 UTC,chriserickson,,"React version: 0.0.0-experimental-94c0244ba

## Steps To Reproduce

Attempt to load the following component:
```jsx
export default function Component() {
  const value = { something: ""I'm new every render"" };
  const deferredValue = React.unstable_useDeferredValue(value, {
     timeoutMs: 3000
  });
  console.log(""Component render"");
  return (
    <div>{deferredValue}</div>
  );
}
```

The above (buggy) component will peg the CPU and hang the browser. While this is understandable (there are theoretically infinite concurrent trees), it is an easy pitfall for someone to fall into.

Not sure if this could be identified by a console warning or lint rule.

## The current behavior
Browser hangs.

## The expected behavior
A lint rule informs me of my error or the console warns me that the deferred value changes every render.",,
19921,OPEN,Bug: shallowEqual() is flawed,,2021-01-07 23:55:42 +0000 UTC,Salmatron,,"The `shallowEqual()` function located in `packages/shared/shallowEqual.js` is incorrectly using `Object.prototype.hasOwnProperty()` instead of `Object.prototype.propertyIsEnumerable()`, which is the correct counterpart for `Object.keys()`. 

Explanation:
------------
The `Object.keys()` method used inside `shallowEqual()` returns an array of a given object's own enumerable property names. But `hasOwnProperty.call(...)` (used in the `for` loop titled `Test for A's keys different from B`), checks only one of those things: ownership. Which causes the bug pointed out below. `Object.prototype.propertyIsEnumerable()` must be used instead which checks both direct ownership and enumerable-ity.

React version: v16.13.1

## Steps To Reproduce

```
const person = {
  name: 'Salman',
  age: 25,
};

const personWithProfession = {
  name: 'Salman',
  profession: 'Software Engineer', // This property goes undetected by shallowEqual()
};

// Add age
Object.defineProperty(personWithProfession, 'age', {
  value: 25, // non-enumerable by default
});

const keysA = Object.keys(person);
const keysB = Object.keys(personWithProfession);

console.log(keysA); // name,age
console.log(keysB); // name,profession

console.log(keysA.length === keysB.length); // true // Passes the length check
```

Link to code example with a demonstration and fixed version:
[https://codesandbox.io/s/infallible-keldysh-r98gl?file=/src/index.js](https://codesandbox.io/s/infallible-keldysh-r98gl?file=/src/index.js)

## The current behavior
```
shallowEqual(person, personWithProfession) // true
```

## The expected behavior
```
shallowEqual(person, personWithProfession) // false
```

## The fix
Replace
`!hasOwnProperty.call(objB, keysA[i])`
with:
`!propertyIsEnumerable.call(objB, keysA[i])`",,
19901,OPEN,Bug: hydrating fails with nested paragraph and dangerouslySetInnerHTML,,2021-01-21 08:18:12 +0000 UTC,romeovs,,"1. Use the `dangerouslySetInnerHTML` on a `p` element where the `__html` contains a `<p>` tag
2. Server-side render this component and try to hydrate

Link to code example:
```html
<!doctype html>
<html>
  <head>
    <script crossorigin src=""https://unpkg.com/react@16/umd/react.development.js""></script>
    <script crossorigin src=""https://unpkg.com/react-dom@16/umd/react-dom.development.js""></script>
  </head>
  <body>
    <!-- Pretend for an instance that this html was generated on the server by ReactDOM.renderToString() -->
    <div id=""app""><p><p>Dope!</p></p></div>
  </body>
  <script>
    function Component() {
      return React.createElement(""p"", {
        dangerouslySetInnerHTML: { __html: ""<p>Dope!</p>"" },
      })
    }
    const component = React.createElement(Component)
    const root = document.getElementById(""app"")
    ReactDOM.hydrate(component, root)
  </script>
</html>
```

JSFiddles:
- This one breaks because it has nesting `p`:  https://jsfiddle.net/mw19p0g3/
- This one works because the wrapper is `div` instead of `p`: https://jsfiddle.net/mw19p0g3/2/
- This one works too because there no nesting `p` in the html: https://jsfiddle.net/mw19p0g3/3/

## The current behaviour
The `ReactDOM.hydrate` throws a cryptic error:
```
Warning: Prop `dangerouslySetInnerHTML` did not match. Server: """" Client: ""<p>Dope!</p>""
```
Note the missing `Server: """"` string.

## The expected behavior
Do not throw an error and just hydrate the component as expected.

I realise that nesting `p` elements does not conform to the [HTML spec for the p element](https://www.w3.org/TR/html401/struct/text.html#h-9.3.1).
If React chooses not to support the use case of nesting `p` tags through `dangerouslySetInnerHTML`, that's understandable. 
In that case the error should be more descriptive and there should probably also be an error or warning while performing the server side render. 
It should also be documenting somewhere that will easily show up in Google.

The current behaviour is very confusing and it took me a while to track down what was going on.
",,
19891,OPEN,FR: Allow displaying debug information for reconcilers in DevTools,Component: Developer Tools; Type: Discussion,2020-09-24 20:06:29 +0000 UTC,derolf,,"React allows to develop custom reconcilers. However, currently it is not possible to display custom debug information about the generated Instances in the react DevTools.

Therefore, I propose to introduce two functions into `HostConfig`:

```TypeScript
  getInstanceDebugInfo?: (instance: Instance) => any;
  getTextInstanceDebugInfo?: (textInstance: TextInstance) => any
```

They should return an object with custom debug information that would be shown in DevTools whenever an Instance-backed Component is highlighted.",,
19887,OPEN,Feature request: dealing with dependencies in custom React hooks,,2020-10-16 01:58:24 +0000 UTC,Patrick-DS,,"Let's suppose that I'm trying to define a custom hook using useEffect (the same comment applies for other hooks relying on dependencies such as useCallback, useMemo, useLayoutEffect, etc...):

```
import {useEffect} from ""react""

export const useWindowScroll = (dependencies) => {
  useEffect(() => {
    window.scrollTo(0,0)
  }, dependencies)
}
```

This would be the ideal code to write to make this hook re-usable:
- It encapsulates the exact business logic, which is to scroll back to the top of the page when one of the dependencies change
- It works using similar syntax to a standard React hook, so provides a nice interface to the developer
- It's as simple as it gets: do the exact thing you've always been doing with the standard hooks. 

However, this leads to problems because React complains about the 'dependencies' array. There are different ways one could go about solving this, but they all feel sort of hacky and unnatural to me, one of them being replacing 'dependencies' by 'JSON.stringify(dependencies)' (suggested by Dan Abramov according to a quote I cannot find anymore). It works, but it looks strange to remember that this trick needs to be done.

Something else that would also be practical would be to be able to write [someOtherVariable, ...dependencies] in that second argument of a useEffect/useCallback/use(...), without having to wrap it in a JSON.stringify.

Is there anything that we could do in React itself to make the API for custom hooks simpler when it comes to dependencies? ",,
19870,OPEN,Bug: Nested Suspense not catching fast resolved Promises,Component: Concurrent Mode; Component: Suspense; Status: Unconfirmed,2021-01-04 11:45:43 +0000 UTC,Xiphe,,"Given I have two resources stored and initiated in the `useState` of two nested components.
And both components have a `<Suspense>` 
And the resources are read by child components rendered within these Suspense-Boundaries.

Then I expect both resources to just be created once
And I expect the thrown promises to be captured by the closest `<Suspense>`

⚠️  But when the resources resolve within ~10ms
Then the inner resource is created more then once (i've seen up to 80 creations)
And the inner `<Suspense>` seems to be ignored


React version: `0.0.0-experimental-94c0244ba-0.0.0` - `0.0.0-experimental-3310209d0` (maybe also earlier)


## Steps To Reproduce

1. Go to: https://codesandbox.io/s/youthful-banach-dl5mq?file=/src/index.js
2. Open the console
3. Run the code
4. Observe multiple ""CREATE SUB RES (with INIT) "" logs
5. set `DELAY` in line 7 to `1000` or greater
6. Rerun the code
7. Observe only one ""CREATE SUB RES (with INIT)""

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

`0.0.0-experimental-94c0244ba`: https://codesandbox.io/s/quirky-bassi-1mbt7?file=/src/index.js

`0.0.0-experimental-3310209d0`: https://codesandbox.io/s/youthful-banach-dl5mq?file=/src/index.js


## The current behavior

lazy state initiation in nested component is called multiple times when promises/resources resolve fast
and called only once when promises/resources resolve slow

## The expected behavior

no change in behaviour weather the promises/resources resolve fast or not

---

Not sure if this maybe is intended and meant to prevent UI flickering / loading-waterfalls.
Or I am not supposed to create resources in lazy state initiations

In both cases I'd love to see deep docs about the why and how I am supposed to setup my resources.",,
19865,OPEN,Removal of <script> functionality needs to be added to https://reactjs.org/docs/ and a warning displayed while in development mode.,Type: Discussion,2020-09-19 02:20:15 +0000 UTC,infoeon,,"When a <script> tag is used within JSX there is functionality that tricks the browser into not executing the contained code or from fetching the `src`. There is a code comment indicating this behaviour:

`Create the script via .innerHTML so its ""parser-inserted"" flag is set to true and it does not execute`

but for those who are expecting the tag to work like _every other html tag_ in React it is a bit of a surprise that wastes several hours tracking down the cause.  This ""feature"" is obviously there for security reasons, but there are numerous ways around it (changing the case of a letter such as <sCript src=""..."">).

Please either remove this feature and add a warning while in dev mode stating that adding <script> tags is not best practices, or keep the feature but warn that <script> tags are not supported inline and document this behaviour in the React docs. I personally recommend the first once since it simplifies the React code base while allowing the developer to still proceed at their own risk.  The ""risk"" is minor since this isn't readily exploitable as the dangerouslySetHtml feature.

",,
19860,OPEN,"Bug: input[type=""radio""] controlled value can get out-of-sync",Component: DOM; Status: Unconfirmed; Type: Bug,2021-03-26 08:30:15 +0000 UTC,eps1lon,,"

React version: 16.13.1 and 17.0.0-alpha.0-2d131d782

## Steps To Reproduce

1. Render two `input[type=""radio""][name=""radio""]`: one is checked, one isn't
2. Get warning about passing `onChange` or `readOnly`
3. Add empty `onChange` to both

Link to code example:

- [React 16 repro](https://codesandbox.io/s/react-16-radio-cannot-be-read-only-z9ldc)
- [React 17 repro](https://codesandbox.io/s/react-17-radio-cannot-be-read-only-forked-r6m9r)

## The current behavior

![screencapture of the described behavior](https://i.ibb.co/CMGcrSH/react-readonly-radio.gif)

1. React recommends `readOnly` for `input[type=""radio""]` even though this isn't supported natively (though React could polyfill it)
2. After looping through the radios once with arrow key navigation the checked state changes

## The expected behavior

Arrow key navigation shouldn't break out of the controlled value. It's debateable whether React should recommend `readOnly` when this isn't a standard attribute like `readOnly` for `<input type=""text"" />`.
",,
19857,OPEN,Bug: React Portals - Memory Leak,Resolution: Stale; Status: Unconfirmed,2020-12-25 13:08:08 +0000 UTC,seanlandsman,,"
We use React and interact with a 3rd party JS library - we use React Portals to create & destroy React Components within the overall application.

The supplied repo demonstrates a very simplified version of what we do - after destroying/cleaning up components and detached HTML elements still remain in memory.

React version: 16.3.1

## Steps To Reproduce

1. Check out https://github.com/seanlandsman/react-portal-memory-leak.git
2. take a snapshot (or several until the memory footprint stabilises)
3. click ""Create Portal""
4. click ""Delete Portal""
5. If you now take another snapshot and compare against the first one you'll see a ""Detached HTMLDivElement"", as well as the supplied ""TestComponent""

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://github.com/seanlandsman/react-portal-memory-leak.git

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

Post forceUpdate components and HTML elements remain in memory.

## The expected behavior

Memory before and after create/destroy(update) should be the same
",,
19851,OPEN,Bug: Component with a Symbol as key; causes Crash,Type: Discussion,2020-10-01 01:38:34 +0000 UTC,omarsy,,"1. Go To the link https://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js
2. We can see errors caused by this part of code: https://github.com/facebook/react/blob/6fddca27e75950adda92ab4f4946442907dc3bb7/packages/react/src/ReactElement.js#L228

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://codesandbox.io/s/happy-ramanujan-xlegp?file=/src/App.js
<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Crash
## The expected behavior
No crash
",,
19848,OPEN,Bug: Handling of symbols when used as deps incorrectly to create error message results in an unrelated TypeError: Cannot convert a Symbol value to a string,Component: Hooks; Type: Bug,2020-09-18 06:27:21 +0000 UTC,leidegre,,"React version: 16.3.1

## Steps To Reproduce

1. Click the button in this Code Sandbox https://codesandbox.io/s/blissful-sun-e0lle?file=/src/App.js

## The current behavior

The wrong error is generated

## The expected behavior

An error should still be generated but the error message should be correct. The problem is that if you do `[Symbol('...')].join(',')` JavaScript will freak out which is what happens if you put symbols incorrectly in the deps to hooks.",,
19846,OPEN,Bug: manually created 'change' events via new Event() don't trigger React event handlers,Resolution: Stale; Status: Unconfirmed,2020-12-25 13:08:06 +0000 UTC,jesseko,,"## Description:
Manually created events created via `new Event` and emitted from a hidden input work great for `'input'` events, they bubble as expected and can be caught via `onInput` handlers, but using `'change'` events this way doesn't work -- `onChange` handlers are never called.

The vanilla JS `'change'` events do bubble normally and can be caught by parents with vanilla JS listeners ( using `addEventListener`), but the React `onChange` listeners don't register anything. 

I've created a codepen to demonstrate a minimal case for this via console logging.  See repro steps below and code comments for additional details.

### React version: 16.13.1

## Steps To Reproduce

1. Open https://codepen.io/jesseko/pen/dyMqGKG
2. Observe that logging shows a single entry, the `change` event being emitted from a child component after render.  We expect a second log from a parent's `onChange` but it never comes.
3. Change `EVENT_TYPE` to `'input'`
4. Observe that logging shows two entries, one for the event being emitted and a second for it being detected via an `onInput` handler in the parent component.
5. optional: there's some commented out code at the bottom to test a vanilla JS listener.  Change `EVENT_TYPE` back to `'change'` and uncomment that code and you'll see that that listener does work

",,
19839,OPEN,"Error: ""Maximum call stack size exceeded""",Component: Developer Tools; Type: Bug,2020-10-18 09:18:07 +0000 UTC,mungojam,,"Describe what you were doing when the bug occurred:
1. Clicking back to go back through the frames following a profile session. I think I got to zero and then clicked it again and then it errored

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.8.2-fed4ae024

Call stack: at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17661:26)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)
    at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17710:30)

Component stack: at CommitRankedAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:31963:48)
    at div
    at div
    at div
    at SettingsModalContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:26139:23)
    at Profiler_Profiler (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:33363:48)
    at ErrorBoundary (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:27172:5)
    at PortaledContent (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:27303:32)
    at div
    at div
    at ProfilerContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:30463:23)
    at TreeContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:22538:23)
    at SettingsContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:23040:27)
    at ModalDialogContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28328:23)
    at DevTools_DevTools (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:33797:21)",,
19834,OPEN,Bug: memoized component not re-rendering when prop changes after suspense resume,Resolution: Stale; Status: Unconfirmed,2020-12-25 13:08:13 +0000 UTC,sfc-gh-sbessler,,"1. Given 3 React.memo'd components: A which contains B which contains C all inside a suspense context.
2. If A changes a context that causes B to throw a promise on re-render, and upon getting the result of that promise passes a value to C (changing C's prop) C will not re-render.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/upbeat-buck-f6ntj
_This also shows a workaround, that if we don't use context to ""pass"" the ""val"" from A to B and instead actually pass a prop, it all works as-expected._

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

C does not re-render in the above scenario. Altho, C2 does.

## The expected behavior

Component C should re-render in the above scenario.  Just like C2 does.",,
19818,OPEN,Bug: Glitchy behaviour when rendering/setState in an onKeyDown event callback,Status: Unconfirmed,2020-09-30 04:27:53 +0000 UTC,maximedupre,,"React version: 16.13.1

## Steps To Reproduce

1. Please open the [minimal reproduction](https://codesandbox.io/s/silly-glitter-5xrdl)
2. Focus your cursor at the end of the third input text
3. Press CMD + Backspace

This successfully removes the third todo, but also sets the `text` attribute of the forth to an empty string, because the onChange event callback is called on the same input, but a new model is attached to it. Since CMD + Backspace has deleted the content of the input, the value of `e.target` in the `onChange` callback is an empty string, thus setting the value of the newly attached model to `''`.

Note that if the input is not being focused on in the `componentDidUpdate` method, the onChange event does not occur. The onChange event also does not occur if we wrap the focusing of the input in a `setTimeout(..., 0)`.

## The expected behavior

The input probably shouldn't be reused for a different model. The parent of the input is `<div key={todo.id}>`, so the input element should probably be recreated.",,
19800,OPEN,Bug: Memory leakage with setInterval,Status: Unconfirmed,2020-10-17 06:03:55 +0000 UTC,secretlifeof,,"
<img width=""1353"" alt=""image"" src=""https://user-images.githubusercontent.com/38684618/92622156-05529a00-f2c5-11ea-82d4-e87fd5feaaab.png"">

The image above is taken from profiling this [sandbox](https://codesandbox.io/s/eager-franklin-3km4k?file=/src/App.js). The example is rather simple and can be viewed below.

```javascript
export default function App() {
  const [counter, changeCounter] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      changeCounter(prevCounter => prevCounter + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, []); // setting [counter] does not remove memory leakage

  return (
    <div className=""App"">
      <h1>SetInterval()</h1>
      <h2>Sandbox counter: {counter}</h2>
    </div>
  );
}
```

What seems to make it worse (more rapid incline) is putting more useEffects hooks that depend on counter.
Is this a bug? Can I provide more information?",,
19778,OPEN,"Bug: React devtools ""highlight updates when components render"" and profiler output not matching when using memo",Component: Developer Tools; Status: Unconfirmed,2021-03-18 07:35:26 +0000 UTC,saranshkataria,,"1. Create a dynamic list component
2. Use memo to memoize the list, dynamically change one of the properties of an item on the list
3. Open devtools and check the ""highlight updates when components render"" and ""record why component rendered while profiling"" option
4. Start profiling and recording
5. All components of the list are shown as being re-rendered
6. Open React profiler and see the re-rendered items
7. React profiler shows that only the selected item on the list was re-rendered


![2020-09-05 13-23-43](https://user-images.githubusercontent.com/1450819/92313029-9222ee00-ef7b-11ea-97c2-6ee0212b2d1d.gif)


<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/practical-lovelace-ch4mw

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
React Devtools ""highlight updates when components render"" highlights all components. When using the profiler to do the same recording, it shows that only one component was re-rendering.

(My guess is that highlight updates is hooking into the function call itself and the profiler is looking into DOM changes and showing only those that actually re-render.)

## The expected behavior
React Devtools ""highlight updates when components render"" should only show the components that were re-rendered",,
19765,OPEN,App crashes upon the automatic attempt to inspect hooks on a Fiber with tag of type ClassComponent,Component: Developer Tools; Status: Unconfirmed,2020-12-26 20:05:05 +0000 UTC,shmuelhizmi,,the issue from https://github.com/facebook/react-devtools/issues/1352 still occur when trying to use react-devtools with a nodejs react application (the issue was closed due to the react-devtools rewrite of version 4),,
19756,OPEN,Bug: React DevTools throws ReferenceError: regeneratorRuntime is not defined,Component: Developer Tools,2021-02-26 11:16:48 +0000 UTC,leidegre,,"React version: 16.3.1

## Steps To Reproduce

1. In the Chrome script debugger, enable ""Pause on caught exceptions""
2. Open React DevTools in a app that doesn't use babel or webpack
3. ReferenceError: regeneratorRuntime is not defined

## The current behavior

```
ReferenceError: regeneratorRuntime is not defined
```

The source of this error seems to be something like this:

```
try {
  // add if support for Symbol.iterator is present
  __webpack_require__(23)(Yallist);
} catch (er) {}
```

From `chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/react_devtools_backend.js`

## The expected behavior

No errors are thrown. It's really annoying when React or it's tooling is throwing exceptions because it makes me having to step through a lot of noise when I'm debugging my own stuff. If this could be avoided that would be much appreciated.

---

I get that his might not be fixable and if so, feel free to close but please keep it in mind. Please don't throw exceptions if you absolutely musn't.",,
19749,OPEN,Bug: react-hooks/exhaustive-deps includes too much logic?,Component: ESLint Rules; Status: Unconfirmed,2021-03-10 00:16:24 +0000 UTC,dartess,,"Judging by the name the rule should check `deps` of some hooks. Instead, it checks for other things as well, such as the asynchronous effects. This violates the single responsibility principle and reduces the flexibility of the rule.

Example:

I am writing a new hook that must accept an asynchronous function, but must have deps.

If I just write it, I won't get linter errors for missing dependencies:

```
    useEffectAsync(
        async (getIsIgnore) => {
            console.log(roleCode)
        },
        [], // missing deps: roleCode
    );
```

Now I can set up a rule, which is very cool:

```
        'react-hooks/exhaustive-deps': ['warn', {
            'additionalHooks': '(useEffectAsync|useEffectOnUpdate)'
        }],
```

But if I do that, I get a warning from the linter about the async function.


```
    useEffectAsync(
        async (getIsIgnore) => { // warn about async func, what is useless here
            console.log(roleCode)
        },
        [roleCode], // ok, can be fixed automatically
    );
```

I think the rule for checking the correctness of the effects functions should be separate. ",,
19732,OPEN,Bug: React DevTools 'Why did this component render?' incorrectly reports 'The parent component rendered',Component: Developer Tools; Resolution: Stale; Status: Unconfirmed,2020-12-25 13:08:25 +0000 UTC,bgirard,,"React Devtools shows why a component has re-render but sometimes it says 'The parent component rendered' when it just doesn't know. Ideally we would split out these two scenario, otherwise the string should highlight the uncertainty. Me and another Jimmy both went debugging the wrong thing and I lost time assuming the message was correct.

React version: React DevTools 4.8.2

## Steps To Reproduce

I believe this bug happens when there's a context changing but I'm not positive.",,
19731,OPEN,Craft a demo profile for the scheduling profiler,Component: Scheduling Profiler; Resolution: Stale,2020-12-25 13:08:29 +0000 UTC,kartikcho,,"We should create a custom demo profile to show the various performance 'patterns' observed in the scheduling profiler.

**cc: @bvaughn @taneliang**",,
19713,OPEN,Consider improving React.cloneElement validation in DEV,Status: Unconfirmed,2020-12-25 16:14:47 +0000 UTC,markspolakovs,,"React version: 16.12.0

This bit me earlier: if you try to `cloneElement` a component type, you'll get a confusing error message. `createElement` has validation for silly inputs in DEV, maybe `cloneElement` should have the same.

## Steps To Reproduce

1. Create new React app
2. `React.render(React.cloneElement(App, {}), document.getElementById('root'));`

Link to code example: https://codesandbox.io/s/cranky-dawn-ret64?file=/src/index.js

## The current behavior

`Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.`

## The expected behavior

A more helpful error message, like `createElement` would give, for example `React.cloneElement: element type is invalid -- expected a React element but got: function. You're likely trying to clone a component - you want createElement instead.`",,
19701,OPEN,Bug: `Context.Consumer` inside `Suspense` does not receive context updates while suspended,Component: Reconciler; Type: Bug,2020-10-01 17:37:00 +0000 UTC,overlookmotel,,"A `<Context.Consumer>` callback inside a suspended `<Suspense>` boundary does not receive updates when context value changes.

This issue was originally found with React Router (https://github.com/ReactTraining/react-router/issues/7137) but can be reproduced with React alone.

React version: 16.13.1 or 17.0.0-rc.0 (and at least *some* earlier versions too)

## Steps To Reproduce

https://codesandbox.io/s/suspense-context-test-case-6jlsq

## The current behavior

In the example above, clicking on the ""About"" button puts the `<Suspense>` boundary into a suspended state. Clicking ""Home"" updates the context value, but the `<Context.Consumer>` callback is not called with this updated value. Therefore the page never navigates back to ""Home"".

Please note that `Received context: home` is not logged after the ""Home"" button is pressed.

## The expected behavior

The `<Context.Consumer>` callback should be called with value `'home'` when the value of the context is updated.

Please note that the problem does not occur if any of:

1. the Suspense boundary is never suspended (uncomment the first line of `About` function to verify).
2. `useContext()` is used in place of `<Context.Consumer>` (substitute `<SwitchWithUseContext />` for `<Switch />`).
3. the contents of `Switch` function is inlined within the `<Suspense>` rather than in a separate component.

The last of these leads me to suspect that the problem may be related to https://github.com/facebook/react/issues/17356. In the example, `<Context.Consumer>` is within a `Switch` component. But the `<Switch>` element inside `<Suspense>` never changes - so it's effectively memoized. I wonder if this is why it doesn't receive context updates?",,
19695,OPEN,Bug ?: Weird reconciliation result on list elements from array with same length as the list.,Resolution: Stale; Status: Unconfirmed,2020-12-25 13:08:20 +0000 UTC,mark-night,,"## Steps To Reproduce

1. Run this code and check in browser what elements are destroyed or reused.
```
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

const num = [3, 4, 5, 6]; // array serving content for list elements
const loop = [1, 2, 3, 4]; // array to be mapped to generate list

const RollingNums = () => {
  const [cur, setCur] = React.useState(0); // control number rolling

  return (
    <div className=""problem"">
      <ul>
        {loop.map((value, index) => { // list item counts are fixed to loop.length
          // some simple CS to get continued list item
          let idx = index + cur; 
          idx =
            idx >= 0
              ? idx % num.length
              : ((idx % num.length) + num.length) % num.length;
          const target = num[idx].toString(); // get content from array num for current list element
          return (
            <li key={target} className={target}>
              {target}
            </li>
          );
        })}
      </ul>
      <div className=""control"">
        <button onClick={() => setCur((prev) => prev - 1)}>-</button>
        <span>{cur}</span>
        <button onClick={() => setCur((prev) => prev + 1)}>+</button>
      </div>
    </div>
  );
};

ReactDOM.render(<RollingNums />, document.querySelector('#root'));
```  

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

[Example on codepen](https://codepen.io/mark-night/pen/bGpqvyL).

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Clicking on `+` destroys the first item and recreates it as the last item, while reusing all others. Clicking on `-` reuses first item (the last item from last render) and destroys/recreates all others.
**This only happens if `num` and `loop` have same length.** If `num` has more items than `loop` does, items are destroyed/reused as expected.

## The expected behavior
All items should be reused instead of being destroyed.

Although it looks perfectly fine in this simple app, everything still work. However, all class driven transitions mess up due to item destroy/recreate, and children elements underneath `<li>` will reinitialize (e.g. `<img>` reload) due to the same reason.",,
19692,OPEN,Bug: different handling of onMouseEnter & onMouseLeave based on pointerEvents in Chrome,Resolution: Stale; Status: Unconfirmed,2020-12-25 14:06:51 +0000 UTC,layershifter,,"React: 16.13.1
React-DOM: 16.13.1

Chrome 84.0.4147.135.
MS Edge 84.0.522.63.

---

_This looks somehow related to #4251._

## Steps To Reproduce

1. Open a CodeSandbox, https://codesandbox.io/s/laughing-sound-ox5yz
2. Move your mouse from the ""point 1"" to ""point 2"". Move your mouse from the ""point 2"" to ""point 1"". 

## The current behavior

![image](https://user-images.githubusercontent.com/14183168/91198165-81ad8080-e6fc-11ea-9148-5a3aac8102e4.png)

Notice in your console:
```
#disabled:mouseenter 
```

For the button `#disabled-style` with the same movement:

```
#disabled-style:mouseenter 
#disabled-style:mouseleave 
```

_The difference is that `#disabled-style` has `pointer-events: none`._

## The expected behavior

Both buttons should log the same output.

## It works?

- for the native DOM (https://codesandbox.io/s/recursing-leftpad-y5xbb)
- in IE11, Edge Dev 86, Firefox 79/80
",,
19683,OPEN,Support Firefox profiles in scheduling profiler,Component: Scheduling Profiler; Resolution: Stale,2020-12-25 13:08:31 +0000 UTC,taneliang,,"The scheduling profiler only supports Chrome profiles at the moment.

Migrated from https://github.com/MLH-Fellowship/scheduling-profiler-prototype/issues/52

## Possible Implementation Plan

1. Export Firefox importing code from Speedscope in this file in our fork: https://github.com/taneliang/speedscope/blob/fork-for-scheduling-profiler/src/library.ts
1. Refactor `preprocessData` to remove dependency on Chrome-specific types
1. Add Firefox profile support to `preprocessData`. Possibly use this line to read the JSON data: https://github.com/jlfwong/speedscope/blob/64fe369c42d956f6e35f8eb79c19f52cd6427fd6/src/import/index.ts#L146
1. Add separate Firefox profile import button to `ImportPage` (so that we don't have to guess the profile type)",,
19671,OPEN,Discussion: Async cleanups of useEffect,Type: Discussion,2021-02-19 16:06:32 +0000 UTC,Andarist,,"Hi 👋 

I've been asking about this on Twitter but was told that the issues here might be better to discuss this stuff.

My general concern is that async cleanups might lead to weird race conditions. It may be unwarranted but the concept itself sounds quite alarming to me and I'd like to discuss this, if possible.

If you go with the async cleanups then there is no guarantee that a scheduled work (or just any listeners) would get cleaned up before you get rid of a component instance, so for example:
```js
useEffect(() => {
  if (state !== 'foo') return
  const id = setTimeout(() => setShouldAnimate(true), 300)
  return () => clearTimeout(id)
}, [state])
```
This might not work as intended. There is an off-chance that the scheduled timeout will fire after the containing component unmounts but before the timer gets disposed.

Calling `setState` after unmounting was always a sign of broken assumptions in the code or some programming error and React has been warning about it. I was told though that this has been accounted for and the warning is being suppressed now - so it won't pop up for users if `setState` got called in that short timeframe. So at least that's OK.

I'm worried though that a disposed component can still cause an unwanted side-effect in a parent. One can imagine some scenarios where that would matter.

1. orchestrating animation - an unmounted component tells the parent to trigger some sort of animation. The reason why the animation should happen is owned by a child, but it's also based on an additional timer because the reason might become invalid if the user performs some invalidating action quickly enough. It's not obvious here that `useLayoutEffect` should be used here to achieve instant cleanup.
2. similar case: orchestrating some in-product tour, triggering tooltips, arrows, whatever in the parent. It becomes even less apparent that this should be `useLayoutEffect`-based to achieve instant clean up as this is not related to layout, even remotely. This is business logic.

I hope my concerns are not warranted and you could clear up them for me, but right now I'm worried a lot that this is such a small difference for most of the people and that's it's hard to spot in the code that this might become a source of many very subtle bugs. 

cc @gaearon @bvaughn ",,
19670,OPEN,Add documentation for views abstraction,Component: Scheduling Profiler; Resolution: Stale,2020-12-25 14:06:54 +0000 UTC,kartikcho,,"https://github.com/MLH-Fellowship/scheduling-profiler-prototype/pull/80 implemented a views abstraction for the Scheduling Profiler. Although the PR description is reasonably comprehensive, it needs clearer documentation for future contributors.

These blogs written by @taneliang explain the design and implementation in detail. We should port these to a MD file as discussed with @bvaughn.

- https://blog.eliangtan.com/view-framework-1/
- https://blog.eliangtan.com/view-framework-2/",,
19669,OPEN,Show User Timing measures in the Scheduling Profiler UI,Component: Scheduling Profiler; Resolution: Stale,2020-12-25 14:06:55 +0000 UTC,kartikcho,,"Follows up from https://github.com/MLH-Fellowship/scheduling-profiler-prototype/issues/72, which implemented User Timing marks but not measures.

We should also highlight a User Timing measure's marks together when one is hovered
This is a similar idea to https://github.com/MLH-Fellowship/scheduling-profiler-prototype/issues/44. When a measure's start/end mark is hovered over, we can highlight its corresponding mark.

### Iteration 1: Highlight a User Timing measure's marks together when one is hovered

#### Steps

There are multiple ways to implement this; the easiest way will be to implement something similar to suspense wakeable IDs ([more context](https://github.com/MLH-Fellowship/scheduling-profiler-prototype/issues/44)), so that we can reuse the rendering logic.

- [ ] Modify types with a measure ID.
- [ ] Update `preprocessData` to process User Timing measures.
- [ ] Update `renderCanvas` to highlight related marks.

#### Acceptance Criteria

- When a custom User Timing mark is moused over, all User Timing marks with the same `id` should be highlighted.
- No Flow errors in affected code.

### Iteration 2: Display User Timing measures

This is trickier than the above iteration, as this requires a variable number of rows (or 1 variable-height row) whereas the above only require a fixed-height row.

The end result should be something similar to a combination of our React measures and the Chrome Performance tab's Timings section (screenshot below).

![image](https://user-images.githubusercontent.com/12784593/88007975-b9476c80-cb41-11ea-9177-0fa483886f86.png)

##### Acceptance Criteria

- If no User Timing measures are present, there should be no change in the UI.
- Custom User Timing measures should appear as bars in a new canvas section.
- Custom User Timing measures should not overlap.
- Measures should be ordered roughly similar to how Chrome orders them.
- Hovering over the User Timing measures should display a tooltip with more information such as the measure's name, start time, and duration.
- Hovering over other items onscreen should not be broken.
- No Flow errors in affected code.",,
19668,OPEN,Show React version in Scheduling Profiler UI,Component: Scheduling Profiler; Resolution: Stale,2020-12-25 14:06:56 +0000 UTC,kartikcho,,"

Display React version in the profiler UI somewhere. 

React version mark was added to profiling in #19553 

**Related:** The idea to display lane labels has been put on hold as discussed in the [original issue.](https://github.com/MLH-Fellowship/scheduling-profiler-prototype/issues/73)",,
19667,OPEN,Normalize panning across browsers in the Scheduling Profiler,Component: Scheduling Profiler; Resolution: Stale,2020-12-25 14:06:57 +0000 UTC,kartikcho,,"Pan behavior differs in different situations:

* Safari on macOS on a Retina display: pans at about half the speed of Firefox/Chrome
* Chrome when zoomed in: pans faster than the mouse",,
19666,OPEN,Add an option to DevTools to enable double-logging,Type: Enhancement; good first issue (taken),2020-10-21 03:55:26 +0000 UTC,gaearon,,"We currently plan to suppress double-logging in development by overriding console in 17: https://github.com/facebook/react/pull/18547

However this can be confusing for some scenarios and double logging may be preferable in them.

Ideally we'd add a toggle to DevTools that would allow to re-enable it on this screen:

![Ef3bFlWWoAARjz9](https://user-images.githubusercontent.com/810438/90825360-b7372000-e330-11ea-9128-803d35d27e07.png)

",,
19644,OPEN,Bug: react-hooks/exhaustive-deps does not recognize different signaturres,Status: Unconfirmed,2021-02-26 12:59:37 +0000 UTC,swissspidy,,"`eslint-plugin-react-hooks` version: 4.1.2

## Steps To Reproduce

The current `additionalHooks` in the react-hooks/exhaustive-deps eslint plugin accepts a regular expression to match hook names. It always assumes the following format:
 
```
function useCustomHook(callback, deps) {}
```

However, this format is not always convenient when other arguments are available in the hook's signature, because the set of dependencies could potentially be large. In those cases, it'd be more convenient to place callback and deps as the last two arguments. For instance, the standard `useImperativeHandle` has an additional first argument:

```
function useImperativeHandle(ref, callback, deps) {}
```

## The current behavior

The `react-hooks/exhaustive-deps` rule does not recognize hooks with a function signature as mentioned above.

## The expected behavior

The `react-hooks/exhaustive-deps` rule allows customization to specify the argument offset via the `additionalHooks` config option.

----

**Note:** A PR for this already exists at #18861. This issue is meant to increase visibility for it, and allow any additional discussion if necessary.
",,
19637,OPEN,Portal Event Bubbling Use Cases,Type: Discussion,2021-04-01 15:43:48 +0000 UTC,gaearon,,"This is a spillover from https://github.com/facebook/react/issues/11387.

The goal of this issue is **not** to argue about whether the current React's behavior makes sense in all situations. Rather, it is **collect a list of use cases, both when the current behavior works well, and when it doesn't**, so that they can inform the next iteration of the related APIs. We can't commit to any concrete timeframe on this at the moment, but a list like this will definitely reduce the amount of time that we'd need to spend to get up to speed on the problem space when we're ready to approach it.

If you'd like to contribute a use case, please comment with:

- A name for your pattern (come up with something unique so we can refer to it later)
- A brief description of the UI (but a screenshot is worth a thousand words)
- A small CodeSandbox demo, if you want to make a stronger case
- How React event bubbling behavior breaks (or helps) your case
  - Include any information about other pitfalls you encountered, be very specific
- A workaround you are currently using, if any
  - If you tried some workarounds but they cause issues, let us know which ones

Please keep this thread on topic and let's keep general discussion in https://github.com/facebook/react/issues/11387. This is not a good thread for ""+1"" or requests to solve this faster — it's a thread for gathering research.

Thank you!",,
19611,OPEN,Bug: click event is attached to createPortal,Component: DOM; Resolution: Needs More Information; Type: Discussion,2020-08-17 07:17:09 +0000 UTC,615349,,"
use createPortal will have click event attached to the DOM element automatically

```
import { createPortal } from ""react-dom"";

const Modal = ({ children, onClose, open }) =>
  open &&
  createPortal(
    <div />,
    document.getElementById(""modal"")
  );
```

this snippet will add click event attached to the element with id = modal
please open chrome dev tool to check

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://codesandbox.io/s/vibrant-kowalevski-7ginb?file=/src/App.js
<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
click event is added on the element

## The expected behavior
click event should not be added


## EDIT
------------------------------------------------------------
```
createPortal(
    <h1>This is heading</h1>,
    document.getElementById(""modal"")
  );
```
The header is read by **jaws** (not sure about nvda) as
**this is heading, heading level one, clickable**",,
19602,OPEN,"Error: ""getCommitTree(): Unable to reconstruct tree for root ""1"" and commit 21""",Component: Developer Tools; Type: Bug,2020-08-31 15:32:54 +0000 UTC,bhumijgupta,,"Describe what you were doing when the bug occurred:
1. I was going through the profiler result to check each render and what triggered each render

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.8.2-fed4ae024

Call stack: at getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:17728:9)
    at ProfilingCache.getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:18265:14)
    at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:31718:33)
    at vh (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:11067:7)
    at fi (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:11733:7)
    at ck (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:14430:86)
    at bk (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13779:11)
    at ak (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13768:5)
    at Sj (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13750:7)
    at Mj (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:13351:105)

Component stack: at CommitFlamegraphAutoSizer (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:31701:48)
    at div
    at div
    at div
    at SettingsModalContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:26139:23)
    at Profiler_Profiler (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:33363:48)
    at ErrorBoundary (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:27172:5)
    at PortaledContent (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:27303:32)
    at div
    at div
    at ProfilerContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:30463:23)
    at TreeContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:22538:23)
    at SettingsContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:23040:27)
    at ModalDialogContextController (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:28328:23)
    at DevTools_DevTools (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:33797:21)",,
19589,OPEN,Bug: SVG foreignObject misplaced on browser zoom in React app,Component: Developer Tools; Type: Bug,2020-11-10 04:47:54 +0000 UTC,maazadeeb,,"
1. Hover over the red circle in the codesandbox. Notice that the Popover comes up above the circle
2. Now, use `CMD/Ctrl` + `+` to zoom the sandbox. Notice how the Popover is displaced
3. Find the red circle in the browser devtools and the React devtools and notice the difference in the position of the red circle. Interestingly enough, the Popover seems to render at the position that the React devtools show it

Note: Refreshing the page after zooming does not solve the problem.
Note: The problem is reproducible without the `antd` Popover as well, but it's hard to notice visually as nothing looks misplaced

### Browser devtools

![Browser devtools](https://i.stack.imgur.com/yFLqS.png)

### React devtools

![React devtools](https://i.stack.imgur.com/Pvl2z.png)

I found this problem when trying to add a popover to a [custom node](https://danielcaldas.github.io/react-d3-graph/docs/#node-view-generator) in [react-d3-graph](https://danielcaldas.github.io/react-d3-graph/). I've removed all other dependencies in order to create this minimal reproducible example.

I asked this on [SO](https://stackoverflow.com/q/62622105/2950032) and after receiving no response and no success in solving it myself, decided to report it here.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: [Sandbox](https://codesandbox.io/s/nameless-sunset-ld78l) and [running app](https://ld78l.csb.app/) from the sandbox

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

The `foreignObject` is misplaced on zoom

## The expected behavior

I would expect that the `foreignObject` gets a proper position, in sync with the DOM's position
",,
19587,OPEN,DOM attribute stringification fixes,Type: Feature Request,2020-12-28 09:31:40 +0000 UTC,koto,,"This is regarding the discussion in #17773. 

React-DOM currently stringifies DOM attribute values  before passing them to `Element.setAttribute(NS)` functions. This might be unnecessary, as these functions implicitly stringify attribute values on their own (WebIDL attributes typed as `DOMString`). It also makes it difficult to enforce [Trusted Types](https://w3c.github.io/webappsec-trusted-types/dist/spec/) in React applications, as the trusted type objects would be stringified before values reach the DOM sinks.

Currently there is a `enableTrustedTypesIntegration` feature flag to disable stringification, but it seems like this behavior can be safely removed for modern browsers with no backwards-compatibility problems. Let me explain:

Attribute stringification was introduced in https://github.com/facebook/react/commit/b0455f46709fca94da0b6126b719d6dd07605e65, at that time to workaround a [**jsdom**](https://github.com/jsdom/jsdom) limitation (jsdom's DOM emulation didn't stringify on its own). **IE 8/9** [have a similar issue](https://github.com/facebook/react/commit/3b94abcb3b2c05fc38406b02a501427e58377c44). If an object is passed to a DOM attribute, its value becomes `[object]`, ignoring any stringification rules defined in objects' `toString` function.

- Jsdom does not have the issue anymore. Since at least 4.0.0 its `setAttribute` function does stringify the values via its IDL layer ([runkit demo](https://runkit.com/kkotowicz/jsdom-setattribute)).
- React doesn't support IE 8 anymore.
- The issue still exists for IE9 (contrary to https://github.com/facebook/react/issues/11735, my tests confirm that the bug still exists, but one needs to try a standard attribute, like `p.title`, and not one with a custom name).
- All other browsers, even in their old versions (I tested IEs, Firefox, Chrome, Safari, Opera and a few mobile browsers ) correctly stringify.

I propose to remove the stringification (similar to https://github.com/facebook/react/pull/17774) unless a browser bug is detected. 

That way there is no spurious stringification, and the code branches with the workaround can be removed once buggy browsers stop being supported. My testing shows that only IE9 is affected. The change would be backwards-compatible. I'll send a PR with the proposed change.",,
19570,OPEN,Bug: onInput is not firing on contentEditable div in IE11,Resolution: Stale; Status: Unconfirmed,2020-12-25 14:07:09 +0000 UTC,cy6eria,,"When using onInput event on contentEditable div, the event is not being fired on IE11. It does work on Chrome 84.0.4147.105 (64-bit).

React version: 16.13.1

I can't find any service which supports IE, thats why I provide only code example.

Code example:

```
const MessageBox = () => {
  const [state, setState] = useState('');
  
  const handleInput = useCallback((e) => {
    setState(e.currentTarget.innerHTML);
  }, []);

  return (
    <div
        role=""textbox""
        tabIndex={0}
        contentEditable
        onInput={handleInput}
      />
  );
};
```",,
19541,OPEN,Bug: Context doesn't work when exported from a package with multiple entrypoints,Status: Unconfirmed,2021-04-06 19:24:56 +0000 UTC,ROODAY,,"React version: **^16.13.1**

I had some code in my React app that handled loading Firebase and getting an AuthUser. Both the Firebase object and the AuthUser object were stored in their own contexts so they could be used throughout my app, and this worked fine. I then wanted to abstract this functionality into a component library so that I could reuse it easily between projects, and that's where this issue cropped up. I made my library using Neutrino,js since it was recommended on the React docs site, and the ""react-components"" preset for making component libraries creates a separate entrypoint for every file/directory in `src/components`. 

So in my case, my build directory contained `Firebase.js` and `Session.js`, each of which exported their respective context, However, importing these contexts back into my original React app wouldn't work, as any changes to the value in the context provider (inside the library) would not propagate to the context consumers (outside the library/in my app). I confirmed this by checking the Component tree in dev tools (screenshots [here](https://stackoverflow.com/questions/63267934/react-context-from-library-not-updating-in-consumer)).

I eventually got around this issue by following [this answer](https://stackoverflow.com/a/60655639/3325942) from SO. Basically just make an index.js that imports/re-exports everything so that it's all considered one module. This made it work, but now my imports went from
```
import AuthuserContext, {withAuthentication} from ""my-library/Session"";
import Firebase, {withFirebase} from ""my-library/Firebase"";
```
to
```
import {AuthuserContext, withAuthentication, Firebase, withFirebase} from ""my-library"";
```
which feels a lot messier. Is there a fix for this or is this expected behavior for Contexts? And if so, can that change in the future?

## Steps To Reproduce

1. Bootstrap a Neutrino.js react-components preset.
2. Create a file that exports a context and updates the value asynchronously (in my case loads firebase, but you could probably even do a setTimeout).
3. Create a file that uses that contexts provider.
4. Create an HOC that wraps an element with contexts consumer.
5. Build the Neutrino.js project and import the HOC into another project and wrap a component with it. Notice that the consumer won't ever update.

The buggy context code is available on [this commit](https://github.com/BUUPE/React-Components/tree/a34cfd58c00dface71031c3ba551cc778c1b8e83) of my component library.

## The current behavior
Context can be used within the module/library it was defined in, but consumers won't update if they are defined outside the library.

## The expected behavior
Context would update anywhere the consumer is,",,
19537,OPEN,Bug: Overwriting console.log during rendering,Type: Discussion,2020-10-19 03:56:45 +0000 UTC,Jack-Works,,"```jsx
function App() {
  return <h1 onClick={console.log}>h1</h1>;
  // console.log is replaced by ""disableLog"" so I can't log any event.
  return <h1 onClick={x => console.log(x)}>h1</h1>;
  // have to do this
}
```

Previous discussion at https://github.com/facebook/react/pull/15894#issuecomment-668542243
",,
19491,OPEN,Memory leak after component unload,Resolution: Stale,2020-12-25 14:07:12 +0000 UTC,rocky-one,,"React version: 16.13.1

Description
Data passed by props after uninstalling a component is still referenced and not GC.

```
import React from 'react';
class App extends React.Component {
  state = {
    show: false,
    userObj: {
      arr: []
    }
  }
  onClick = () => {
    let show = !this.state.show
    let arr = []
    if (show) {
      for (let i = 0; i < 100000; i++) {
        arr.push({
          name: `rocky_${i}`
        })
      }
    }
    this.setState({
      show,
      userObj: {
        arr
      }
    })
  }
  render() {
    return (
      <div className=""App"">
        <div>
          <button onClick={this.onClick} style={{margin: '10px'}}>
            {this.state.show ? 'uninstall components' : 'install components'}
          </button>
        </div>
        {this.state.show && <Test userObj={this.state.userObj}></Test>}
      </div>
    )
  }
}

class Test extends React.Component {
  render() {
    return (
      <div style={{width: '200px', height: '100px', border: '1px solid #ccc', margin: '10px'}}>
        I am a test component
      </div>
    )
  }
}

export default App;
```
**1. component not installed**
![image](https://user-images.githubusercontent.com/26345259/88901082-e81cbb80-d282-11ea-8719-50334a4c7e57.png)


**2. after installation of components**
![image](https://user-images.githubusercontent.com/26345259/88901263-2c0fc080-d283-11ea-84d0-9daacc3426b2.png)


**3.component unloaded**
![image](https://user-images.githubusercontent.com/26345259/88901447-5feae600-d283-11ea-84e7-5eb9fb362311.png)

[The sample code is here](https://codesandbox.io/s/tender-dewdney-l5zcs?file=/src/App.js)

**I understand that component unloaded memory should return to the original 4.6MB, but component unloaded memory is still 8.8MB. Is this a memory leak? I am a novice still ask grant instruction, thank!**

",,
19482,OPEN,Bug: the order of effect and cleanup in Parent and Child component is weird,Status: Unconfirmed,2020-11-20 23:31:20 +0000 UTC,xialvjun,,"1. just as the code example shows: just click the button 6 times respectively and see the console

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://stackblitz.com/edit/react-effect-order-matters?file=index.js
<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
useEffect logs: `cpcc*1 + ppcc*n + pppc*1`
useLayoutEffect logs: `cpcp*(1+n) + cppc*1`

## The expected behavior
both useEffect and useLayoutEffect should log: `cppc*(1+n+1)`

## Why I need a stable effect and cleanup order
There is a vanilla js package `mapbox-gl` whose use case is:
```js
import mapboxgl from 'mapbox-gl';
var container = document.querySelector('#map');
var map = new mapboxgl.Map({ container });

map.on('load', function () {
  // every thing should be done after load
  map.addSource('route_source', route_source_data);
  map.addLayer({
    source: 'route_source',  // the layer relies on the source
    id: 'route_layer',
    ...other_layer_config,
  });
  // ...;
  do_many_things();
  // ...;
  // you must remove the layer before removing the source
  map.removeLayer('route_layer');
  map.removeSource('route_source');
});
```

Then I want to make a react version:
```jsx
var vdom = (
  <Map opts={x}>
    <Source opts={xx}>
      <Layer opts={xxx}></Layer>
    </Source>
  </Map>
)
```
 
But since the order of react effect and cleanup in parent and child component is not stable (well, it' stable but it's weird), things became complex.

I think the effect and cleanup order matters because there are dependency relations between parent and child components.

And react should handle it.

There are some related(maybe) issues:
https://github.com/facebook/react/issues/16728
https://github.com/facebook/react/issues/17080

And the react lifecycle order is works right: https://stackblitz.com/edit/react-lifecycle-effect-order-right?file=index.js",,
19476,OPEN,[eslint-plugin-react-hooks] Bug: rules-of-hooks false positive conditional call after foreach,Status: Unconfirmed,2020-11-16 22:41:40 +0000 UTC,likuilin,,"## Steps To Reproduce

1. Here is a minimal reproduction: 

```javascript
export default function App() {
  for (let a of []) {
    if (true) {
    } else {
    }
  }
  React.useState();
  return null;
}
```

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Sandbox link: https://codesandbox.io/s/elated-sunset-wguwp?file=/src/App.js

Removing the `else` block or the `for ... of` both cause the error to not present. 

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

ESLint throws a build-time error: `React Hook ""React.useState"" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return? (react-hooks/rules-of-hooks)`

## The expected behavior

There is no error because `React.useState` is not called conditionally.",,
19474,OPEN,Bug: Constraint Validation API not reflected on Textarea's value attribute change,Resolution: Stale; Status: Unconfirmed,2020-12-25 14:07:18 +0000 UTC,tdiluzio,,"Hi,

thank you very much for what you do and you've been doing so far.

I've been working on some form validations via the [Validation Constraints API](https://developer.mozilla.org/en-US/docs/Web/API/Constraint_validation) and I've noticed that `event.target.validity` read-only object doesn't get updated and is always valid although some constraints are set when the `value` attribute is set to the `Textarea`.

On the other hand, when `value` is passed as `children` `validity` gets updated as expected but I'm being warned to `Warning: Use the defaultValue or value props instead of setting children on <textarea>` 



React version: 16.13.1

## Steps To Reproduce
Here's how you can reproduce:

1. setup this basic _app_ component with one `Textarea` element, set some constraints and add the `value` attribute as you normally would on any form.

2. add another `Textarea` element but instead of passing value as an attribute pass it as `children` _see_ code below
```
import React, { useState } from 'react';

function App() {
  const [state, setState] = useState({
    first: '',
    second: '',
  });

  function handleTextChange({ target }) {
    const { name, value, validity } = target;

    setState({
      [name]: value,
    });

    console.log(`${name} validity:`, validity);
  }
  return (
    <div className=""App"">
      <textarea
        name=""first""
        placeholder=""First""
        value={state.first}
        onChange={handleTextChange}
        required={true}
        minLength={10}
      />

      <textarea
        name=""second""
        placeholder=""Second""
        onChange={handleTextChange}
        required={true}
        minLength={10}
      >
        {state.second}
      </textarea>
    </div>
  );
}

export default App;
```
   
2. Open your console
3. Type at least one character into the first `Textarea` _see_ screenshot
![Capture d’écran 2020-07-28 à 15 43 33](https://user-images.githubusercontent.com/8101889/88674309-f2f01880-d0e9-11ea-944b-a524b39fd749.png)

4. Type at least one character into the second `Textarea` _see_ screenshot
![Capture d’écran 2020-07-28 à 15 44 02](https://user-images.githubusercontent.com/8101889/88674323-f71c3600-d0e9-11ea-9bc4-443f613ca491.png)

## The current behavior
You'll notice that the first `Textarea` ignores the validation constraints set

## The expected behavior
Validation constraints should be set and field should be invalid
<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

## Link to code example
Please find sample code at https://github.com/tdiluzio/react-dom-textarea-bug

## Demo
Here's the URL to the demo https://tdiluzio.github.io/react-dom-textarea-bug/

",,
19419,OPEN,Bug: MouseEnter does not fire when coming _from_ disabled elements,Component: DOM; Type: Bug,2021-04-02 19:00:52 +0000 UTC,jquense,,"https://codesandbox.io/s/eager-euler-c72fw?file=/src/App.js

1. move from a disabled element to an element with a `mouseenter` listener.
2. `mouseenter` does not fire

Link to code example: https://codesandbox.io/s/eager-euler-c72fw?file=/src/App.js


## The current behavior

`mouseenter` does not fire because React calculates mouseenter/leave based on the relative element of the opposing event.
e.g. `mouseenter` calculated from the `mouseout` on the button. Browsers do not fire pointer events on disabled elements


## The expected behavior

`mouseenter` should fire


Previous issue: https://github.com/facebook/react/issues/4251",,
19416,OPEN,Should act() warnings be deduplicated by component stack?,Component: Reconciler; Type: Discussion,2020-10-27 08:18:24 +0000 UTC,eps1lon,,"React version: `16.13.1` (latest) and `0.0.0-7f28234f8` (next)

## Steps To Reproduce

1. Create component that has multiple effects (i.e. `useEffect` calls)
2. Render component in a jest test


Link to code example: https://codesandbox.io/s/long-sound-xhe5w?file=/package.json

## The current behavior

A error is logged for each call of `useEffect`.

## The expected behavior

An error per component calling `useEffect`.

## Context

Current errror:
```
Warning: An update to Component ran an effect, but was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://fb.me/react-wrap-tests-with-act
    at Component (https://xhe5w.csb.app/src/index.test.js:23:20)
    at App (https://xhe5w.csb.app/src/index.test.js:35:20)
```

The prescription is to wrap the update in act(). The warning may be unintented because a component with an effect rendered unexpectedly. But due to the rules of hooks it's unlikely that we remove a `useEffect` call: It's easier to prevent rendering a component (wrong branch logic, return early etc) than preventing an effect (which requires moving it to a component we render conditionally).

From my experience most of these cases come down to adding an `act()` and not changing component implementation. In these cases firing errors for each effect makes the console output unreadable. Especially if you compose custom hooks and end up with 4+ effects per component.

An alternate solution would be to only fire an error if the effect was actually scheduled (see #19318).
",,
19406,OPEN,Bug: Updates to keyed lists break FLIP animations when they occur mid-animation,Status: Unconfirmed,2021-02-14 11:06:50 +0000 UTC,isiahmeadows,,"1. Open code example below
2. Observe animation

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

[Flems](https://flems.io/#0=N4Igxg9gdgzhA2BTEAucD4EMAONEBMQAaEAMwEskZUBtUKTAW2TQDoALAF0fmPSk6IBqEAB4ARgFdOnaAAJy+ALwAdELIDmGpGoB8AFQhakogPRSZ0XSqij85AG5yYnAJ5JVIezGxZXKUiQADz0bOTlRSXgFZTVsACdEBz1ReHJdAAYzNN1U9IBGbPS83QAmItycgGYKkoAWWpyAVkb0gDZW3QB2WtMo6yhwyOjFT0wockZMQRS++AGhqJjPKEQgzhScrNMcksKd4pzyg8r0mpP6zpaLnI6b9J6LuYGzewddPjwkME5yaGo0BkUBkALRNFBtEAAXyI9CYLBArAAVtQSJABEJOCJ0S45ONJtNEAAlCAQThyJRyfAQMCSZgCVgaRCcACiSHpnAAQq4AJL4AAUanxUxmIAAlDYkOSHJh4JJEDAKXIAILxeKYVysUjxCCMfnAJBQDScdgoOQADhhcn5AH0iAoxRTdA6bDZSJIoD8-oNElB8Ih4vzHcAwnIiYhMD8ACIAeQAsqxff7A6HwjK5QrWFNsPzyE6wxGfqwwIlCWzEBzBSA0mp7cAANaIfwKK3kMVioipvETEXE0kbQZyCVQKGuqBShQY+LppV4Tj6SaICDSfmSbD4QmciD4Vz2poZDLDt0er3yNcbwRbndBuQhwfkKczylzhfMZecVfrzfb3dyfeH0McXJBIkiVdN5RgUNTFMOQuE4XAUGgoRWAAd3IetyGwAhyEwVgIHiDRTDQjDTAAMXIGB2ADABSFlSmo80MmogBOKoAE1CRgG1KMkUhAkQQD-nJVZ1jA2UIKVECHFYGA0jARAg1DUh8OtCc80pETOFYQ1jXYOQQTkfIAG4FDkZ0MhM8gQRBYMuyAuQkSVONpnYLV4FJQNnJNRNxmpPVHQAKmtPMAGpDPbOyhLkQRGGwJVNJoJEAF0uwS5L4rWTgaHIFLB3CBKcqVGLsFDUcoFDRIAEcIM4ZUe2mb1SPVZh+RvJRnTvcJwnsqSABkKPJSlqVpDlGWZcsOW5PkqyktQxWLdhKHwAA5bcFUi2BhMy-rcSGmk6UxMbWXZTEpoFNRNLmhaltW-1IPKvK5Gggt8OTOREBOgRFQfORYzjLtlPiVTmVMykLNM0Q5Ck7ShF0yyQpC2zHvCPqBuypLWEEdYAGFoEEARJMSBx0a7MqurkQHgfJdS5HBvNIc0mGjRNeHEdvLt8u2tGcsxzLcYxAmNMyknHrKjbcSkibFUpVV1U1bVdX5YVCRJMlrvgFa1pgYdya7Z7yPiFxxfJChDc4AAFTBfUG7sCUEVWtKZLllz9B8NGxtJMXDH5FMe+zTd2qGialrMcH5RB8068m5HssBFo1pVECOrcPXsI0PfIL3EB9nXo8SThJHiQYo+j6KIGwM046WzHy-0inyDNy3rZr7BO2RrqkFIThK-j-AYa7uuA4tq3Ds7zg29LsmuqhI9HqTANfb1mDeswXEwp5KAHADAdyfsrAXCbzElWV+3+2Tl20-dz2BG9j9c+6qLGAgLf8ClwmkhDih4EEQNw-tNtI4cxjlFfeNsk5OxTq7dO19OC319qXey+AghKiHujfu5IDL8lAeguuoDD4MjHvfLqiDXAoIbi4NBsg4qYOwVQ3Bq9h7NyoUQ8I5BSDWiQRSJQYM5AADJeFUlIdwsGjp86F0GKQWUeAgFJxcO4JOnB1SwEBowJUAADRR4xZKEn5AAEmAEgqE2AghEH0TuIxQQxRqJkTJNwSBMZKJgOQX40AoyFwavISkagMiQRAEAsRRdorxHlKTWe5N9b4XknIRIII-Dvi7MNA6DJxA-jwnxOcAAJRA5ANBcDHOEmC5s-Bdifi-T++EWSRnYK1RA-9HTtXZu3WOsp4DiEjPWJUbUOpAPCEnRIpTEAsi3gIHa+MF5qE0bAZx3ohD4FrDHFpbSwD1ntJI+AeAWFdSTmAfeMBRmJgrM-BSEzHHTOgHNIBU9ybbN2fszA+BzrqFOS48q4obH3NfsMzgoyhDjKeVos5qw-TzLAIs9pqypGIE2bIuxCjHEqMTrY+RDiAUvLceqF5SoADkWLQmlWHGLP0+1RpOwmqdXkAosWaG0IgLF81oA7PIMszp9Tun3nYbmR8soka7yQFbV8S4VwPh-umIhwqAxPjkFAKI8BSrvXWRHEuchzzfmvLnKeOYqVGBpVi-+XLogAEINIyoJWOeegYxR8EgLFSgAZUDSvgPAGEcJmAiGLDAVE-B8ZYjYJMpxmKo5+sBWaUoio-UqKMjYKEnwPrZxeQCEA+QUD5CaNCJKJA0hQHrACOgIAGCurQKWIs-ot7uWwKNFEfBC68DQHBBC0EPTYHrBoYsupTBFs4AAAXyG0Vg+Qqh9r6IwfA7bCxaRLR9cuFbPVuCwiIGAJZMJYmdXm+EIgO0gj8qwCdZbp1VviDWkAdaYCIT6FAJtLbrWjsjJwTdupu29v7YOukI6N1bp3VOw6laSCzoRAu+IS601QiAA)

## The current behavior
Animations are choppy

## The expected behavior
Animations are smooth like in [this example](https://flems.io/#0=N4Igxg9gdgzhA2BTEAucD4EMAONEBMQAaEAMwEskZUBtUKTAW2TQDoALAF0fmPSk6IBqEAB4ARgFdOnaAAJy+ALwAdELIDmGpGoB8AFQhakogPRSZ0XSqij85AG5yYnAJ5JVIezGxZXKUiQADz0bOTlRSXgFZTVsACdEBz1ReHJdAAYzNN1U9IBGbPS83QAmItycgGYKkoAWWpyAVkb0gDZW3QB2WtMo6yhwyOjFT0wockZMQRScrNMcksKF4pzylcr0mo36zpadnI6D9J6dvvgBoaiYzyhEIM5Z9PnFnOXX9PWP3W3vhuPdPtvkdvqdFucBmZ7A5dHw8EgwJxyNBqGgqih8hk6iAAL5EehMFggVgAK2oJEgAiEnBElJccnGk2miAAShAIJw5Eo5PgIGBJMwBKwNIhOABRJCCzgAIVcAEl8AAKNSMqYzEAAShsSE5YEwYHYBAliEYMC5cgAgvF4phXKxSPEIIxFarmWyOawDZR8AA5CD4RAwLVQHUKKnxByYaLcvCcfSTRAQaSKyTYfDM6X+1xEORNDIZYM2UiSKCI5GDRJQAPxRUauTAMJyUgQeJyRV0zmISVyCCkOR6g1GyVBhkTNWs9mcVg4bBCfAAYXY3sVXZNwZxNiLJbL8lT6cEmfwrlr9cb5HDkejzlF8eYSc4KbTGazObzBc3g37KM5CSSxtN5oDoa+D-jAjYdnIdwPKBgH6sBMHcr+DigawMBpGAiC1o2pimHIXCcLgKA4UIrAAO7kAA1uQs72JgrAthopjkVRpgAGLkDAhrxAApGKpTcQAHBk3EAJxVAAmsyMAAPqcZIpCBIgjbNq2iqhuQ5pQeKw6sEgUAaJw7ByAAtHI+QANwKHIuhyBklnkMZxl1g2n7hBBJLmgAstM7D2vA7I1t5hmsDaVZOieABUbYaQA1GZGrBuEbnfnIgiMNgmn3NpJowDQJIALqNuEWmgXl+WZdBw40OQhWuZBWWlTV5ppdgjYblAjaJAAjpIgacBaY7TOWrE2swionkoNkuUlX6wD+iQOAAMhxnLcry-JSsKor-tSsoKsqIBIWoGqeku8C+v6gZFbN9Jact9JrXyArUlt2VSntSpqFpx2nd6foBmBHV1Thcgsom8TVnIq5Sma55yAAIgA8p510qW26nmnZVmiHISEoXpBnsPZMUxc513hEh92cNV+WsIIDzztAggCOaeNVTVdNZYzVICNd7Woy26OilZ3JYxpOMlTpBOGcTpOnnVxVZVTNOcwzTPUhVb25Rz9OcNzzOPHV-PA7h7HxC410QRQ5ucAACpglaraOTKCO6U4ijKSZVueGjzmk1Jg4iWF1Vb5A26zC0oVM2ArlyU3kzdupnfg5qIK9mYlvY+l++QAeIEHiUzXIiScJI8SDNNRfhLI2AoP2yd0xAGWmdbLj247jfYEQCfhEgpCcHXXrnbpiD9yZTZh23DsvX3nDdwrcjtTNOKFnVlbVsH10g4tmD0nFcpQA4iDxIbM0QVgU+O+arqu5O6de1nvv+wIgcPoXyVzXIjAQEfIHDhHf4dIUHgIIGsK4czkDrJNeWVdz67ydmnD2GdvbZ2fpwV+wdYEpXwEEc0rdqYc1nuPNS8CR5j1MhfO208hSz3fklCCR48GTwIbTGuxDKGd3HpQ9uL0a50PCOQPsiocFciUKLOQAAyCRPJXCiNFnWEuZdBikCjHgBOacXDuDTpwUKMAVKMHNAAAx0eMNCzJFQABJgA4JxNgIIRArFHlsUEDUhj1GoTcEgOmujyBImgPDMuQ15DcjUBkMCIAE6KPLqleIvU+arxmiDViLYMLF0QMZPw95rrrWekKcQWZ6IKVjAACUQOQDQXAPyJNwrbPw11v6-xQipMUcFxqIAgVA+OC8IJ6ngPAcQ+oKLmgml0qu4Q06JAaYgMUR8BBUyEMfA6JjYC+PLHONQOZen9MGTmFR8A8D8KSmnMAF8YBUxCiaH+mE1DLJgKs6Ax0E5LyLsc055zMD4E+uoHxfiOqancR8kCszODzLuDWG5Py1lVg2f2KM2ywAUV2aoxAhyNGeO0bo-RqcPFaO8aY+5UAAk2l+eaAA5KS+JbV1wfhBgAVSRGkNwchxC+MBjkzaHsdoCA+oqUlmhtCIFJSdaAJzyAIuGZ0mBCghHnlAZeMmIckAO1vImZMsrj7yuuuqiMUZNJRHgG1KG+zEBSvCHuZ8R5MGL0bDHPlRgBWkogReXVABCbkUB9XUqBuvRZwY+CQHSpQY+IgBniC7LifEIAGDMBEJ6GA5J+AG1jbcglUqU2-LrqUM0tz9HmRsDiOEq4dywBEPkDETRcT5RxEAA)

-----

Context: this bug is far from unique to React: https://twitter.com/isiahmeadows1/status/1284726730574315522

**Edit:** Also relevant: https://github.com/whatwg/html/issues/5742",,
19404,OPEN,Bug: firefox 'select all' menu item not firing select events on textareas,Resolution: Stale; Status: Unconfirmed,2020-12-25 14:06:58 +0000 UTC,jedierikb,,"React version: 16.3.1
Firefox version: 78.0.2 (OSX 10.15.5)

## Steps To Reproduce

Make a `textarea` (with some text) and listen for select events ( `onSelect={ ...}` ).
Use the firefox browser's 'select all' menu item (not the keyboard shortcut) to expand your selection area.

Link to code example:
https://codepen.io/jedierikb/pen/pogQVLo

## The current behavior
Firefox browser's 'select all' menu item (not the keyboard shortcut) does not fire a `select` event.

## The expected behavior
Firefox browser's 'select all' menu item should fire a `select` event on textareas.
Works in Chrome and Safari.
Also works in Firefox with an ordinary event listener.  See https://developer.mozilla.org/en-US/docs/Web/API/Element/select_event
",,
19371,OPEN,Setup CI infra to run DevTools tests against multiple React versions,Component: Build Infrastructure; Component: Developer Tools; good first issue,2021-04-01 19:48:41 +0000 UTC,bvaughn,,"PR #19108 caused some Suspense-related DevTools regressions (more info available on #19368) which we did not catch because of the fact that DevTools tests are only run against the version of React in master.

We should follow the precedent of the [regression fixtures tests](https://github.com/facebook/react/tree/master/fixtures/devtools/regression) and have CI run DevTools tests against multiple React versions, including v15, all v16 minors, and the current HEAD of master branch.

Setting this up will involve several things:
* Infra to checkout older React packages and run tests against them.
* Some form of gating so that we can account for expected differences in Store snapshots between React versions.
* Some form of gating so that we can avoid running tests against invalid combinations of features and versions (e.g. don't test for `Suspense` in a version of React that didn't include that component yet).",,
19318,OPEN,Bug: act warning misleading if an effect wasn't run,Component: Reconciler; Type: Discussion,2021-02-12 07:45:30 +0000 UTC,eps1lon,,"
React version: 16.13.1 and `next`

## Steps To Reproduce

1. Re-render a component where an effect wasn't run because dependencies didn't change
2. Receive missing act warning


Link to code example: https://codesandbox.io/s/missing-act-on-every-effect-ldy3b?file=/src/index.test.js

## The current behavior

React creates warnings for each call of React.useEffect regardless of whether an effect was actually scheduled i.e. the effect was run.

## The expected behavior

If it is impossible for an effect to be run I shouldn't have to wrap it in act. Changing the behavior would help identifying what effects were unexpectedly scheduled. Right now we receive warnings for effects that are unrelated to a specific update.

I consider the current warning misleading and unnecessary because the [documentation](https://reactjs.org/docs/testing-recipes.html#act) talks about ""all updates related to these “units”"" which is not the case here in my opinion. The act warning says ""When testing, code that causes React state updates should be wrapped into act(...):"" which also doesn't apply here: The code in question could not cause a state update from an effect.
",,
19246,OPEN,Bug: missing interactions in profiler,Component: Developer Tools; Status: Unconfirmed,2020-12-25 15:42:20 +0000 UTC,OliverJAsh,,"There's a few things involved here, so it's hard to describe the exact steps, but here's a reduced test case:

- Code https://stackblitz.com/edit/react-profiler-missing-interactions?file=index.tsx
- Run the code https://react-profiler-missing-interactions.stackblitz.io/

The test case has a parent and child component, both of which are dispatching an action to Redux and subscribing to Redux state. Each action dispatch is wrapped in `unstable_trace`.

Note I did try to reduce the test case further to see if I could reproduce without Redux and React Redux, but to no avail. However, due to the fact that the state updates occur—we're just missing the interactions—I believe this problem is not due to either of those libraries.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

Both state updates apply (parent _and_ child), but the profiler only seems to capture the interactions for the child, not the parent. The parent interaction is missing.

The test case is logging interactions to the console so you can verify there.

Here's a screenshot to show what I mean. I took this screenshot after using the profiler's ""reload and start profiling"" feature:

![image](https://user-images.githubusercontent.com/921609/86485667-38226400-bd51-11ea-9ac4-4d216bc7d1dc.png)

## The expected behavior

No missing interactions

---

Potentially related: https://github.com/facebook/react/issues/15566",,
19219,OPEN,"Profiler dev tools suggestion: in ""ranked"" view; add a way to group/aggregate component instances",Component: Developer Tools; Type: Discussion,2020-07-06 19:54:50 +0000 UTC,OliverJAsh,,"(Deleted template as this is a suggestion, not a bug.)

In the profiler's ""ranked"" view, when there are many instances of a single component, there's no way to answer the question ""how much time did this component spend rendering _across all instances_.

For example, here I have a component called `PhotoLink` which is used in many places across the tree. The ""ranked"" view shows us that each render is very cheap, but it does not tell us the aggregate cost of this component.

Perhaps we could add something to dev tools to group/aggregate component instances?

![image](https://user-images.githubusercontent.com/921609/86143237-170d0980-baec-11ea-891e-636bbe73d3f5.png)
",,
19217,OPEN,Feature proposal(eslint-react-hooks): don't require empty dependency useCallback in another dependency array,Component: ESLint Rules; Type: Discussion,2020-07-27 16:51:20 +0000 UTC,georeith,,"Consider the following:

```js
  const [mouseDown, setMouseDown] = useState(false);
  const onMouseDown = useCallback(() => { 
    setMouseDown(true);
  }, []);
  const onMouseMove = useCallback(e => { /* ... */ }, []);
  const onMouseUp = useCallback(() => {
    setMouseDown(false);
  }, []);
  useEffect(() => {
    if (mouseDown) {
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
      return () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      }
    }
  }, [mouseDown]);
```

Above the `useEffect()` will complain that it didn't receive `onMouseMove` and `onMouseUp` in its dependency array and it's correct. But it could be smarter, because they were all defined by `useCallback(() => {}, [])` meaning they will all remain the same value throughout the lifetime of this component.

Given this information I could write 
```js
  useEffect(() => {
    if (mouseDown) {
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
      return () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      }
    }
  }, [mouseDown, onMouseMove, onMouseUp]);
```
To satisfy the linter and that would work but only because I know they were defined by `useCallback(() => {}, [])`. If someone were to change the dependency array for `onMouseMove` or `onMouseUp` this would now break (the event listeners won't be removed and readded if `onMouseMove` changes for instance), but the linter will be happy.

However if I was able to specify it like I did in the first example it is the same as saying, this works as long as these specific variables don't change, if someone unwittingly changes the dependency array of `onMouseMove` the linter would shout at them again and they would have to rewrite this into something more flexible.

This is similar to the way `useCallback` doesn't complain about my usage of `setMouseDown` as it knows it can't change.",,
19177,OPEN,Bug: I want to confirm why the parameter of currentTime is missing in Line 68 of schedule.js source code.,Resolution: Stale; Status: Unconfirmed,2020-12-25 13:08:10 +0000 UTC,ABCDdouyaer,,"React@16.13.1 source code
Parameter of currentTime is necessary for the function of handleTimeout. However, this parameter is not inputted under compatibility conditions.

```
 requestHostTimeout = function (cb, ms) {
    _timeoutID = setTimeout(cb, ms);
  };
```


```
requestHostTimeout(handleTimeout, startTime - currentTime);
```

```
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  advanceTimers(currentTime);

  if (!isHostCallbackScheduled) {
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    } else {
      var firstTimer = peek(timerQueue);

      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}
```",,
19162,OPEN,Hiding MUI Components inside React Developer Tools,Component: Developer Tools; Type: Discussion,2020-09-10 18:14:17 +0000 UTC,samuelhulla,,"Hello, recently we've overhauled a client's website with the usage of [Material UI](https://material-ui.com/). It's been an enjoyable experience, however one thing that really irks me - given the project is pretty large and there's multiple people working on it, sometimes it gets chaotic which component is exactly what and you need to find out which component you should be working on.

My general fallback was using the [React Develeloper Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) extension, however given MUI consists of ready-made JSX components, it essentially spams and halts the usefulness of the 'Components' tab.

![image](https://user-images.githubusercontent.com/17268815/85140844-25cf0300-b246-11ea-98ec-e0d37aea2707.png)

Is there perhaps any way that would allow for filtering of specific packages / jsx elements inside the React Developer Tools?

I know I could technically user regex to filter out a list of all the known MUI Components, but that seems bit overkill.  I sadly suspect such a thing is not supported, but you never know unless you ask.
",,
19150,OPEN,Proposition about onInput/onChange,Resolution: Stale; Status: Unconfirmed,2020-12-26 20:19:06 +0000 UTC,mr21,,"Hi :)

In ReactDom we can find:

``` javascript
function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
	if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {
		return getInstIfValueChanged(targetInst);
	}
}
```

Why not adding an extra condition here like:
``` javascript
function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
	if ((!React.$$useRealOnChange && topLevelType === TOP_INPUT) || topLevelType === TOP_CHANGE) {
		return getInstIfValueChanged(targetInst);
	}
}
```

By checking `React.$$useRealOnChange` in this function, a user could add this line:
``` javascript
React.$$useRealOnChange = true;
```
anywhere in their code (before or after including ReactDom) to find back the more native behavior.

I'm sorry in advance if this proposition has already been proposed",,
19134,OPEN,Could you please rename master branch and remove any problematic references?,Type: Discussion,2020-06-23 20:13:06 +0000 UTC,,,"There are many people doing the same in light of BLM and deep racist history associated with words such as blacklist, whitelist, slave, master and many others which see wide use in CS and code.

There are many big projects doing the same - golang, rustlang, python.

Here is a note from github CEO - https://twitter.com/natfriedman/status/1271253144442253312

Could you please remove racism from code?

PS - Historical context for main - https://www.nakasendoway.com/the-japanese-family-system/

Please consider alternatives such as canary, develop or edge.",,
19131,OPEN,Bug: useState with ResizeObserver leaks React components on Safari 13.1,Resolution: Stale; Status: Unconfirmed,2020-12-25 14:07:06 +0000 UTC,luketmillar,,"_From what I can tell this only repros in Safari._
React version: 16.13.1
Safari : 13.1.1

### Description

Using the Safari dev tools, specifically the Graphics tab to track active canvas contexts, I noticed that Safari was infinitely collecting canvas contexts as React components mounted and unmounted. They were never garbage collected. After pairing back my use case I was able to narrow it to a very specific repro.

**If you have a React component that instantiates a ResizeObserver AND captures the result of React.useState, it will never get garbage collected.**

I'm not positive, but I assume that the full React component is leaking in these cases, although I can only see the canvas contexts leaking because that's what Safari devtools makes easy to see.

### Code

**Leak repro:**
If you mount and unmount this `SizedCanvas` component over and over the canvas contexts will leak.
```javascript
const LeakyResizeDetector = () => {
    const x = React.useState(false)

    React.useEffect(() => {
        const observer = new ResizeObserver(() => null)
        return () => observer.disconnect()
    }, [])

    return <div />
}

const SizedCanvas = () => {
  return <>
    <LeakyResizeDetector />
    <canvas ref={ref => ref && ref.getContext('2d')} />
  </>
}
```

**Clean repro:**
If you mount and unmount this `SizedCanvas` component over and over the canvas contexts will get garbage collected and you'll remain in a clean state.
```javascript
const CleanResizeDetector = () => {
    React.useState(false)

    React.useEffect(() => {
        const observer = new ResizeObserver(() => null)
        return () => observer.disconnect()
    }, [])

    return <div />
}

const SizedCanvas = () => {
  return <>
    <CleanResizeDetector />
    <canvas ref={ref => ref && ref.getContext('2d')} />
  </>
}
```

The only difference between these two examples is that the leaky component captures the result of the `useState` call. Other than that they are identical.

## The current behavior
Canvas contexts infinitely collect and never get garbage collected.

## The expected behavior
Canvas contexts get garbage collected as their React components get unmounted.
",,
19117,OPEN,Bug: rules-of-hooks ESLint rule not catching conditional hooks in React.memo() (Typescript),Status: Unconfirmed,2020-10-23 17:50:54 +0000 UTC,zachkirsch,,"I've noticed that the ""no conditional hooks"" aspect of the `rules-of-hooks` eslint rule isn't working inside a `React.memo()`'ed component. The project is typescript and I'm using the parse from `@typescript-eslint/parser`, so I'm not sure if the problem is with the rule or with the parser.

React version:

## Steps To Reproduce

1. Create a component using `React.memo()` inside a Typescript project
2. Add a hook that is called conditionally, e.g.
```typescript
export const MyMemoizedComponent = React.memo((props: {}) => {
  if (Math.random() > 0.5) {
    React.useEffect(() => {}, []);
  }
  return <div />;
});
```

Link to code example: https://codesandbox.io/s/no-rules-of-hooks-warning-in-typescript-reactmemo-ei00n?file=/src/index.tsx

## The current behavior

ESLint does not show any errors.

## The expected behavior

ESLint should show an error like `React Hook ""React.useEffect"" is called conditionally. React Hooks must be called in the exact same order in every component render.`",,
19078,OPEN,Bug: Form reset lost checkbox onChange event,Component: DOM; Type: Bug,2020-06-25 23:48:12 +0000 UTC,imagine10255,,"Hi, I use checkbox uncontrolled mode, onChange in form reset after, lose onChange.
```js
<input type=""checkbox"" onChange={onChange} />
```

but use add ref.addEventListener('change', onChange) is ok
```js
const checkRef = useRef<HTMLInputElement>();
useEffect(() => {
        if (checkboxRef) {
            checkboxRef.current.addEventListener('change', onChange);
        }
    }, []);

<input type=""checkbox"" ref=""checkboxRef"" onChange={onChange} />
```


React version: 16.13 and old 

## Steps To Reproduce

1. checkbox => checked
2. form reset
3. checked  => checked

Link to code example:
[not react is ok](https://codepen.io/imagine10255/pen/ExPaLOJ?editors=1111)
[reset is lose target onChange](https://codesandbox.io/s/affectionate-brook-96dw9?file=/src/App.js)

## The current behavior
1. checkbox => checked (target onChange)
2. form reset
3. checked  => checked (lose target onChange)

## The expected behavior
1. checkbox => checked (target onChange)
2. form reset
3. checked  => checked (target onChange)
",,
19056,OPEN,[eslint-plugin-react-hooks] Add whitelist for functions that are not to be considered as callbacks,Component: ESLint Rules; Status: Unconfirmed,2021-01-29 09:36:26 +0000 UTC,xaviergonz,,"I have a library to hook mobx with react: https://github.com/xaviergonz/mobx-react-component

Hooking is usually done via a wrapper method named ""mobxObserver"" and is used like this:

```ts
export const MyComponent = memo(
    mobxObserver(
        (props: IMyComponentProps) => {
          // React.useLayoutEffect(...) // will warn
        }
))
```

however as soon as a hook is used inside the component the eslint rule-of-hooks will warn with:
```
React Hook ""React.useLayoutEffect"" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.
```

If a named function is used it works, but it is far from ideal (e.g. name repetition):

```ts
export const MyComponent = memo(
    mobxObserver(
        function MyComponent(props: IMyComponentProps) {
          // React.useLayoutEffect(...) // won't warn
        }
))
```

Would it be possible to have a custom whitelist of methods that are allowed to wrap the functional component without raising this warning? (same as React.memo is whitelisted right now)

E.g. something like:
```
allowedWrappers: [ ""mobxObserver"" ] 
```

Or even better, do not consider a callback something that is just wrapping the functional component, but I'm not sure if that's feasible.

Thanks.",,
19034,OPEN,exhaustive-deps: custom effects should support async functions,Component: ESLint Rules; Type: Discussion,2021-03-13 22:09:56 +0000 UTC,whatisaphone,,"We have a custom hook, `useAsyncEffect`, which works like `useEffect` except it accepts an async function. We would like to check the deps of this function using `exhaustive-deps`, but that lint rule is going a bit beyond its name and also checking the type of function we pass.

The `exhaustive-deps` rule can't know anything about the semantics of arbitrary third-party hooks, so I think it's overstepping its bounds a bit (at least if you take the name ""exhaustive deps"" literally)

React version: 16.13.1
eslint version: 7.0.0
eslint-plugin-react-hooks version: 4.0.3

## Steps To Reproduce

Source:

```
import React from 'react';
import { useAsyncEffect } from './utilities/react';

function MyComponent() {
  useAsyncEffect(async () => {
    await Promise.resolve()
  }, []);
  return <div />;
}
```

`.eslintrc.json`:

```
{
  ""parserOptions"": {
    ""ecmaVersion"": 2020,
    ""sourceType"": ""module"",
    ""ecmaFeatures"": {
      ""jsx"": true
    }
  },
  ""plugins"": [""react-hooks""],
  ""rules"": {
    ""react-hooks/exhaustive-deps"": [
      ""error"",
      {
        ""additionalHooks"": ""^useAsyncEffect$""
      }
    ]
  }
}
```

Then run:

```
node_modules/.bin/eslint --ext jsx src/file.jsx
```

## The current behavior

```
  5:18  error  Effect callbacks are synchronous to prevent race conditions. Put the async function inside:

<snip>

✖ 1 problem (1 error, 0 warnings)
```

## The expected behavior

There should be no lint error",,
19016,OPEN,Bug: Mouse leave event not fired after removing portal,Status: Unconfirmed,2020-10-12 05:28:13 +0000 UTC,amannn,,"1. Go to https://1r4ib.csb.app/
2. Open dev tools to see console logs
3. Click on ""Toggle portal""
4. Leave the popover by moving the mouse out on the lower side.
5. See the logs: Only the portal mouse leave event is logged, not the one from the `<App />` component.

![Kapture 2020-05-27 at 13 21 52](https://user-images.githubusercontent.com/4038316/83013321-1d0b5880-a01d-11ea-85ba-f592a7027ff6.gif)


<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/condescending-wilson-1r4ib?file=/src/App.js:890-951

I noticed this only happens if the event handler that triggers the closing of the popover is registered on a DOM node that is nested within another DOM node within the popover. If you 
swap the lines 35 and 36 everything works as expected.

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

The mouse leave event on the outer div of the `<App />` component is not fired.

## The expected behavior

The mouse leave event on the outer div of the `<App />` component should be fired.",,
18986,OPEN,Bug: Firefox: Autocomplete/Autofill still not working,Status: Unconfirmed,2021-01-12 18:16:17 +0000 UTC,Hadsch,,"Description, steps to reproduce and sandbox example see #17022! 
The native autocomplete function from firefox is still not working.

This also affects other frameworks (antd, material UI):
* https://github.com/mui-org/material-ui/issues/16943
* https://github.com/ant-design/ant-design/issues/21232

It would be nice if someone of the react community could give it a shot because I think that the native autocomplete is a very important UX feature. ",,
18965,OPEN,Bug: React throws warning on browser default function,Component: DOM; Type: Discussion,2020-10-28 13:47:33 +0000 UTC,welsen,,"I'm receiving the following ""Warning""
```
Warning: Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.
    in option (created by styled.option)
    in styled.option (created by Menu)
    in select (created by styled.select)
    in styled.select (created by Menu)
    in div (created by styled.div)
    in styled.div (created by Menu)
````

React version:

## Steps To Reproduce

1. create a select with options
```
return (<select>
  <option>a</option>
  <option selected>b</option>
</select>);
```
as usecase: the selected property is defined outside the state of the select component, it is set by navigating the site. As of now it is only a warning, so it works if I use this, but the customer whom I build the application, has strict standards, so as for this warning, it kills the audit of the  application, even we stated that it is a React specific warning, not a standard, caused by some coding error.
2. see the warnning whowing up *RED* in your browser that a simple already built-in function of all browser if overriden and damned eternally.

Code does not have any outside dependencies.

## The current behavior

It throws the warning in development.

## The expected behavior

It is a standard behavior of all modern browsers, that you can tell the select dropdown or multiselect, that it has one ora other selected by code even from context.

This should not be a warning, as it is a w3c standard feature of the select dropdown. Please remove warnings and what-so-ever that you are forcing developers to do, to avoid using w3c standards.",,
18945,OPEN,DevTools: Improve browser extension iframe support,Component: Developer Tools; good first issue,2021-01-07 14:12:27 +0000 UTC,dmail,,"Have you considered adding `all_frames: true` to chrome extension ?

## Steps To Reproduce

1. Create a file `react-main.html`
```html
<!DOCTYPE html>
<html>
  <head>
    <script crossorigin src=""https://unpkg.com/react@16/umd/react.development.js""></script>
    <script crossorigin src=""https://unpkg.com/react-dom@16/umd/react-dom.development.js""></script>
  </head>
  <body></body>
</html>

```
2. Create a file `react-iframe.html`
```html
<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <iframe src=""./react-main.html"" />
  </body>
</html>
```
3. Open `react-iframe.html` in chrome

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

![react-devtools-not-detected](https://user-images.githubusercontent.com/443639/82196553-21879100-98fa-11ea-932b-b9f49a4079c7.png)

## The expected behavior

![react-devtools-detected](https://user-images.githubusercontent.com/443639/82196588-2cdabc80-98fa-11ea-925d-186e8c999f44.png)

Pull request: https://github.com/facebook/react/pull/18952



",,
18940,OPEN,"Feature Request: <input type=""textarea"" .../>",Resolution: Stale; Status: Unconfirmed,2020-12-25 14:07:04 +0000 UTC,JasonWoof,,"I'm delighted that you made it so `<textarea>` can take `value=` and `defaultValue=...` but what I really want is `<input type=""textarea"">`.

That would make this use case more fun:

    <input type={field.type} ...

No explanation necessary if you decide not to implement this. I've already made a wrapper class to solve my problem at hand.",,
18908,OPEN,Show better warning when <React.Fragment> is missing a key,Resolution: Stale; Status: Unconfirmed,2020-12-25 13:08:25 +0000 UTC,jtrost,,"React version: 16.9.0

## Steps To Reproduce

1. Take an array of data, and render each item inside of `<React.Fragment></React.Fragment>`
2. Load the page to and see the topmost line in the backtrace: `in Fragment (at App.js:6)`

Link to code example: https://codesandbox.io/s/icy-rgb-wyuyk?file=/src/App.js

## The current behavior
The warning says that a `<Fragment>` tag needs a key, but `<React.Fragment>` is the tag that actually needs a key.

## The expected behavior
Any line in this backtrace that's a `<React.Fragment>` should say `in React.Fragment` for clarity.

I am suggesting this change because I have a component named `Fragment`, so when I saw a `<Fragment>` tag in the backtrace I thought my `<Fragment>` tag needed a key. But it turns out that `<React.Fragment>` needed a key. Since React does not prevent you from naming a component `Fragment`, it should correctly name `React.Fragment` in the backtrace.
",,
18906,OPEN,Bug: IE11 with Suspense doesn't support direct child with inline display: flex style,Component: Suspense; Type: Needs Investigation,2020-10-19 14:00:25 +0000 UTC,AdrianoRuberto,,"React version: 16.13.1

## Steps To Reproduce

1. Add <React.Suspense /> 
2. Add a direct child with an inline style as `display: flex`
3. Lazy load something

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://github.com/AdrianoRuberto/ie11-suspense-bug

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
A blank page with IE11

## The expected behavior
The loaded page.

## Workarounds
Basically, remove the inline style with `display: flex` to be the direct child of `<React.Suspense />` does the trick, such as:
1. Add a div between the `React.Suspense` and the `<div style={{display: ""flex""}}>`
2. Use a `className` and move the inline style inside the stylesheet.


",,
18883,OPEN,Feature proposal(eslint-react-hooks): Recursive dependencies scanning for exhaustive-deps,,2020-11-14 22:58:30 +0000 UTC,Telokis,,"## Context

After reading https://github.com/facebook/react/issues/14920 (not 100% of it, I admit), I decided to refactor my codebase in order to be more resilient against potential mistakes.  
During this conversion, I converted a ton of callbacks to `useCallback` and made extensive use of the array dependencies for `useCallback` and `useEffect` everywhere.  
However, I often stumbled upon the following pattern:

```js
const myCallback = useCallback(() => {
  // Do something with value.
}, [value]);

const myOtherCallback = useCallback(() => {
  const result = myCallback();

  // Do something with BOTH value and result.
}, [value, myCallback ]);

useEffect(() => {
  // Do something with myCallback, myOtherCallback and value, independently.
}, [value, myCallback, myOtherCallback ])
```

[Basic CodeSandBox with this example](https://codesandbox.io/s/goofy-thunder-2y4s9)

For the sake of argument, let's say that this code can't ""move"" callbacks around: I can't declare `myCallback` and/or `myOtherCallback` because they are used below in the main scope.

## Problem

With the above example, we can conclude the following statements:
- `myCallback` will change if `value` changes
- `myOtherCallback` will change if `value` or `myCallback` changes
- The `useEffect` will rerun if `myCallback`, `value` or `myOtherCallback` changes

We can instantly notice there is a lot of redundancy right there:

If `value` changes, `myCallback` will change so I only need to specify `myCallback` as a dependency for `myOtherCallback` even though I also use `value` directly.  
The same reasoning can be applied to the dependencies of `useEffect`.

As a human, I could omit `value` from the dependencies of `myOtherCallback` and be 100% absolutely guaranteed that the behavior would be strictly identical as per the hooks very own specifications.  
But if I do so, the `react-hooks/exhaustive-deps` eslint rule will complain that I'm missing some dependencies from the array.

## Proposal

If I understood properly, the rule does some kind of dependency traversal in order to attempt to recognize infinite loops.  
I think it would be nice for it to also be able to detect this kind of dependency redundancies.  
Even better, it should be able to take it into account when suggesting changes/reporting errors.  

## Benefits

From reading the [issue](https://github.com/facebook/react/issues/14920) I mentionned at the top of this post, there is a fair amout of people who are not happy with the clutter the rule forces us to have in the codebase.  
Myself, I'm fairly hesitant and sometimes find myself thinking ""I shouldn't need to specify this dep"".  
Implementing the proposal mentionned above would be extremely beneficial regarding the readability of the code by totally preventing redundancy of dependencies.

## Drawbacks

I can see two potential issues with this proposal:

#### Performance impact

Requiring the rule to recursively assess dependencies may have a performance impact on the linting.  

I'm not sure if this is the case since the rule does a similar check to try to avoid infinite loop. (Maybe I'm wrong and it's not the same thing).  
If this is too much of an impact, I think it could be opt-in behind a config flag.  
This would allow people to decide for themselves if the impact is worth it.

#### Less obvious dependencies

Not explicitely specifying every used dependency may make it harder to assess the real update impact.  
From the above example, I know that my `useEffect` depends on `value`. If it weren't there, I would have to mentally climb up the dependencies myself.  

I think this is a fake drawback since I always need to climb up the dependencies tree to REALLY know what could cause my effect (or other) to be triggered.  
I would even argue that this proposal makes this mental parsing easier because I don't have any redundancy when reading the dependencies: every variable I see in a dependency array is specified exactly once. (Well, there may be exceptions when it comes to diverging dependencies but it's even more of an improvement in such a situation.)

## Conclusion

This proposal seems to be entirely positive from my point of view. The drawbacks are quite small and an opt-in design may make them even more manageable.",,
18873,OPEN,Deprecate SyntheticKeyboardEvent.{charCode;keyCode;which},Resolution: Stale; Status: Unconfirmed,2020-12-25 14:07:10 +0000 UTC,japgolly,,"The following `KeyboardEvent` properties have been officially deprecated:

* https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/charCode
* https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
* https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which

React should probably mark these as deprecated too, and issue warnings in development mode.",,
18859,OPEN,"Error: ""Commit tree already contains fiber 19587. This is a bug in React DevTools.""",Component: Developer Tools; Resolution: Needs More Information; Type: Bug,2020-05-14 15:57:18 +0000 UTC,phoenisx,,"### Describe what you were doing when the bug occurred:
1. I did profiling on a list, that gets updated on each pagination api call.
2. Once the profiling was done, I moved around in the Profiler to view the Flamegraph
3. Moving to second capture, the Profiler crashed.


**DevTools version**: 4.6.0-6cceaeb67

```
Component stack: in ec
    in div
    in div
    in div
    in So
    in Unknown
    in n
    in Unknown
    in div
    in div
    in rl
    in Ze
    in fn
    in Ga
    in _s
```",,
18857,OPEN,[eslint-plugin-react-hooks] just mark react's implemented hooks as invalid in classes,Resolution: Stale; Status: Unconfirmed,2020-12-25 15:06:32 +0000 UTC,DoubleU23,,"## The current behavior
`react-hooks/rules-of-hooks` marks custom hooks to be invalid in classes

## The expected behavior
imho this rules should only mark react's implemented hooks as invalid in classes

__as the rule states:__
""React Hook ""useTranslation"" cannot be called in a class component.  
React Hooks must be called in a React function component __or a custom React Hook function__.""

__so it is allowed to use custom hook functions in classes?__ (at least it works)

if that's wrong (usage of custom hooks), then:
* why does it work
* the rule statement should be changed

__BTW:__ altought it might be no classical custom hook, maybe just a function using a hook,
__but it should not be marked as hook, just because of the prefix?__


## The alternative way
__support a whitelist for that rule?__

related to #15227, #14791, #17636",,
18841,OPEN,Bug: Error in useEffect is caught in ErrorBoundary; but still logs uncaught error to console in tests,Status: Unconfirmed,2021-01-02 00:13:03 +0000 UTC,mpeyper,,"1. Create a component with a useEffect hook
2. Render the component in an error boundary using `react-test-renderer`
3. Throw an error synchronously in the effect callback (i.e. not in a promise callback)
4. Observe the error in the console

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://github.com/mpeyper/error-boundary-error-repro

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

> **When you first clone the repo, all the tests are being skipped.  This is to reduce the noise when observing the output.  Please remove the `.skip` from the tests to see the output.**
>
> Note that I have also used `react-error-boundary` for creating the error boundaries in the example repo to simplify the setup, but if you believe this is interfering with test, I'm happy to hand roll an error boundary instead.

Given the following two components, the way in which the error is being handled is inconsistent when using `react-test-renderer` vs. `react-dom` (via `@testing-library/react` in my example):

```jsx
export function HasErrorInRender() {
  throw Error(""This error was expected"")
}

export function HasErrorInEffect() {
  useEffect(() => {
    throw Error(""This error was expected"")
  })

  return <p>This component has an error in an effect</p>
}
```

When rendering with `react-dom`, both [the following tests](https://github.com/mpeyper/error-boundary-error-repro/blob/master/src/HasError.test.js#L7) pass, and produce the same output in the console:

```jsx
describe('@testing-library/react', () => {
  test('should catch error in render', () => {
    let err = null
    function Fallback({ error }) {
      err = error
      return <p>An error was thrown</p>
    }

    render((
      <ErrorBoundary FallbackComponent={Fallback}>
        <HasErrorInRender />
      </ErrorBoundary>
    ))

    expect(err).toEqual(Error(""This error was expected""))
  })

  test('should catch error in effect', () => {
    let err = null
    function Fallback({ error }) {
      err = error
      return <p>An error was thrown</p>
    }

    render((
      <ErrorBoundary FallbackComponent={Fallback}>
        <HasErrorInEffect />
      </ErrorBoundary>
    ))

    expect(err).toEqual(Error(""This error was expected""))
  })
})
```

The output they produce is:

```txt
  console.error node_modules/jsdom/lib/jsdom/virtual-console.js:29
    Error: Uncaught [Error: This error was expected]
        at reportException (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/helpers/runtime-script-errors.js:66:24)
        at invokeEventListeners (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:209:9)
        at HTMLUnknownElementImpl._dispatch (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:119:9)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:82:17)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/nodes/HTMLElement-impl.js:30:27)
        at HTMLUnknownElement.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js:157:21)
        at Object.invokeGuardedCallbackDev (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:237:16)
        at invokeGuardedCallback (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:292:31)
        at beginWork$1 (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:23203:7)
        at performUnitOfWork (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:22157:12) Error: This error was expected
        at HasErrorInRender (/<REDACTED>/error-boundary-error-repro/src/HasError.js:4:9)
        at renderWithHooks (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:14803:18)
        at mountIndeterminateComponent (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:17482:13)
        at beginWork (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:18596:16)
        at HTMLUnknownElement.callCallback (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:188:14)
        at invokeEventListeners (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:193:27)
        at HTMLUnknownElementImpl._dispatch (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:119:9)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:82:17)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/nodes/HTMLElement-impl.js:30:27)
        at HTMLUnknownElement.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js:157:21)
        at Object.invokeGuardedCallbackDev (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:237:16)
        at invokeGuardedCallback (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:292:31)
        at beginWork$1 (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:23203:7)
        at performUnitOfWork (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:22157:12)
        at workLoopSync (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:22130:22)
        at performSyncWorkOnRoot (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:21756:9)
        at scheduleUpdateOnFiber (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:21188:7)
        at updateContainer (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:24373:3)
        at /<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:24758:7
        at unbatchedUpdates (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:21903:12)
        at legacyRenderSubtreeIntoContainer (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:24757:5)
        at Object.render (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:24840:10)
        at /<REDACTED>/error-boundary-error-repro/node_modules/@testing-library/react/dist/pure.js:86:25
        at batchedUpdates$1 (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom.development.js:21856:12)
        at act (/<REDACTED>/error-boundary-error-repro/node_modules/react-dom/cjs/react-dom-test-utils.development.js:929:14)
        at render (/<REDACTED>/error-boundary-error-repro/node_modules/@testing-library/react/dist/pure.js:82:26)
        at Object.<anonymous> (/<REDACTED>/error-boundary-error-repro/src/HasError.test.js:15:5)
        at Object.asyncJestTest (/<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:102:37)
        at /<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/queueRunner.js:43:12
        at new Promise (<anonymous>)
        at mapper (/<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/queueRunner.js:26:19)
        at /<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/queueRunner.js:73:41
        at processTicksAndRejections (internal/process/task_queues.js:97:5)

  console.error node_modules/react-dom/cjs/react-dom.development.js:19527
    The above error occurred in the <HasErrorInRender> component:
        in HasErrorInRender (at HasError.test.js:17)
        in ErrorBoundary (at HasError.test.js:16)
    
    React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.
```

This is somewhat expected when using `react-dom` and reflects the output one would see in the browser console if the some components were rendered in an app (you can run `npm start` in the example repo if you would like to observe this).

However, where things start to get a bit strange is when the renderer is [replaced with `react-test-renderer`](https://github.com/mpeyper/error-boundary-error-repro/blob/master/src/HasError.test.js#L41) and the same tests are run:

```jsx
describe('react-test-renderer', () => {
  test('should catch error in render', () => {
    let err = null
    function Fallback({ error }) {
      err = error
      return <p>An error was thrown</p>
    }

    act(() => {
      create((
        <ErrorBoundary FallbackComponent={Fallback}>
          <HasErrorInRender />
        </ErrorBoundary>
      ))
    })

    expect(err).toEqual(Error(""This error was expected""))
  })

  test('should catch error in effect', () => {
    let err = null
    function Fallback({ error }) {
      err = error
      return <p>An error was thrown</p>
    }

    act(() => {
      create((
        <ErrorBoundary FallbackComponent={Fallback}>
          <HasErrorInEffect />
        </ErrorBoundary>
      ))
    })

    expect(err).toEqual(Error(""This error was expected""))
  })
})
```

Again both tests here do pass, but the output they produce is not the same.  When the first test (error in the `render` function) is run, it only produces the following output:

```txt
  console.error node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10141
    The above error occurred in the <HasErrorInRender> component:
        in HasErrorInRender (at HasError.test.js:52)
        in ErrorBoundary (at HasError.test.js:51)
    
    React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.
```

As you can see, the [frustratingly difficult to suppress](https://github.com/facebook/react/issues/15520) error log from the error boundary is present, but the long stack trace from the uncaught error that is present in the `react-dom` output is not.

When the second test (error in the `useEffect` callback) is run, the output is:

```txt
  console.error node_modules/jsdom/lib/jsdom/virtual-console.js:29
    Error: Uncaught [Error: This error was expected]
        at reportException (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/helpers/runtime-script-errors.js:66:24)
        at invokeEventListeners (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:209:9)
        at HTMLUnknownElementImpl._dispatch (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:119:9)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:82:17)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/nodes/HTMLElement-impl.js:30:27)
        at HTMLUnknownElement.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js:157:21)
        at Object.invokeGuardedCallbackDev (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10021:16)
        at invokeGuardedCallback (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10073:31)
        at flushPassiveEffectsImpl (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:13345:9)
        at unstable_runWithPriority (/<REDACTED>/error-boundary-error-repro/node_modules/scheduler/cjs/scheduler.development.js:653:12) Error: This error was expected
        at /<REDACTED>/error-boundary-error-repro/src/HasError.js:9:11
        at commitHookEffectListMount (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10345:26)
        at commitPassiveHookEffects (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10383:11)
        at HTMLUnknownElement.callCallback (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:9972:14)
        at invokeEventListeners (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:193:27)
        at HTMLUnknownElementImpl._dispatch (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:119:9)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:82:17)
        at HTMLUnknownElementImpl.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/nodes/HTMLElement-impl.js:30:27)
        at HTMLUnknownElement.dispatchEvent (/<REDACTED>/error-boundary-error-repro/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js:157:21)
        at Object.invokeGuardedCallbackDev (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10021:16)
        at invokeGuardedCallback (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10073:31)
        at flushPassiveEffectsImpl (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:13345:9)
        at unstable_runWithPriority (/<REDACTED>/error-boundary-error-repro/node_modules/scheduler/cjs/scheduler.development.js:653:12)
        at runWithPriority (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:1775:10)
        at flushPassiveEffects (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:13312:12)
        at Object.<anonymous>.flushWork (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:14883:10)
        at act (/<REDACTED>/error-boundary-error-repro/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:15001:9)
        at Object.<anonymous> (/<REDACTED>/error-boundary-error-repro/src/HasError.test.js:67:5)
        at Object.asyncJestTest (/<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:102:37)
        at /<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/queueRunner.js:43:12
        at new Promise (<anonymous>)
        at mapper (/<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/queueRunner.js:26:19)
        at /<REDACTED>/error-boundary-error-repro/node_modules/jest-jasmine2/build/queueRunner.js:73:41
        at processTicksAndRejections (internal/process/task_queues.js:97:5)

  console.error node_modules/react-test-renderer/cjs/react-test-renderer.development.js:10141
    The above error occurred in the <HasErrorInEffect> component:
        in HasErrorInEffect (at HasError.test.js:70)
        in ErrorBoundary (at HasError.test.js:69)
    
    React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.
```

Now, the uncaught error message is back, which is not what I would have expected.  Even more confusingly, when inspecting the stacktrace of the uncaught error, it has references to `jsdom` which I was of the belief was not a dependency of `react-test-renderer`.  I suspect that there is some `jest` and/or `jsdom` trickery going on to report the uncaught error, rather than `react-test-renderer` using it in some way, but I'm not familiar enough with any of them to know for certain.

The part that's has me the most perplexed is how the error boundary can intercept the error to pass into it's handler callbacks (surfaced in my example in `react-error-boundary`'s `FallbackComponent`) without catching the error, unless it is throwing it again after catching it, but then both tests would be producing the uncaught error output, right?

## The expected behavior

My expected (and preferred) behaviour here would be for the the `react-test-renderer` test to only produce the error boundary error log and not have any additional uncaught error output.",,
18835,OPEN,useMutableSource: Release version snapshots once hydration is finished,React Core Team,2020-05-05 22:29:47 +0000 UTC,bvaughn,,"Follow up for #18183 and PR #18771.

Decide when to clear `mutableSourceEagerHydrationData`. We don't currently have a way to detect when all outstanding hydration work is finished. (It may never finish.) This means that in use cases where the version is the entire sore (e.g. an immutable store without a version ""number"") we would retain a reference to that store, preventing it from being GCed.
",,
18822,OPEN,"Add devtools ""Inspect React component"" to right-click menu",Component: Developer Tools; Type: Feature Request,2021-02-18 17:09:26 +0000 UTC,sophiebits,,"Noticed today that Vue's devtools have an awesome ""Inspect Vue component"" option when right-clicking on a webpage (added in https://github.com/vuejs/vue-devtools/pull/479).

The React devtools should have the same feature! It would be useful when debugging for sure.
",,
18818,OPEN,"Bug: devtools ""rendered at"" for child components uses value of top component",Component: Developer Tools; Status: Unconfirmed,2020-11-19 20:38:00 +0000 UTC,eps1lon,,"React version: 16.13.1
devtools version: 4.10.0 (3/26/2020). Adds React debugging tools to the Chrome Developer Tools. Created from revision 11a2ae3a0d on 11/12/2020.

## Steps To Reproduce

1. Record profiling session
2. Goto flamegraph
3. Click on a ""bar"" that's not the top-most

Link to code example: https://codesandbox.io/s/cocky-rain-uuoi8?file=/src/index.js

## The current behavior

""rendered at"" uses the value from the root component

![devtools-profiler-rendered-at](https://i.ibb.co/pPfBCHM/devtools-profiler-rendered-at.png)




## The expected behavior

it should use the same value that is displayed in the tooltip. Otherwise I don't see much value in displaying it since I could just read the value directly from the root. I thought it was intended for very dense flamegraphs e.g.
![Screenshot from 2020-05-04 19-53-53](https://user-images.githubusercontent.com/12292047/80996992-02402c80-8e41-11ea-9396-f3777c01cf4d.png)

",,
18790,OPEN,Memory Leak - React DOM keeps references to stale child components when using the Container/Pure component pattern,,2020-11-12 23:37:52 +0000 UTC,jzworkman,,"**Do you want to request a feature or report a bug?**
Report a bug.

**What is the current behavior?**
ReactDOM keeps references to previous states/props/children when component gets updated. All in all consuming three times as much memory as it really needed.

We are seeing this as a significant issue when using Redux and container components. When our container componet(that is connected to redux store) passes props to the child components, and then the redux store updates. The child component props are being stranded in the dom with old reference(seen in the heap after forcing a garbage collection cycle). This is causing huge amounts of memory bloat when on a page that is connected to signalR for real time collaboration between users(as each redux update creates hundreds of stranded object references in the child components).

I have verified that this is the cause by instead having all of the previously ""dumb"" pure child components be converted to Connected components and pull their props from redux instead of having the container component pattern control all of the store connections. this then correctly all references the single redux store object and garbage collection works as expected without stranded references.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

Link to the example below (using production versions of react and react-dom):
https://codesandbox.io/s/epic-bartik-pvgqx.

Consider following example:

```
import * as React from 'react';
import * as ReactDOM from 'react-dom';

let dataInstanceCount = 0;
class MyBigData {
  constructor() {
    const id = `my-big-data:${dataInstanceCount++}`;
    this.getMyDataId = () => id;
    this.data = new Array(100000).fill('');
  }
}

let componentInstanceCount = 0;
class MyItem extends React.Component {
  constructor(props) {
    super(props);
    this._myItemId = `my-item:${componentInstanceCount++}`;
    this.state = {list: []};
  }

  render() {
    return this.props.item.getMyDataId();
  }
}

class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {list: []};
  }

  componentDidMount() {
    this.updateList(() => {
      this.updateList(() => {
        this.updateList();
      });
    });
  }

  updateList(callback) {
    this.setState({
      list: [new MyBigData()]
    }, callback);
  }

  render() {
    return this.state.list.map((item) => (
      <MyItem key={item.getMyDataId()} item={item} />
    ));
  }
}

const rootElement = document.getElementById('root');
ReactDOM.render(
  <MyApp />,
  rootElement
);

setTimeout(() => {
  console.log(
    rootElement._reactRootContainer._internalRoot.current.alternate.firstEffect.memoizedProps.item.getMyDataId(),
    rootElement._reactRootContainer._internalRoot.current.alternate.firstEffect.stateNode._myItemId
  );
  // > my-big-data:0, my-item:0
  console.log(
    rootElement._reactRootContainer._internalRoot.current.firstEffect.memoizedProps.item.getMyDataId(),
    rootElement._reactRootContainer._internalRoot.current.firstEffect.stateNode._myItemId
  );
  // > my-big-data:1, my-item:1
  console.log(
    rootElement._reactRootContainer._internalRoot.current.lastEffect.memoizedProps.item.getMyDataId(),
    rootElement._reactRootContainer._internalRoot.current.lastEffect.stateNode._myItemId
  );
  // > my-big-data:2, my-item:2
}, 1000);
```
I expect only one MyBigObject and one MyItem component to be in the memory. But instead I can see three of each in memory heap snapshot.

**UPDATE**
As shown in the updated example the references to these objects and components can be accessed in the sub-properties of the root DOM element.

**What is the expected behavior?**
There's no justifiable reason to keep in memory unmounted components and previous states/props of component after it was updated.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React 16.9.0, ReactDOM 16.9.0 (Production versions)
Mac/Win

This info was gathered from the follow issue that was marked stale, but is still definitely an issue with Redux and passing store props to Pure Child unconnected components: https://github.com/facebook/react/issues/16138 ",,
18777,OPEN,Bug: Stop browser hanging on Maximum update depth exceeded,Status: Unconfirmed,2021-01-04 16:07:17 +0000 UTC,laclance,,"React version: 16.13.1
OS: Windows 10
Browser: Google chrome 81.0.4044.122

Whenever I incorrectly use useEffect hook and get the Maximum update depth exceeded error the chrome tab hangs and I have to force close using task manager and reopen chrome again in order to close the tab. This makes debugging the cause very time consuming and annoying, is there a way to avoid this? like for example stop rendering after 100 renders.
",,
18768,OPEN,Bug: `React.lazy` throws undefined instead of an `Error` object,Type: Bug,2020-05-22 02:49:29 +0000 UTC,mischnic,,"React version: 16.13.1

## Steps To Reproduce

```js
import React, { Suspense, lazy } from ""react"";

const Async = lazy(() => {}); // <------

let App = () => {
	return (
		<Suspense fallback={""Loading""}>
			<Async />
		</Suspense>
	);
};

export default App;
```

Link to code example: https://codesandbox.io/s/elegant-fermi-bxwtb

Might be related to https://github.com/facebook/react/issues/15019, https://github.com/facebook/react/pull/15222

## Context

I know that this is incorrect code, but `lazy(() => {import(...)})` is a rather easy typo to make.
The main reason why I'm bringing this is up is that other tools (like JSDOM and Codesandbox with the link above) expect an `Error` object to be thrown. 

## The current behavior


**Input**: `const Async = lazy(async () => ({}));`
**Error**: (this is correct)
```
Warning: lazy: Expected the result of a dynamic import() call. Instead received: [object Object]

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))
```

**Input**: `const Async = lazy(() => ({}));`
**Error**: (the exception is not an `Error` object)
```
Uncaught {}
```

**Input**: `const Async = lazy(() => {});`
**Error**:  (the exception is not an `Error` object)
```
Uncaught undefined
```


## The expected behavior

**Input**: `const Async = lazy(async () => ({}));`
**Error**:
```
Warning: lazy: Expected the result of a dynamic import() call. Instead received: [object Object]

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))
```

**Input**: `const Async = lazy(() => ({}));`
**Error**:
```
Warning: lazy: Expected the result of a dynamic import() call. Instead received: undefined

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))
```

**Input**: `const Async = lazy(() => {});`
**Error**:
```
Warning: lazy: Expected the result of a dynamic import() call. Instead received: [object Object]

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))
```",,
18752,OPEN,Bug: <iframe /> onLoad is not getting triggered after the reload triggered by moving the DOM Node,Type: Needs Investigation,2020-07-21 22:53:59 +0000 UTC,adamziel,,"When an `<iframe />` DOM Node is moved to a different place in the tree, Chrome triggers a reload. That reload does not notify event handlers registered via `onLoad=`. In other words:

* If there is an event handler registered via `onLoad={myCallback}`, it **will not** be fired.
* If there is an event handler registered via `iframe.addEventListener(""load"", myCallback, false)`, it **will** be fired.

React version: 16.13.1

## Steps To Reproduce

Open a code example below and move the iframe **down** using arrow button next to it.

https://codesandbox.io/s/serverless-surf-k1ypg?file=/src/App.js

## The current behavior

The iframe does not say ""Initialized"" anymore.

## The expected behavior

The iframe should say ""Initialized"".

## Other notes

If you move `setIframeContent(e.currentTarget);` to `nativeLoad` and repeat the steps above, it works as expected. The bug does not occur in Firefox.",,
18661,OPEN,Bug: Nested SuspenseList may display fallbacks while the component is loaded on re-render,Component: Concurrent Mode; Type: Needs Investigation,2020-05-22 08:47:00 +0000 UTC,dubzzz,,"## Steps To Reproduce

_In concurrent mode only_

0. Setup

Let's suppose we have three components `<A />` (**not** lazy loaded), `<B />` (**not** lazy loaded) and `<C />` (lazy loaded).

In other words:

```jsx
import A from './A';
import B from './B';
const C = React.lazy(() => import('./C'));
```

1. Render

```jsx
render(
  <SuspenseList key=""1"" revealOrder=""forwards"">
    <SuspenseList key=""1.1"" revealOrder=""forwards"">
      <Suspense key=""1.1.a"" fallback={<div>Loading A</div>}>
        <A />
      </Suspense>
    </SuspenseList>
  </SuspenseList>
)
```

2. Update the component (component now shows A, B, and C)

```jsx
render(
  <SuspenseList key=""1"" revealOrder=""forwards"">
    <SuspenseList key=""1.1"" revealOrder=""forwards"">
      <Suspense key=""1.1.a"" fallback={<div>Loading A</div>}>
        <A />
      </Suspense>
      <Suspense key=""1.1.b"" fallback={<div>Loading B</div>}>
        <B />
      </Suspense>
      <Suspense key=""1.1.c"" fallback={<div>Loading C</div>}>
        <C />
      </Suspense>
    </SuspenseList>
  </SuspenseList>
)
```

3. Output is: `A / Loading B / Loading C`. While `B` has already been loaded (not lazy loaded). If I understand well the behaviour of `forwards` I would have expect to have `A / B / Loading C` instead.

Please note that the behaviour is not the same if I do not use nested `<SuspenseList />`.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

CodeSandbox: https://codesandbox.io/s/mutable-rain-3ikor
GitHub pages repro: https://dubzzz.github.io/react-suspenselist-bug/build/
GitHub pages source code: https://github.com/dubzzz/react-suspenselist-bug

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

Output is: `A / Loading B / Loading C` with nested `SuspenseList`

## The expected behavior

Output is: `A / B / Loading C` with nested `SuspenseList`

**How did I found this bug?**

This _potential bug_ has been discovered while I was trying to run property based tests based on [fast-check](https://github.com/dubzzz/fast-check/) against React library.

See https://github.com/dubzzz/react/commit/e2cb4776ea3634fab2021d83cb8259bde03c0f3a
",,
18616,OPEN,Bug: window as new portal will break event delegation,Type: Discussion,2020-07-13 12:50:45 +0000 UTC,hanq08,,"1. Button attach to a window portal with window.open
2. Event not triggering


<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
```javascript
const { useState, useEffect } = React;


function WindowPortal({ children }) {
  const [container, setContainer] = useState(document.createElement('div'));
  useEffect(() => { 
    const newWindow = window.open('', '', 'width=600,height=400,left=200,top=200');
    newWindow.document.body.appendChild(container);
  });
  return ReactDOM.createPortal(children, container);
}
function App() {
  const [value, setValue] = useState('unclicked');
  const handleClick = () => setValue('clicked'); 
  return (
    <div>
      <div>Portal Test</div>
      <WindowPortal>
        <button onClick={handleClick}>{value}</button>
      </WindowPortal>
    </div>
  );
}

ReactDOM.render(
  React.createElement(App),
  document.getElementById('root')
);
```
<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->
Any event in the new window will not be triggered since all events are bind to the original window. I think react can support a new mode for using native event binding rather than event delegation if it makes sense. [Preact](https://github.com/preactjs/preact) actually uses native browser event and don't use react event delegation system.
## The current behavior
Event not trigger for components in new window

## The expected behavior
Event will trigger",,
18595,OPEN,Delay setting useTransition isPending to true until JND,Component: Concurrent Mode; Type: Enhancement; Type: Needs Investigation,2020-07-09 01:30:32 +0000 UTC,subhero24,,"**Do you want to request a feature or report a bug?**
Maybe a feature?

When using Suspense and useTransition, the isPending of useTransition is immediately set to true.
I want to show a spinner when a transition is still pending, but showing it immediately results in a flashing spinner when the underlying promise resolves very fast. This is not a nice experience. 

Is there a useTransition suspense option to delay the isPending indicator? I want to prevent the spinner from showing if the transition completes in for example 100ms.",,
18594,OPEN,feat: allow multiple opaque identifiers in HTML attributes,Component: DOM; Resolution: Backlog,2021-03-24 04:05:54 +0000 UTC,eps1lon,,"react version: #17322
Original: https://github.com/facebook/react/pull/17322#issuecomment-613104823

Currently only a single value from `useOpaqueIdentifier` (unreleased) can be passed to HTML attributes. However, there are HTML attributes which support multiple ids (IDREFS) like `aria-labelledby`. This can be used to implement various patterns such as: 
```jsx
export default function App() {
  const taxpayerId = React.unstable_useOpaqueIdentifier();
  const spouseId = React.unstable_useOpaqueIdentifier();
  const w2GrossId = React.unstable_useOpaqueIdentifier();
  const dividendsId = React.unstable_useOpaqueIdentifier();
  return (
    <table>
      <tbody>
        <tr>
          <td />
          <th id={taxpayerId}>Taxpayer</th>
          <th id={spouseId}>Spouse</th>
        </tr>

        <tr>
          <th id={w2GrossId}>W2 Gross</th>
          <td>
            <input type=""text"" aria-labelledby={[taxpayerId, w2GrossId]} />
          </td>
          <td>
            <input type=""text"" aria-labelledby={[spouseId, w2GrossId]} />
          </td>
        </tr>

        <tr>
          <th id={dividendsId}>Dividends</th>
          <td>
            <input type=""text"" aria-labelledby={[taxpayerId, dividendsId]} />
          </td>
          <td>
            <input type=""text"" aria-labelledby={[spouseId, dividendsId]} />
          </td>
        </tr>
      </tbody>
    </table>
  );
}
````
-- https://codesandbox.io/s/useopaqueidentifier-for-idrefs-ocnm4

This example is from https://www.w3.org/WAI/GL/wiki/Using_aria-labelledby_to_concatenate_a_label_from_several_text_nodes

This currently almost works but it concatenates the ids with `"",""` (default toString of arrays) instead of `"" ""`.

`<button aria-labelledby={[opaqueIdentifier1, opaqueIdentifier1]} />` is to me the most intuitive one since we're passing a list of ids. 

Edit:
Removed the collapsible listbox example since that pattern has some a11y issue.",,
18565,OPEN,useOpaqueIdentifier and multiple React cases,Component: Server Rendering; Type: Discussion,2020-04-16 23:52:37 +0000 UTC,theKashey,,"React version: experimental

This is a theoretical issue, and is not proven to be a real issue. Written after #17322

## Steps To Reproduce

1. Use multiple independent version of react
2. Get a clash of `id`s

## The current behavior

Every React instance is generating `ids` based on a single counter, which increments every time new `id` is generated.
That `counter` is stored inside `react-dom` and it's lifetime is bound to React instance lifetime causing:
- `undefined behaviour` in tests/mocks, which might clear nodejs module cache by different reasons.
- `unpredictable` results with `lambda` as a backend, as long as many different renderers are working in a parallel, and their lifetime is limited.
- potentially `broken` state when more than one lambda is used to generate server response (multiple roots during SSR to speedup/parallelise rendering)
- guaranteed `broken` state on the client, with multiple react roots using different React instances, which could occur when the host application is not written in react, or when those ""multiple"" root as self-contained (aka widgets) and modules resolution is not hoisting a single React version to the top (for example parent application is just ""old"").

## The expected behavior

Let's imagine a static site generator. 
- You run it once and got 1000 HTML files. 
- You run it twice, and all those 1000 files got updated. 
- 🙀, you haven't changed anything!

👉 So the expected behavior  is to get the same result no matter on server up time. This means that `counter` should be ""per-render"", or ""per-react-root"".

--- 

Let's imagine there is a old legacy Java site, and we are adding two (non iframe based) widgets to it, both are self-contained (ie just ""bundled""), and both are using the same React version.
Then they would generate the same `ids` in the same order.

👉 this is purely frontend issue, and both React instances, even if separated, are living in the same DOM/window. They should somehow talk to eachother, and probably prefix their `ids` with some `uuid`s

---

Let's image the microfrontend, but old (or new, aka fragment cache) SSR-only application. For example I do have one very old, initially php-based application, where  every ""block"" is generated by a subsequent network request. Nowadays some of those ""blocks"" are using React, just for a better SSR experience (because, well, I am not using php that much for last 10years). 
👉 every time you render App it shall produce the same Ids, to mend static site generators, however, what if different apps could prefix their `ids` differently?

---

To be honest - there 3 points sounds like CAP theorem - you never gonna have all 3 at once.",,
18502,OPEN,Bug: Server hydration mistmatch and radio group with defaultChecked,Component: DOM; Component: Server Rendering; Type: Bug,2020-10-07 03:24:31 +0000 UTC,leoasis,,"
## Steps To Reproduce

1. In the example provided below, make sure you refresh the browser within Code Sandbox.
2. Check the first radio button. Verify that the radio is checked, but the text next to it still shows as ""not checked"" (which means the onChange prop was not triggered)
3. Attempt to select any other option (works fine), and then back the first one (works fine too).
4. Refreshing the page again, choosing any other option other than the first works fine.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/affectionate-stonebraker-3wj68

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

I know that using hydrate doesn't guarantee fixing the mismatches, but it says that it should warn about them in development (https://reactjs.org/docs/react-dom.html#hydrate). In this case, React doesn't warn about the mismatch, and the behavior is buggy, as shown in the example and steps to repro.

## The expected behavior

React should ideally work without the issue, but given that it's not guaranteed to be fixed according to the documentation, it should at least warn about the mismatch.",,
18499,OPEN,Provide a renderer-agnostic equivalent of setNativeProps(),Type: Discussion; Type: Feature Request,2021-03-26 08:17:09 +0000 UTC,drcmda,,"Dan asked me to open up an issue: https://twitter.com/dan_abramov/status/1246883821477339139

My proposal is to extend React with a small hook that allows us to mutate nodes without causing render. React has no official means to deal with fast occurring updates and libraries like react-spring and framer-motion already do something similar but in a way that forces them to carry a lot of burden.

```jsx
import React, { useMutation }

function A() {
  const [specialRef, set] = useMutation()

  useEffect(() => {
    // the following would execute sync and without causing render
    // going through the same channel as a regular props update with all
    // the internal interpolation (100 --> ""100px"")
    set({ style: { left: 100 } })
  }, [])

  return <div ref={specialRef} ... />
```

It uses the fact that reconcilers know how to handle props, something we don't know in userland unless we cause render to set fresh props, which is not at all optimal for animation or anything frame based. react-dom for instance knows what `margin: 3px` is, react-three-fiber knows what `position: [1,2,3]` is, and so on. These details are defined in the reconciler:

```jsx
  commitUpdate(instance: any, updatePayload: any, type: string, oldProps: any, newProps: any, fiber: Reconciler.Fiber)
```

If libraries could use this knowledge from outside they could deal with any platform. Animation libraries like react-spring or framer-motion would turn x-platform in one strike, they could animate everything: dom nodes, react native views, meshes, hardware diodes. We could finally write libraries that are not reliant on platforms.",,
18460,OPEN,Bug: Suspense fallbacks potentially never showing due to a race,Component: Suspense; Type: Bug; Type: Needs Investigation,2020-04-01 22:25:50 +0000 UTC,gaearon,,See https://github.com/facebook/react/pull/16632. I haven't verified but it seems plausible.,,
18434,OPEN,"Bug: SuspenseList revealOrder=""backwards"" is not consistent without tail props",Component: Suspense; Type: Needs Investigation,2020-04-06 17:51:36 +0000 UTC,velusgautam,,"1. If `<SuspenseList revealOrder=""backwards"">` is expected to show last component to load first if it loads early but it waits for the top components. If `tail` prop is set it works fine. 
2. if `<SuspenseList revealOrder=""backwards"" tail=""collapsed"">` is given everything works as expected

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->
```
<SuspenseList revealOrder=""backwards"">
      <ProfileDetails resource={resource} />
      <ErrorBoundary fallback={null}>
        <Suspense fallback={<h2>Loading posts...</h2>}>
          <ProfileTimeline resource={resource} />
        </Suspense>
      </ErrorBoundary>
      <Suspense fallback={<h2>Loading fun facts...</h2>}>
        <ProfileTrivia resource={resource} />
      </Suspense>
 </SuspenseList>
```

works fine when added tail
```
<SuspenseList revealOrder=""backwards"" tail=""hidden"">
      <ProfileDetails resource={resource} />
      <ErrorBoundary fallback={null}>
        <Suspense fallback={<h2>Loading posts...</h2>}>
          <ProfileTimeline resource={resource} />
        </Suspense>
      </ErrorBoundary>
      <Suspense fallback={<h2>Loading fun facts...</h2>}>
        <ProfileTrivia resource={resource} />
      </Suspense>
 </SuspenseList>
```
Link to code example: [https://codesandbox.io/s/bug-suspenselist-revealordertogether-and-error-boundaries-18429-1oky8](https://codesandbox.io/s/bug-suspenselist-revealordertogether-and-error-boundaries-18429-1oky8)

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
`<SuspenseList revealOrder=""backwards"">` waits for the top elements to load unless tail props is set.

## The expected behavior
 It is expected to work backwards order is last component is loaded in suspense without tail prop being set or not.",,
18413,OPEN,Bug: Editing context in react-devtools,Component: Developer Tools; Type: Feature Request,2020-12-25 19:14:33 +0000 UTC,eps1lon,,"React version: 16.13 and `0.0.0-experimental-aae83a4b9

## Steps To Reproduce

1. Goto https://codesandbox.io/s/xenodochial-field-rfdjz
2. Try editing value of `MessageListContext.Provider`

Link to code example: https://codesandbox.io/s/xenodochial-field-rfdjz

## The current behavior

Context from `createContext` can't be edited in the current devtools (provider, consumer, hooks)

## The expected behavior

Context value should be editable. I already proposed an implementation for [Provider](https://github.com/facebook/react/pull/18255) and [Consumer](https://github.com/facebook/react/pull/18257).
",,
18402,OPEN,Batching makes it difficult to perform imperative actions like focus,Type: Discussion,2020-12-26 17:16:54 +0000 UTC,astoilkov,,"React version: 16.9.5

## Steps To Reproduce

1. Overwrite batched updates with the following code: `ReactDOM.unstable_batchedUpdates = callback => callback()`
2. Batched updates aren't actually overwritten.

## Reasoning

I recognize that this may not be classified as bug because it isn't a documented feature but I have tried to search for a different solution but to no avail. Fixing this behavior can open a new way of using React. I tried writing on [Stack Overflow](https://stackoverflow.com/questions/60852219/disable-unstable-batchedupdates-on-event-handlers-in-react) and writing to [@gaearon](https://twitter.com/antoniostoilkov/status/1242789762307588097).

I have a number of arguments which support the disabling of batched updates in event handlers and in effects initialization. If anybody is willing to read a document and consider this scenario I am willing to write an RFC.",,
18390,OPEN,Bug: Event handlers on custom elements work on the client but not on the server,Component: Server Rendering; Type: Needs Investigation,2020-08-28 04:24:26 +0000 UTC,esprehn,,"```js
ReactDOMServer.renderToString(<div-x onClick={() => console.log('clicked')} />)
```

vs

```js
ReactDOM.render(<div-x onClick={() => { console.log('clicked'); }} />, root)
```

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://jsfiddle.net/hsug65x0/2/

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

Custom element event handlers only work client side. In SSR the code of the event handler becomes an attribute value.

## The expected behavior

Custom element event handlers work in SSR.
",,
18368,OPEN,May be bug: onChange events don't fire in controlled forms in portals rendered in external window,Component: DOM; Type: Needs Investigation,2020-04-27 16:57:33 +0000 UTC,ZYinMD,,"React version: 16.13.1

I may be using Portal in a way that's not intended, which is why I had this bug, but at least it's not mentioned in the doc.

## Steps To Reproduce

Demo: [CodeSandbox](https://codesandbox.io/s/kind-morning-t3q9c)

Inspired by [this blogpost](https://medium.com/hackernoon/using-a-react-16-portal-to-do-something-cool-2a2d627b0202), I open a new browser window with `window.open()`, then render a portal in it, so the two windows belong to the same react app, and share states. It works like magic, but I find that the `onChange` events of controlled forms (like `input` or `select`) don't fire.

## The current behavior
As shown in the sandbox, my controlled `input` and `select` components work well in normal portals, but same components don't work in portals in external window. 

## The expected behavior
I hope they just work the same.

If it can't work, I'll need to use uncontrolled forms.",,
18314,OPEN,Bug: React-test-renderer error when updating state in act,Component: Test Renderer; Resolution: Stale,2020-12-25 15:06:34 +0000 UTC,ahummel25,,"
<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: [Here](https://codesandbox.io/s/dazzling-kare-nxtfs) is a reproducible link.

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
It's worth noting this example is using material-ui as a dependency. Regardless, I believe the test should still pass.

 When updating state in my component, a drawer component opens and closes depending on a boolean value. Code works fine in the browser. When running the above test, it fails with a trace error that includes the below.

```
TypeError: parentInstance.children.indexOf is not a function
    at appendChild (https://psnrk.csb.app/node_modules/react-test-renderer/cjs/react-test-renderer.development.js:720:39)
```

Here I am drilling down to a child anchor tag to access its `onClick` function. As you'll see in the sandbox example, I am passing it a `mockEvent` because the handler first calls `event.preventDefault`. 

This does not cause any issues. The error occurs when the `setOpen` hook function gets called. Just wanted to point that out.
```
act(() => {
    tree.root.children[0].props.children.props.children.props.onClick(mockEvent);
});
```

Same error happens when I try to initiate the `onClose` handler of the `Drawer` component:

```
act(() => {
    tree.root.children[1].props.onClose(mockEvent);
});
```

## The expected behavior

Test should pass. The state should be properly updated in the `onClick` handler or the `onClose` handler and I should be able to make further assertions after that.

If this is not the best way to execute a click event with `react-test-renderer` please let me know. I was looking for examples and it seemed like this was the way to do it.",,
18229,OPEN,[Feature Request] Allow dependency length to change in hooks,,2021-02-18 16:45:12 +0000 UTC,georeith,,"Not allowing dependency lists to change size limits the usefulness of `useMemo` in this particular use case but I imagine there are other similar use cases.

To be clear I am talking about the error triggered here:

https://github.com/facebook/react/blob/024a764310e64ef38963df16970364b9942a60cd/packages/react-reconciler/src/ReactFiberHooks.js#L322

For instance, in my app I have a bunch of items and the user can select an unlimited amount of them, in another component I want to compute an expensive derived value based on this selection that is relevant only to this component, a good use case for `useMemo`.

However it is not currently possible to use `useMemo` and I am forced to compute this derived data outside of this component even though I am only interested in doing so whilst this component is mounted.

I don't understand why a change in dependency list length cannot be assumed to be a change in the dependencies itself?

I believe this can be implemented by changing the above to:

```js
if (prevDeps.length !== nextDeps.length) {
    return false;
}
```",,
18128,OPEN,Bug: input won't trigger onChange after a chain of setStates,Type: Bug,2020-08-26 16:08:00 +0000 UTC,voliva,,"## Steps To Reproduce

1. Create a controlled input element
2. Add an `onKeyDown` event handler that will change a state.
3. Add a `useEffect` hook that depends on the state from (2.), and changes another state
4. Try to type in something in the input

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/nostalgic-lake-zzynt

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
The input updates with the key the user has pressed

## The expected behavior
The input doesn't update. The handler for `onKeyDown` was called, but the handler for `onChange` wasn't.
",,
18116,OPEN,React retains component references to old renders causing browser memory to increase,Type: Needs Investigation,2020-08-18 07:44:13 +0000 UTC,tsjohns9,,"## The current behavior
React appears to retain references to old renders of components which prevents the browser from running the garbage collector on unused memory.

## The expected behavior
React should release the memory of components from previous renders

## Description
I have a web app that imports an OAS 3/Swagger 2.0 json spec file, and renders the file using the swagger-ui component, https://github.com/swagger-api/swagger-ui.

These json files can be very large. If I upload a file that is 500kb and pass it into the swagger-ui component the heap snapshot in chrome will show about 32.6 MB being used to render the app.

At some point during the lifecycle of this component the spec file may be updated by a user. When this happens the swagger-ui component will re-render. Between re-renders I can see from my heap snapshot that about 15 more mb are added to the heap.

Even if this component is completely unmounted, the memory is still retained and cannot be garbage collected.

I would expect that after a re-render the heap size would be about the same, and the old references would be released for garbage collection.

I have come here with this issue and not swagger-ui because based on the heap snapshots the detached DOM elements are being retained by React directly.

The spec file that I have used is about 500kb. Unfortunately it is a proprietary file and I cannot share it here. Instead, I have provided a spec file from swagger-ui. This file is much smaller, but it will serve the purpose of showing how react is retaining references to old component renders. In my situation since the file is so large this becomes much more apparent to the user that there is a problem than with a much smaller json file.

![Screen Shot 2020-02-24 at 1 17 42 PM](https://user-images.githubusercontent.com/24981281/75188107-c97d2c00-5708-11ea-95dd-7320d75cbf99.png)
![Screen Shot 2020-02-24 at 1 21 30 PM](https://user-images.githubusercontent.com/24981281/75188095-c2eeb480-5708-11ea-9ede-c6f29452dde5.png)

## Steps To Reproduce
1. View the app [here](https://tsjohns9.github.io/react-memory-leak/)
2. Open the console, and take a heap snapshot
3. Press the Update Spec button in the top left of the app, or the Unmount button
4. Take another heap snapshot.
5. You will see that the heap size has increased
6. Compare the two heap sizes and check to see how many new detached objects there are. Here is a screenshot as an example
![Screen Shot 2020-02-24 at 1 26 19 PM](https://user-images.githubusercontent.com/24981281/75188470-6c35aa80-5709-11ea-956b-61022e80fa4b.png)

Link to code example: https://tsjohns9.github.io/react-memory-leak",,
18101,OPEN,"Arbitrary log lines may appear in between an error and the subsequent ""The above error…"" message",Type: Bug,2020-09-16 18:56:48 +0000 UTC,sophiebits,,"React version: 16.12

If one component throws, and one of its siblings logs something else to the console, that sibling's logs appear in between the throwing component and the extra React information about that throw.

This is hard to explain in words but easy to explain in code and pictures, so look:

Repro: https://codesandbox.io/s/boring-firefly-bu79e

![image](https://user-images.githubusercontent.com/6820/75078940-d822d380-54bb-11ea-99d2-c77fbc0c9a5b.png)

The third log line (""The above…"") refers to the first (""Uncaught…"") but looks like it refers to the second (""Please don't…""). This is confusing when debugging.

Instead, I would expect ""The above error…"" to be right below the uncaught window-level exception we raise. (Maybe this isn't possible without diverging dev vs. prod behavior? Not sure but thought I'd file…)",,
18098,OPEN,Bug: Unexpected render,Type: Bug,2020-12-26 08:36:58 +0000 UTC,TriStarGod,,"
## The current behavior

[Sample 1][1] - Initially renders once. Regardless of the number of times the button is clicked, it doesn't render. This is expected.

    import React, { useState } from ""react"";
    import ""./styles.css"";
    
    export default function App() {
      const [state, setState] = useState([
        { id: 1, name: ""test1"" },
        { id: 2, name: ""test2"" }
      ]);
      const onClick = () => setState(data => data);
      console.log(""App rendered"");
      return (
        <div className=""App"">
          <h1>Test if setting same data causes re-rendering</h1>
          <button onClick={onClick}>Call setState with same data</button>
          {state.map(({ id, name }) => (
            <p key={id}>{name}</p>
          ))}
        </div>
      );
    }


[Sample 2][2] - Initially renders twice since `useEffect` updates `setMessages` with a value. This is expected. However, if the button is click 1+ times, it renders once. It shouldn't even re-render since the same value is being set. **Why is it rendering if no new value / reference is being updated?**

    import React, { useState, useEffect, useMemo, useCallback } from ""react"";
    import axios from ""axios"";
    import ""./styles.css"";
    
    const days = [
      ""Sunday"",
      ""Monday"",
      ""Tuesday"",
      ""Wednesday"",
      ""Thursday"",
      ""Friday"",
      ""Saturday""
    ];
    export default function App() {
      const [messages, setMessages] = useState([]);
      useEffect(() => {
        axios
          .get(`https://api.myjson.com/bins/10xva4`)
          .then(({ data: { messages } }) => setMessages(messages));
      }, []);
      const Display = useMemo(
        () =>
          messages.map(({ content, senderUuid, sentAt }, index) => {
            let d = new Date(sentAt);
            return (
              <div className=""container"" key={index}>
                <p>Content: {content}</p>
                <p>SenderUuid: {senderUuid}</p>
                <p>DayOfTheWeek: {d.getDate()}</p>
                <p>Month: {d.getMonth()}</p>
                <p>Day: {days[d.getDay()]}</p>
                <p>Year: {d.getFullYear()}</p>
              </div>
            );
          }),
        [messages]
      );
      const onClick = useCallback(() => setMessages(messages => messages), []);
      console.log(""App rendered"");
      // console.log({ messages });
      return useMemo(
        () => (
          <div className=""App"">
            <button onClick={onClick}>Call setMessages with same data</button>
            {Display}
          </div>
        ),
        [Display, onClick]
      );
    }


  [1]: https://codesandbox.io/s/testing-rendering-bo9bp
  [2]: https://codesandbox.io/s/call-api-with-useeffect-vlo34

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

## The expected behavior

Should not re-render if no new value or reference is updated.
",,
18051,OPEN,"Bug: [eslint-plugin-react-hooks] exhaustive-deps false positive on ""unnecessary"" dependency if its a React component",Component: ESLint Rules; Type: Bug,2020-10-17 08:24:03 +0000 UTC,zeorin,,"## Steps to reproduce

1. create a memoized value using `useMemo`
2. a React component is used in the creation of this value, in a JSX expression
3. specify the React component in the dependency array

Link to code example: https://github.com/zeorin/eslint-plugin-react-hooks-repro

## The current behavior

```
React Hook useMemo has an unnecessary dependency: 'Component'. Either exclude it or remove the dependency array react-hooks/exhaustive-deps
```

## The expected behavior

No lint errors.

## More details

A simple repro (taken from the link above) is:

```javascript.jsx
function Foo({ component: Component }) {
	const memoized = useMemo(() => ({
		render: () => <Component />
	}), [Component]);

	return memoized.render();
}
```

## Workarounds

If one changes the component to lowercase, the lint error goes away. It does also mean that we need to change the way we render the component:

```javascript.jsx
function Foo({ component }) {
	const memoized = useMemo(() => ({
		render: component
	}), [component]);

	return memoized.render();
}
```

Alternatively we can decide not to use JSX, in which case the lint rule functions correctly, too:

```javascript.jsx
function Foo({ component: Component }) {
	const memoized = useMemo(() => ({
		render: () => React.createElement(Component)
	}), [Component]);

	return memoized.render();
}
```

## Impact

Currently it is hard to use props that are components in a JSX expression if one is using the `exhaustive-deps` rule.

This is also compounded by the fact that this rule has a ESLint fix that removes the dependency, thus changing the behaviour of the code and leading to bugs. See https://github.com/facebook/react/issues/16313 for that bug report.",,
18006,OPEN,Bug: useTransition's pending boolean is triggered immediately; even if there's no suspension,Component: Concurrent Mode; Resolution: Backlog; Type: Enhancement,2020-08-14 22:23:54 +0000 UTC,arackaf,,"1.  https://codesandbox.io/s/cranky-wing-lc7wr
2. Swap between the two screens by clicking the two buttons
3. Inline loading shows the first time you load screen A. But it also usually shows on subsequent loads, even though there's nothing Suspending

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

Inline loading indicator usually shows on subsequent loads.

## The expected behavior

It should only show on the first load of A",,
17997,OPEN,Bug: React Dev Tools Firefox extension fails to detect React,Component: Developer Tools; good first issue,2021-02-14 04:51:26 +0000 UTC,Kein,,"React extension version: 4.4.0

## Steps To Reproduce

1. Install Firefox 72.0.2x64
2. Go to Discordapp.com

## The current behavior
Extension reports: _""This page does not appears to be using React""_

## The expected behavior
React is detected (just like it is currently in Chrome/Chromium)",,
17953,OPEN,Bug: useReducer runs the queued updates with new props,Component: Hooks; Type: Bug,2020-11-13 08:52:03 +0000 UTC,a-c-sreedhar-reddy,,"<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://codesandbox.io/s/usereducer-wfcmq Link to codesandbox.

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Initially step is 0. So for every step react does not rerender due to this https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L1347. But state updates are queued. So when `step` changes all the state updates are done and hence creates a bug by adding the new step prop.

https://overreacted.io/a-complete-guide-to-useeffect/#why-usereducer-is-the-cheat-mode-of-hooks",,
17938,OPEN,Bug: Render-phase update to another root causes an over-rendering loop,Type: Regression,2020-01-30 17:08:04 +0000 UTC,gaearon,,"```js
    let container1 = document.createElement('div');
    let container2 = document.createElement('div');

    function Root1() {
      _setX(x => x + 1);
      return 'Hello';
    }

    let _setX = () => {};
    function Root2() {
      console.log('Root 2')
      let [x, setX] = React.useState(0);
      _setX = setX;
      return <div>{x}</div>
    }

    const root1 = ReactDOM.createRoot(container1);
    root1.render(<Root1 />);
    const root2 = ReactDOM.createRoot(container2);
    root2.render(<Root2 />);
```

Expected: `Root2` renders twice.
Actual: `Root2` renders a non-deterministic number of times.

This bisects to https://github.com/facebook/react/pull/15755, which removed the `5000` clamping. Without it, we get updates that have a slightly larger timeout than `5000`, and so the loop doesn't stop until we get to `5000`.",,
17899,OPEN,Bug: styles object using css variables and both a shorthand and a specific property renders incorrectly,Component: DOM; Type: Discussion,2020-04-11 23:19:58 +0000 UTC,joaomoleiro,,"React does not produce the correct css inline styles when using css variables for both the shorthand property and another specific one (like `padding` and `paddingRight`).

The styles object:

```js
{
  padding: ""calc(var(--spacing) * 1)"",
  paddingRight: ""calc(var(--spacing) * 3)"",
  paddingBottom: ""calc(var(--spacing) * 4)""
};
```
produces the following styles:

![image](https://user-images.githubusercontent.com/23476208/72995030-1d39e400-3df0-11ea-9235-0e6ad00718b2.png)

and the following html:
```html
<span style=""padding-top: ; padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4); padding-left: ;"">App</span>
```

even though the computed properties tab of the dev-tools appear to be correct and the padding is properly rendered in the screen:

![image](https://user-images.githubusercontent.com/23476208/72995225-6e49d800-3df0-11ea-9770-98f062008ca3.png)

If I remove the css-variable, everything works as expected.

**React version**: From v15.0.0 to 16.12.0

_Note_: Below v15.0.0 the styles are correctly produced:

```html
<span style=""padding:calc(var(--spacing) * 1);padding-right:calc(var(--spacing) * 3);padding-bottom:calc(var(--spacing) * 4);"">App</span>
```


## Steps To Reproduce

1. Add a style object to a component that has both a property shorthand and a specific one (like `padding` and `paddingRight`) and uses a css variable (like `var(--spacing)`.
2. Render that component and inspect using dev-tools.

Link to code example: https://codesandbox.io/s/heuristic-wood-bjr1y

styles object:
```js
{
  padding: ""calc(var(--spacing) * 1)"",
  paddingRight: ""calc(var(--spacing) * 3)"",
  paddingBottom: ""calc(var(--spacing) * 4)""
};
```
## The current behavior

React does not produces the correct css inline styles when using css variables for both the shorthand property and another specific one:

```html
<span style=""padding-top: ; padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4); padding-left: ;"">App</span>
```

## The expected behavior

Inline styles using css variables that have both a shorthand and a specific one should produce the correct styles.
```html
<span style=""padding: calc(var(--spacing) * 1); padding-right: calc(var(--spacing) * 3); padding-bottom: calc(var(--spacing) * 4);"">App</span>
```",,
17894,OPEN,Bug: button onFocus not called when focus() called from useEffect cleanup,Component: DOM; Type: Needs Investigation,2020-10-09 13:08:03 +0000 UTC,fyodore82,,"1. Have a `<button/>` HTML element with `onFocus` event handler defined
```
<button ref={btnRef} onFocus={() => console.log(""I'm in focus"")}>Focus Target</button>
```
2. Have another component with `useEffect` cleanup code which will call `focus()`
```
React.useEffect(() => {
  const ref = btnRef.current;  // btnRef is a ref to the button component above
  return () => {
    console.log(""effect cleanup "", new Date().toISOString());
    ref.focus();
  };
}, []);
```

When the cleanup code from `useEffect` is called, `onFocus` event handler of the `button` is not called. The `button` is rendered in a component which is mounted when `useEffect` cleanup executes. For example it can be in the parent component.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/onfocus-not-called-from-useeffect-cleanup-npw7k

1. Open example in browser (tested in Chrome 79.0.3945.88 and in Firefox 72.0.1).
2. Open dev console
3. Click on Focus target button. See another component below it with two buttons.
4. Remove focus from Focus target button by setting it in adjacent input field 
5. Click on Set focus button. Observe that focus is set to Focus target button and in console see message 'I'm in focus...'. This message is logged from `onFocus` event handler
6. Remove focus from Focus target button.
7. Click Close me button. Observe that focus is set to Focus target button but no message in console from `onFocus` event handler

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
`onFocus` is not called

## The expected behavior
`onFocus` is called",,
17855,OPEN,Bug: DevTools DOM highlighting gets stuck after a prolonged hover,Component: Developer Tools; Type: Bug,2021-03-16 14:24:19 +0000 UTC,gaearon,,"## Steps To Reproduce

1. Hover a component in DevTools
2. *Keep hovering it for a second or so*
3. Quickly move the cursor out of the DevTools without hovering anything else

Expected: DOM highlighting goes away.
Actual: DOM highlighting gets stuck.

![](https://d1sz9tkli0lfjq.cloudfront.net/items/2o2r240l0o3i1B0d1n3J/Screen%20Recording%202020-01-16%20at%2005.14%20PM.gif?v=e1a91e13)",,
17831,OPEN,Bug: I shouldn't own the DOM fixtures website,Component: Build Infrastructure; Type: Needs Investigation,2020-01-15 19:19:46 +0000 UTC,nhunzaker,,"Some folks at Google are helping us to think through some ideas to help our input code be more sane, and we discovered that our DOM Text Fixtures site (http://react-dom-fixtures.surge.sh) was both:

- _Very_ out of date
- Owned by me

Both seem fixable. However I think a good first start is to figure out a way to publicly host the fixtures where I am not a bottleneck.

What do you think? Could we setup a deploy process - maybe with netlify - to deploy the fixtures automatically?",,
17794,OPEN,"flushPassiveEffects and IsThisRendererActing are on the wrong ""secret"" object",Component: Test Utils; React Core Team,2020-01-08 19:07:45 +0000 UTC,sebmarkbage,,"They're currently attached to the ""Events"" namespace but they don't have anything to do with events. It needs to move to its own names on the secret object.

Once we delete Events, after ReactTestUtils and RNW are fixed, then we won't be able to clean up the array because these two are on it.

Additionally the IsSomeRendererActing field is in the production bundles.

We need to make all of these DEV-only.",,
17779,OPEN,SuspenseList tail property not working on re-renders,Component: Concurrent Mode; Component: Suspense; Type: Discussion,2020-01-09 20:04:57 +0000 UTC,kmurgic,,"
When a component with a SuspenseList re-renders (such as when it is is passed a new resource), the SuspenseList component still  respects the revealOrder=""forwards"" or revealOrder=""backwards"" prop but does not respect the tail=""collapsed"" or tail=""hidden"" prop.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/exciting-cherry-g9uc9

In order to see bug: 
1) Refresh the Code Sandbox browser and see that ""Loading profile..."" displays and ""Loading posts..."" does not due to the tail being collapsed.  This is the expected behavior.
2) Press the ""Next"" button.  Both ""Loading Profile..."" and ""Loading posts..."" display.  The tail is no longer collapsed.

**What is the expected behavior?**

The expected behavior would be for the tail to be collapsed when pressing the ""Next"" button. ""Loading profile..."" should be displayed, but not ""Loading posts...""

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

This affects only the experimental Concurrent Mode build of React.
",,
17741,OPEN,hydrate SVG error: Expected server HTML to contain a matching <clipPath> in <svg>,Component: DOM; Type: Bug,2020-01-07 06:22:08 +0000 UTC,benbot,,"
**Do you want to request a *feature* or report a *bug*?**

bug

**What is the current behavior?**

It seems like `ReactDOM.hydrate` doesn't play nice with certain kinds of inline SVGs.
Specifically ones that have `clipPath`s

When nextjs tries calling hydrate on a page with one of these SVGs, the offending part of the svg flashes quickly then react throws this error to the console.

```
Expected server HTML to contain a matching <clipPath> in <svg>.
```

I have a very small example of this happening here https://github.com/Delray-Devs/site/tree/brokenSVG

The strange part is when next builds the site statically it all works.

I originally opened this issue on zeit/nextjs, but @timneutkens suggested I open the issue here.

See https://github.com/zeit/next.js/issues/9871 for all the details.

**What is the expected behavior?**

The SVG containing the `clipPath` gets rendered correctly on the client side.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React: 16.12, not sure about previous versions
Browser: Firefox and Chrome
OS: macOS
",,
17624,OPEN,React DevTools might retain references to unmounted DOM elements (and their Fibers),Component: Developer Tools; Partner; Type: Needs Investigation,2020-01-08 23:38:18 +0000 UTC,bgirard,,"![Screenshot 2019-12-16 10 51 05](https://user-images.githubusercontent.com/793565/70934095-fd91ed80-1ff1-11ea-93b5-746e816585ec.png)
There's seems to be circumstances where unmounted DOM/Fibers are kept alive by React DevTools. They're kept alive in `primaryFibers`:
https://github.com/facebook/react/blob/34527063083195558f98108cde10b5d6ad0d6865/packages/react-devtools-shared/src/backend/renderer.js#L772

It seems like a WeakSet would be appropriate and would remove the leak. Otherwise we'd need to understand why recordUnmount isn't called.

CC @bvaughn  ",,
17609,OPEN,Controlled numeric input gets cleared when unfocused,Component: DOM; Resolution: Backlog; Type: Bug,2020-04-01 20:58:15 +0000 UTC,kripod,,"
**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

1. Open [this sandbox](https://codesandbox.io/embed/sad-rgb-mltuj)
2. Type “12.” into the field, with the trailing decimal separator
3. Unfocus the control
4. Append “.” to the field’s value to see “12..”
5. Unfocus the control once again and see that the number has completely disappeared

**What is the expected behavior?**

Similar to how uncontrolled inputs work (remove the `value` prop and then repeat the steps above), the input should not be cleared on blur.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

I’m using React 16.12.0 and experienced the same behavior with the latest version of Chrome and iOS Safari. Regarding this bug, I have no experience with previous versions of React.
",,
17594,OPEN,DevTools: Profiler: Enable correlating console logs to profiler output (and vice versa),Component: Developer Tools; Type: Discussion; Type: Needs Investigation,2019-12-20 22:42:06 +0000 UTC,justingrant,,"A challenge with the React DevTools profiler is that it's too hard to correlate profiler results with console logs. This makes diagnosing and fixing render performance issues much more difficult.

For example, yesterday I was debugging an app where each render usually took 10ms-20ms except every 20-30 renders it'd take 600-800ms.  It was frustrating that I didn't have a way to correlate the profiler UI (which told me which renders were problematic) with the verbose console log output that might tell me exactly what went wrong during those renders. Instead I had to comb through logs and guess which output came from ""bad"" renders. This was tedious and error-prone.

Anyway, my proposal is for React DevTools to make it easy to correlate profiler results with console log output.  Both directions would be useful:
1) **navigate from logs to profiler** - if I see a suspicious line in the logs, I'd like to easily navigate to the profiler with the specific component/commit selected that was running when the line was logged.
2) **navigate from profiler to logs** - if I see a suspiciously long commit, I'd like to select it in the profiler pane and have an easy way to see associated logs.

I don't have a strong opinion about how this should be accomplished, but below are a few ideas to spur discussion.

A minimal solution could be something like this: 
a) The profiler assigns a unique ID to each commit
b) The profiler's right pane would show the ID for each commit
c) React would add a new hook that'd return that ID
d) Userland code could include the ID in logs.

Just this minimal support would be a vast improvement.

If we wanted to make it smoother, here's a few ideas that could be layered on top.

1. **Profiler->Console Links** The ID in the profiler UI could be a hyperlink that'd open the console drawer and put the ID in the console's CMD+F search box. This would be one-click navigation from profiler to logs. I don't know if Chrome allows this kind of cross-pane control, over the console UI so this might not be practical.

2. **Console -> Profiler Links**  For one-click logging in the other direction., we could have a special URL format (e.g. `react://profiler/commit/2c1056b5-1be1-43d4-a105-1d840cf4f9c3`) that would enable userland code to emit links in the console that, when clicked, would navigate to the specific commit (in the profile pane) that was active when the logs were emitted. Similar caveat as above: I'm not sure if chrome extensions can be ""deeplinked"" like this. 

3. **Log Components Where** Building on (1) and (2) above, we could enable console<->profiler linking without requiring changes to userland code. We could have a profiler setting (e.g. ""log components where"" with UX like ""hide components where"") that, when active, would emit a line to the console log at the start of each render of a matching component. The output would link back to the profiler, e.g. 
`[RDT] Starting MyCoolComponent (react://profiler/commit/2c1056b51be143d4a1051d840cf4f9c3)`.

What do you think? I'm unfamiliar with React and RDT internals so there might be much better ways to solve log<->profiler correlation than my naive ideas above. But at least I wanted to call out the problem and encourage discussion about a solution.
",,
17581,OPEN,Input nodes leaked by the browser retain React fibers,Type: Needs Investigation,2020-05-13 17:02:24 +0000 UTC,albertxing,,"**Do you want to request a *feature* or report a *bug*?**

🐛 

**What is the current behavior?**

Browsers retain references to inputs in their undo stacks, which in turn retain React fibers (including `memoizedProps`)

See https://bugs.chromium.org/p/chromium/issues/detail?id=1029189

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://jsfiddle.net/altxg/nzu6ab5e/3/

**What is the expected behavior?**

Although the leak originates from the browser, it might be helpful if React detached internal fiber references from input and contenteditable nodes on unmount

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

All versions of React as far as I know.
I can reproduce the leak on Chrome and Firefox on Mac

---

Potentially related issues:
https://github.com/facebook/react/issues/12692
https://github.com/facebook/react/issues/16087",,
17553,OPEN,DevTools: Provide full file path for React Native component stacks,Component: Developer Tools; Partner,2020-01-08 23:38:18 +0000 UTC,rickhanlonii,,"## Overview

In React Native, we're working on a new RedBox experience for errors and warnings called LogBox. In LogBox, we separate out component stack traces and show them similar to call stacks.

We'd like to be able to tap on these components and open them (like we can with call stacks).

## Solutions
In React we have the full file path context, but when we build the component stack trace, we strip the full path so that it displays only the file name.

There are two options to achieve this:
- For React Native, don't strip the full path [here](https://github.com/facebook/react/blob/b438699d3620bff236282b049204e1221b3689e9/packages/react-devtools-shared/src/backend/describeComponentFrame.js#L25). This will result in longer component stack messages with every frame having the full path.
- Keep the message the same, and instead add structured component stack frame info including the full file path.",,
17494,OPEN,Undo behavior in controlled input doesn't work as expected,Component: DOM; Type: Needs Investigation,2020-06-23 10:30:12 +0000 UTC,oliviertassinari,,"
1. Load https://codesandbox.io/s/material-demo-8wgfs.
1. Focus the first input.
1. Type <kbd>a</kbd>.
1. Press <kbd>Tab</kbd> to focus the second input.
1. Type <kbd>a</kbd>.
1. Use Ctrl/Cmd+Z or Edit->Undo to undo these two changes.

Notice that the uncontrollable input change is reverted
Notice that the controllable input change is **not** reverted

![undo](https://user-images.githubusercontent.com/3165635/69901991-fb405a00-1388-11ea-9085-ddd4131a42a9.gif)

**What is the expected behavior?**

uncontrollable & controllable inputs behave identically.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React 16.12.0
Chrome 78.0.3904.108
macOS 10.14.6

First reported in https://github.com/mui-org/material-ui/issues/18545.
",,
17436,OPEN,What will suspense look like for the streaming case?,Component: Suspense; Type: Discussion,2019-11-22 16:21:05 +0000 UTC,benlesh,,"
I'm very curious what the public API will be for Suspense in streaming cases. The work I do or have pretty much always done in React involves dealing with streams of data, generally coming over a web socket. What will it look like? Will it be easy for users to implement/use? Is a promise/thenable an appropriate type for dealing with this even internally, given that the first value may never show up?

### Desire

The ability to leverage suspense to ""suspend"" until the first of many values arrives from a stream of data coming from any source. For the sake of conversation, we'll say a web socket.


### Constraints

- The first value may never arrive
- The source may close without error, having never provided a value
- There must be an ergonomic teardown mechanism, for example how developers can currently teardown in the returned function of `useEffect` or in `componentWillUnmount`.
- There may be more than one value returned by the streaming source

### Optional constraints

- The first N values form the source may be synchronous (followed by asynchronous values)

### Scenario

A simple app with two routes, one where the app needs to open a web socket connection and collect streaming data, and the other where the socket connection should be closed. The values from the web socket may take long enough that the developer will want to move to that routed component right away and show some spinner with suspense until the first bit of data arrives. If the user navigates to the first route, then leaves before the first value arrives, what happens?

My concern is, that if, even internally, the mechanism is a promise or thenable, there is a chance leaks will be created in the event that the source of that first value is torn down before the first value arrives. The only way, with a thenable or promise, to avoid that chance would be to make sure that the teardown mechanism was somehow tied to the thenable, so that the thenable to be rejected (or resolved) with a known value, such that it will be ""settled"".",,
17425,OPEN,"SuspenseList revealOrder=""forwards"" has issues when Suspense is nested in another element",Component: Concurrent Mode; Component: Suspense; Type: Needs Investigation,2020-02-20 04:59:44 +0000 UTC,kentcdodds,,"**Do you want to request a *feature* or report a *bug*?**

SuspenseList is currently experimental, so it's neither. But I think that this should be fixed before it's stable.

**What is the current behavior?**

![Screen Recording 2019-11-21 at 12 39 56 PM](https://user-images.githubusercontent.com/1500684/69371223-a6039a80-0c5c-11ea-9fd4-848a3f1672fa.gif)

Note the 1000ms at the bottom (which should show last based on the `revealOrder`) shows at 2000ms for the nested version.

The only difference between those two sets of SuspenseLists is that one has nested the two bottom suspense elements in a `div`. Something like this:

```javascript
function App() {
  return (
    <SuspenseList revealOrder=""forwards"">
      <Suspense fallback={<div>2000ms loading</div>}>
        <A />
      </Suspense>
      <div> {/* nesting */}
        <Suspense fallback={<div>3000ms loading</div>}>
          <B />
        </Suspense>
        <Suspense fallback={<div>1000ms loading</div>}>
          <C />
        </Suspense>
      </div> {/* nesting */}
    </SuspenseList>
  )
}
```

https://codesandbox.io/s/suspenselist-issues-sdqzb

**What is the expected behavior?**

I would expect them to behave exactly the same. Nesting things is often necessary for styling reasons.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

I'm experiencing this on `react@0.0.0-experimental-b53ea6ca0` and `react-dom@0.0.0-experimental-b53ea6ca0`. I don't believe this ever worked in previous versions of React.",,
17386,OPEN,Feature Request: Soft Component,Type: Discussion,2019-11-19 14:24:25 +0000 UTC,hackwaly,,"```
import React, {useState} from 'react';
import ReactDOM from 'react-dom';

function PageLayout({title, children}) {
  return <div>
    <h1>{title}</h1>
    <input type=""text""/>
    {children}
  </div>;
}
function Page2({setPage}) {
  return <PageLayout title=""Page2"">
    <button onClick={() => {setPage(() => Page1);}}>Test</button>
  </PageLayout>
}
function Page1({setPage}) {
  return <PageLayout title=""Page1"">
    <button onClick={() => {setPage(() => Page2);}}>Test</button>
  </PageLayout>
}
function App() {
  let [Page, setPage] = useState(() => Page1);
  return <Page setPage={setPage}/>; 
}
ReactDOM.render(<App />, document.getElementById('app'));
```

https://codesandbox.io/embed/serene-browser-tehj4?fontsize=14

The above code is most intuitive pattern for build multiple page web app. -- Don't mind the setPage. Just focus Page component returns PageLayout instance.

But react's diff algorithm is not optimized for that pattern.  If you click ""Test"" button. The text you inputed in input will lost.

So I proposal ""Soft Component"" concept. Two soft component will be treated as same component in diff algorithm. In the example, we change Page1 and Page2 to soft components. Thus solve the problem I shown above.",,
17355,OPEN,Should not already be working in Firefox after a breakpoint/alert,Difficulty: medium; Type: Bug; Type: Needs Investigation; good first issue,2021-03-24 19:33:21 +0000 UTC,gzzo,,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
I'm seeing ""Error: Should not already be working"" after upgrading to React 16.11

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

This is exclusively happening on an older version of Chrome, 68.0.3440 on Windows 7

I was unable to reproduce this in a VM environment but our Sentry is getting littered with these errors. 

I know it's a long shot, but I wasn't able to find any information about this error anywhere, just a reference in the error codes file in react, so thought it would be a good idea to report this just in case. Curious if anyone has seen this.
",,
17352,OPEN,Upgrade Rollup to 0.68.1+,Component: Build Infrastructure; Type: Bug,2020-03-15 07:58:32 +0000 UTC,MicahZoltu,,"**Do you want to request a *feature* or report a *bug*?**
Bug-ish.

**What is the current behavior?**
`import 'react'` (where 'react' is the UMD module build) from an ES module will fail due to https://github.com/rollup/rollup/pull/2274.  `this` is not set in the context of ES modules, so if you try to `import 'react'` in that context you will get a runtime error since `this` is undefined and Rollup (before the linked fix) tries to use `this` when it really means `globalThis` or `self`.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
```
npm install react
```
`index.html`
```html
<!DOCTYPE html>
<head><meta charset='utf-8'></head>
<body>
	<script type='module'>
		import './node_modules/react/umd/react.development.js'
	</script>
</body>
```

**What is the expected behavior?**
The React UMD module can be loaded by an ES module.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React: 16.11.0
Firefox: 70.0.1
Windows 10",,
17351,OPEN,Possibility to set min duration of Suspense fallback,Component: Concurrent Mode; Resolution: Backlog; Type: Feature Request,2021-01-24 11:11:39 +0000 UTC,tonix-tuft,,"**Do you want to request a *feature* or report a *bug*?**
Feature

**What is the current behavior?**
I have played a bit with Concurrent Mode and the Suspense API.
Really exiting features and I look forward to use them in a stable release. Thank you for everything you are doing!

Regarding the `Suspense` component, could it be nice to have a property (both in Concurrent Mode and in ""normal/synchronous"" mode) which would allow us to set the minimum duration of the `Suspense` fallback UI in case the fallback UI ever gets rendered?

**What is the expected behavior?**
Let me do an example. Try clicking on the `Next` button in this codesandbox: 
https://codesandbox.io/s/cold-monad-ifr29.

You will see that the `Suspense` fallback UI is rendered and stays in the tree just for a little moment (`~200ms`) because both promises resolve in `1200ms`, while `useTransition` has a `timeoutMs` of 1 second.
In my opinion, this is a bit unpleasant to the eye.

Wouldn't it be nicer if we could tell the `Suspense` component something like ""If you ever render the fallback, show it for at least N millisec.""? E.g.:

```jsx
...
function ProfilePage({ resource }) {
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}
      // If the fallback ever gets rendered,
      // it will be shown for at least 1500 millisec.,
      // even if the promise resolves right after rendering the fallback.
      fallbackMinDurationMs={1500}>
      <ProfileDetails resource={resource} />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
    </Suspense>
  );
}
...
```

Consider an animated spinner used as a fallback of `Suspense`, if it happens that the promise resolves just a few milliseconds after rendering the fallback like above, the spinner will be rendered and suddenly disappear, without completing its animation cycle and showing an incomplete animation.

Whereas, if we could keep the spinner in the tree for at least `fallbackMinDurationMs` millisec. once rendered, we could improve its appearance in such cases.

The `Suspense` component responsible for rendering the fallback would have to wrap the caught Promise in a promise which would look something like this:

```js
function maxDelayFallbackPromise({
  promise,
  timeoutMs, // ---> This would be the value of `useTransition`'s `timeoutMs`
  onFallback = () => {}, // ---> This code would run in case `timeoutMs` exceeds (i.e. when `Suspense`'s fallback UI is rendered)
  fallbackMinDurationMs
} = {}) {
  // Generate a unique identifier, like a string, a number, in order to identify which promise resolves first...
  const uniqueIdentifier = `promise_value_${Math.random()}`
  return Promise.race([
    promise,
    timeout(timeoutMs).then(() => uniqueIdentifier)
  ]).then(value => {
    if (value === uniqueIdentifier) {
      onFallback()
      return minDelayPromise(promise, fallbackMinDurationMs)
    }
    else {
      return value
    }
  })
}
```

Where `timeout` and `minDelayPromise` are:

```js
function timeout(delayMs) {
  return new Promise(resolve => setTimeout(resolve, delayMs))
}

function minDelayPromise(promise, minDelay) {
  return Promise.all([
    promise,
    timeout(minDelay)
  ]).then(([value]) => {
    return value
  })
}
```

This could also apply to the `isPending` flag of `useTransition`...

Do you think such a feature could improve the UX in such cases?
",,
17306,OPEN,img onLoad does not always fire in concurrent mode,Type: Needs Investigation,2020-02-06 17:21:26 +0000 UTC,peternycander,,"
**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/quiet-dawn-t1std
You might have to use the retry button a few times, but hopefully you should be able to see it. Don't disable cache while trying

**What is the expected behavior?**

onLoad always fires if img gets loaded.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

0.0.0-experimental-f6b8d31a7
Reproduced in chrome and firefox windows. Have not tried the codesandbox in mac, but the actual bug in our app occurred there first so I'd be surprised if it is OS specific.

It does not happen with regular ""sync"" mode.",,
17301,OPEN,react-test-renderer: the findByType method doesn't work with memo components,Component: Test Renderer; Type: Bug,2020-09-25 19:39:43 +0000 UTC,bensampaio,,"
```
ReactTestRenderer.create(<SomeComponent />).root.findByType(SomeMemoComponent);
```

I get the following error: `No instances found with node type: ""undefined""`. The only way I found for this to work was to reference the `type` property of memo components like this:

```
ReactTestRenderer.create(<SomeComponent />).root.findByType(SomeMemoComponent.type);
```

I am fine with this solution but then flow complains that `type` doesn't exist so I find myself fixing this with `$FlowFixMe` all over the place.

**What is the expected behavior?**

I would expect that passing a memo component to `findByType` would work. Or that flow would recognize the `type` property of memo components. I think both should work, specially the first option.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

No, it never worked as far as I know.
",,
17298,OPEN,"Hotkey for ""Select an element in the page to inspect it"" in Chrome extension",Component: Developer Tools; Type: Feature Request,2021-01-26 14:33:35 +0000 UTC,skoshy,,"Reopening https://github.com/facebook/react-devtools/issues/966 as I feel it'd still be a great feature to have.

To reiterate, it'd be great to have a hotkey to trigger the ""Select an element in the page to inspect it"" functionality, similar to how `Ctrl` + `Shift` + `C` triggers Chrome's element inspector mode.",,
17281,OPEN,react-refresh: Dependent functions/data don't trigger refresh,Type: Discussion,2020-07-31 13:51:30 +0000 UTC,lilactown,,"**Do you want to request a *feature* or report a *bug*?**

Both/neither?

**What is the current behavior?**

Currently, react-refresh marks each component whose `type` and/or `signature` has changed as ""dirty"" and will either re-render or re-mount those components selectively.

The problem occurs when the dev tooling (webpack, parcel, etc.) loads a module that exports functions or data that are used inside of components, but aren't registered components themselves. For example, a utility function that concatenates a string:

```js
export greet(name) {
  return `Hello, ${name}!`;
}
```

Changing the returned string to `Yo, ${name}!` would trigger this module to reload in the browser, but because components which depended on it don't reload, the old greeting will persist 
until the next render of each dependent component.

(BTW in actuality, some tooling will reload immediate dependents of modules that are reloaded in order to get around similar problems. You can extend the dependency chain from two to three modules, where `a.js` depends on `b.js` depends on `c.js`, and you will get the same result when editing `c.js`)

What this forces tooling to do is apply a heuristic to try and guess whether a given module should be refreshed, vs. completely restart the app in order to cause all components to re-mount and pick up any changes that wouldn't be picked up by react-refresh.

The problems with the heuristic approach is:
- each dev tool needs to implement this logic, leading to more potential for bugs
- it leads to a degradation of hot reloading capabilities based on what your module exports. not obvious at all on it's face and will lead people to twisting their code base to route around this
- It's very unfriendly to compile-to-JS languages like ReasonML, ClojureScript, etc. which might have different default semantics for what is public / private, different conventions for naming components, etc. which make it difficult to detect whether a module is ""safe"" to refresh

**What is the expected behavior?**

That components depended on newly loaded code will pick up those changes correctly, without losing state.

A potential (maybe naive?) solution to this in react-refresh is, instead of only re-rendering the components marked as dirty (due to a different `type` being registered), to _re-render from the root_ while maintaining hooks state. If components' signatures have changed, then re-mount.

I've read through and kind of grok most of the code in react-refresh, but I'm not sure how this would impact the way that the reconciler currently handles the HMR stuff. This is as much of a question, as it is a request: could this be a viable solution?

I appreciate your time and energy in reading through this. I'm very excited about having first-class support for hot reloading in React, as it's been something that I've loved ever since seeing the first demo of it. I hope that this issue can help create a way to provide a consistently excellent dev experience across tools/platforms/languages!

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React 16.11",,
17276,OPEN,Unexpected value order with useTransition,Component: Concurrent Mode; Type: Discussion,2021-03-11 13:51:28 +0000 UTC,denis-sokolov,,"The order of returned values in useTransition is opposite to what I consider to be an established pattern of `[value, function]`.

Current: `const [startTransition, isPending] = useTransition()`.
Expected: `const [isPending, startTransition] = useTransition()`.
Also fine: `const { startTransition, isPending } = useTransition()`.

## Rationale

The order is in my opinion inconsistent with other hooks, built-in and community hooks, and this inconsistency is somewhat bothersome on the aesthetic level.

Users without tooling support (TypeScript et al) will see `Uncaught TypeError: startTransition is not a function` error whenever they get the order wrong.

Having this insonsistency risks reducing the strength of the convention in the community, making hooks less convenient to use overall.

## Built-in hooks

```js
const [state, setState] = useState();
const [state, dispatch] = useReducer();
const [startTransition, isPending] = useTransition();
```

## Community examples

I have done a quick overview of positional returned values from hooks in the community. Hooks that use `[value, function]` pattern:

[useImmer](https://github.com/immerjs/use-immer#useimmer), [streamich/react-use](https://github.com/streamich/react-use) ([useTimeout](https://github.com/streamich/react-use/blob/master/docs/useTimeout.md), [useSessionStorage](https://github.com/streamich/react-use/blob/master/docs/useSessionStorage.md), [useLockBodyScroll](https://github.com/streamich/react-use/blob/master/docs/useLockBodyScroll.md), [useLocalStorage](https://github.com/streamich/react-use/blob/master/docs/useLocalStorage.md), [useToggle](https://github.com/streamich/react-use/blob/master/docs/useToggle.md)) [bdbch/react-localstorage](https://github.com/bdbch/react-localstorage), [rehooks/local-storage](https://github.com/rehooks/local-storage), [react-rekindle/use-request](https://github.com/react-rekindle/use-request).

Hooks that use `[function, value]` pattern: none.

## Is second value optional?

One could argue that, unlike with other examples, useTransition does not require the user to care about the `isPending` value. However, not using isPending creates a poor UX that the extisting React docs explicitly call out as a problem. We’re supposed to care about isPending. ([docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#adding-a-pending-indicator-adding-a-pending-indicator)).

Besides, even with corrected value order, the user can still ignore isPending at a low cost of an explicit parameter skip (`const [, startTransition] = useTransition()`).

## Can we return an object?

useState returns a list for convenient aliasing:

```ts
const [color, setColor] = useState();
const [position, setPosition] = useState();
```

For hooks that a single component uses only once the benefit is significantly reduced and the community often chooses to return an object with named values instead. This removes the problem of getting positioned values incorrectly and is more inline with the broader JavaScript ecosystem.

I am speculating here, but it seems like a component will often only have one transition, like [the Button example in the docs](https://github.com/reactjs/reactjs.org/blob/081bb31226919062938ef924472ba1b4170facfc/content/docs/concurrent-mode-patterns.md#baking-transitions-into-the-design-system-baking-transitions-into-the-design-system). In that case it seems beneficial to return named values and reserve the positioned return values for cases where it really matters.
",,
17275,OPEN,Is it possible to share contexts between renderers?,Type: Enhancement,2020-12-25 14:10:11 +0000 UTC,diegomura,,"**What is the current behavior?**

Hey 👋 I maintain [react-pdf](https://github.com/diegomura/react-pdf). Thanks for your awesome work and making `react-reconciler` for us to use! 

 I've got many issues  lately regarding context not working on my library and when doing tests I found out that context values aren't shared between renderers. This makes it impossible to share state such as themes, i18n, redux and more. As a bit of context, React-pdf is not a primary renderer, and as such, when used in the browser it runs on top of react-dom.

I found the `isPrimaryRenderer` reconciler option that's supposed to be used for ""multiple renderers concurrently render using the same context objects"" but still any access of the context inside react-pdf components get's just the initial value (even if the context was updated with other value). The same happens for `react-art` that also set `isPrimaryRenderer=false`.

**Minimal demo**

I prepared a quick demo using react-art so you can see how it currently works:

https://codesandbox.io/s/pedantic-hill-54kid?fontsize=14

**What is the expected behavior?**

Share contexts between renderers when using `isPrimaryRenderer` config. Is there a way of achieving this? Am I missing something?

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React: 16.11.0
React-dom: 16.11.0
",,
17256,OPEN,NotFoundError: Failed to execute 'removeChild' on 'Node' when using React.Fragment <></> with Chrome extension which does not modify the DOM tree below the root div of the React app,Type: Needs Investigation,2021-02-24 00:34:03 +0000 UTC,tonix-tuft,,"This has already been discussed before (#14740), but there wasn't a reproducing example for this kind of issue and I think that my use case is also a bit different.

**Do you want to request a *feature* or report a *bug*?**
I believe this can be considered a bug.

**What is the current behavior?**
In order to reproduce this issue using Chrome, you will need to install the following Chrome extension called TransOver:

![Screen Shot 2019-11-03 at 22 51 33](https://user-images.githubusercontent.com/10134421/68092541-86165d80-fe8c-11e9-9f39-e566f770fcb2.png)

https://chrome.google.com/webstore/detail/transover/aggiiclaiamajehmlfpkjmlbadmkledi?hl=en

I use it to translate text on hover.
The only thing that this extension does is appending a tooltip with the translated text to the `body` HTML element when you hover an element with text (it doesn't seem it appends stuff below the React's root `div` element).

I have created two code sandboxes to show you better and explain the problem.
It is a minimal example of a movie app like the one Dan showed at JSConf 2018 in Iceland, though not as beautiful as his and without all that cool Suspense stuff, but at least it uses hooks :) .

- https://codesandbox.io/s/heuristic-lake-exxvu

- https://codesandbox.io/s/magical-grass-016kc

The two code sandboxes are essentially identical, the only difference is that the first one (`heuristic-lake-exxvu`) uses a `div` element for `MovieApp`, whereas the second (`magical-grass-016kc`) uses a `React.Fragment` (`<></>`) component:

`heuristic-lake-exxvu`'s `MovieApp`:

```
const MovieApp = () => {
  const [currentMovie, setCurrentMovie] = useState(initialCurrentMovieState);
  const { isLoading, id: currentMovieId, movieDetails } = currentMovie;
  ...
  return (
    <div> // <======================= Uses a `div`
      {isLoading ? (
        ""Loading...""
      ) : (
      ...
```

`magical-grass-016kc`'s `MovieApp`:

```
const MovieApp = () => {
  const [currentMovie, setCurrentMovie] = useState(initialCurrentMovieState);
  const { isLoading, id: currentMovieId, movieDetails } = currentMovie;
  ...
  return (
    <> // <======================= Uses a fragment
      {isLoading ? (
        ""Loading...""
      ) : (
      ...
```

Now, if you open `heuristic-lake-exxvu` and click on the `Show movie info` button of any movie in the list, you will see the `Loading...` text before the promise with the data of the movie resolves, and the `Movie` component is rendered.

Before the promise resolves, try hovering on the `Loading...` text with the `TransOver` extension enabled, you should see:

![Screen Shot 2019-11-03 at 23 26 48](https://user-images.githubusercontent.com/10134421/68093013-764d4800-fe91-11e9-8b64-2dbdade0a500.png)

The world makes sense here, no errors, no warnings, everything works.

Now try to do the same thing on `magical-grass-016kc`, as soon as you hover `Loading...`, you will see the `NotFoundError: Failed to execute 'removeChild' on 'Node'` error logged in the browser's console:

![Screen Shot 2019-11-03 at 23 40 00](https://user-images.githubusercontent.com/10134421/68093177-49019980-fe93-11e9-9f9b-13f91a12e996.png)

![Screen Shot 2019-11-03 at 23 40 52](https://user-images.githubusercontent.com/10134421/68093194-6df60c80-fe93-11e9-910f-ae748bc9fb91.png)

Here is a streamable video showing this same error:

https://streamable.com/4gxua

**What is the expected behavior?**
In `heuristic-lake-exxvu` (uses a `div` instead of React fragment), everything worked.
The TransOver extension appends to `body` and does not modify the React's root `div` neither does it append stuff below it, so I would expect the code in the React fragment example (`magical-grass-016kc`) to behave the same and work as in `heuristic-lake-exxvu`.

Chrome is plenty of useful extensions like this one and they should not really interfere with React, I think that users using React applications may also install other extensions which modify the DOM which they find useful.
If an extension appends to body like TransOver does, I wouldn't expect React to have problems with it and cause undesirable effects and application errors like this one.

This is my opinion, I would be very glad to hear what you think about it, and if you think I have spotted a bug of React fragments (I think it's a bug because, again, it works when using a `div` in `heuristic-lake-exxvu`).

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Browser: Chrome
React v16.11.0
React DOM v16.11.0


",,
17254,OPEN,"React DevTools w/ Electron: Profiler ""Reload and start profiling"" doesn't work due to XMLHttpRequest 'null' origin",Component: Developer Tools; Type: Discussion,2019-11-02 15:45:02 +0000 UTC,tomsseisums,,"**Do you want to request a *feature* or report a *bug*?**

An error gets thrown when using DevTools Profiler on **Electron** with the ""**Reload and start profiling**"" feature that leaves Profiler in an unexpected state - the profiling session does not end.

I initially opened [the issue over at Electron](https://github.com/electron/electron/issues/20915), but [got asked to get your opinion first](https://github.com/electron/electron/issues/20915#issuecomment-548996868).

**What is the current behavior?**

- Open React DevTools Profiler in **Electron**
- Click ""Reload and start profiling""
- Await reload
- Do actions
- Click ""Stop profiling"" - does not work
- Because there are errors in console (actually thrown immediately after reload, don't have to do any extra actions):
  ```
  Access to XMLHttpRequest at 'chrome-extension://react-developer-tools/build/renderer.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, https.
  ```
  ```
  Uncaught DOMException: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'chrome-extension://react-developer-tools/build/renderer.js'.
  ```

![Errors after triggering profiler](https://user-images.githubusercontent.com/1030080/68028419-81e81580-fcbd-11e9-85ae-58b8437df6d8.png)

![The respective code in React DevTools](https://user-images.githubusercontent.com/1030080/68028680-1ce0ef80-fcbe-11e9-9b63-4fa0494af0dd.png)

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

You'll have to use [Electron Fiddle](https://github.com/electron/fiddle) for this one with this gist: https://gist.github.com/joltmode/82574cab4970def210dac0c68d4c34b8

**What is the expected behavior?**

- Open React DevTools Profiler
- Click ""Reload and start profiling""
- Await reload
- Do actions
- Click ""Stop profiling""
- See profiler results

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

- React 16.11.0
- Latest version of DevTools
- Electron 6.1.2",,
17239,OPEN,Blink with useTransition,Component: Concurrent Mode; Type: Bug; Type: Needs Investigation,2020-07-21 21:40:08 +0000 UTC,gregberge,,"**Bug**

**What is the current behavior?**

As discussed with @gaearon in this thread: https://twitter.com/dan_abramov/status/1189923059031068672

When the `useTransition` is fast, it results to a small blink for the user. You can reproduce it in this example :

- Choose ""Concurrent Mode""
- Click ""Next"" in ""fretch-mode: legacy-mode"" 

https://codesandbox.io/s/fretch-example-r6t8g

A simpler example can be provided but I don't have time right now, I just want to track the issue.

**What is the expected behavior?**

The expected behaviour would be to avoid the blink if it is less than ""100ms"" (or another arbitrary delay).

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

The experimental version, see the example.
",,
17208,OPEN,Devtools tabs should not appear in chrome-extension pages when using react-devtools as an entry point,Component: Developer Tools; Resolution: Stale,2020-12-25 14:07:15 +0000 UTC,nickmccurdy,,"
The React devtools tabs in Chrome devtools can be displayed in extension pages, even though modifying extensions in other extensions is not supported by Chrome, and React devtools are therefore broken.

![image](https://user-images.githubusercontent.com/927220/67774646-21927300-fa34-11e9-99b5-ea3c62a99e0d.png)

![image](https://user-images.githubusercontent.com/927220/67774697-38d16080-fa34-11e9-8ea6-fddb21c7bb14.png)


**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

1. Install Chrome and React devtools
2. Open devtools in a chrome-extension page implemented with React

Example: [prettier-chrome-extension](https://github.com/prettier/prettier-chrome-extension/tree/options) (install from source and open extension options)

**What is the expected behavior?**

React devtools should not appear when it's not supported, just like when devtools are opened on a page that doesn't use React.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

- React 16.11.0
- React Developer Tools 4.2.0 (10/3/2019)
- Chrome 78.0.3904.70
- macOS 10.15",,
17190,OPEN,useTransition hook name already exits in the ecosystem,Component: Concurrent Mode; Type: Discussion,2019-11-05 07:00:19 +0000 UTC,just-boris,,"The new concurrent mode provides a new hook - [`useTransition`](https://reactjs.org/docs/concurrent-mode-reference.html#usetransition). However the name of it is confusing. The word “transition” in web development already refers to animations and css [transition](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions) property. There also exist [useTransition hook](https://www.react-spring.io/docs/hooks/use-transition) provided by react-spring library. So people who will use both concurrent mode and react-spring in their projects will be confused by clashing names.

Did you consider different names for concurrent transitions? For example, `useTransaction` is not present in the ecosystems and can be used to describe concurrent updates.",,
17168,OPEN,Script tags are rendered inconsistently between client and server (html-encoded on server),Resolution: Stale,2020-12-25 14:06:52 +0000 UTC,accidentaldeveloper,,"
**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
1. Render a script tag with quotes on the server.
2. Render a script tag with quotes on the client.
3. Compare the output. 

Note that the quotes are html-encoded to `&quot` when rendered on the server.

This CodeSandbox is a little rough but very simple: https://codesandbox.io/s/affectionate-star-xe8ym

**What is the expected behavior?**
The script tag content is not html-encoded on either the server or the client.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.8.6
I'm not sure when this was introduced.",,
17140,OPEN,SuspenseList in DevTools could cycle through the Suspense states,Component: Developer Tools; React Core Team,2020-01-08 19:08:53 +0000 UTC,sebmarkbage,,"We currently have a way to force a fallback on a Suspense boundary in DevTools.

It might be cool to have a ""play"" button or something on SuspenseList that cycles through the states.

E.g. if it's ""together"" mode it shows all the fallbacks and then switches to showing all the content and then back again in a loop.

If it's ""forwards"" it shows all the fallbacks then one at a time and then back to all fallbacks. If it's tail ""hidden"" or ""collapsed"" it hides all the ones that are not yet inserted and then inserts one at a time.

Could be a nice way to demo/test the loading sequence experience.",,
17064,OPEN,mouseEnter behaves like mouseOver when using ReactDOM.render() to mount a child element,Component: DOM; Type: Needs Investigation,2020-04-01 22:07:46 +0000 UTC,sen14251,,"https://codepen.io/sen-dream/pen/VwwvGbm

**What is the expected behavior?**
https://codepen.io/sen-dream/pen/WNNQgoy

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Testes with React 16.8 on Chrome/macOS. It didn't work in previous versions.
",,
17003,OPEN,DevTools not properly shutting down between reloads in some cases,Component: Developer Tools; React Core Team,2020-01-08 19:09:21 +0000 UTC,bvaughn,,"Noticed this while testing the recently added ""highlight updates"" feature. It seems like relying on the content script's ""disconnect"" to shutdown things is too late, and we seem to be leaving at least an `Agent` (possibly more) connected.

I think we may want to add some cleanup code to our initialization path (of the backend) to handle the case where a previous backend instance didn't get to finish shutting down.",,
16993,OPEN,Add DevTools visualization for SSR hydration,Component: Developer Tools; React Core Team,2020-01-08 19:09:21 +0000 UTC,bvaughn,,"This feature relates to several new React APIs: concurrent mode, suspense, and server rendering / hydration

# Background info
When hydrating server-rendered content, React starts working on the outermost Suspense boundary and works its way in. During hydration, the server rendered HTML isn't interactive. React records events to replay them once content becomes interactive- (but that doesn't actually happen until React finishes work on the nearest boundary and commits it). React may also reprioritize the order in which boundaries are processed (so that boundaries with pending events get processed sooner).

This general process can be hard to reason about and debug, because much of it is not observable visually (beyond some interactions potentially feeling more laggy than expected).

DevTools already provides some visual overlays (e.g. which elements were rendered by the currently selected Component, [""highlight updates""](https://github.com/facebook/react/pull/16989)). Perhaps DevTools could help here too by visualizing which boundaries in the tree have been hydrated.

# Visualizing hydration progress
1. When React begins hydrating a new root<sup>1</sup> DevTools will show a visual overlay<sup>2</sup> that covers the entire DOM element container.
1. As React hydrates and commits each new level of Suspense boundaries, DevTools will draw the overlay to only cover the not-yet-hydrated boundaries.
1. Once hydration is completed, all overlays will be cleared<sup>3</sup>.

This feature would be opt-in via a new DevTools setting.

<sup>1</sup> This suggests a new React-to-DevTools hook to inform DevTools when hydration starts.

<sup>2</sup> This overlay would nee to be designed. Perhaps some combination of semi-transparent with stripes or bars so that it is high contrast enough to be seen.

<sup>3</sup> Because the data required to draw these overlays is essentially just a timestamp and a set of rects, some form of replay might be a nice addition.

# Special cases
It could be helpful to highlight a couple of special cases by temporarily showing a different style overlay:

* **Client rendered content inside of a server rendered fallback.** ([This case.](https://github.com/facebook/react/blob/bb680a09052b5af6543daf28bfcc3283bbc35cf9/packages/react-reconciler/src/ReactFiberBeginWork.js#L2030-L2039)) In some cases, the server rendered content may be a forced fallback that gets filled in with client rendered content.
* **React can't complete hydration fast enough to process a client-side update.** ([This case.](https://github.com/facebook/react/blob/bb680a09052b5af6543daf28bfcc3283bbc35cf9/packages/react-reconciler/src/ReactFiberBeginWork.js#L2064-L2074)) In this case, React ends up deleting the server-rendered content and replacing it with client rendered content. For example, a layout effect may set state on an ancestor that updates context. This update is synchronous (because it comes from within a layout effect) so it immediately expires.

I don't know if the above cases can be reliably detected by DevTools at present. They may require additional information (or an additional React-to-DevTools hook).

The following case does **not** need to be highlighted because it is not a deopt:
* **Server rendered content removed before hydration.** In some cases, server rendered content is thrown away before hydration completes because of a user interaction. For example, if the user navigates to a new page before the initial page has finished hydrating.",,
16980,OPEN,React DevTools recording commit without any component re-render,Component: Developer Tools; React Core Team,2021-03-25 14:21:17 +0000 UTC,kentcdodds,,"I'm struggling to make an isolated example of this, but the app where I found this is pretty simple so hopefully it's not too challenging to track down.

So I was profiling https://the-react-bookshelf.netlify.com (locally) and got this when I clicked on the ""login"" button:

![image](https://user-images.githubusercontent.com/1500684/66011343-fe4dc580-e47f-11e9-9220-50ba884640f3.png)

![image](https://user-images.githubusercontent.com/1500684/66011358-0dcd0e80-e480-11e9-80fb-86c0f2196ef9.png)

The fact that there was no profile data for a commit is interesting. Each commit should be associated to a state update somewhere in the tree, and wherever that happened should trigger at least one component to re-render, but that didn't appear to happen here.

I also verified that I don't have any components filtered out:

![image](https://user-images.githubusercontent.com/1500684/66011428-57b5f480-e480-11e9-9e66-7cf86f8ba48f.png)

And I didn't filter any commits either:

![image](https://user-images.githubusercontent.com/1500684/66011433-5ab0e500-e480-11e9-97a8-be202351870d.png)

Here's the exported profile data:

https://gist.github.com/kentcdodds/dbff66043653333cd22cb9261a08550b

And here's the repo where you can pull it down and reproduce yourself: https://github.com/kentcdodds/bookshelf. The component we're looking at is here: https://github.com/kentcdodds/bookshelf/blob/master/src/unauthenticated-app.js

Sorry I can't give a more direct reproduction.",,
16965,OPEN,Devtools Inspect Button Doesn't Work with Repeat Selections,Component: Developer Tools; React Core Team,2020-01-08 19:09:20 +0000 UTC,lunaruan,,Maybe we can detect this case by checking $0 and if not we can temporarily select null before reselecting. (?),,
16956,OPEN,Design decision: why do we need the stale closure problem in the first place?,Type: Discussion,2021-01-29 15:03:05 +0000 UTC,slorber,,"Hi,

I initially asked this on Twitter and @gaearon suggested me to open an issue instead.
The original thread is here: https://twitter.com/sebastienlorber/status/1178328607376232449?s=19
More easy to read here: https://threadreaderapp.com/thread/1178328607376232449.html
But will try to make this issue more clear and structured about my args and questions.

Don't get me wrong, I really like hooks, but wonder if we can't have smarter abstractions and official patterns that make dealing with them more easy for authors and consumers.

--------------------------------------

## Workaround for the stale closure

After using hooks for a while, and being familiar with the stale closure problem, I don't really understand why we need to handle closure dependencies, instead of just doing something like the following code, which always executes latest provided closure (capturing fresh variables)

![image](https://user-images.githubusercontent.com/749374/65869094-f7d52600-e379-11e9-9634-1ab06b41e3ca.png)

Coupling the dependencies of the closure and the conditions to trigger effect re-execution does not make much sense to me. For me it's perfectly valid to want to capture some variables in the closure, yet when those variables change we don't necessarily want to re-execute.

There are many cases where people are using refs to ""stabilize"" some value that should not trigger re-execution, or to access fresh values in closures.

Examples in major libs includes:
- Formik (code is pretty similar to my ""useSafeEffect"" above): https://github.com/jaredpalmer/formik/blob/master/src/Formik.tsx#L975
- React-redux, which uses refs to access fresh props: https://github.com/reduxjs/react-redux/blob/b6b47995acfb8c1ff5d04a31c14aa75f112a47ab/src/components/connectAdvanced.js#L286

Also @Andarist (who maintains a few important React libs for a while): 

![image](https://user-images.githubusercontent.com/749374/65872332-9d8b9380-e380-11e9-90b3-bf294991bb82.png)


We often find in such codebase the ""useIsomorphicLayoutEffect"" hook which permits to ensure that the ref is set the earliest, and try to avoid the useLayoutEffect warning (see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85). What we are doing here seems unrelated to layout and makes me a bit uncomfortable btw.



## Do we need an ESLint rule?

The ESLint rule looks to me only useful to avoid the stale closure problem. Without the stale closure problem (which the trick above solves), you can just focus on crafting the array/conditions for effect re-execution and don't need ESLint for that.

Also this would make it easier to wrap useEffect in userland without the fear to exposing users to stale closure problem, because eslint plugin won't notice missing dependencies for custom hooks.

Here's some code for react-navigation (alpha/v5). To me this is weird to have to ask the user to ""useCallback"" just to stabilize the closure of useFocusEffect, just to ensure the effect only runs on messageId change.

![image](https://user-images.githubusercontent.com/749374/65869719-3d462300-e37b-11e9-94d2-5200481588bc.png)

Not sure to understand why we can't simply use the following instead. For which I don't see the point of using any ESLint rule. I just want the effect to run on messageId change, this is explicit enough for me and there's no ""trap""

![image](https://user-images.githubusercontent.com/749374/65869777-564ed400-e37b-11e9-8570-12534e5f2a53.png)

I've heard that the [React team recommends rather the later](https://twitter.com/satya164/status/1178571088172896256), asking the user to useCallback, instead of building custom hooks taking a dependency array, why exactly? Also heard that the ESLint plugin now was able to detect missing deps in a custom hook, if you add the [hook name to ESLint conf](https://twitter.com/n1rual/status/1178568248062877701). Not, sure what to think we are supposed to do in the end.

## Are we safe using workarounds?

It's still a bit hard for me to be sure which kind of code is ""safe"" regarding React's upcoming features, particularly Concurrent Mode. 

If I use the `useEffectSafe` above or something equivalent relying on refs, I am safe and future proof?

If this is safe, and makes my life easier, why do I have to build this abstraction myself? 

Wouldn't it make sense to make this kind of pattern more ""official"" / documented?

I keep adding this kind of code to every project I work with:

```tsx 
const useGetter = <S>(value: S): (() => S) => {
  const ref = useRef(value);
  useIsomorphicLayoutEffect(() => {
    ref.current = value;
  });
  return useCallback(() => ref.current, [ref]);
};
```
(including important community projects like [react-navigation-hooks](https://github.com/react-navigation/hooks/blob/master/src/Hooks.ts#L46))

## Is it a strategy to teach users?

Is it a choice of the React team to not ship safer abstractions officially and make sure the users hit the closure problem early and get familiar with it? 

Because anyway, even when using getters, we still can't prevent the user to capture some value. This has been documented by @sebmarkbage [here](https://gist.github.com/sebmarkbage/a5ef436427437a98408672108df01919) with async code, even with a getter, we can't prevent the user to do things like:

```tsx
onMount(async () => {
  let isEligible = getIsEligible();
  let data = await fetch(...);
  // at this point, isEligible might has changed: we should rather use `getIsEligible()` again instead of storing a boolean in the closure (might depend on the usecase though, but maybe we can imagine isEligible => isMounted)
  if (isEligible) {
    doStuff(data);
  }
});
```  
As far as I understand, this might be the case:

> So you can easily get into the same situation even with a mutable source value. React just makes you always deal with it so that you don't get too far down the road before you have to refactor you code to deal with these cases anyway. I'm really glad how well the React community has dealt with this since the release of hooks because it really sets us up to predictably deal with more complex scenario and for doing more things in the future.


## A concrete problem

A react-navigation-hooks user reported that his effect run too much, using the following code:

![image](https://user-images.githubusercontent.com/749374/65870979-bf374b80-e37d-11e9-8a6c-1f7df8503c18.png)

In practice, this is because react-navigation core does not provide stable `navigate` function, and thus the hooks too. The core does not necessarily want to ""stabilize"" the navigate function and guarantee that contract in its API.

It's not clear to me what should I do, between officially stabilizing the `navigate` function in the hooks project (relying on core, so core can still return distinct navigate functions), or if I should ask the user to stabilize the function himself in userland, leading to pain and boilerplate for many users trying to use the API.

I don't understand why you can't simply dissociate the closure dependencies to the effect's triggering, and simply omitting the `navigate` function here:

![image](https://user-images.githubusercontent.com/749374/65871264-51d7ea80-e37e-11e9-837d-291775853b2e.png)


What bothers me is that somehow as hooks lib authors we now have to think about whether what we return to the user is stable or not, ie safe to use in an effect dependency array without unwanted effect re-executions.

Returning a stable value in v1 and unstable in v2 is a breaking change that might break users apps in nasty ways, and we have to document this too in our api doc, or ask the user to not trust us, and do the memoization work themselves, which is quite error prone and verbose. Now as lib authors we have to think not only about the inputs/outputs, but also about preserving identities or not (it's probably not a new problem, because we already need to in userland for optimisations anyway).

Asking users to do this memoization themselves is error prone and verbose. And intuitively some people will maybe want to `useMemo` (just because of the naming) which actually can tricks them by not offering the same guarantees than `useCallback`.


## A tradeoff between different usecases in the name of a consistent API?

@satya164 also mentionned that there are also usecases where the [ESLint plugin saved him](https://twitter.com/satya164/status/1178395620236759043) more than once because he forgot some dependency, and for him, it's more easy to fix an effect re-executing too much than to find out about some cached value not updating. 

I see how the ESLint plugin is really handy for usecases such as building a stable object to optimize renders or provide a stable context value. 

But for useEffect, when capturing functions, sometimes executing 2 functions with distinct identities actually lead to the same result. Having to add those functions to dependencies is quite annoying in such case. 

But I totally understand we want to guarantee some kind of consistency across all hooks API.

## Conclusion

I try to understand some of the tradeoffs being made in the API. Not sure to understand yet the whole picture, and I'm probably not alone. 

@gaearon said to open an issue with a comment: `It's more nuanced`. I'm here to discuss all the nuances if possible :)

What particularly bothers me currently is not necessarily the existing API. It's rather:
- the dogmatism of absolutely wanting to conform the ESLint rules (for which I don't agree with for all usecases). Currently I think users are really afraid to not follow the rules.
- the lack of official patterns on how we are supposed to handle some specific hooks cases. And I think the ""getter"" pattern should be a thing that every hooks users know about and learn very early. Eventually adding such pattern in core would make it even more visible. Currently it's more lib authors and tech leads that all find out about this pattern in userland with small implementation variations.

Those are the solutions that I think of. As I said I may miss something important and may change my opinions according to the answers.

As an author of a few React libs, I feel a bit frustrated to not be 100% sure what kind of API contract I should offer to my lib's users. I'm also not sure about the hooks patterns I can recommend or not. I plan to open-source something soon but don't even know if that's a good idea, and if it goes in the direction the React team want to go with hooks.

Thanks


",,
16873,OPEN,"[eslint-plugin-react-hooks] allow configuring custom hooks as ""static""",,2020-12-28 07:53:01 +0000 UTC,grncdr,,"
Currently the eslint plugin is unable to understand when the **return value** of a custom hook is static.

Example:

```jsx
import React from 'react'

function useToggle(init = false) {
  const [state, setState] = React.useState(init)
  const toggleState = React.useCallback(() => { setState(v => !v) }, [])
  return [state, toggleState]
}

function MyComponent({someProp}) {
  const [enabled, toggleEnabled] = useToggle()

  const handler = React.useCallback(() => {
    toggleEnabled()
    doSomethingWithTheProp(someProp)
  }, [someProp]) // exhaustive-deps warning for toggleEnabled

  return <button onClick={handler}>Do something</button>
}
```

**What is the expected behavior?**

I would like to configure `eslint-plugin-react-hooks` to tell it that `toggleEnabled` is static and doesn't need to be included in a dependency array. This isn't a huge deal but more of an ergonomic papercut that discourages writing/using custom hooks.

As for how/where to configure it, I would be happy to add something like this to my .eslintrc:

```js
{
  ""staticHooks"": {
    ""useToggle"": [false, true],  // first return value is not stable, second is
    ""useForm"": true,             // entire return value is stable 
  }
}
```

Then the plugin could have an additional check [after these 2 checks](https://github.com/facebook/react/blob/8b580a89d6dbbde8a3ed69475899addef1751116/packages/eslint-plugin-react-hooks/src/ExhaustiveDeps.js#L228-L231) that tests for custom names.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

All versions of eslint-plugin-react-hooks have the same deficiency.

",,
16606,OPEN,"TypeError: ""'requestAnimationFrame' called on an object that does not implement interface Window.""",Component: Scheduler; Type: Bug,2019-08-31 01:25:21 +0000 UTC,Jack-Works,,"**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://github.com/facebook/react/blob/0f6e3cd61cf4a5a1491bb3c92780936aebc2a146/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L88

In the WebExtension content script, globalThis !== window.
So when `const requestAnimationFrame = window.requestAnimationFrame`, the `this` binding of `rAF` is lost.

In the after calling, `rAF` rebinds to the globalThis, but globalThis doesn't implements Window interface.

PoC: Install this extension in the Firefox and you will see the error reported.
```index.js
try {
    const raf = window.requestAnimationFrame
    raf(() => console.log('Okay.'))
} catch (e) {
    console.warn(e)
}
```

```manifest.json
{
    ""name"": ""rAF in content script test"",
    ""version"": ""0.0.1"",
    ""manifest_version"": 2,
    ""content_scripts"": [{ ""js"": [""/index.js""], ""matches"": [""<all_urls>""] }]
}
```

**What is the expected behavior?**

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Firefox, in WebExtension. 

Related to https://github.com/facebook/react/issues/16605",,
16599,OPEN,New plugin not working after change any props in debugger tools,Component: Developer Tools; Type: Bug,2019-09-12 15:48:47 +0000 UTC,sagar-k,,"![image](https://user-images.githubusercontent.com/7201068/63866449-d7a7f500-c9d0-11e9-80dd-a19d0456711c.png)

Uncaught TypeError: Cannot read property '_reactInternalInstance' of undefined
    at Object.get (react-dom.min.js:formatted:4200)
    at a (react-dom.min.js:formatted:4937)
    at Object.enqueueForceUpdate (react-dom.min.js:formatted:4965)
    at s (backend.js:9)
    at Object.setInProps (backend.js:9)
    at t.<anonymous> (backend.js:1)
    at t.l.emit (backend.js:1)
    at backend.js:9
    at t (backend.js:1)



**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

Reproduce bug.
try to change any dynamic pros in the debugger tools section and you will not able to see any DOM changes

**What is the expected behavior?**

Whenever change any props in debugger tools. react component should be rendered as per it.
It was working fine with previous react developer tools chrome plugin 

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
I am using the below version.
""react"": ""15.6.2"",
   ""react-dom"": ""15.6.2"",
",,
16589,OPEN,Confusing error when passing non-function to useMemo,Component: Hooks; Partner,2020-07-23 18:27:23 +0000 UTC,aweary,,"

[Example](https://codesandbox.io/s/boring-albattani-grhhp).

When passing something like an object to `useMemo` the error isn't very helpful.

```
TypeError: nextCreate is not a function
    at mountMemo (https://grhhp.csb.app/node_modules/react-dom/cjs/react-dom.development.js:13459:19)
    ...
```

Most developers wont know what `nextCreate` is, and passing an object to `useMemo` doesn't seem _obviously_ wrong at first. We could add a `typeof` check that throws a better error, but maybe that's too much overhead? At the very least we could add a DEV warning with more helpful guidance.",,
16566,OPEN,onMouseEnter event missing when component hides on top of another (i.e. contextual menu),Component: DOM; Type: Needs Investigation,2020-04-01 22:31:07 +0000 UTC,ivalduan,,"I provide a codepen example showcasing the issue here,
https://codepen.io/ivalduan/pen/VwZpmMQ

1. The component on the screen tracks correctly a hover state of the mouse pointer
2. With the right button you create a contextual menu without covering the text and the hover state is correct when the mouse is over the menu
3. When you select and option of the contextual menu on top of the background component the second does not receive an onMouseEnter event and the hover state remains false when it should be true",,
16550,OPEN,Devtools scrollbar hides flamegraph,Component: Developer Tools; Type: Bug,2019-11-27 15:29:14 +0000 UTC,Curzy,,"**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
current
![current](https://user-images.githubusercontent.com/3931792/63563638-b09a8f00-c59c-11e9-95fc-627dcea023b6.png)

without scrollbar, there is more graphs hidden by scrollbar
![without scrollbar](https://user-images.githubusercontent.com/3931792/63563645-b8f2ca00-c59c-11e9-917e-8c63be90cb2d.png)

**What is the expected behavior?**
scrollbar does not cover flame graph or if flamegraph's height is long enough to use scrollbar, flamegraph container's width should shrink about scrollbars width 

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.9 / chrome 78.0.3887.7 / macOS 10.14.6 /  
",,
16547,OPEN,Devtools v4 does not work with Firefox's private window,Component: Developer Tools,2021-02-09 06:12:14 +0000 UTC,tetsuharuohzeki,,"**What is the current behavior?**


Steps to Reproduce is here:

1. Environments are:
2. Open the page which uses react with a private window.
3. Open Firefox's devtools.

Actual Result is:

* react devtools' _component_ pane show `Unable to find React on the page.`
* From about:debugging, we can see the below messsage:

```
SecurityError: Permission denied to access property ""container"" on cross-origin object main.js:51:305877
    Kl moz-extension://56db142d-3d36-b04e-91ca-a7504c7708a5/build/main.js:51
    apply self-hosted:4417
    applySafeWithoutClone resource://gre/modules/ExtensionCommon.jsm:588
    asyncWithoutClone resource://gre/modules/ExtensionCommon.jsm:2400
```



**What is the expected behavior?**

react devtools work

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

* Firefox 68
* react devtools v4.0.5
* react v16.9",,
16505,OPEN,Chrome's Custom Formatters,Component: Developer Tools; Type: Discussion,2020-01-19 17:36:04 +0000 UTC,roman01la,,"**Do you want to request a *feature* or report a *bug*?**
Feature

_Transferring feature request from the old repo https://github.com/facebook/react-devtools/issues/989_

Hi! Is there any plans on supporting [Chrome's custom formatters](https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview) to display custom data structures in readable format in React dev tools?

For example when debugging ClojureScript's immutable data structures we have a custom formatter that outputs data into the console in readable and inspectable format.

Here how it looks like
![screen shot 2018-02-19 at 3 02 32 pm](https://user-images.githubusercontent.com/1355501/36379156-39e8a882-1586-11e8-8973-7e6d3772cb4e.png)

And here's how data looks like in React Dev Tools inspector (basically underlying implementation of a data structure as seen in plain JS)
![screen shot 2018-02-19 at 2 59 04 pm](https://user-images.githubusercontent.com/1355501/36379177-4b280d90-1586-11e8-808d-ea7f2cebb274.png)

I think this can be done for React Dev Tools since once Custom Formatters are defined they are applied everywhere in Chrome's Dev Tools where it's possible to inspect data.
",,
16501,OPEN,Getting maximum call stack exceeded on backend.js when rendering many elements.,Component: Developer Tools; Type: Bug,2021-03-16 15:46:29 +0000 UTC,ryan-rushton,,"## Details
Using version 4.0.2 (8/15/2019) I am getting a maximum call stack size exceeded when my app starts up. While my app using this is a little different I have replicated the issue using a fresh create-react-app. I will include the App.js code below.

## Steps to reproduce
1. Create a new app using version 3.0.1 of create-react-app
2. Replace the code in App.js with the code listed below
3. Inspect the console, there should be a stack trace from a maximum call stack exceeded error

## App.js
```
import React from 'react';
import logo from './logo.svg';
import './App.css';

const createDivs = num => {
    const rtn = [];
    for(let i = 0; i < num; i++) {
        const key = `div-${i}`;
        rtn.push(<div className={key} key={key} />)
    }
    return rtn;
}

function App() {
  return (
    <div className=""App"">
      <header className=""App-header"">
        <img src={logo} className=""App-logo"" alt=""logo"" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className=""App-link""
          href=""https://reactjs.org""
          target=""_blank""
          rel=""noopener noreferrer""
        >
          Learn React
        </a>
      </header>
      <div>
        {createDivs(15000)}
      </div>
    </div>
  );
}

export default App;
```

## Call Stack
<details>

<summary>backend.js:formatted:2097 Uncaught RangeError: Maximum call stack size exceeded
</summary>

```
    at ge (backend.js:formatted:2097)
    at Ge (backend.js:formatted:2435)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
    at Ge (backend.js:formatted:2478)
ge @ backend.js:formatted:2097
Ge @ backend.js:formatted:2435
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
Ge @ backend.js:formatted:2478
postMessage (async)
r @ contentScript.js:1
88 @ contentScript.js:1
n @ contentScript.js:1
(anonymous) @ contentScript.js:1
(anonymous) @ contentScript.js:1
Show 170 more frames
```

</details>

This was not an issue in the previous version of react-devtools.",,
16496,OPEN,DevTools: Write tests for preserving selection,Component: Developer Tools; React Core Team,2020-01-08 19:10:09 +0000 UTC,bvaughn,,"See https://github.com/bvaughn/react-devtools-experimental/pull/215. It would be nice to have test coverage for it.

---
I got stuck here:

```js
    const Component = () => <div>Hi</div>;

    act(() =>
      ReactDOM.render(<Component />, document.createElement('div'))
    );
    const id = store.getElementIDAtIndex(0);
    const rendererID = store.getRendererIDForElement(id);

    act(() => {
      global.bridge.send('selectElement', { id, rendererID });
    })
```

This test fails on master because bridge object is shared between agent and store. Separating it and emulating having two bridges didn't work because of some regression in the Suspense test. I haven't dug into why because the stack trace display is obscured and points to the wrong line in the test. The stack trace display points to the wrong line likely because of regenerator code. The regenerator code is likely coming from `babel-preset-env` thinking we need to polyfill async/await. I don't know why `babel-preset-env` doesn't realize my Node already has async/await. At that point I punted on this.

---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/219",,
16495,OPEN,DevTools: Components tree is sometimes unexpectedly empty after navigation,Component: Developer Tools; React Core Team; Type: Bug,2020-01-08 19:10:09 +0000 UTC,bvaughn,,"1. Open FB page
2. Open Components tab
3. Change address bar to `https://reactjs.org` and press Enter

Expected: Components tab gets populated.
Actual:

<img width=""783"" alt=""Screen Shot 2019-04-23 at 7 27 37 PM"" src=""https://user-images.githubusercontent.com/810438/56606380-00247a80-65fe-11e9-988c-2ad3e69eb579.png"">

~~If I **inspect background page**, I see this:~~ (fixed by #229)

<img width=""652"" alt=""Screen Shot 2019-04-23 at 7 27 12 PM"" src=""https://user-images.githubusercontent.com/810438/56606408-0b77a600-65fe-11e9-9f65-5502401b7e4a.png"">

---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/217",,
16494,OPEN,DevTools: Audit places where we change tags or disconnect alternates in React,Component: Developer Tools; React Core Team,2020-01-08 19:10:09 +0000 UTC,bvaughn,,"Cases like https://github.com/bvaughn/react-devtools-experimental/issues/197 (where a dehydrated Suspense node turns into a regular one) produce confusing failures because we expect Fiber alternates to be ""for life"", whereas in practice they can actually get disconnected by React in some cases. (Search for ""Disconnect"" in ReactFiberBeginWork.)

Additionally, I think changing `tag` can also produce confusing failures if it changes from a value that was filtered out, to a value that is not filtered out.

We need to be more proactive about handling these cases when we make such changes to React, and we need to look at existing cases where this happens and whether we can handle them.

---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/198",,
16490,OPEN,DevTools: Check if accessibility regressions exist compared to old DevTools,Component: Developer Tools; React Core Team,2020-01-08 19:11:00 +0000 UTC,bvaughn,,"Before this becomes stable, we need to check if we are regressing accessibility on any important existing interactions.

At least, we should probably make the tree view focusable.

---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/52",,
16489,OPEN,DevTools: Suspense Debugger,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:11:00 +0000 UTC,bvaughn,,"### MVP
- [x] Initial prototype with a tree and toggling.
- [x] Tree should reflect real suspense state.
- [ ] Make it less fragile.
  - [x] Does findDOMNode issue affect this?
- [ ] Ensure expensive tree construction doesn't run unless you're on the tab.
- [ ] Improve navigation so the user doesn't get lost.
  - [ ] Maybe flash nodes.
  - [ ] Maybe offer a ""finder"" tool.
- [ ] Sync selection with the Components tab.
- [ ] Make it look nice. @bvaughn 

### Future
- [ ] Consider a fuzzer.
- [ ] Considering filtering by viewport.
- [ ] Optimize the tree updates.
  - [ ] Consider listening to operations. Don't forget to handle ancestor reorder.

---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/43",,
16488,OPEN,DevTools: Re-enable postMessage transferable for faster ArrayBuffer transfers,Component: Developer Tools; React Core Team; Type: Bug,2020-01-08 19:11:00 +0000 UTC,bvaughn,,"I got this on FB.com sandbox:

<img width=""815"" alt=""screen shot 2019-03-01 at 1 15 24 pm"" src=""https://user-images.githubusercontent.com/810438/53640457-26dcbb00-3c24-11e9-828f-a987ffeec4da.png"">


---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/25",,
16487,OPEN,DevTools: Crashes and warnings when quickly collapsing,Component: Developer Tools; React Core Team; Type: Bug,2020-01-08 19:10:59 +0000 UTC,bvaughn,,"This is weird. Happens if I select a node deeply and then long-press ""left"" arrow.

```
Invalid index 154 specified; store contains 154 items.

Uncaught Invariant Violation: Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.
    at ReactError (file:///Users/gaearon/p/react-devtools-experimental/shells/dev/build/devtools.js:8529:40)
```

It starts with ""invalid index"" and then gives me different React invariants or warnings depending on how lucky I am.

![Screen Recording 2019-04-25 at 05 58 PM](https://user-images.githubusercontent.com/810438/56754075-fcbafb80-6783-11e9-8fe6-84aa29d1c120.gif)

---
More weird symptoms:

<img width=""889"" alt=""Screen Shot 2019-04-25 at 6 38 22 PM"" src=""https://user-images.githubusercontent.com/810438/56756281-5671f480-6789-11e9-8d0b-631a5217e63b.png"">

---
<img width=""832"" alt=""Screen Shot 2019-04-25 at 6 41 37 PM"" src=""https://user-images.githubusercontent.com/810438/56756492-c7191100-6789-11e9-8814-cb849590ee01.png"">

---
This ""fixes"" it:

```diff
       runWithPriority(UserBlockingPriority, () => dispatch(action));
-      next(() => dispatch({ type: 'UPDATE_INSPECTED_ELEMENT_ID' }));
+      runWithPriority(UserBlockingPriority, () => dispatch({ type: 'UPDATE_INSPECTED_ELEMENT_ID' }));
     },
```

So I suspect it's a bug with `Scheduler.next()`.

---
This also looks funky. Note how somewhere in the middle right pane gets ""stuck"" showing the same cycle of values:

![Screen Recording 2019-04-25 at 07 36 PM](https://user-images.githubusercontent.com/810438/56759733-8b824500-6791-11e9-95ba-d4d3630a4c5e.gif)

---
React bug: https://github.com/facebook/react/issues/15512

---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/228",,
16486,OPEN,DevTools: Elements height being clipped by console,Component: Developer Tools; React Core Team; Type: Bug,2020-01-08 19:10:59 +0000 UTC,bvaughn,,"![clipping-bug](https://user-images.githubusercontent.com/10223856/55770859-3984b400-5a5c-11e9-8ae4-e51ecf1e4f51.gif)

This one was kinda tricky to reproduce, but basically the steps are:

1. Click the inspect element and hover any component
2. Open the console pressing esc
3. Move mouse back to devtools and click again the inspect button (to stop inspection).
4. Close the console with esc.

(ps: sorry for the gif quality, I don't know how to properly convert the .mov to .gif)

---
Originally reported by @lucasecdb via https://github.com/bvaughn/react-devtools-experimental/issues/110",,
16483,OPEN,DevTools: Better linking between browser Performance tab and DevTools Profiler,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:10:58 +0000 UTC,bvaughn,,"Notes from a chat with Benoit:

It would be nice if starting profiling (or reload and profiling) in the browser auto-started profiling in DevTools.

It would also be nice if viewing a range of time in the Performance tab narrowed down the commits within the Profiler. At least starting the profilers at the same time would enable a manual match-up.

To my knowledge, none of the currently available APIs (including experimental) would enable us to support this level of integration.

---
If we were to make use of the DevTools protocol, we could [`Profiler.start`](https://vanilla.aslushnikov.com/?Profiler.start) and [`Profiler.stop`](https://vanilla.aslushnikov.com/?Profiler.stop) the built-in profiler in sync with React's own profiler. Chrome's profiler also dispatches [`Profiler.consoleProfileStarted`](https://vanilla.aslushnikov.com/?Profiler.consoleProfileStarted) and [`Profiler.consoleProfileFinished`](https://vanilla.aslushnikov.com/?Profiler.consoleProfileFinished) events which we _could_ use to follow the browser's profiler if we wanted to.

There do not appear to be any APIs/events for syncing the zoomed-in range.

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/37",,
16482,OPEN,DevTools: Should Profiler surface the base duration?,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:10:58 +0000 UTC,bvaughn,,"Benoit shared feedback that it would be helpful to show the base duration for the tree (and/or selected element) to get a sense of the total cost over time. (Not sure yet what we'd call this.)

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/55",,
16481,OPEN,DevTools: Collect more info when profiling,Component: Developer Tools; React Core Team; Type: Enhancement,2020-04-17 18:37:54 +0000 UTC,bvaughn,,"Some feedback I've heard from a DevTools user (roughly transcribed by me):

> I'm trying to pinpoint those renders...with hooks, it's sometimes more unclear to me why something is rendering...I generally don't use devtools much anywhere. I use console.log. But Redux devtools worked really well for me because I could see when things were changing and what exactly changed.

Maybe we could add an opt-in mode (in Settings > Profiler) to collect more data when profiling about _why_ a component rendered. For example, if `props` or `state` changed, we could show which keys changed (just their name, not their values). Maybe we could do something similar for context and for hooks?

Then we could add this information to the right side panel for the selected fiber in the Profiler UI.

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/98",,
16480,OPEN,DevTools: Fix disabled hooks lint rule,Component: Developer Tools; React Core Team,2020-01-08 19:10:57 +0000 UTC,bvaughn,,"Disabled via 00f6466

More context at https://github.com/bvaughn/react-devtools-experimental/pull/154#discussion_r275134664

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/156",,
16478,OPEN,DevTools: Component bookmarks,Component: Developer Tools; React Core Team; Type: Discussion; Type: Enhancement,2020-01-08 19:10:57 +0000 UTC,bvaughn,,"Product developers sometimes find it useful to jump back and forth between a few components in a tree. Currently this requires scrolling or using the selection tool. Maybe we could allow you to temporarily bookmark one or more components somehow? Then the existing Search interface could maybe be repurposed to let you step between bookmarked components (when there's no search text).

These bookmarks would probably not need to be persisted between reloads, so they could be associated with the specific in-memory element<sup>1</sup>.

<sup>1</sup> Although this association would be lost with a filter change.

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/305",,
16477,OPEN,DevTools: Profiler: Show which hooks changed,Component: Developer Tools; React Core Team; Type: Enhancement,2021-03-25 14:22:36 +0000 UTC,bvaughn,,"# ""Can you show which hooks changed?""

...is a question I've heard a couple of times with regard to the new Profiler change-tracking feature. This request is certainly understandable, but it presents a couple of challenges:

1. Identifying which hooks values change would requires shallowly re-rendering each function component.
2. Identifying a hook in a non-ambiguous way requires displaying the full hooks tree structure, since hooks aren't named. (Alternately we could support named hooks, #16474)

Let's take each of a look at each of these below.

## 1 - Identifying which hooks values change

One of the challenge for DevTools when it comes to hooks is identifying custom hooks. Sebastian's [proposed solution](https://github.com/bvaughn/react-devtools-experimental/blob/master/src/backend/ReactDebugHooks.js) is that DevTools temporarily overrides React's hooks dispatcher while it shallowly re-renders the component. During the re-render, each time one of the built-in hooks is used, our override implementation parses the stack to identify ""custom hooks"" (functions higher up in the callstack that begin with ""use""). After render is completed, we reassemble this information into a tree structure which DevTools can display.

Currently we only do this  shallow render when a component is [inspected](https://github.com/bvaughn/react-devtools-experimental/blob/master/OVERVIEW.md#inspecting-an-element), but in order for us to track which hooks have changed while profiling, we would need to shallowly render _every_ component using hooks during the profiling session. Mostly likely we would have to do this during the performance sensitive ""commit"" phase since that's when DevTools is notified of an update.

I think we could do better than re-running the above hooks override for every component on every commit if we:
* Created a map of Fiber to cached hooks tree structure.
* Lazily populate the above map (by shallow re-rendering) only when a component was updated for the first time.
* Compared Fiber `memoizedState`s to identify changes on future commits and map them back to the tree structure based on their position in the list structure. <sup>1</sup>

However, even with the above optimizations this would still add significant overhead to a performance sensitive phase.

<sup>1</sup> I think this should work but might also end up being complicated to implement.

## 2 - Identifying a hook

Although the variables that hooks values are assigned to are meaningfully named, the hooks themselves are unnamed. Because of this, DevTools has no feasible way of identifying a hook short of displaying the entire hooks tree structure. Consider the following example code:

```js
function useCustomHook(...) {
  const [foo, setFoo] = useState(...);
  // ...
}

function ExampleComponent(props) {
  const [bar, setBar] = useState(...);
  const [baz, setBaz] = useState(...);
  const custom = useCustomHook(...);
  // ...
}
```

The example above shows 4 hooks: three `useState` and one custom. Let's say that ""foo"" and ""baz"" changed in a particular render. How would DevTools identify this? It could just show ""two state hooks"" but that's not very helpful. I think the only way we could identify it would be to show the entire tree, and visually highlight which hooks in it have changed:

```
State
State *
CustomHook
  State *
```

This is _okay_ but it's not great unless the developer is cross-referencing the component (and probably the custom hooks definition as well). To help with this, we could also _show the values_ but now we're adding more overhead in terms of trackin and bridge traffic.

## In summary

Clearly both of these challenges can be overcome but they are non-trivial to implement and they will certainly add more runtime overhead to the profiler. Because of this, it may be a while before we add this feature to the DevTools.

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/312",,
16474,OPEN,DevTools: Named hooks,Component: Developer Tools; React Core Team; Type: Discussion; Type: Enhancement,2021-04-05 17:26:28 +0000 UTC,bvaughn,,"**Note** this issue is outdated. The current thinking is that the alternative, ""*load source code (with source maps) and parse for name*"", is probably the best course of action.

---

## The problem

One common piece of feedback about DevTools hooks integration is that hooks have no name and can be confusing. Consider the following example:
```js
function useSomeCustomHook() {
  const [foo, setFoo] = useState(true);
  const [bar, setBar] = useState(false);

  // ...
}

function Example() {
  const baz = useSomeCustomHook();

  // ...
}
```

Currently in DevTools the above component would be displayed as follows:
```
SomeCustomHook:
  State: true
  State: false
```

This information isn't as rich as we would prefer. ☹️

The next question is often: ""can you use the name of the variable the hook return value is assigned to?"" but this is tricky because DevTools doesn't actually have any way to access that variable. (Even if DevTools has a handle on the `Example` function above, how would it access the `useSomeCustomHook` function?)

## The proposal

The solution to this would be some form of user-defined metadata (preferably generated by a code transform). Building on the precedent of the `useDebugValue` hook (https://github.com/facebook/react/pull/14559), we might introduce a new no-op hook e.g. `useDebugName`.

The above example could make use of this hook like so:
```js
function useSomeCustomHook() {
  const [foo, setFoo] = useState(true);
  useDebugName(""foo""); // injected by Babel transform
  const [bar, setBar] = useState(false);
  useDebugName(""bar""); // injected by Babel transform

  // ...
}

function Example() {
  const baz = useSomeCustomHook();

  // ...
}
```

DevTools could then display something like:
```
SomeCustomHook:
  State (foo): true
  State (bar): true
```

## Implementation details

The new `useDebugName` hook might be a noop hook provided by React (similar to `useDebugValue`) _or_ it could even be an export from the (soon to be released [`react-debug-hooks` package](https://github.com/facebook/react/blob/master/packages/react-debug-tools/)). The key concerns would be that:
1. It has no effect (and adds no overhead) when DevTools is not present.
2. Not calling it at all (or only calling it for _some_ hooks) should not break or corrupt anything.

DevTools could override the no-op `useDebugName` implementation before inspecting a component and automatically associate the provided name with the most recently called native hook.

For example, the following code should only result in one named hook (the second `useState` call).
```js
const [foo, setFoo] = useState(true);
const [bar, setBar] = useState(false);
useDebugName(""bar""); // injected by Babel transform
const [baz, setBaz] = useState(true);
```

Being able to support sparse name metadata would be important for third party code (that might not be transformed to supply the metadata).

A code transform would be ideal for this scenario because manual annotation would probably be cumbersome. This could also be marketed as a **DEV-only transform** so as not to bloat production bundles with display names. We might even try to detect the env and throw if it isn't DEV (like https://github.com/facebook/react/pull/15939).

## Further considerations

### Custom hooks?

In some cases, custom hooks might also be ambiguous. Consider the `useSubscription` hook (https://github.com/facebook/react/pull/15022):
```js
function Example() {
  const foo = useSubscription(...);
  const bar = useSubscription(...);

  // ...
}
```

Currently in DevTools the above component would be displayed as follows:
```
Subscription: ""some value""
  State: Object
Subscription: ""some other  value""
  State: Object
```

Maybe the value alone (provided by `useDebugValue`) could be enough to uniquely identify the hook, but I suspect in many cases it might not be sufficient. Should we then use `useDebugName` for custom hooks as well?

I think it would be more fragile given the way our custom hooks detection logic is implemented. Custom hooks are not identified until after a component has finished rendering. In order for us to associate names with custom hooks, we would need to maintain a stack of names. This could lead to potential mismatches though in the event that `useDebugName` was called more (or fewer) times than there are custom hooks.

For example, consider the following code:
```js
function useSomeCustomHook() {
  const [foo, setFoo] = useState(true);
  useDebugName(""foo"");
  useDebugName(""effectively ignored"");
  const [bar, setBar] = useState(false);
  const [baz, setBaz] = useState(false);
  useDebugName(""baz"");

  // ...
}
````

The proposed implementation of `useDebugName` would be robust enough to handle naming ""foo"" and ""baz"" states and leaving ""bar"" as anonymous state hook. If we were maintaining a stack of names however, this discrepency would be more difficult to manage.

Perhaps there is a clever solution to this problem. I would probably suggest leaving it out of the initial implementation though and only revisiting if we determine it's a necessary feature.

## Alternatives considered

### Pass debug name as an additional (unused) parameter

An alternative approach to calling a separate hook for naming purposes would be to pass the display name as an additional parameter to the native hook, e.g.:
```js
function useSomeCustomHook() {
  const [foo, setFoo] = useState(true, ""foo"");
  const [bar, setBar] = useState(false, ""bar"");

  // ...
}

function Example() {
  const baz = useSomeCustomHook();

  // ...
}
```

**Pros**:
* Less code.
* Does not introduce a new hook.

**Cons**:
* It requires knowledge about the arity of native hooks. Ror example `useReducer` has optional parameters that the transform (or manual code) would need to be aware of to avoid a runtime error.
* It would not be possible to support naming custom hooks (if that's something we decided to do).

### Load source code (with source maps) and parse for name
We could use an extension API like [`Resource.getContent`](https://developer.chrome.com/extensions/devtools_inspectedWindow#method-Resource-getContent) to load the source code (including custom hooks) and parse it determine the hook/variable names. Essentially this would work like the proposed transform above, but at runtime.

**Pros**:
* Does not require a Babel transform step. (""Just works"")
* Does not potentially bloat production builds (if transform is used incorrectly).

**Cons**:
* Adds additional async loading (complexity) to suspense cache used for hooks inspection.
* May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a full parser.

### Call `toString` on the function component and parse for name
A possible 80/20 variant of the above proposal would be to simply call` toString` on the function component and parse any top-level hooks.

**Pros**:
* Does not require a Babel transform step. (""Just works"")
* Does not potentially bloat production builds (if transform is used incorrectly).
* Does not require any additional asynchronous code.

**Cons**:
* Only supports top-level hooks (used directly within the function).
* May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a fullp parser.

### Use a Babel transform to leave an inline comment (and call `toString` to search for it)
Rather than inserting a call to a new custom hook, our code transform could just insert an inline comment with the name. We could then parse the code to find the inline comment, e.g.:
```js
function Example() {
  /* hook:foo:Example.react.js:3 */
  const foo = useSubscription(...);
  /* hook:bar:Example.react.js:5 */
  const bar = useSubscription(...);

  // ...
}
```

**Pros**:
* Does not potentially bloat production builds (if transform is used incorrectly).
* Potentially sidesteps difficulty of parsing certain code patterns (e.g. Babel's destructuring transform).

**Cons**:
* Only supports top-level hooks (used directly within the function).
* Still requires an explicit transform step.

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/323",,
16472,OPEN,DevTools: Keyboard arrow-key navigation for the flamegraph view,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:10:55 +0000 UTC,bvaughn,,"It would be good to have keyboard navigation on the flamegraph view to make it easier and faster to scoot around to different components in the same render. 

Given that flamegraph is implemented in SVG and given the complexity of navigating through an uneven grid, I suspect keyboard access is probably beyond the scope of near-future DevTools releases, but wanted to file this issue while it's top-of-mind. 

Expected behavior: 
* There should be a selected/focused UI of some sort around the active component. This could be a black or colored outline around the currently selected component, or perhaps a background pattern like diagonal hatching.  IMHO, this would be valuable even without keyboard support! 
* Up arrow should change selection to the parent component
* Left/Right arrows should move selection to the prev/next sibling components. Should wrap when at the beginning or end of the line.
* Tab should move focus to the right pane (this matches behavior of other DevTools tabs like Elements)
* Shift+Tab should move focus to the rightmost control in the toolbar (currently this is the ""next commit"" button)

This is a companion issue to #332 which asks for keyboard access for the ""Rendered At"" list. Compared to this suggestion, #332 should be much easier to implement so I split them.

---
Originally reported by @justingrant via https://github.com/bvaughn/react-devtools-experimental/issues/333",,
16471,OPEN,DevTools: React Native: Support reload-and-profile be an important feature,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:10:55 +0000 UTC,bvaughn,,"React DevTools v4 adds a new reload and profile feature to measure perf for application ""mount"" ([although it required a bit of hacking](https://github.com/bvaughn/react-devtools-experimental/pull/35)). I don't feel knowledgeable enough about React Native to tackle it, so my current plan is to just **not** support this feature for RN.

If we did decide to support it,I think we would need to solve the following:

1. A reload hook on the backend that worked for all bundle types (not just DEV).
2. Some assurance that the backend will be injected/initialized _before_ the first mount/commit (or a mechanism to delay the first commit, like we do in the browser).
3. Some way for third party code to request a production+profiling build ([similar to how DOM does it](https://fb.me/react-profiling)).
4. A sync storage mechanism (or some other way for DevTools could leave a flag for itself so it knows to begin profiling immediately after reload+connection).

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/336",,
16470,OPEN,DevTools: React Native: Remember saved component filters between reloads,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:10:55 +0000 UTC,bvaughn,,"DevTools v4 added a pretty powerful new component filtering feature that enables devs to filter out components by type, name, or file system location. Because these filters can be a bit elaborate to create, they are saved between sessions to improve dev experience.

**Unfortunately, I don't think I am going to be able to support the persistence functionality for React Native.** (In other words, filters will be forgotten each time you reload the app.)

The reason for this is a mix of timing and context. The biggest limiting factor is the lack of a synchronous storage option. React Native has a couple of faux sync storage options, but they just in-memory wrappers around an async storage layer and they require async initialization. That _could_ work if the React Native backend waited to initialize DevTools until it also initialized the async storage layer, _but_ this has implications on reload-and-profile support (#336).

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/337",,
16469,OPEN,DevTools: Triggering Error Boundaries from DevTools,Component: Developer Tools; React Core Team; Type: Enhancement; good first issue (taken),2021-04-08 14:02:18 +0000 UTC,bvaughn,,"It would be useful to force components into an error state, in order to test error boundaries (similar to how the suspense toggle works).

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/340",,
16468,OPEN,Remember saved component filters by url or in bookmarks,Component: Developer Tools; React Core Team; Type: Discussion,2020-07-25 19:40:17 +0000 UTC,bvaughn,,"It would be cool if it will support saving filter based on url or some bookmarks. I think it will be really useful for switching between different projects. And seems that bookmarks is better solution because usually people have some different stages like production/pre-production/local development.

---
Originally reported by @7rulnik via https://github.com/bvaughn/react-devtools-experimental/issues/359",,
16465,OPEN,DevTools: Occasional FOUC when loading DevTools,Component: Developer Tools; React Core Team; Type: Bug,2020-01-08 19:10:53 +0000 UTC,bvaughn,,"Seems to only happen the first time DevTools is opened after being installed (or perhaps the first time after the browser is opened).

---
Originally reported via https://github.com/bvaughn/react-devtools-experimental/issues/381",,
16463,OPEN,DevTools: An easier way to see all siblings,Component: Developer Tools; React Core Team; Type: Enhancement,2020-02-08 07:47:08 +0000 UTC,bvaughn,,"I have a particular pattern that I struggle with when navigating deep trees in devtools: I want to see all siblings of a node together.

Say I'm in the middle of something and I wonder what are all nodes on the same level. It's super hard to actually get to that state. I wonder if we could tweak ""left"" button to do that as an intermediate state.

* first press: collapse the current node
* second press: collapse all siblings (new)
* third press: move to the parent

Maybe this is too crazy :-) Or maybe there's another mechanic that can achieve the same effect. The goal here is to be able to make sense of the tree structure by going _upwards_. Currently implementation details of children prevent me from seeing it. (At least, with the ""expand"" mode on — which is now on by default.)

---
Originally reported by @gaearon via https://github.com/bvaughn/react-devtools-experimental/issues/384",,
16456,OPEN,React DevTools: styling overrides global styles,Component: Developer Tools; Type: Bug,2020-01-04 10:14:15 +0000 UTC,CompuIves,,"
**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

It's funny, I can give a *real* CodeSandbox editor now! You can see the styling on the editor elements here: https://codesandbox.io/s/new.

**What is the expected behavior?**

No leaking styles. Ideally the `* {` would be prefixed by an id or classname specific for the devtools. I think this should be possible with the styling used by the devtools. I can open a PR to fix this if everyone agrees on this fix.

cc @bvaughn 	",,
16444,OPEN,Refactor ProfilerContext to use reducer instead of multi-state,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:10:52 +0000 UTC,bvaughn,,"The `ProfilerContext` is currently comprised of several pieces of related state, each managed with `useState`. This necessitates awkward checks like [this](https://github.com/bvaughn/react-devtools-experimental/blob/4697f5b37967b85b2c844044aeebb5b1a740875d/src/devtools/views/Profiler/ProfilerContext.js#L126-L131) or even worse like [this](https://github.com/bvaughn/react-devtools-experimental/blob/4697f5b37967b85b2c844044aeebb5b1a740875d/src/devtools/views/Profiler/SnapshotSelector.js#L62-L73) or [this](https://github.com/bvaughn/react-devtools-experimental/blob/source/src/devtools/views/Profiler/Profiler.js#L71-L83).

This context should be refactored to use a single reducer (`useReducer`) like `TreeContext`. This is a bit more involved at the moment because of suspense and the `ProfilerContext` being higher level than the suspense cache. Although maybe we could work around this by using some sort of [subscription](https://github.com/bvaughn/react-devtools-experimental/blob/4697f5b37967b85b2c844044aeebb5b1a740875d/src/devtools/views/Profiler/ProfilerContext.js#L118-L124)?

See related issues like #16441 and commit [4697f5b](https://github.com/bvaughn/react-devtools-experimental/commit/4697f5b37967b85b2c844044aeebb5b1a740875d).",,
16416,OPEN,SSR: Cannot set property 'memoizedState' of null,Type: Bug; good first issue,2021-03-25 14:17:57 +0000 UTC,ambar,,"
> Cannot set property 'memoizedState' of null

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

```js
const processLink = html => {
  return renderToStaticMarkup(<Link />)
};

const RichText = ({ html }) => {
  const htmlProcessed = useMemo(() => processLink(html), [html]);
}
```
See https://codesandbox.io/s/cannot-set-property-memoizedstate-of-null-mrxfr

**What is the expected behavior?**

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.8~16.9

",,
16374,OPEN,Verify that Dehydrated Boundaries (and SuspenseList) Works with DevTools,Component: Developer Tools; React Core Team; Type: Needs Investigation,2020-01-08 19:11:25 +0000 UTC,sebmarkbage,,"The fixture might be a good start https://github.com/facebook/react/tree/master/fixtures/ssr (enableSuspenseServerRenderer flag to try it).

It has a long suspending thing.

It doesn't have a SuspenseList yet but might be nice.",,
16365,OPEN,ErrorBoundary rendering multiple copies of itself when ref assignment fails,Component: Reconciler; Type: Bug,2020-01-09 17:05:27 +0000 UTC,silverwind,,"**Do you want to request a *feature* or report a *bug*?**

bug

**What is the current behavior?**

When a error occurs during the assignment of a `ref` (and maybe other conditions), a error boundary wrapping that error may get confused and it renders itself multiple times inside the same parent. See https://codesandbox.io/s/stoic-fermi-6etqb which renders:

```html
<div id=""root"">
  <div class=""boundary""><span>content</span></div>
  <div class=""boundary""><span>error</span></div>
</div>
```

**What is the expected behavior?**

```html
<div id=""root"">
  <div class=""boundary""><span>error</span></div>
</div>
```",,
16342,OPEN,textarea does not show warning when switching from uncontrolled to controlled like inputs do,Component: DOM; Type: Bug,2019-12-01 22:39:25 +0000 UTC,bradwestfall,,"
While things like `<input>` correctly get a warning when switching from uncrontrolled to controlled, I'm noticing `<textarea>` does not

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

Here's a codesandbox. Type in the input field, we see error (correct), change to textarea and start over, type in field and we don't see the error (incorrect I think) https://codesandbox.io/s/recursing-dawn-jls8i

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.8
",,
16265,OPEN,Warning for 'exhaustive-deps' keeps asking for the full 'props' object instead of allowing single 'props' properties as dependencies,,2020-10-21 16:42:11 +0000 UTC,cbdeveloper,,"
When I'm in CodeSanbox using a React Sandbox I can use single properties of the `props` object as dependencies for the `useEffect` hook:

Example 1:

```
useEffect(()=>{
    console.log('Running useEffect...');
    console.log(typeof(props.myProp));
  },[ ]);
```

The example 1 gives me the following warning in CodeSandbox environment:

>React Hook useEffect has a missing dependency: '**props.myProp'**. Either include it or remove the dependency array. (react-hooks/exhaustive-deps) eslint

And if I add `[props.myProp]` to the array, the warning goes away.

But the same example 1 in my local environment in VSCode, I get the following warning:

>React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.eslint(react-hooks/exhaustive-deps)

**What is the expected behavior?**

I would expect that I would get the same behavior that I get on CodeSandbox in my local environment in VSCode.

But, if I add `[props.myProp]` to the array, the warning DOES NOT go away. Although the code works as intended.

What could be happening? Does CodeSandbox uses a different version of the plugin? Is there any configuration I can make to change this behavior?

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Versions I'm using:

DEV:
```
""eslint"": ""^5.10.0"",
""eslint-plugin-react"": ""^7.11.1"",
""eslint-plugin-react-hooks"": ""^1.6.1"",
```

REGULAR
```
""react"": ""^16.8.6"",
""react-dom"": ""^16.8.6"",
```

VSCODE (probably not causing this issue)

Version: 1.32.3 (user setup)
Commit: a3db5be9b5c6ba46bb7555ec5d60178ecc2eaae4
Date: 2019-03-14T23:43:35.476Z
Electron: 3.1.6
Chrome: 66.0.3359.181
Node.js: 10.2.0
V8: 6.6.346.32
OS: Windows_NT x64 10.0.17763

**.eslintrc.json**

```
{
  ""root""  :true,
  ""env"": {
    ""browser"": true,
    ""commonjs"": true,
    ""es6"": true,
    ""node"": true
  },
  ""extends"": [
    ""eslint:recommended"",
    ""plugin:react/recommended"",
    ""plugin:import/errors""
  ],
  ""parser"":""babel-eslint"",
  ""parserOptions"": {
    ""ecmaVersion"": 2018,
    ""sourceType"": ""module"",
    ""ecmaFeatures"": {
      ""jsx"":true
    }
  },
  ""plugins"":[
    ""react"",
    ""react-hooks""
  ],
  ""rules"": {
    ""react/prop-types"": 0,
    ""semi"": ""error"",
    ""no-console"": 0,
    ""react-hooks/rules-of-hooks"": ""error"",
    ""react-hooks/exhaustive-deps"": ""warn""
  },
  ""settings"": {
    ""import/resolver"" : {
      ""alias"" : {
        ""map"" : [
          [""@components"",""./src/components""],
          [""@constants"",""./src/constants""],
          [""@helpers"",""./src/helpers""]
        ],
        ""extensions"": ["".js""]
      }
    },
    ""react"" : {
      ""version"": ""detect""
    }
  }
}

```


",,
16258,OPEN,[Regression] onChange behaviour on radio buttons,Component: DOM; Type: Needs Investigation,2020-04-01 21:19:31 +0000 UTC,theKashey,,"**Do you want to request a *feature* or report a *bug*?**

Bug

**What is the current behavior?**

Having an uncontrolled, but _observed_ Radio Group, `onChange` would not be called on the previously selected Radio, only on the newly selected one.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/elastic-tu-yvytn

**What is the expected behavior?**

onChange is called on both `inputs`

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.8.6

This issue was fixed in 15.6.2 - https://github.com/facebook/react/issues/12172

**Workaround**
```js
const radioStates = new Map();
const nop = () => null;
export const Radio = ({inputGroupName, value}) => {
  const [checked, setChecked] = React.useState(false);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Radio change events are broken
    // see https://github.com/facebook/react/issues/9988
    // emulating Radio Group controller
    const group = e.target.name;

    // disable old radio    
    const oldHandler = radioStates.get(group) || nop;
    oldHandler(false); 

    // enable new radio
    radioStates.set(group, setChecked);    
    setChecked(e.target.checked);
  };

  return (
    <label>
      <input
        type=""radio""
        name={inputGroupName}
        value={value}
        onChange={handleInputChange}
      />
    </label>
  );
};
```",,
16161,OPEN,"onBeforeInput fires after browser updates the DOM for special characters like ""中"" or 😣on Firefox and Edge",Component: DOM; Type: Needs Investigation,2020-04-01 21:19:04 +0000 UTC,Chun-Yang,,"https://codesandbox.io/s/modest-franklin-muirj  
NOTE: pasting it would not trigger the bug, you have to type it in. You can use control-command-space to open the emoji keyboard on mac

**What is the expected behavior?**
DOM should not update before onBeforeInput fires

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React: 16.3.1
Firefox: 68.0.1 
Mac: 10.14.5
",,
16087,OPEN,[Umbrella] Memory Leaks,React Core Team,2020-09-23 20:27:47 +0000 UTC,sebmarkbage,,"This issue is a summary of issues mentioned in https://github.com/facebook/react/pull/15157.

There are many different ways to create memory leaks with React since we give you access to the imperative power to do so. Most should be dealt with by clean up / unmount functions.

Some could be pure React bugs. Some could be related to the lack of clean up of render phase effects. Others could be related to leaks that exists but the way React works makes them larger than they otherwise would've.

# Resolved

- [x] Land https://github.com/facebook/react/pull/16115 What patterns are actually covered? It can cut down on a potentially larger leak but is that the whole leak? I could imagine some patterns where this is the complete solution but unclear if it's the complete solution for the patterns that people are actually hitting in practice.

# Actionable

I think there are at least two actionable patterns to address from #15157:

- [ ] If a handle on a DOM node is leaked, it takes the React tree with it. This is a fairly easy mistake to make and the effect is pretty high. What we would do here is special case DOM nodes with refs on them, and always detach their back pointer to the React Fiber, if it was ever fully mounted. We currently traverse these trees anyway when they get deleted. We want to stop doing this for most things but for nodes with a ref it seems minor to special case since they typically need to be invoked with null anyway.
- [ ] Investigate the source of the leak in https://github.com/jonnycornwell/potential_react_leak and fix the source of the problem.

# Unresolved

- [ ] Closing over setState/dispatch or class component instances to global state can leak too. Does this pattern warrant special casing too? Under what conditions?
- [ ] It appears Chrome (and maybe other browsers?) may retain inputs due to the Undo Stack (https://github.com/facebook/react/issues/17581)
- [ ] What other issues remain after solving the actionable above? Let's make another pass investigating if people's original issues remain.

# Won't Fix

- Side-effects in class constructor, componentWillMount, componentWillReceiveProps, componentWillUpdate, getDerivedStateFrom... and render that store a reference to anything stateful outside React won't be able to clean up. This is [documented](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html) in the 16.3 release and is a major design decision as part of the concurrent/suspense/error handling strategy.
- Effects/state retained temporarily in alternate fiber likely won't be fixed short term. This is due to how Fiber uses two trees and swaps between them. This can lead to additional values being retained until that tree gets some work on it to swap again. This was observed in the Hooks release and there are some confusing cases where a destroy function can hold onto more memory than expected in the closure. Typically this is solved by using a custom hook since that gets its own scope/closure.
- Props/child trees retained by alternate children. Similarly, children that was just removed can sometimes between retained by the alternate copy of that. That is until that node gets another update on it which clears out the old children. These cases are fairly unusual and fix themselves eventually as the app lives on.",,
15989,OPEN,Collapsible Error Dialogs for the Ecosystem,Component: Developer Tools; React Core Team; Type: Feature Request,2020-01-08 19:11:48 +0000 UTC,gaearon,,"Spinoff from https://github.com/facebook/react/pull/15797#issuecomment-504782329.

Both in React Native and Create React App, redboxes are full screen. But in React, most errors are recoverable. Even with accidental runtime crashes it's useful to look ""underneath"" to see whether your boundary worked as expected, and to have an idea of the end user experience.

We could solve this with a collapsed-by-default floating error panel that just shows a list of messages. You can click to expand. We could also use this as an opportunity to unify the RN and web designs.",,
15988,OPEN,getDerivedStateFromError for Control Flow,Component: Reconciler; React Core Team; Type: Feature Request,2020-01-08 19:11:47 +0000 UTC,gaearon,,"Spinoff from https://github.com/facebook/react/pull/15797#issuecomment-504782329.

We might want to offer a way to ""bubble"" control flow up the tree a la Algebraic Effects. `throw Redirect()` is a canonical example. However, we want them to bypass the normal error boundaries. So it probably needs to be a first-class API.",,
15879,OPEN,Component delegation to context,,2019-06-13 17:47:48 +0000 UTC,,,"**Do you want to request a *feature* or report a *bug*?**
Report a bug

**Introduction/Concept**
I was trying to make a modal package (bootstrap visual as a placeholder) that instead of instancing modals all over the DOM and virtual DOM, would concentrate the data in a holder/controller. This controller would be responsible for providing the modal context and display/hide when necessary.

**What is the current behavior?**
The state of the modal content only updates when I recall the show method. 

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
https://codesandbox.io/s/modals-react-i8bdn (Bootstrap is included only to make the modal work)

**What is the expected behavior?**
That React would keep the state sync with the counter value.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.8.6
All browsers/OS
No",,
15739,OPEN,Controlled input makes browser not saving submitted value (for autocomplete),Component: DOM; Type: Bug,2021-01-30 10:18:42 +0000 UTC,bootleq,,"**Bug** (behaves different per browser, but generally inconsistent to uncontrolled inputs)

**Current behavior**
Reproduce with https://jsfiddle.net/bootleq/hos4r6qd/
1. Type `a` in *name* field, and `b` in *uncontrolled* field.
2. Submit.
3. Re-run the fiddle.
4. Focus input fields to see if browser ""saves"" previous input.

**Expected behavior**
Browser provides `a` suggestion for *name* and `b` for *uncontrolled* field.
Controlled and uncontrolled elements should behave the same.

**Actual result**
Uncontrolled input has `b` suggestion, but controlled input (*name*) has **no** suggestion.
Tested on Windows 7, Google Chrome 74.0.3729.169.
And on Firefox 68.0b4, we can click the *workaround* button before submit, by reset the `value` DOM attribute it behaves as expected.",,
15727,OPEN,Root-level performance events,React Core Team,2020-01-08 19:12:23 +0000 UTC,bvaughn,,"DevTools (and other perf related infra) would benefit from being able to observer the following:
* Starting (or resuming) work on a root.
* Completing (or yielding) work on a root.
* Committing work for a root.
* A particularly component suspending during a render.
* A suspended (identified by a component stack) promise resolving/retrying.
* An update being scheduled (e.g. `setState`) by a component (identified by a component stack).
* A root-level `render` call being made.

In order to fit within the context of the scheduler, we would also want to emit/capture the following events:
* The scheduler is starting to run tasks at a specific priority.
* The scheduler is stopping.
* The scheduler currently has X number of tasks scheduled for each priority. (Maybe this could be logged periodically? Or along with each time we stopped work at a priority?)

We could use this info to e.g. draw a timeline in the Profiler UI that showed CPU/IO work breakdown.

If we used a mechanism like `performance.mark` to record these events as part of the browser's profiling session, we could also include information about _unscheduled_ JavaScript- as well as other important related concepts, like network requests, paints, etc.

### Sequencing
- [ ] (ʀᴇᴀᴄᴛ) Add logging to react-reconciler and scheduler packages.
    * e.g. Make sure we are logging start/stop/yield/cancel for renders correctly
    * e.g. Make sure state-updates are being logged with the scheduled priority (not just the current)
    * Research: Make sure performance.mark is actually fast enough to use.
    * Add some basic test coverage to ensure we are marking the expected events in the expected order.
    * (Do not expose component stacks for now).
- [ ] (ʀᴇᴀᴄᴛ) Design API for DevTools to start/stop performance marking.
    * This shouldn’t be on by default, only when we’re actually profiling.
- [ ] (ʀᴇᴀᴄᴛ) Design public API (if we want one) for collecting and logging these new data points.
    * Web-speed would probably like to collect this data.
- [ ] (ᴅᴇᴠᴛᴏᴏʟs) [Parse Chrome](https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview) performance profile JSON output.
    * Filter unsupported event types.
    * Massage data slightly (e.g. combine multiple micro-yields into a single task).
- [ ] (ᴅᴇᴠᴛᴏᴏʟs) Create visualization (chart) UI for data.
    * Turn individual events (or “B” and “E” pairs) into graphics on a timeline.
    * Needs exploratory prototyping / design work.
- [ ] (ᴅᴇᴠᴛᴏᴏʟs) Create zoom-and-pan controls.
    * Something that works similar to Chrome’s Performance tab probably.
    * Enables zooming in on regions of profiling data.
    * Would be nice to build using the interactions stuff Dominic/Nicolas made for Comet
    * Consider not zooming all the way out by default (but setting some max zoom-out cap?)
    * Consider adding windowing logic to avoid rendering things outside of the viewport?
- [ ] (ᴅᴇᴠᴛᴏᴏʟs) Add [Chrome debug protocol](https://chromedevtools.github.io/devtools-protocol/tot/Profiler#method-start) support
    * Requires [“debugger” permission](https://developer.chrome.com/extensions/debugger), but it should be an [optional permission](https://developer.chrome.com/extensions/permissions) that we just-in-time prompt for.
- [ ] (ʀᴇᴀᴄᴛ/ᴅᴇᴠᴛᴏᴏʟs) Initial integration.
    * When user starts profiling React, Chrome’s profiling recorder should also be started.
        * We may want to enable running one without the other? Depends on how much overhead.
    * Also call the React hook to enable performance.mark calls for scheduler and react-dom.
- [ ] (ʀᴇᴀᴄᴛ/ᴅᴇᴠᴛᴏᴏʟs) Improved integration.
    * Add component stack ID to marked “update state” and “suspend” events (e.g. “state-update-normal-123”)
    * Read actual component stack string from DevTools using this ID.
- [ ] (ʀᴇᴀᴄᴛ/ᴅᴇᴠᴛᴏᴏʟs) Explore implementing a queue size visualization
    * Would require a new event or a hook into scheduler to get the current queue size.",,
15726,OPEN,Improving the component logging/debugging experience,React Core Team; Type: Discussion,2020-02-11 08:41:15 +0000 UTC,bvaughn,,"# Backstory

DevTools re-renders function components that use hooks in order to build up metadata to display in the selected element panel. This may cause confusion, since these re-renders will trigger breakpoints and cause unexpected console logging (see [this comment](https://github.com/facebook/react-devtools/issues/1215#issuecomment-495382645)). We avoid unnecessary re-renders by caching data (see [PR 289](https://github.com/bvaughn/react-devtools-experimental/pull/289)) but even so this is likely to be a point of confusion.

# Solution

It would be nice if the shallow re-rendering done by DevTools were less observable (e.g. console logs were suppressed to avoid cluttering the console). Breakpoints would still be hit, but that seems like a less common use case. 

While we are considering logging, we might also consider if there are additional improvements that could be made, e.g.

1. Add a new section to the Components tree that shows the most recently logged messages for a given component.
2. Add an option to coalesce render-time logs into a single message that's printed at commit (or error) time to make debug logging easier to read. (Perhaps we could use `console.group` to also indicate the nested structure of these logs.)

The proposals below address both (a) collecting per-component logging info and (b) temporarily disabling console logging while re-rendering for inspection purposes.

# API Proposals

## 1: Modify built-in `console` methods

DevTools could spy on the built-in `console` methods and disable the pass-through functionality when re-rendering.

### Pros
* Requires no effort / code changes for developers to opt in and benefit from this.
* ""Just works"" for advanced methods like `console.group` and `console.table`.
* ""Just works"" for third party libraries that may not even be React-specific.
### Cons
* Feels questionable to modify native browser APIs.

## 2: Add `React.log` and `React.info` API

React will be adding two new logging methods in the upcoming v16.9 release- `React.warn` and `React.error` (see #15170). These methods decorate `console.warn` and `console.error` and append the current component stack to any logged messages. We could extend this pattern and add additional `log` and `info` methods. These APIs could be extended by DevTools as needed.

### Pros
* Does not require mutating global APIs.
### Cons
* Requires code changes to opt-in.
* Would not cover (or would be a hassle to cover) all `console` methods (e.g. `group`)
* Would not work for third party components or non-React utility code.

## 3: Add `React.debug(callback)` API

React could add a new `debug` API that accepts a callback for general debug operations (most commonly `console` logging, but also potentially breakpoints or other things).

### Pros
* Works with breakpoints.
* Covers more complex use cases (e.g. pushing to an array for debug purposes).
* Single method rather than mirroring (or spying on) multiple `console` APIs.
### Cons
* Requires code changes to opt-in.
* Requires more boilerplate for simple logging use cases.
",,
15520,OPEN,Cannot suppress error boundary output using react-test-renderer,,2020-12-12 14:17:18 +0000 UTC,mpeyper,,"
When following @gaearon's example on [how to suppress the error boundary logging in tests expecting errors](https://github.com/facebook/react/issues/11098#issuecomment-412682721), it appears to not be working in 16.8.6 (I'm not sure which versions after 16.4.3 is _has_ worked for).

[Here is a sandbox.](https://codesandbox.io/s/l5mrl747wm?expanddevtools=1&fontsize=14&module=%2Fsrc%2Fexample.test.js&previewwindow=tests)

I had to make a change to the `renderError` as it looks like the way codesandbox executes the script cause the `event.error` to be hidden from the code (it just had an object with `isTrusted: true` on it - google led me [here](https://stackoverflow.com/a/44862693/6902543) so I changed it to just count the number of errors).

I also made a change to be able to use `react-test-renderer` as well as `react-dom` as I'm actually after a way to suppress the error using the test renderer for an [issue raised in `react-hooks-testing-library`](https://github.com/mpeyper/react-hooks-testing-library/issues/50).

In my sandbox, you will see the errors

> The above error occurred in the <Darth> component:
> in Darth
> in TestBoundary
>
> React will try to recreate this component tree from scratch using the error boundary you provided, TestBoundary.

and

> The above error occurred in the <ObiWan> component:
> in ObiWan
> in TestBoundary
> 
> React will try to recreate this component tree from scratch using the error boundary you provided, TestBoundary.

get printed to the console, despite the `event.preventDefault()` call.

The other main thing to note is that the `react-test-renderer` test does not pass, which implies the error listener is not firing for it, which sort of makes sense to me as it's not using the DOM, so it's not erroring on the window, but my understanding of these things is somewhat limited.

**What is the expected behavior?**

Assuming the `expectRenderError`, `TestBoundary` and `handleTopLevelError` code is sufficient to suppress the output as indicated in #11098, I would expect the `react-dom` test to produce no output.

Assuming the same setup should also work for `react-test-renderer`, I would also expect that test to have no output.

If either of these assumptions are wrong, how should one go about suppressing the output in these tests?  

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

`react`: `16.8.6`
`react-dom`: `16.8.6`
`react-test-renderer`: `16.8.6`",,
15488,OPEN,eslint-plugin-react-hooks suggests adding a dependency on a function that always changes,Component: ESLint Rules; Partner; Type: Enhancement,2020-01-08 23:42:28 +0000 UTC,sophiebits,,"If you write:

```js
import React, {useEffect} from 'react';
const Foo = ({ orgId }) => {
  const fetchOrg = () => {
    alert(orgId);
  };
  useEffect(() => {
    fetchOrg();
  }, [orgId]);
  return <div />;
};
```

then you get the error:

> React Hook useEffect has a missing dependency: 'fetchOrg'. Either include it or remove the dependency array

But if you follow that advice and add `fetchOrg` to the dep array, you get:

> The 'fetchOrg' function makes the dependencies of useEffect Hook (at line 6) change on every render. Move it inside the useEffect callback. Alternatively, wrap the 'fetchOrg' definition into its own useCallback() Hook

Ideally it could suggest the second solution immediately, instead of suggesting a remediation that it will immediately warn about.",,
15486,OPEN,<details> open attribute not synchronised,Type: Needs Investigation,2020-08-06 04:22:16 +0000 UTC,afenton90,,"**What is the expected behavior?**
The `open` attribute stays synchronised with the virtual dom and is added/removed.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React: **`16.8.6`**
Browser: **Chrome**
Did this work in previous versions of React? **No**
",,
15484,OPEN,An error in render() + boundary behaves unexpectedly on ReactDOM.hydrate(),Component: Server Rendering; Type: Bug,2020-04-18 07:08:05 +0000 UTC,Rendez,,"From the React.org docs:
> Error boundaries preserve the declarative nature of React, [...] somewhere deep in the tree, **it will still correctly propagate to the closest error boundary.**

**Do you want to request a *feature* or report a *bug*?**
I am not sure if this is a bug or intended behavior, because it only happens with `ReactDOM.hydrate` when an error is thrown only within `render`.

**What is the current behavior?**
If an error is thrown in the `render()` method of any component, the error boundary at any given top-level renders its fallback exactly where that component is, instead of where the error boundary is defined.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
https://codesandbox.io/s/74kmwk3o1j

**What is the expected behavior?**
Just like it `ReactDOM.hydrate` behaves if the error happens in `componentDidMount`, the error boundary's fallback should be rendered where the error boundary element is actually declared.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
v16.8.6 on Chrome, haven't tested previous versions, but I think to remember this working correctly when we upgraded to v16 and added our top-level, page boundary.
",,
15446,OPEN,Events before Client Side Hydration,Resolution: Backlog,2021-01-29 21:17:56 +0000 UTC,aralroca,,"Recently I detected a problem using React in SSR. Maybe is quite obvious, but all the JavaScript events that are fired before the JavaScript is loaded, are lost...

This is something normal. The JS is not there yet... Ok. However, I expect to have some utility to do some exceptions.

I'm going to try to explain my case:

I'm using an image, and in the event `onError`, I want to change the src to render a fallback image.

```jsx
function Img(props) {
  return (
    <img {...props} onError={e => { e.target.src = fallbackSrc } } />
  )
}
```

Nevertheless, this code loaded from SSR, is working ""sometimes""... I guess that this ""sometimes"" is because if the event is fired before the client side hydration. Is not catched by my JS. And the `e => e.target.src = fallbackSrc` is never executed. However, if the JS is loaded faster than the onError event, is catched, and is rendering the fallback image as I expected.

I want to propose some utility to do sometimes some exceptions, and render the JS inline on the first render. Perhaps, adding some extra config in `ReactDOM.hydrate`? I dunno... 

Or maybe someone can help me providing any tip in order to fix this?

",,
15439,OPEN,act() should warn in testing frameworks besides jest,Component: Test Utils; React Core Team; Type: Feature Request,2020-01-08 19:12:59 +0000 UTC,threepointone,,"**Do you want to request a *feature* or report a *bug*?**

feature request

**What is the current behavior?**

The warnings for missing act() warnings around updates only happen in jest. 

**What is the expected behavior?**

We should support other test runners/frameworks as well (like jasmine, karma, etc)

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.8.0+",,
15418,OPEN,"Field type=""email"" with multiple attribute cursor jumps to start",Component: DOM; Type: Bug,2020-11-06 20:35:45 +0000 UTC,jordyvg,,"
Example pure React: https://codesandbox.io/embed/0y06zo7l8p
Example React with Formik: https://codesandbox.io/embed/k57zw7wz5
MDN docs: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#multiple

**What is the expected behavior?**
Cursor stays on current position.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Chrome 73, Safari 12.1, Opera 60.0
React 16.7.0

Maybe #14551 related?
",,
15344,OPEN,useReducer's dispatch should return a promise which resolves once its action has been delivered,Component: Hooks; Type: Feature Request,2020-12-30 07:51:58 +0000 UTC,pelotom,,"(This is a spinoff from [this thread](https://github.com/facebook/react/issues/15240).)

It's sometimes useful to be able to dispatch an action from within an async function, wait for the action to transform the state, and then use the resulting state to determine possible further async work to do. For this purpose it's possible to define a `useNext` hook which returns a promise of the next value:

```js
function useNext(value) {
  const valueRef = useRef(value);
  const resolvesRef = useRef([]);
  useEffect(() => {
    if (valueRef.current !== value) {
      for (const resolve of resolvesRef.current) {
        resolve(value);
      }
      resolvesRef.current = [];
      valueRef.current = value;
    }
  }, [value]);
  return () => new Promise(resolve => {
    resolvesRef.current.push(resolve);
  });
}
```

and use it like so:

```js
const nextState = useNext(state);

useEffect(() => {
  fetchStuff(state);
}, []);

async function fetchStuff(state) {
  dispatch({ type: 'START_LOADING' });
  
  let data = await xhr.post('/api/data');
  dispatch({ type: 'RECEIVE_DATA', data });
  
  // get the new state after the action has taken effect
  state = await nextState();

  if (!state.needsMoreData) return;

  data = await xhr.post('/api/more-data');
  dispatch({ type: 'RECEIVE_MORE_DATA', data });
}
```


This is all well and good, but `useNext` has a fundamental limitation: it only resolves promises when the state _changes_... so if dispatching an action resulted in the same state (thus causing `useReducer` to [bail out](https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-state-update)), our async function would hang waiting for an update that wasn't coming.

What we _really_ want here is a way to obtain the state after the last dispatch has taken effect, whether or not it resulted in the state changing. Currently I'm not aware of a foolproof way to implement this in userland (happy to be corrected on this point). But it seems like it could be a very useful feature of `useReducer`'s `dispatch` function itself to return a promise of the state resulting from reducing by the action. Then we could rewrite the preceding example as

```js
useEffect(() => {
  fetchStuff(state);
}, []);

async function fetchStuff(state) {
  dispatch({ type: 'START_LOADING' });
  
  let data = await xhr.post('/api/data');
  state = await dispatch({ type: 'RECEIVE_DATA', data });
  
  if (!state.needsMoreData) return;

  data = await xhr.post('/api/more-data');
  dispatch({ type: 'RECEIVE_MORE_DATA', data });
}
```

## EDIT

Thinking about this a little more, the promise returned from `dispatch` doesn't need to carry the next state, because there are other situations where you want to obtain the latest state too and we can already solve that with a simple ref. The narrowly-defined problem is: we need to be able to wait until after a `dispatch()` has taken affect. So `dispatch` could just return a `Promise<void>`:

```js
const stateRef = useRef(state);
useEffect(() => {
  stateRef.current = state;
}, [state]);

useEffect(() => {
  fetchStuff();
}, []);

async function fetchStuff() {
  dispatch({ type: 'START_LOADING' });
  
  let data = await xhr.post('/api/data');

  // can look at current state here too
  if (!stateRef.current.shouldReceiveData) return;
  
  await dispatch({ type: 'RECEIVE_DATA', data });

  if (!stateRef.current.needsMoreData) return;

  data = await xhr.post('/api/more-data');
  dispatch({ type: 'RECEIVE_MORE_DATA', data });
}
```",,
15317,OPEN,[Concurrent] Safely disposing uncommitted objects,Type: Discussion,2020-12-26 18:34:19 +0000 UTC,FredyC,,"## How to safely keep a reference to uncommitted objects and dispose of them on unmount? 

For a MobX world, we are trying to [prepare for the Concurrent mode](https://github.com/mobxjs/mobx-react-lite/issues/53). In short, there is a [Reaction object being created](https://github.com/mobxjs/mobx-react-lite/blob/231be100e6ba458f40642adb9f0bc77aa4d366ce/src/useObserver.ts#L32
) to track for observables and it is stored within `useRef`.

The major problem is, that we can't just `useEffect` to create it in a safe way later. We need it to start tracking the observables on a first render otherwise we might miss some updates and cause inconsistent behavior.

We do have a [semi-working solution](https://github.com/mobxjs/mobx-react-lite/pull/121), basically, a custom made garbage collector based on `setTimeout`. However, it's unreliable as it can accidentally dispose of Reactions that are actually being used but weren't committed yet.

Would love to hear we are overlooking some obvious solution there.",,
15293,OPEN,Is it recommended to fetch in effect or should it be imperative,Component: Hooks; Type: Discussion,2021-03-24 18:31:38 +0000 UTC,otakustay,,"In out team we encountered a explosive discussion on how we should handle the relationship of a fetch and its parameters, after searching in community I still find various solutions to this, I'd like to raise this discussion to find a best practive.

## Background

Suppose we have a simple list view like:

<img width=""687"" alt=""Jietu20190402-130206@2x"" src=""https://user-images.githubusercontent.com/639549/55377435-87268b80-5547-11e9-97a8-313a5713ced3.png"">

Whenever user types keyword in textbox and clicks ""Search"" button, or they change the page number, we should fetch a new list from remote and render it in table.

We use redux to manage global state of this simple app, the store is structured as:

```js
{
    filter: '',
    pageIndex: 0,
    results: []
}
```

We developed a total of 3 solutions to demonstrate how the change of `filter` and `pageIndex` should cause a fetch of `results`.

## Use effect and separation of view and logic

This is the first demo: https://codesandbox.io/s/20x1m39w00

In this implementation we tried to:

1. Utilize `useEffect` to trigger a fetch when any parameter changes.
2. Do not pass any parameter as prop to `components/List` component.

In my point of view, I like this solution best because:

1. It have a very clear separation of view and logic, `components/List` does not receive any redundant props such as `filter` or `pageIndex`.
2. It theoretically treat a callback prop as a normal one, make it a dependency of `useEffect`.
3. It works in a **reactive** way, which means ""we trigger a fetch not because the action taken from user, only because the change of state"".

Still we have concerns about it:

1. It obviously triggers more render and updates because change of `filter` or `pageIndex` does not dispatch `FETCH_RESULTS` immediately, this cause a sync dispatch in effect which we previously avoided by `no-set-state-did-update` rule.
2. We create a state update from another state update, this ""chaining"" is not clear enough for developers and may cause unwanted infinite loop.

## Use effect and params together

The second demo is much like the first one: https://codesandbox.io/s/54o1rjvyv4

The only change is we pass `filter` and `pageIndex` to `components/List`, in this case we believe **effect is a part of component** so that every dependencies used to form an effect should be passed as prop.

This solution gives a more clear view of what is used to fetch data in `components/List`, this is 
 a highly adopted solution in community, however we're not sure this is recommended officially.

## Imperative action to fetch data

As opposed to previous, this is our third demo: https://codesandbox.io/s/p5yv48x97x

In this solution we changed our thought and implement the app in a more ""redux way"":

1. We trigger the fetch on user interactions, either click on ""Search"" button or change the page number, however either interaction only provides its own parameter, we don't provide `pageIndex` when ""Search"" button is clicked.
2. We have a thunk which computes a new parameter object based on current state using `getState()` function, a `FETCH_RESULTS` action is dispatched.
3. We have several reducers to observe `FETCH_RESULTS` action and updates corresponding parameter in global state.
4. Fetched list is connected to `components/List` component, this component now is a pure presentational component, no lifecycle effect is involved.
5. To solve the first fetch when application is mounted, we create an `containers/App` container component.

By doing these we eliminated the ""chaining state update"" issue, however it introduces several concerns:

1. If we add more user interactions in the future, the `loadResults` thunk could be more and more complex.
2. The use of `getState` in `redux-thunk` is not highly recommended in community, we found some articles stating that developers should avoid to use it in most cases.
3. We can't explain the exist of the `containers/App` container only to trigger a fetch on mount, thee `useEffect` take no dependencies and `exhaustive-deps` rules complains about it, not paring mount and update is also a big uncomfortable point to us.
4. Trigger fetch from user interactions is what we called ""imperative"", we're confused about whether a reactive framework like react recommends imperative programming.

------

Since we are not able to get a conclusion for a very long time, we decide to raise this issue for more discussion to find a better solution to these very common use cases.",,
15278,OPEN,useMemo / useCallback cache busting opt out,Type: Discussion,2021-04-09 22:52:33 +0000 UTC,alexreardon,,"According to the `React` docs, `useMemo` and `useCallback` are subject to cache purging:

> You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without useMemo — and then add it to optimize performance. [source](https://reactjs.org/docs/hooks-reference.html#usememo)

I am working on moving `react-beautiful-dnd` over to using hooks https://github.com/atlassian/react-beautiful-dnd/issues/871. I have the whole thing working and tested 👍 

It leans quite heavily on `useMemo` and `useCallback` right now. If the memoization cache for is cleared for a dragging item, the result will be a cancelled drag. This is not good. 

My understanding is that `useMemo` and `useCallback` are currently *not* subject to cache purging based on this language:

> In the **future**, React may choose to “forget”

**Request 1**: Is it possible to opt-out of this cache purging? Perhaps a third `options` argument to `useMemo` and `useCallback`:

```js
const value = useMemo(() => ({ hello: 'world' }), [], { usePersistantCache: true });
```

(Naming up for grabs, but this is just the big idea)

A work around is to use a custom memoization toolset such as a `useMemoOne` which reimplements `useMemo` and `useCallback` just using `ref`s [see example](https://twitter.com/alexandereardon/status/1108488559881641986)

I am keen to avoid the work around if possible.

**Request 2**: While *request 1* is favourable, it would be good to know the exact conditions in which the memoization caches are purged",,
15255,OPEN,Profiler marks,Component: Developer Tools; React Core Team; Type: Enhancement,2020-02-11 03:48:34 +0000 UTC,bvaughn,,"Can we expose a lighter weight set of Performance ""marks"" for people consuming browser Performance tracing? e.g. when a particular `Profiler` commits. This should be a lot less heavyweight than the full mark-and-measure stuff.",,
15240,OPEN,Dancing between state and effects - a real-world use case,Type: Discussion,2019-10-08 21:39:01 +0000 UTC,jlongster,,"I started this as a gist but Dan mentioned that this would be a good discussion issue so here goes. I've been writing with and refactoring code into hooks for a while now. For 95% of code, they are great and very straight-forward once you get the basic idea. There are still a few more complex cases where I struggle with the right answer though. This is an attempt to explain them.

## The use case

This is a real-world use case from an app I'm building: interacting with a list items. I've simplified the examples into codesandboxes though to illustrate the basic idea.

Here's the first one: https://codesandbox.io/s/lx55q0v3qz. It renders a list of items, and if you click on any of them, an editable input will appear to edit it (it doesn't save yet). The colored box on the right will change whenever an item rerenders.

If you click around in the items, you can see that when changing the edited item, all items rerender. But the `Row` component is wrapped with `React.memo`! They all rerender because the `onEdit` is new each time the app renders, causing all items to rerender.

## Maintaining callback identity

We want `onEdit` to be same function for all future renders. In this case, it's easy because it doesn't depend on anything. We can simply wrap it in `useCallback` with an empty dependencies array:

```js
  let onEdit = useCallback(id => {
    setEditingId(id);
  }, []);
```

Now, you can see clicking around only rerenders the necessary items (only those colors change): https://codesandbox.io/s/k33klz68yr

## Implementing saving

We're missing a crucial feature: after editing an item, on blur it should save the value. In my app the way the ""save"" event gets triggered is different, but doing it on blur is fine here.

To do this, we create an `onSave` callback in the app and pass it down to each item, which calls it on blur with the new value. `onSave` takes a new item and updates the items array with the new item and sets the `items` state.

Here is it running: https://codesandbox.io/s/yvl79qj5vj

You'll notice that all items are rerendering again when saving. The list rerenders twice when you click another item: first when you click down and the input loses focus, and then again to edit a different item. So all the colors change once, and then only the editing rows color changes again.

The reason all of them are rerendering is because `onSave` is now a new callback every render. But we can't fix it with the same technique as `onEdit` because it depends on `items` - so we *have* to create a new callback which closes over `items` otherwise you'd lose previous edits. This is the ""callbacks are recreated too many times"" problem with hooks.

One solution is to switch to `useReducer`. Here's that implementation:
https://codesandbox.io/s/nrq5y77kj0

Note that I still wrap up the reducer into `onEdit` and `onSave` callbacks that are passed down to the row. I find passing callbacks to be clearer in most cases, and works with any components in the ecosystem that already expect callbacks. We can simply use `useCallback` with no dependencies though since `dispatch` is always the same.

Note how that even when saving an item, only the necessary rows rerender.

## The difference between event handlers and dispatch

There's a problem though. This works with a simple demo, but in my real app `onSave` *both* optimistically updates local state and saves it off to the server. It does a side effect.

It's something like this:

```js
async function onSave(transaction) {
  let { changes, newTransactions } = updateTransaction(transactions, transaction);
  // optimistic update
  setTransactions(newTransactions)
  // save to server
  await postToServer('apply-changes', { changes })
}
```

There's a big difference between the phase when an event handler and dispatch is run. Event handlers are run whenever they are triggered (naturally) but the dispatching the action (running `reducer`) happens when rendering. The reducer must be pure because of this.

Here's the reducer from https://codesandbox.io/s/nrq5y77kj0:

```js
  function reducer(state, action) {
    switch (action.type) {
      case ""save-item"": {
        let { item } = action;
        return {
          ...state,
          items: items.map(it => (it.id === item.id ? item : it))
        };
      }
      case ""edit-item"": {
        return { ...state, editingId: action.id };
      }
    }
  }
```

How is `save-item` also supposed to trigger a side effect? First, item's important to understand these 3 phases:

```
Event handler -> render -> commit
```

Events are run in the first phase, which causes a render (when dispatches happen), and when everything is finally ready to be flushed to the DOM it does it in a ""commit"" phase, which is when all effects are run (more or less).

We need our side effect to run in the commit phase.

### Option 1

One option is to use a ref to ""mark"" the saving effect to be run. Here's the code: https://codesandbox.io/s/m5xrrm4ym8

Basically you create a flag as a ref:

```js
let shouldSave = useRef(false);
```

Luckily, we've already wrapped the save dispatch into an event handler. Inside `onSave` we mark this flag as true. We can't do it inside of the reducer because it must be pure:

```js
  let onSave = useCallback(item => {
    shouldSave.current = true;
    dispatch({ type: ""save-item"", item });
  }, []);
```

Finally, we define an effect that always runs after rendering and checks the flag and resets it:

```js
  useEffect(() => {
    if (shouldSave.current) {
      // save... all the items to the server?
      post(items)
      shouldSave.current = false;
    }
  });
```

I thought this option was going to work, but just ran into this issue. We don't know *what* to save anymore. We certainly don't want to send the entire items array to the server! I suppose we could store the item in the ref, but what happens if multiple events are fired before the effect runs? I suppose you could store an array, but... do we really need that?

### Option 2

**Note**: I just noticed this option is documented in [How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback), but I disagree with the tone used. I think this is a fine pattern an better in many cases than `dispatch`, even if it's not quite as robust. Especially since it's not as powerful as callbacks. (see end of this section)

Keeping around all of the data we need to do the effect might work in some cases, but it feels a little clunky. If we could ""queue up"" effect from the reducer, that would work, but we can't do that. Instead, another option is to embrace callbacks.

Going back to the version which used a naive `onSave` which forced all items to rerender (https://codesandbox.io/s/yvl79qj5vj), `onSave` looks like this:

```js
  let onSave = useCallback(
    item => {
      setItems(items.map(it => (it.id === item.id ? item : it)));
    },
    [items]
  );
```

The core problem is that it depends on items. We need to recreate `onSave` because it closes over `items`. But what if it didn't close over it? Instead, let's create a ref:

```js
let latestItems = useRef(items);
```

And an effect which keeps it up-to-date with items:

```js
useEffect(() => {
  latestItems.current = items
});
```

Now, the `onSave` callback can reference the ref to always get the up-to-date items. Which means we can memoize it with `useCallback`:


```js
let onSave = useCallback(item => {
  setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));
}, []);
```

We are **intentionally** opting to always referencing the latest item. The biggest change with hooks in my opinion is that they are safe by default: an async function will always reference the exact same state that existed at the time they were called. Classes operate the other way: you access state from this.state which can be mutated between async work. Sometimes you want that though so you can maintain callback identity.

Here is the running sandbox for it: https://codesandbox.io/s/0129jop840. Notice how you can edit items and only the necessary rows rerender, even though it updates `items`. Now, we can do anything we want in our callback, like posting to a server:

```js
let onSave = useCallback(item => {
  setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));
  // save to server
  post('/save-item', { item })
}, []);
```

Basically, if all you need is the latest data since last commit, **callbacks can be memoized as well as reducers**. The drawback is that you need to put each piece of data you need in a ref. If you have lots of pieces of data and only a few simple effects, reducers would be better, but in my case (and I suspect in many others) it's easier to use callbacks with refs.

It's nice too because in my real app the save process is more complicated. It needs to get changes back from the server and apply them locally as well, so it looks more like this:

```js
let onSave = useCallback(item => {
  setItems(latestItems.current.map(it => (it.id === item.id ? item : it)));
  // save to server
  let changes = await post('/save-item', { item })
  applyChanges(latestItems.current, changes)
}, []);
```

Maintainability-wise, it's *really* nice to see this whole flow here in one place. Breakin this up to try to manually queue up effects and do a dance with `useReducer` feels much more convoluted.

### Option 3

I suppose another option would be to try to ""mark"" the effect to be run in state itself. That way you could do it in `useReducer` as well, and it would look something like this:

```js
function reducer(state, action) {
  switch (action.type) {
    case ""save-item"": {
      let { item } = action;
      return {
        ...state,
        items: state.items.map(it => (it.id === item.id ? item : it)),
        itemsToSave: itemsToSave.concat([item])
      };
    }
    // ...
  }
}
```

And an effect would check the `itemsToSave` state and save them off. The problem is resetting that state - the effect would have to change state, causing a useless rerender, and it's not determistic to make sure that the effect does not run multiple times before `itemsToSave` gets reset.

In my experience mixing effects into state, causing renders, make things a lot more difficult to maintain and debug.

### What's the difference between Option 1 and 2?

Is there a crucial difference between 1 and 2? Yes, but I'd argue it's not a big deal if you can accept it. Remember these three phases:

```
Event handler -> render -> commit
```

The big difference is option 1 is doing the side effect in the commit phase, and option 2 is doing it in the event handler phase. Why does this matter?

If, for some reason, an item called `onSave` multiple times before the next commit phase happened, option 1 is more robust. A reducer will ""queue up"" the actions and run them in order, updating state in between them, so if you did:

```js
onSave({ id: 1, name: ""Foo"" })
onSave({ id: 2, name: ""Bar"" })
```

which runs the callback twice immediately, the reducer will process the first save and update the items, and process the second save **passing in the already updated state**.

However, with option 2, when processing the second save **the commit phase hasn't been run yet** so the `latestItems` ref hasn't been updated yet. **The first save will be lost**.

However, the ergonomics of option 2 is much better for many use cases, and I think it's fine to weight these benefits and never need the ability to handle such quick updates. Although concurrent mode might introduce some interesting arguments against that.

## Another small use case for triggering effects

In case this wasn't already long enough, there's a similar use case I'll describe quickly. You can also add new items to the list by editing data in an empty row, and the state of this ""new item"" is tracked separately. ""Saving"" this item doesn't touch the backend, but simply updates the local state, and separate explicit ""add"" action is needed to add it to the list.

The hard part is that there is a keybinding for adding the item to the list while editing - something like alt+enter. The problem is I want to coordinate with the state change, so first I want to save the existing field and *then* add to the list. The saving process is complicated so it need to run through that first (I can't just duplicate it all in `onAdd`).

This isn't a problem specific to hooks, it's just about coordinating with state changes. When I was working with reducers, I had though that something like this would be neat. Basically when the new items detect that you want to save + add it first an action like `{ type: 'save-item', fields: { name: 'Foo' }, shouldAdd: true }`


```js
function reducer(state, action) {
  switch (action.type) {
    case ""save-item"": {
      let { fields } = action;
      let newItem = { ...state.newItem, ...fields };

      if(action.shouldAdd) {
        shouldAdd.current = true
      }

      return { ...state, newItem };
    }
    // ...
  }
}
```

where `shouldAdd` is a ref that is checked on commit phase and saves the item off to the server. This isn't possible though.

Another option would be for the item to call `onAdd` instead of `onSave` when saving + adding, and you could manually call the reducer yourself to process the changes:

```js
async function onAdd(fields) {
  let action = { type: 'save-item', fields }
  dispatch(action)
  
  let newItem = reducer(state, action)
  post('/add-item', { newItem });

}
```

This is kind of a neat trick: you are manually running the reducer to get the updated state, and React will run the reducer again whenever it wants.

Since I ended up liking callbacks for my original problems, I ended up going with a similar approach where I have a ref flag that I just set in `onSave`:

```js
let [newItem, setNewItem] = useState({})
let latestNewItem = useRef(newItem);
let shouldAdd = useRef(false);

useEffect(() => {
  latestNewItem.current = newItem;
})

useEffect(() => {
  if(shouldAdd.current) {
    setNewItem({})
    post('/add-item', { newItem })
    shouldAdd.current = false;
  }
})

let onSave = useCallback((fields, { add }) => {
  // In my real app, applying the changes to the current item is a bit more complicated than this,
  // so it's not an option to separate on an `onAdd` function that duplicates this logic
  setNewItem({ ...latestNewItem.current, ...fields });

  // This action also should add, mark the effect to be run
  if(add) {
    shouldAdd.current = true;
  }
}, [])
```

## Conclusions

Sorry for the length of this. I figure I'd be over-detailed rather than under-detailed, and I've been brewing these thoughts since hooks came out. I'll try to conclude my thoughts here:

* Effects are **very nice**. It feels like we have easy access to the ""commit"" phase of React, whereas previously it was all in `componentDidUpdate` and not composable at all. Now it's super easy to throw on code to the commit phase which makes coordinating stuff with state easier.

* Reducers have interesting properties, and I can see how they are fully robust in a concurrent world, but for many cases they are too limited. The ergonomics of implementing many effect-ful workflows with them requires an awkward dance, kind of like when you try to track effect states in local state and split up workflows. Keeping a linear workflow in a callback is not only nice, but necessary in many cases for maintainability.

* Callbacks can be made memoizable without much work. In many cases I think it's easier to use the ref trick than reducers, but the question is: just *how* dangerous is it? Right now it's not that dangerous, but maybe concurrent mode really is going to break it.

* If that's the case, we should figure out a better way to weave together effects and state changes.

I hope all of this made sense. Let me know if something is unclear and I'll try to fix it.",,
15238,OPEN,Noscript tags no longer rendering components in 16.5.0,Type: Discussion,2020-08-18 14:54:18 +0000 UTC,zfletch,,"**Do you want to request a *feature* or report a *bug*?**

Bug

**What is the current behavior?**

Starting in version 16.4.3, the following code:

```
<noscript>
  <a href=""/cat"">Cat</a>
  <a href=""/dog"">Dog</a>
</noscript>
```

is being rendered in the browser as:

```
<noscript></noscript>
```

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**

Prior to 16.4.3: https://codesandbox.io/embed/5mww4nzpwp

After 16.4.3: https://codesandbox.io/embed/6v8m4yo303

(The changes are not visible, but if you `inspect element` you can see that, in the first example, the links are being rendered, and in the second example they're not being rendered.)

**What is the expected behavior?**

It should render in the browser the same as in the code:

```
<noscript>
  <a href=""/cat"">Cat</a>
  <a href=""/dog"">Dog</a>
</noscript>
```

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

See above, it was working in versions prior to 16.4.3. (I couldn't find a previous issue mentioning this bug. I think it could have been introduced in the fix for https://github.com/facebook/react/issues/11423)

**Why is this a problem?**

I use a snapshot tool with React to generate a set of static pages from a React project. These pages have less functionality than the full application, but they allow webcrawlers and users who have disabled JavaScript to use the site at a basic level. For example, the code might look like this:

```
<FancyInteractiveButton linksTo=""page"">link</FancyInteractiveButton>
<noscript>
  <a href=""page"">link</a>
</noscript>
```

Preventing components in `<noscript>` tags from rendering breaks this functionality for users with JavaScript disabled. The generated snapshots no longer contain the links. It also makes the site harder to navigate by webcrawlers, even if they have JavaScript enabled, because they have to be smart enough to use the fancy button instead of following the link.",,
15221,OPEN,Hook equivalent for `getSnapshotBeforeUpdate`,Resolution: Backlog; Type: Feature Request,2020-10-21 09:57:27 +0000 UTC,brainkim,,"
There is no hook based equivalent for `getSnapshotBeforeUpdate`. The docs state:
> Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon getSnapshotBeforeUpdate and componentDidCatch lifecycles yet, but we plan to add them soon.

**What is the expected behavior?**

There is a hook based equivalent for `getSnapshotBeforeUpdate`, maybe something like:

```js
function ScrollingList(props) {
  const lengthRef = React.useRef(0);
  const listRef = React.useRef(null);

  const prevHeight = React.useSnapshot(() => {
    if (lengthRef.current < props.list.length) {
      const list = listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
  }); 

  React.useEffect(() => {
    lengthRef.current = props.list.length;
  }, [props.list.length]);

  React.useEffect(() => {
    if (prevHeight != null) {
      const list = listRef.current;
      list.scrollTop = list.scrollHeight - prevHeight;
    }
  }, [prevHeight]);
  return (
    <div ref={listRef}>{/* ... */}</div>
  );
}
```

This code probably is bug-ridden and not the best use of hooks but you get the idea.

I’d like to know:
1. If this feature is planned or on the roadmap.
2. What the proposed API will be.
3. If anyone is working on this.

Sorry, if this is being tracked somewhere and I haven’t seen it. I’m planning an intense component which will use `getSnapshotBeforeUpdate` and I’d love some guidance about the future of this lifecycle method.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React v16.8.0 and later. All browsers and OSes.

",,
15207,OPEN,Memoized components should forward displayName,Component: Shallow Renderer; Type: Enhancement,2020-12-25 20:09:09 +0000 UTC,pbondoer,,"**Do you want to request a *feature* or report a *bug*?**

I'd like to report a bug.

**What is the current behavior?**

First of all, thanks for the great work on fixing https://github.com/facebook/react/issues/14807. However there is still an issue with the current implementation.

`React.memo` does not forward displayName for tests. In snapshots, components display as `<Component />` and string assertions such as `.find('MyMemoizedComponent')` won't work.

**What is the expected behavior?**

`React.memo` should forward displayName for the test renderer.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

* React 16.8.5
* Jest 24.5.0
* enzyme 3.9.0
* enzyme-adapter-react-16 1.11.2

---

N.B. - Potentially related to https://github.com/facebook/react/issues/14319, but this is related to the more recent changes to support `memo` in the test renderer. Please close if needed, I'm quite new here!

I'd be happy to submit a PR if the issue is not too complex to look into :smile: ",,
15188,OPEN,useEffect can very quickly consume free quotas or cost money when used with 3rd party services,Type: Discussion,2019-03-23 16:00:25 +0000 UTC,PutziSan,,"
**What is the expected behavior?**
I'm not sure how you could solve this on your side. Of course you could do the check in development-mode, but that would probably trigger existing projects too much. However, a small hint in the documentation would be good that you should take care during development that useEffect can quickly lead to this behavior and that you should be careful when using other 3rd-party services that have a quota or have to be paid.

I just wanted to share my experiences while developing a ""real"" app. If you can't or won't do anything here, you are welcome to close the issue.",,
15187,OPEN,Edge 18 & IE 11 server mismatch with SVG icons,Component: Server Rendering; Type: Needs Investigation,2020-07-14 03:40:15 +0000 UTC,oliviertassinari,,"**Do you want to request a *feature* or report a *bug*?**

bug

**What is the current behavior?**

React raises a warning:

![Capture d’écran 2019-03-22 à 00 40 00](https://user-images.githubusercontent.com/3165635/54791630-0c05d100-4c3b-11e9-8426-4ea1ebb6e3f4.png)

https://codesandbox.io/s/k91nr3xzy5

```jsx
import React from ""react"";

export default () => (
  <div>
    2
    <svg>
      <path d=""M0 0h24v24H0z"" />
    </svg>
  </div>
);
```

**What is the expected behavior?**

No warning

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React: 16.8.4
Browser: Edge 18",,
15176,OPEN,React callback ref cleanup function,Type: Discussion,2021-03-10 05:38:31 +0000 UTC,k15a,,"At the time React added callback refs the main use case for them was to replace string refs. A lot of the callback refs looked like this:

```jsx
<div ref={node => this.node = node} />
```

With the introduction of `createRef` and `useRef` this use case is pretty much replaced by these alternatives so the use case of callback refs will shift to advanced use cases like [measuring DOM nodes](https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node).

It would be nice if you could return a cleanup function from the callback ref which is called instead of the callback with null. This way it will behave more like the `useEffect` API.

```jsx
<div ref={node => {
  // Normal ref callback

  return () => {
    // Cleanup function which is called when the ref is removed
  }
}} />
```

This will be super helpful when you need to set up a Resize-, Intersection- or  MutationObserver.

```jsx
function useDimensions() {
  const [entry, setEntry] = useState()
  
  const targetRef = useCallback((node) => {
    const observer = new ResizeObserver(([entry]) => {
      setEntry(entry)
    })

    observer.observe(node)

    return () => {
      observer.disconnect()
    }
  }, [])

  return [entry, targetRef]
}

function Comp() {
  const [dimensions, targetRef] = useDimensions()

  return (
    <pre ref={targetRef}>
      {JSON.stringify(dimensions, null, 2)}
    </pre>
  )
}
```

Currently, if you want to implement something like this you need to save the observer into a ref and then if the callback ref is called with null you have to clean up the observer from the ref.

To be 99% backward compatible we could call both the callback ref with null and the cleanup function. The only case where it isn't backward compatible is if currently someone is returning a function and doesn't expect the function to be called.

```jsx
function ref(node) {
  if (node === null) {
    return
  }

  // Do something

  return () => {
    // Cleanup something
  }
}
```",,
15171,OPEN,dangerouslySetInnerHTML is left empty on client render on top of bad server markup when rendering HTML,Type: Bug; Type: Needs Investigation,2020-09-04 21:52:27 +0000 UTC,petetnt,,"This seems to be an edge case of https://github.com/facebook/react/issues/11789 fixed in https://github.com/facebook/react/pull/13353/files.

I ran into this when trying to hydrate content rendered with https://github.com/prismicio/prismic-dom `asHtml` method.

**Do you want to request a *feature* or report a *bug*?**

Bug? I think. 

**What is the current behavior?**

Current behavior:

1. Server-side stuff comes in from server and contains the things we need
2. Hydration mismatch happens
3. dangerouslySetInnerHTML is called with correct value but an empty string gets rendered instead

I tried to replicate the issue on https://codesandbox.io/s/2xojk10jln but failed.

The following testcase for `packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test.js` produces the same result (I tried it first with the same PrismicDOM.RichText.asHtml(obj) call I have in the app) but I am not sure if it's correct:

  ```js

# test case
    itRenders(
      'a div with dangerouslySetInnerHTML set to html inserted',
      async render => {
        const obj = '<li>bar</li>';
        const e = await render(
          <div dangerouslySetInnerHTML={{__html: obj }} />,
        );
        expect(e.childNodes.length).toBe(1);
        expect(e.firstChild.tagName).toBe('LI');
        expect(e.firstChild.childNodes.length).toBe(1);
      },
    );
```

```bash
      ✓ renders a div with dangerouslySetInnerHTML set to html return value of function called with server string render (190ms)
      ✓ renders a div with dangerouslySetInnerHTML set to html return value of function called with server stream render (52ms)
      ✓ renders a div with dangerouslySetInnerHTML set to html return value of function called with clean client render (37ms)
      ✓ renders a div with dangerouslySetInnerHTML set to html return value of function called with client render on top of good server markup (74ms)
      ✕ renders a div with dangerouslySetInnerHTML set to html return value of function called with client render on top of bad server markup (34ms)

  ● ReactDOMServerIntegration › ... › renders a div with dangerouslySetInnerHTML set to html return value of function called with client render on top of bad server markup

    expect(received).toBe(expected) // Object.is equality

    Expected: ""bar""
    Received: """"
```


**What is the expected behavior?**

The client render would have rendered `<li>bar</li>`

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

commit c05b4b8  (latest master) and >16.8.

Sorry for a bit vague bug report.
",,
15154,OPEN,Effect memoization and immutable data structures,Type: Discussion,2019-03-22 16:07:08 +0000 UTC,roman01la,,"Current design of `useEffect` requires dependencies to be either primitive values or references to the same object, because shallow equality check relies on `Object.is` which is an identity check for objects.

The above means that there's no way to perform structural comparison, which is needed for immutable data structures when identity check fails.

To maintain backwards compatibility a comparator function could be provided as the third argument to `useEffect`:
```js
useEffect(fn, deps, depsComparator);
```

The goal here is to preserve an ease of use of the API with immutable data structures in order to provide an idiomatic usage of `useEffect` in ClojureScript and other environments that rely on immutability e.g. Immutable.js

cc @mhuebert @Lokeh @orestis",,
15153,OPEN,eslint-plugin-react-hooks - autofix useCallback/useMemo behaviour,Component: ESLint Rules; Type: Discussion,2019-03-19 18:21:32 +0000 UTC,RedTn,,"**Do you want to request a *feature* or report a *bug*?**

Discussion for new feature

**What is the current behavior?**

useCallback/useMemo hook's do nothing when there is no second argument provided for deps. The eslint plugin reports this but does not autofix


**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.8.4

**PR to implement:** 

https://github.com/facebook/react/pull/15146

&nbsp;

Currently, the eslint plugin does not autofix useCallback/useMemo to infer deps if there isn't a second argument provided to the hook. We can autofix it to infer deps if needed, or autofix to remove the hook altogether if there no deps needed (according to https://reactjs.org/docs/hooks-reference.html#usememo, if no second argument is provided it behaves as if the hook doesn't exist anyways).

What would be the best way to implement this autofix? In my opinion, linting shouldn't be breaking functionality on an autofix, so autofixing to remove the hook is the safest to implement. Autofixing to infer deps will change behavior in code so I was thinking of having a config option the dev needs to specify so that linting changes that is affecting behavior is explicit.
",,
15129,OPEN,Hooks - unmount and didUpdate,Type: Discussion,2019-03-18 14:33:18 +0000 UTC,lichstam,,"I'm opening this up at Dan's request from a twitter discussion:
https://twitter.com/lichstam/status/1106995545938247682

From Twitter:

I can fill in on this. The first example I would like to point to is a debouncing hook I've created that looks something like this:
  
```javascript
useEffect(() => {
  const debounced = setTimeout(() => setDebounced(steps), 500);
  return () => clearTimeout(debounced);
}, [steps])
```

and then I have another one, that actually performs the request:

```javascript
useEffect(request, [debounced])
```

And it all works fine, apart from when the component is mounted and unmounted.
In the class model I was able to make sure it never runs the first time and on unmounting I could clear the timeout and, if the state value differs from prop (yes I know, you shouldn't mirror your props but I have to debounce somewhere), I could just perform a last request before I unmount. 
Furthermore, `componentDidUpdate` really made it easy preventing this from running the first time. I'm not quite sure how to approach this with hooks.
Perhaps I'm doing it all wrong but to Patrick's point, the class way was more straight forward.

Another example: I code in RN and use the Animated API a lot. I have cases that translates into something like this:

```javascript
useEffect(() => {
  if (inAddStage) moveAndShowStep(); // Animate with Animated API
}, [inAddStage]);
```

This works well but it does perform an unnecessary initial run which makes me wonder if I've missed the point with hooks (again, to Patrick's point, it seems a bit more complex sometimes). Why isn't there a hook that **doesn't** run the first time btw? Again, with the old lifecycles it was much clearer how to prevent this from happening (using `componentDidUpdate`).

On a last note, I just want to say that I'm very fond of the idea and wholeheartedly support the functional approach and I really like the concept of hooks being ""state observers"", that react only when the specified attributes change - which basically makes the whole code more declarative.
I've just started using them so I'll probably figure things out along the way but I thought I could give you something since you didn't get any answer :)",,
15088,OPEN,useReducer - eagerReducer optimization discussion/questions,Component: Hooks; Type: Bug,2019-04-04 06:34:03 +0000 UTC,Andarist,,"I'd like to continue the discussion started by me under a recent blog post by Dan as encouraged by Dan 😉 https://github.com/gaearon/overreacted.io/commit/99bfdca459ff4094ee523c7419b58989d18bc594#r32694433

Just to summarize what I've stumbled upon when experimenting with useReducer after reading that hoisted & declared in render reducers are treated differently (I've wanted to explore how they are handled by React):
1. I have no idea how to reenter eagerReducer calculation after first scheduled work (& after render gets fully processed & committed). This might very well be just me not understanding how fibers work - but currently I'm confused by this. It doesn't enter this code branch because `fiber.expirationTime` is not 0 (NoWork) and the work gets scheduled right away. Any pointers regarding this? Is this valid? Might this be a bug somewhere?
2. The logic around reducer bailouts is somewhat iffy for me - maybe it's just a matter of mentioning those in the documentation:
- not every reducer update can bailout from rendering. If the action queue gets processed in the render phase then it's just not possible, we are already rendering after all. 
- action queue gets processed in the render phase for reducers declared inside render, this means that any new state computation might depend on the ""fresh"" props. This is not the case for the bailout mechanism though - it's only possible to perform a bailout when dispatching an action (so when we do not have access to the fresh props). Should this restriction be mentioned in the docs? IMHO this behaviour is inconsistent - for the greater good, so it's acceptable but I think it should be documented because it's slightly inconsistent & people might trip over this.

**Note** I'm happy to provide documentation changes if needed, I'd like to discuss those points first to get a better understanding of things.",,
15080,OPEN,Consider exporting `batchedUpdates` from React,Type: Discussion,2020-02-29 19:10:26 +0000 UTC,markerikson,,"ReactDOM and React Native both currently export an `unstable_batchedUpdates` API.  Because batching is a renderer/reconciliation-level concern, this API is exported by the renderer packages, not the core `react` package.

The React team has recently encouraged the Redux team to make use of `unstable_batchedUpdates` in React-Redux.  However, this becomes complicated due to how that API is being exported.

It's possible to deal with this at the bundler level.  Some experimentation shows that creating an alternate file with a `.native.js` extension will cause that to be picked up by the RN bundler, as in this example:

```js
// batch.js
import {unstable_batchedUpdates} from ""./react-dom"";

// ./react-dom.js
export {unstable_batchedUpdates} from ""react-dom""

// ./react-dom.native.js
export {unstable_batchedUpdates} from ""react-native""
```

However, this does not handle the case where an alternative React renderer is being used.  The [list of other React renderers is continuing to grow](https://github.com/chentsulin/awesome-react-renderer), which means that a React library that needs batching would have to deal with that situation in some way.  This becomes extremely complicated when you start considering variations on bundlers, module formats, and build environments.

It would be extremely beneficial if the React core itself exported a `batchedUpdates` API.  That could default to being a noop wrapper like `(callback) => callback()` if no suitable implementation was available.

I know that `unstable_batchedUpdates()` is, uh... ""unstable"".  However, the React team has stated that ""it's the most stable of the unstable APIs"", and ""half of Facebook depends on this"".

I think it would really help the ecosystem if some form of this API was solidified and exported from the core React package itself.",,
15069,OPEN,Can an error boundary prevent React's error logging?,Type: Feature Request,2021-03-05 03:30:50 +0000 UTC,silverwind,,"I noticed [this unconditional `console.error`](https://github.com/facebook/react/blob/d0289c7e3a2dfc349dcce7f9eb3dee22464e97bd/packages/react-reconciler/src/ReactFiberErrorLogger.js#L86) which I'd like to prevent to keep the console clean from errors that are already ""caught"" in an error boundary.

Maybe a condition on `capturedError.errorBoundaryFound` could prevent this logging?",,
15039,OPEN,react-debug-tools doesn't support legacy context (Component.contextTypes),React Core Team; Type: Bug,2020-09-03 02:51:41 +0000 UTC,bvaughn,,"Original report: https://github.com/facebook/react-devtools/issues/1304

Repro case: https://64yojj2wyk.codesandbox.io/",,
15019,OPEN,The browser crashes when use React.lazy return Promise.resolve(undefined),Resolution: Backlog; Type: Needs Investigation,2020-01-09 21:59:21 +0000 UTC,angular-moon,,"**Do you want to request a *feature* or report a *bug*?**
bug

**What is the current behavior?**
The browser crashes 

```js
const Loading = () => <div>loading...</div>;
const Component = lazy(() => Promise.resolve(undefined));

function App() {
  return (
    <div className=""App"">
      <Suspense fallback={<Loading />}>
        <Component />
      </Suspense>
    </div>
  );
}
```
*I can't provide an example of CodeSandbox, which would cause the browser to crash*

**What is the expected behavior?**
throw Error

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
react@16.8.3
react-dom@16.8.3
chrome 72.0.3626.119",,
15006,OPEN,useEffect memory leak when setting state in fetch promise,Resolution: Needs More Information; Resolution: Stale,2020-12-25 14:07:05 +0000 UTC,ryansaam,,"**Do you want to request a *feature* or report a *bug*?**
Reporting a possible bug

**What is the current behavior?**
My app renders fine with no errors but I can't seem to figure out why I keep getting this warning:

index.js:1446 Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.
    in ArtistProfile (at App.js:51)
    in component (created by Route)

api-calls.js (Here's a link):
https://github.com/ryansaam/litphum/blob/master/src/api-calls.js

App.js
```javascript
class App extends Component {
  constructor(props) {
    super(props)
    this.state = {
      user: {},
      spotifyAPI: {}
    }
  }
  componentDidMount() {
    if (user_token) {
      sessionStorage.setItem('access_token', user_token)
      this.setState({
        spotifyAPI: new spotifyAPI( user_token )
      })
    } else if (sessionStorage.getItem('access_token')) {
      this.setState({
        spotifyAPI: new spotifyAPI( sessionStorage.getItem('access_token') )
      })
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (this.state.spotifyAPI !== prevState.spotifyAPI)
      this.state.spotifyAPI.getUserProfile()
      .then(data => this.setState({user: data}))
  }
  
  render() {
    const { user, spotifyAPI } = this.state
    const token = sessionStorage.getItem('access_token')
    return (
      <Router>
        <div className=""App"">
            { (spotifyAPI.user_token && user)
            ? (<div className=""logged-in"">
                <div style={{width: ""250px"", height: ""100%"", position: ""relative"", float: ""left""}} >
                  <Nav image={user.images ? user.images[0].url : null} user={user} />
                </div>
                <main id=""main"">
                  <Route path={`/${user.type}/${user.id}`} exact component={() => <Home spotifyAPI={spotifyAPI} />} />
                  <Route path=""/artist/"" component={() => <ArtistProfile spotifyAPI={spotifyAPI} />} />
                </main>
              </div>) 
            : <div onClick={() => window.location = ""http://localhost:8888/login""} >log in</div>
            }
        </div>
      </Router>
    );
  }
}
```

ArtistProfile.js
```javascript
const  ArtistProfile = props => {
  const [artistData, setArtistData] = useState(null)
  const { getArtist, getArtistAlbums, getArtistTopTracks } = props.spotifyAPI

  useEffect(() => {
    const id = window.location.pathname.split(""/"").pop()
    const ac = new AbortController()
    console.log(id)
    Promise.all([
      getArtist(id, ac),
      getArtistAlbums(id, [""album""],""US"", 10, 0, ac),
      getArtistTopTracks(id, ""US"", ac)
    ])
    .then(response => {
      setArtistData({
        artist: response[0],
        artistAlbums: response[1],
        artistTopTracks: response[2]
      })
    })
    .catch(ex => console.error(ex))
    return () => ac.abort()
  }, [])
  console.log(artistData)
  return (
    <div>
      <ArtistProfileContainer>
        <AlbumContainer>
          {artistData ? artistData.artistAlbums.items.map(album => {
            return (
              <AlbumTag
                image={album.images[0].url}
                name={album.name}
                artists={album.artists}
                key={album.id}
              />
            )
          })
          : null}
        </AlbumContainer>
      </ArtistProfileContainer>
    </div>
  )
}
```

**What is the expected behavior?**
If you can see in ArtistProfile.js I am using a clean up function that aborts when the component does unmount. The fetch would be aborted and state shouldn't update but for some reason I am still getting this memory leak warning.

What I am expecting is for the warning to no longer throw because am using a clean up function that aborts the fetch.

Link to repo: https://github.com/ryansaam/litphum

- Files mentioned
    App.js: https://github.com/ryansaam/litphum/blob/master/src/App.js
    ArtistProfile.js: https://github.com/ryansaam/litphum/blob/master/src/components/ArtistProfile.js
    api-calls.js: https://github.com/ryansaam/litphum/blob/master/src/api-calls.js

My stackoverflow question: https://stackoverflow.com/questions/54954385/react-useeffect-causing-cant-perform-a-react-state-update-on-an-unmounted-comp/54964237#54964237


**Which versions of React, and which browser**
React 16.8.2
Latest version of Chrome
",,
14988,OPEN,Subscription to event listener in useEffect can miss an update,Component: Concurrent Mode; Component: Hooks; Type: Discussion,2019-07-01 19:33:28 +0000 UTC,jsnajdr,,"**Steps to reproduce:**
Run the following app that uses an event-emitting counter and maintains a subscription to render updates:
```js
import React from ""react"";
import ReactDOM from ""react-dom"";

function createCounter() {
  let value = 0;
  const listeners = new Set();

  return {
    get() { return value; },
    on(listener) { listeners.add(listener); },
    off(listener) { listeners.delete(listener); },
    increment() { value++; listeners.forEach(listener => listener()); }
  };
}

const Counter = createCounter();

function CounterWithHook() {
  const [counter, setCounter] = React.useState(Counter.get);

  React.useEffect(() => {
    const onChange = () => setCounter(Counter.get());
    Counter.on(onChange);
    return () => Counter.off(onChange);
  }, []);

  return <div>counter: {counter}</div>;
}

ReactDOM.render(
  <>
    <CounterWithHook />
    <button onClick={Counter.increment}>increment</button>
  </>,
  document.getElementById(""root"")
);

requestAnimationFrame(Counter.increment);
```

The `requestAnimationFrame` at the end will increment the counter in a slightly insidious way.

**Expected result:**
After loading the app, I see `counter: 1` and clicking the `increment` button updates the UI to `counter: 2`.

**Actual result:**
After loading the app, I see `counter: 0` and clicking the button updates the UI to `counter: 2`.

The timing of the `Counter.increment` is such that it happens after the initial render, but before the listener is attached.

Implementing the same thing with lifecycle methods behaves differently: `componentDidMount` runs soon enough to catch the update.

Is that expected and a part of the `useEffect` contract? Is there a better way to maintain subscriptions? Note that the missed update came from an independent source, completely outside React.",,
14980,OPEN,Misleading error description when using wrong useRef,Type: Bug; Type: Needs Investigation,2020-03-23 13:48:52 +0000 UTC,madroneropaulo,,"There's a misleading error when using wrong the `useRef` hook.

```
function MyComponent() {
    let nameRef = useRef();

   return (
      <div>
        <input ref=""nameRef"" type=""text"" />       
    </div>
  );
}
```

See the example here https://codesandbox.io/s/yvl21qm62j

The code above leads to this error `Function components cannot have refs. Did you mean to use React.forwardRef()?`. I'm moving some class components to Hooks, and stumbled upon this, and it took me a while due to the wrong error message.",,
14962,OPEN,Password input type causes memory leak,Type: Needs Investigation,2020-05-12 16:56:22 +0000 UTC,ejallday,,"An `<input type=""password""/>` causes a memory leak.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

You can recreate the behavior by visiting https://iericallen.github.io/test-react/ and following the steps listed.

Please view our source code at: https://github.com/iericallen/test-react/tree/source

**What is the expected behavior?**

Unmounted components including `<input type=""password"" />` can be garbage collected after next re-rendering.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

OS: macOS X Mojave 10.14.2 (18C54)
Chrome: 72.0.3626.109
React: 16.8.3
ReactDOM: 16.8.3",,
14878,OPEN,Simple memo components being updated with new set of props during context change,Type: Bug; Type: Needs Investigation,2020-01-12 19:23:16 +0000 UTC,Andarist,,"**Do you want to request a *feature* or report a *bug*?**

Bug

**What is the current behavior?**

Simple memo components receive new props during context change if their parent got rerendered.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/jp21pwzrv9

**What is the expected behavior?**

Conceptually from the user's perspective `React.memo(Component)` & `React.memo(Component, shallowEqual)` should behave exactly the same (but they dont)

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Current React's master ( 0e67969cb1ad8c27a72294662e68fa5d7c2c9783 ) & current latest release 16.8.2

I've already written a failing test for this - https://github.com/facebook/react/pull/14876 . Would love to work on fixing this but as mentioned in this PR, I would require some guidance on how this should get fixed properly.
",,
14785,OPEN,defaultValue does not work with input when type is set to submit,Type: Discussion,2019-02-08 16:27:02 +0000 UTC,jakubkosinski,,"
When you use uncontrolled `<input type=""submit"" />` and set `defaultValue` attribute, it would be ignored in versions 1.5.0 or higher (there would be no `value` attribute in the HTML result). It was working correctly in older versions. Looks like only `type=""submit""` is affected, for other input types `defaultValue` behaves correctly.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

Correct behaviour with react 16.4.2: https://codepen.io/anon/pen/zePmrZ
Incorrect behaviour with react 16.8.1: https://codepen.io/anon/pen/PVOyqV

**What is the expected behavior?**

When `defaultValue=""foo""` is set on `<input type=""submit""/>` it should result in `<input type=""submit"" value=""foo"" />` in the HTML result.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

All versions starting from 16.5.0
",,
14750,OPEN,Simultaneous key events in effect handled out of order,Resolution: Backlog; Type: Feature Request,2020-04-01 23:04:23 +0000 UTC,stuartkeith,,"**Do you want to request a *feature* or report a *bug*?**

Report a bug.

**What is the current behavior?**

I have an app that's registering event listeners for `window`'s key events (via `useEffect`). Those event listeners are triggering state updates (via `useState`). I think I have found a bug where simultaneous key events occurring in the same frame (whether down or up) will be handled out of order, causing state to becoming out of sync.

Take the following simple app (https://codesandbox.io/s/1z3v9zrk4j). I've kept this as keyup only for simplicity.

```
function App() {
  const [keys, setKeys] = useState([]);

  console.log('App', keys);

  const onKeyUp = function (event) {
    console.log('onKeyUp', event.key, keys);

    setKeys([...keys, event.key]);
  };

  useEffect(function () {
    console.log('effect', keys);

    window.addEventListener('keyup', onKeyUp);

    return function () {
      console.log('removing event listener', keys);

      window.removeEventListener('keyup', onKeyUp);
    };
  });

  return <p>{keys.join(', ')}</p>;
}
```

If I press down any two keys, e.g. the ""q"" and ""w"" keys, and then release them at precisely the same time, the following happens:

- The `keyup` event listener for `w` is called, which in turn calls `setKeys` with `['w']`
- `App` is re-rendered with `keys === ['w']`
- The `keyup` event listener for `q` is called, which in turn calls `setKeys` with `['q']`
- The effect's cleanup function is called, removing the event listener with `keys === []`
- The effect is run again, the event listener being added with `keys === ['w']`
- `App` is re-rendered with `keys === ['q']`
- The effect's cleanup function is called, removing the event listener with `keys ===['w']`
- The effect is run again, the event listener being added with `keys === ['q']`

This results in `keys === ['q']`. The render with `w` has been lost.

With three keys, only two keys are reliably shown. Four keys - only two are reliably shown.

If I add another `useState` call, the first `useState` has no issues - all keys are reliably detected. See https://codesandbox.io/s/0yo51n5wv:

```
function App() {
  const [keys, setKeys] = useState([]); 
  const [dummy, setDummy] = useState('foo');

  console.log(""rendering App"", keys);

  const onKeyUp = function(event) {
    console.log(""onKeyUp event received"", event.key, keys);

    setKeys([...keys, event.key]);
    setDummy('foo');
  };

  useEffect(function() {
    console.log(""adding event listener"", keys);

    window.addEventListener(""keyup"", onKeyUp);

    return function() {
      console.log(""removing event listener"", keys);

      window.removeEventListener(""keyup"", onKeyUp);
    };
  });

  return (
    <div>
      <p>Keyups received:</p>
      <p>{keys.join("", "")}</p>
      <button onClick={() => setKeys([])}>Reset</button>
    </div>
  );
}
```

**What is the expected behavior?**

I would expect the final state array to contain all keys released, in order. There are a few workarounds for this issue (e.g. passing a function to `setState` to retrieve the current value instead of using the rendered value), but from the documentation it seems that is an escape hatch for use when the effect's callback is not renewed on each state change, and should not be necessary in this case (unless I've misunderstood).

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

It happens on both versions that support hooks - `16.8.0-alpha.0` and `16.8.0-alpha.1`. This is on Chrome/Safari/Firefox on MacOS Mojave.
",,
14694,OPEN,Chrome Autofill overwrites values on controlled components,Component: DOM; Type: Breaking Change; Type: Bug,2019-02-04 15:19:29 +0000 UTC,epicfaace,,"
See https://jsfiddle.net/epicfaace/9p17e2qx/21/ -- to test this, add a ""Saved Address"" in the Chrome options.

![2019-01-24 10 37 23](https://user-images.githubusercontent.com/1689183/51700667-91b32a80-1fc4-11e9-876b-6f795225d99b.gif)

**What is the expected behavior?**
Autofill does not overwrite existing fields. I've made a JSFiddle with a plain HTML form, which works with the expected behavior.

See https://jsfiddle.net/epicfaace/1my3f9n4/6/

![2019-01-24 10 37 02](https://user-images.githubusercontent.com/1689183/51700679-9841a200-1fc4-11e9-9408-dae369ac5366.gif)

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React 15.3.2
Chrome 71.0.3578.98
",,
14658,OPEN,`useCallback()` & `useMemo()` automatically with a Babel Plug-in,Type: Discussion,2019-03-10 06:45:26 +0000 UTC,DAB0mB,,"**Do you want to request a *feature* or report a *bug*?**

Feature request.

**What is the current behavior?**

We need to `useCallback()` and `useMemo()` which seems redundant and can cost us in performance if not used right, which is likely to happen.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

```js
export default ({ data, sortComparator, filterPredicate, history }) => {
  const transformedData = data.filter(filterPredicate).sort(sortComparator)

  return (
    <div>
      <button className=""back-btn"" onClick={() => history.pop()} />
      <ul className=""data-list"">
        {transformedData.map(({ id, value }) => (
          <li className=""data-item"" key={id} onClick={() => history.push(`data/${id}`)}>{value}</li>
        ))}
      </ul>
    </div>
  )
}
```

**What is the expected behavior?**

Just like the [docs](https://reactjs.org/docs/hooks-reference.html#usecallback) suggest:

```
In the future, a sufficiently advanced compiler could create this array automatically.
```

Accordingly, I have implemented a Babel-plug-in that does exactly that; see [babel-plugin-react-persist](https://github.com/DAB0mB/babel-plugin-react-persist). Given the code snippet above, the plug-in should generate the following output:

```js
let _anonymousFnComponent, _anonymousFnComponent2

export default ({ data, sortComparator, filterPredicate, history }) => {
  const transformedData = React.useMemo(() =>
    data.filter(filterPredicate).sort(sortComparator)
  , [data, data.filter, filterPredicate, sortComparator])

  return React.createElement(_anonymousFnComponent2 = _anonymousFnComponent2 || (() => {
    const _onClick2 = React.useCallback(() => history.pop(), [history, history.pop])

    return (
      <div>
        <button className=""back-btn"" onClick={_onClick2} />
        <ul className=""data-list"">
          {transformedData.map(({ id, value }) =>
            React.createElement(_anonymousFnComponent = _anonymousFnComponent || (() => {
              const _onClick = React.useCallback(() =>
                history.push(`data/${id}`)
              , [history, history.push, id])

              return (
                <li className=""data-item"" key={id} onClick={_onClick}>
                  {value}
                </li>
              )
            }), { key: id })
          )}
        </ul>
      </div>
    )
  }), null)
}
```

The plug-in will:

- `useCallback()` automatically when a function is created.
- `useMemo()` automatically when a value is assigned.
- Will memoize inline callbacks.

I don't see however how can `useEffect()` be inferred automatically and if it's a good idea. The plug-in is not a feature request directly for React, but since it's stated in the docs I thought maybe it can be useful somehow. Maybe it can potentially be included as part of `create-react-app`? Would like to hear your thoughts about it. An alternative solution is suggested at #14406, but I don't see why do this at runtime when everything can be done ahead of time and save processing power.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React 16.8-alpha (hooks)
",,
14543,OPEN,Add `get` function to `useState`,Type: Discussion,2019-03-31 15:33:17 +0000 UTC,liyuanqiu,,"```javascript
import { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call ""count""
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```
```javascript
// each time ""count"" changed, this arrow function will be created again.
// so that it can access the latest ""count""
onClick={() => setCount(count + 1)}
```
I don't think it is good to create a fixed function many times, so I try to modify the code:
```javascript
const [count, setCount] = useState(0);
const handleClick = useCallback(() => setCount(count + 1), []);
```
But obviously the callback in `useCallback` couldn't get the latest `count` because I pass in an empty inputs array to avoid this callback been generated again and again.

So, in fact, the inputs array decide two things:
1. when to recreate the callback
2. which state can be accessed in the callback

In most situation, the two things are one thing, but here they conflict. 

So I think maybe it's good to add a `get` function to `useState` like this:
```javascript
import { useState, useCallback } from 'react';

function Example() {
  // Declare a new state variable, which we'll call ""count""
  const [count, setCount, getCount] = useState(0);

  const handleClick = useCallback(() => setCount(getCount() + 1), []);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={handleClick}>
        Click me
      </button>
    </div>
  );
}
```
Maybe it's confusing because `getCount` can totally replace `count`, but it brings the possible to avoid creating callbacks again and again.

### Edited
https://github.com/facebook/react/issues/14543#issuecomment-452237355 exactly resolves the case above. But there‘re many other scenarios can't use `updater` to resolve. Here are some more code snippets:
#### 1. Access states in a timer.
```javascript
useEffect(() => {
  // or setInterval
  const id = setTimeout(() => {
    // access states
  }, period);
  return () => clearTimeout(id);
}, inputs);
```
#### 2. Access states in WebSocket callbacks
```javascript
useEffect(() => {
  // create a WebSocket client named ""ws""
  ws.onopen = () => {
    // access states
  };
  ws.onmessage = () => {
    // access states
  };
  return () => ws.close();
}, inputs);
```
#### 3. Access states in Promise
```javascript
useEffect(() => {
  create_a_promise().then(() => {
    // access states
  });
}, inputs);
```
#### 4. Access states in event callbacks
```javascript
useEffect(() => {
  function handleThatEvent() {
    // access states
  }
  instance.addEventListener('eventName', handleThatEvent);
  return instance.removeEventListener('eventName', handleThatEvent);
}, inputs);
```

We had to use some workaround patterns to resolve those cases, like
https://github.com/facebook/react/issues/14543#issuecomment-452676760
https://github.com/facebook/react/issues/14543#issuecomment-453058025
https://github.com/facebook/react/issues/14543#issuecomment-453079958
Or a funny way:
```javascript
const [state, setState] = useState();
useEffect(() => {
  // or setInterval
  const id = setTimeout(() => {
    // access states
    setState((prevState) => {
      // Now I can do anything with state...🤮
      ...
      return prevState;
    });
  }, period);
  return () => clearTimeout(id);
}, inputs);
```

So let's discuss and wait...
https://github.com/facebook/react/issues/14543#issuecomment-452713416



**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

**What is the expected behavior?**

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
- React 16.7.0-alpha.2

",,
14443,OPEN,Warning should appear when versions of react and react-dom do not match,Type: Discussion,2019-01-29 22:35:39 +0000 UTC,mjhoffm2,,"**Do you want to request a *feature* or report a *bug*?**

Request a feature

**What is the current behavior?**

If the version of react and react-dom do not match, some features fail silently.  See this issue for example: https://github.com/reduxjs/react-redux/issues/1125

In this issue, the new Context API wasn't working as intended, but no errors or warnings were visible.  Components simply did not update.  It turns out that this issue was because I updated react to version 16.6.3, but still had react-dom at version 16.5.

**What is the expected behavior?**

I would like to see some sort of warning message in the console in development mode when the versions of react and react-dom do not match.
",,
14398,OPEN,calculating context changes in componentDidUpdate,Type: Feature Request,2020-10-27 17:09:47 +0000 UTC,Lexicality,,"
**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
```typescript
import React from 'react';

interface ExampleContext {
    param: string;
}

const ExampleContext = React.createContext<ExampleContext>({
    param: 'foo',
});

interface ExampleState {
    data: any;
}

class Example extends React.Component<{}, ExampleState> {
    static contextType = ExampleContext;
    context!: ExampleContext;

    constructor(props) {
        super(props);

        this.state = {
            data: [],
        };
    }

    fetchData(param: string): void {
        // whatever
    }

    componentDidMount() {
        this.fetchData(this.context.param);
    }

    componentDidUpdate() {
        // ???        
    }
}
```
**What is the expected behavior?**
A 4th parameter for `previousContext`

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.6",,
14357,OPEN,findDOMNode deprecation,Type: Feature Request,2021-02-21 14:56:04 +0000 UTC,eps1lon,,"## Timeline
1. <= 16.3: `findDOMNode` is *discouraged* but accepted for certain use cases
2. 16.3 (2018-03-28): `forwardRef` is introduced:
  It can be used in HOCs to avoid using `findDOMNode` on the enhanced component
3. 16.6 (2018-10-23): `findDOMNode` is deprecated in `React.StrictMode`
4. 16.7.alpha (2018-10-24): `React.Concurrent` mode is released:
  This mode *extends* `React.StrictMode` in a way that `findDOMNode` is deprecated in that mode too.
5. 16.8 (Q2 2019): stable `React.Concurrent` mode
  
## findDOMNode use cases
If you have more use cases please let me know. I only started with some examples from `mui-org/material-ui`.
### with a planned alternative
- focus handling (React Fire, ""exploratory phase"") 
- passive event listeners ([facebook/react#6436]). ""Passive events will likely be a part of [React Fire]."" - [facebook/react#13525]

## State of `forwardRef`
`react` has 3.4M downloads/week.

### `hoist-non-react-statics` (3.9M downloads/week; not clear what percentage is 2.x)
A utility mainly used in HOCs and [encouraged to use in the official react docs](https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over). However everyone stuck at `2.x` will likely encounter issues with `forwardRef` since that version
does not handle any `react@^16.3` features. ^3.2.0 should have no issues apart from some minor
issues with propTypes hoisting from `forwardRef` to `forwardRef`. The latest stable from zeit/next still uses that outdated version. However the latest canary for 7.0.3 does not.

### react-docgen (400k downloads/week)
Not recognized as a valid component definition. PR open at [reactjs/react-docgen#311].

### react-redux (1.4M downloads/week)
`connect` does properly forward their refs in the beta release of 6.x. No timeline for stable release given
however 3 betas have already been released so it's probably soon.

### react-router (1.4M downloads/week)
`withRouter` is planned to forward refs ([ReactTraining/react-router#6056#issuecomment-435524678]).
However no comment about the other components and no major release candidate is published.

### display name
`React.forwardRef` components are recognized by `react-devtools`. However when wrapped
in a HOC it's very likely that the display name is lost. See [facebook/react#14319]

### The issue
**Assumptions:**
- you are not in control of your whole component tree i.e. you use components from 3rd party libraries
- you want to use `React.ConcurrentMode`
- Usable includes production and development. It specifically means for development that deprecation warnings in a component
  make that component not usable in development mode because of all the *noise* it adds in those cases.
  *Noise* because it's not actionable if that component is from a 3rd party library.

If none of those applies to you then you probably don't have an issue with `findDOMNode` deprecation.

The mode of a partial tree can only be made more restrictive but not loosened up. If
you wrap your tree in `React.StrictMode` and use a component from a 3rd party library
that 3rd party library has to be `React.StrictMode` compliant too. 

This means that you can't use `React.StrictMode` effectiveley. This might be ok since it's for development only anyway and has no implications for production. However Concurrent mode can have actual implications for production.  Since it is new and the community wants to use new things libraries have to make sure that they are strict mode compliant too.

In addition between the relase of an alternative in the form of `React.forwardRef` and the deprecation only 7 months have passed. One could argue that this is plenty of time but (at least from my perspective) the work on migrating from `findDOMNode` to refs and `forwardRef` was postponed because `findDOMNode` was not deprecated yet.  However the actual deprecation happened one day before the release of `unstable_ConcurrentMode` virtually giving no time to migrate. ~We'll have to see when a stable `16.7` release will happen but assuming this happens today only a month has passed between deprecation and *virtual* removal.~ [React 16.x Roadmap] was release pointing towards Q2 2019 as a release date of stable `React.Concurrent` mode. This relaxes pressure for library maintainers quite a bit IMO.

### Conclusion
Refs are not a viable upgrade path to replace `findDOMNode` yet. 
Until refs are usable without headaches from forwarding refs `findDOMNode` should be undeprecated.

## Releated
- [forwarding Refs guide on official react docs](https://reactjs.org/docs/forwarding-refs.html)
- [findDOMNode API documentation](https://reactjs.org/docs/react-dom.html#finddomnode) (includes arguments against usage)
- [pull request that deprecated findDOMNode](https://github.com/facebook/react/pull/13841)

[facebook/react#6436]: https://github.com/facebook/react/issues/6436
[facebook/react#13525]: https://github.com/facebook/react/issues/13525
[facebook/react#14319]: https://github.com/facebook/react/issues/14319
[reactjs/react-docgen#311]: https://github.com/reactjs/react-docgen/pull/311
[ReactTraining/react-router#6056#issuecomment-435524678]: https://github.com/ReactTraining/react-router/issues/6056#issuecomment-435524678
[React 16.x Roadmap]: https://reactjs.org/blog/2018/11/27/react-16-roadmap.html",,
14356,OPEN,Sometimes controlled email inputs break in Chrome due to punycoding,Component: DOM; Type: Bug,2020-06-18 19:51:13 +0000 UTC,Bastian,,"**Do you want to request a *feature* or report a *bug*?**

Report a  bug

**What is the current behavior?**

In Chrome, when typing a sharp S (ß, a German letter) in an input field with `type=""email""`, it converts the `ß` to `ss` (~~expected~~ unexpected behaviour) and the cursor jumps back to the beginning of the input field (unexpected behaviour). This does only happen if the `ß` is part of the domain.
Trying to type `test@testß.de` will end as `.detest@testss`:
![Example](https://i.imgur.com/SWQ0p4f.gif)

It can be tested with the latest Google Chrome: 
https://codepen.io/anon/pen/MzzEqB
If you don't have a `ß` on your keyboard, you can reproduce the bug by just Copy&Pasting it.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Tested with Chrome Version 70.0.3538.110 (Official Build) (64-bit) on Ubuntu 18.04 and React 16.6.3

In Firefox, this does not happen, as it does not convert `ß` to `ss`. I didn't test other browsers.",,
14342,OPEN,Fail to render input in a separate window on Edge,Browser: IE; Component: DOM; Type: Needs Investigation,2020-01-09 07:15:40 +0000 UTC,haojy,,"
> SCRIPT5673: Unknown runtime error


**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. 

`window.open` dose not work well on JSFiddle or CodeSandbox, so put a page link to reproduce the behavior

https://haojy.github.io/issues/input-error-in-separate-window.html

**What is the expected behavior?**

`<input>` component should be rendered as expected without errors

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React: v16.6.3 and V16.3.0
browser:
- only on Edge v42
- works well on IE 11/Chrome 70/Safari 12",,
14337,OPEN,[react-dom] getEventKey has IE11 key mapping issue,Browser: IE; Component: DOM; Type: Needs Investigation,2020-01-10 17:01:15 +0000 UTC,icfantv,,"**Do you want to request a *feature* or report a *bug*?**

Bug (possibly)

**What is the current behavior?**

This may, in fact, fall under the purview of `Only special keys are supported, all others depend on keyboard layout or browser` but figured I'd enter this to be sure.  Additionally, the bookmark in the link specified in the `@see` comment is no longer valid so I can't confirm the official list of keys.  Looking at [the latest version of the spec](https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode), the key in question appears in the `Optionally fixed virtual keys` section rather than the `Fixed virtual keys` section, but then, none of the 1xx keys appear at all in the fixed list.

The `translateToKey` hash in the `react-dom` package's `getEventKey` function appears to be missing the `-` (dash) key.  When used with CTRL+SHIFT, this key (and probably others) is reported as `Unidentified` in IE11 and since it's not in the `translateToKey` map, returns back to the code as `Unidentified` which breaks keyboard shortcut handling.

This can be seen by navigating to https://w3c.github.io/uievents/tools/key-event-viewer.html and in IE11, pressing `CTRL + SHIFT + -` (note that you will need to check `keydown` under `preventDefault` in the options table or the browser will zoom out.

**What is the expected behavior?**

If it's a bug, it shouldn't allow resolution to just fall through back to the browser.  If it's not, then the code is correct - but then requires special handling.

If I add `'189': '-'` to the hash, it works...on a US Keyboard.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Tested on React 16.6.1 in IE11 on Windows.",,
14319,OPEN,API for display name on forwardRef; memo and potential future exotic components,Type: Feature Request,2020-12-25 15:36:53 +0000 UTC,eps1lon,,"TL;DR: Can you expose [shared/getComponentName](https://github.com/facebook/react/blob/master/packages/shared/getComponentName.js)?

<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**
Expose an API to get the display name of every component (in `__DEV__` only).

**What is the current behavior?**
Most of the ecosystem still uses `Component.displayName || Component.name || someFallbackName` 
 (with some branching depending on the type of `Component`) when setting the display name of an enhanced component i.e. `connect()(WrappedComponent)` will result in `""connect(WrappedComponent)""` as a `displayName`.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
Since components created by `forwardRef` or `memo` are not actual functions these higher-order components are not able to determine a proper display name while `react-devtools` is able to:

https://codesandbox.io/s/zqj9v50243

- `react-redux` creates `""connect(Component)""`
- `react-router` creates `""withRouter(undefined)""`

**What is the expected behavior?**
The new ""exotic-components"" should work with the existing 3rd party libraries WRT to `displayName`.

Now there are a couple of solutions to this issue:
1. **Edit:** Expose [shared/getComponentName](https://github.com/facebook/react/blob/master/packages/shared/getComponentName.js)
2. This is the responsibility of the ecosystem. It should provide a solution and maintain it. Somewhat blocked by #12882, related: #12932
3. Grant access to the functionality used in `react-devtools` (or would this only work on the fibers?)
4. Set a `name` (or `displayName` no preference here) property on those ""exotic-components"" (don't know how to call them). Naive implementation e.g.: `name: 'ForwardRef(' + fn.name + ')'`.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
I guess this started with `forwardRef` in 16.3.
",,
14292,OPEN,Provide a way to pass context to renderToStaticMarkup on the client,Component: Reconciler; React Core Team; Type: Feature Request,2020-01-08 19:14:36 +0000 UTC,gaearon,,See https://github.com/facebook/react/issues/14287#issuecomment-440277999 and https://github.com/facebook/react/pull/14182#issuecomment-440125029. This accidentally worked for a few releases but was a bug. However we might want to consider actually supporting this with an opt-in API.,,
14285,OPEN,Warn when calling dispatch() from useEffect() cleanup function on unmounting,Component: Hooks; Type: Discussion,2019-03-15 08:36:24 +0000 UTC,merongmerongmerong,,"
action dispatched in return callback of `useEffect` seem to not work

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/5yqmo128v4

only foo -> baz is logged

```javascript
import React, { useState, useEffect, useReducer } from ""react"";
import ReactDOM from ""react-dom"";

import ""./styles.css"";

function reducer(state, action) {
  console.log(""bar"", action); // not logged
  // debugger
  return state;
}

function Foo({ value }) {
  const [state, dispatch] = useReducer(reducer, {});

  useEffect(
    () => {
      return () => {
        console.log(""foo"");
        // debugger
        dispatch({ type: ""foo"" });
        // debugger
        console.log(""baz"");
      };
    },
    [state, value]
  );

  return <p>{value}</p>;
}

function App() {
  const [value, set] = useState(0);

  return (
    <div className=""App"">
      <button onClick={() => set(value + 1)}>INC</button>
      {value % 2 ? <Foo value={value} /> : null}
    </div>
  );
}

const rootElement = document.getElementById(""root"");
ReactDOM.render(<App />, rootElement);
```

**What is the expected behavior?**
bar is logged in console
(foo -> baz -> bar`action`)

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

react: ""16.7.0-alpha.2"",
react-dom: ""16.7.0-alpha.2""
",,
14213,OPEN,Textarea loses focus after inserting paired punctuation with Chinese IME,Component: DOM; Type: Bug,2018-11-15 03:06:55 +0000 UTC,,,"
**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

[CodeSandbox Demo](https://codesandbox.io/s/7w23wpl0q1)

[steps(youtube video)](https://youtu.be/4PJ2WVD83Eg)

**What is the expected behavior?**
just work fine!

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
versions of React: 16+
OS: IOS
browser: safari



",,
14170,OPEN,react-test-renderer doesn't support Suspense and lazy nodes,Type: Bug,2021-02-09 12:42:23 +0000 UTC,Dem0n13,,"Hello. How can I test components with Suspense/Lazy?
now renderer.create(...)toTree() throws
""toTree() does not yet know how to handle nodes with tag=13""

react 16.6.1
react-test-renderer 16.6.1",,
14168,OPEN,Input type email bug,Component: DOM; Type: Needs Investigation,2020-11-06 21:10:35 +0000 UTC,dominicarrojado,,"https://codepen.io/anon/pen/GwZeNO

Open this codepen and paste this ""example@gmail.com 1""
Then press backspace, notice that the focus changes to the beginning of the input.
",,
14125,OPEN,Autofocus Text puts cursor at end instead of beginning,Component: DOM; Type: Regression,2020-03-25 07:45:56 +0000 UTC,Matthew-Goldberg,,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
In React 16, a text input with a value and autofocus will set the cursor at the _end_ of the input.
`<input autoFocus={true} type=""text"" defaultValue=""4444"" />`

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

See the React 16 repro here: https://codepen.io/matthewg0/pen/XymjYo

**What is the expected behavior?**
In React 15, and in plain HTML, the behavior is that the cursor is placed at the _start_ of the input.
React 15: https://codepen.io/matthewg0/pen/NEGRzv
Plain HTML: https://codepen.io/matthewg0/pen/wQKoap

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Reproduces as of React 16.  Worked as expected in React 15.",,
14099,OPEN,useCallback() invalidates too often in practice,Component: Hooks; React Core Team,2021-03-12 19:39:20 +0000 UTC,gaearon,,"This is related to https://github.com/facebook/react/issues/14092, https://github.com/facebook/react/issues/14066, https://github.com/reactjs/rfcs/issues/83, and some other issues.

The problem is that we often want to avoid invalidating a callback (e.g. to preserve shallow equality below or to avoid re-subscriptions in the effects). But if it depends on props or state, it's likely it'll invalidate too often. See https://github.com/facebook/react/issues/14092#issuecomment-435907249 for current workarounds.

`useReducer` doesn't suffer from this because the reducer is evaluated directly in the render phase. @sebmarkbage had an idea about giving `useCallback` similar semantics but it'll likely require complex implementation work. Seems like we'd have to do _something_ like this though.

I'm filing this just to acknowledge the issue exists, and to track further work on this.",,
14057,OPEN,Unexpected copies of the props object retained in memory with the new hooks API,Component: Reconciler; Type: Needs Investigation,2020-01-11 16:36:25 +0000 UTC,localvoid,,"
```jsx
function useCustomHook1() {
  useEffect(() => {
    console.log(""mounted"");
    return () => {
      console.log(""unmounted"");
    };
  }, []);
}

function Test3(props) {
  useCustomHook1();
  useEffect(() => {
    console.log(props.test);
  });

  return <div onClick={() => console.log(props.test)}>{props.items.length}</div>;
}
```

`props` object that were used when component was rendered for the first time is kept alive. Completely unexpected behavior even when developer understands [closure context sharing](https://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html).

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/lz61v39r7

- Select test **3** 
- Click on the button ""Create New Array"" 5 times
- Take memory snapshot in the developer tools
- Inspect (array) objects
- There will be 4 arrays retained in memory `t0`, `t-2`, `t-1`, `t`

**What is the expected behavior?**

Should be 2 arrays retained in memory `t-1`, `t`.",,
14049,OPEN,Using both getDerivedStateFromError and getDerivedStateFromProps can be a foot gun,Type: Discussion,2020-09-15 11:28:27 +0000 UTC,blixt,,"
If `componentDidCatch` and/or `getDerivedStateFromError` put the component in a state that avoids the cause of the error, and `getDerivedStateFromProps` reverts that state change, the error boundary will (obviously) fail to avert disaster.

https://codesandbox.io/s/pj0lwxk15j

It sounds very obvious when simplified like this, but when my team updated to React 16.5.x (and 16.6.0), suddenly this started happening for us. So something changed internally, but it's hard to pinpoint what. Unfortunately I haven't been able to create a small repro for that specific case that works in 16.4.2 but not 16.5.0 – so I'm making this issue about avoiding the cause in the first place.

**What is the expected behavior?**

Naively, my thinking is that because errors are more exceptional, let the state from error handlers take precedence. Probably there's a reason why this can't happen so a warning of some kind when this can happen would be nice. Two ways to do this comes to mind:

1. Cross-check that keys in state from `getDerivedStateFromProps` or `setState` in `componentDidCatch` don't collide with `getDerivedStateFromError` (sounds a bit far fetched?)
2. Be more explicit in documentation for error boundaries about how `getDerivedStateFromProps` will run last so that a developer can consider this case

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.5.0 and up (16.4.2 behaves a bit differently – see above), all platforms/browsers.",,
13991,OPEN,Hooks + multiple instances of React,Component: Hooks; Type: Discussion,2021-04-09 08:26:35 +0000 UTC,brunolemos,,"# To people coming from search: please [read this page first](https://reactjs.org/warnings/invalid-hook-call-warning.html). It contains most common possible fixes!



**Do you want to request a *feature* or report a *bug*?**

Enhancement

**What is the current behavior?**

I had multiple instances of React by mistake.

When trying to use hooks, got this error:
`hooks can only be called inside the body of a function component`

Which is not correct since I was using function components. Took me a while to find the real cause of the issue.

**What is the expected behavior?**

Show the correct error message. Maybe detect that the app has multiple instances of React and say that it may be the reason of bugs. ",,
13989,OPEN,nextContext arg in shouldComponentUpdate() method,Component: Reconciler; Type: Needs Investigation,2020-01-16 20:21:43 +0000 UTC,konsultacijos,,"
Is there any other way to solve this problem?

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

**What is the expected behavior?**

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
",,
13970,OPEN,16.6 contextType + getDerivedStateFromProps,Type: Feature Request,2020-10-12 02:02:45 +0000 UTC,natew,,"**Do you want to request a *feature* or report a *bug*?** Feature

**What is the current behavior?**

Context not passed into getDerivedStateFromProps:

```
static getDerivedStateFromProps(props, state, context) {}
```

Just curious with the new `static contextType`, it would save a lot of nesting if I could access context now from getDerivedStateFromProps when using this pattern. I gave it a shot assuming it may work already but I get undefined from the third argument.

Just curious if there's been any discussion on this.",,
13956,OPEN,onMouseEnter does not fire on an underlaying element if an element above is removed,Component: DOM; Type: Needs Investigation,2020-12-02 17:38:07 +0000 UTC,amadeus,,"**Do you want to request a *feature* or report a *bug*?**

Bug - I did do some searching around the issues to see if there was a similar/dupe, but I could not find one.

**What is the current behavior?**

With 2 elements overlaying on top of each other, if the upper element gets removed while the cursor is over both elements, mouse enter never fires on the element below. I compared this to native browser events and the issue does not appear to persist there (native browser events appear to fire mouse enter for the underlying div when the overlaying div gets removed).

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**

[CodeSandbox Example](https://codesandbox.io/s/wonqx3lo7)

I provided a top level boolean constant to switch between using react's synthetic events and the native browser events. In the console I keep track of state updates as console logs. The simple way to test - open the console, mouse over the upper div in a position that is also on top of the lower div, click to remove the upper div, the lower div SHOULD fire mouse enter. It does not with synthetic events, but it does with browser events.

**What is the expected behavior?**

Expected behavior for me would be if react would fire mouse enter on the underlaying div when the upper div is removed.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

```
""dependencies"": {
    ""react"": ""16.5.2"",
    ""react-dom"": ""16.5.2"",
  },
```

I have not had a chance to test previous versions.",,
13954,OPEN,Receive previous state in getDerivedStateFromError,Type: Feature Request,2020-12-25 20:06:38 +0000 UTC,bisubus,,"
`getDerivedStateFromError` hook receives `error` and doesn't have access to `state` or component instance. This limits possible ways in which it could be used and requires to additionally use other hooks to derive the state:

```js
class App extends Component {
  state = {}

  static getDerivedStateFromError(error) {
    return { error }
  }

  static getDerivedStateFromProps(props, state) {
    // do we really need this?
    // the state is derived from error, not props
    if (state.error)
      return remapStateToPreferredStructure(state);
  }

  render() { /* ... */ }
}
```

**What is the expected behavior?**

`getDerivedStateFromError` is expected to receive previous state and have

```
getDerivedStateFromError(error, state)
```
signature to be consistent with related static hook, `getDerivedStateFromProps`. This `getDerivedStateFromError` signature is backward compatible with existing one (React 16.6.0).


**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React 16.6.0
",,
13938,OPEN,Error line number in Error Boundary,Resolution: Needs More Information,2020-12-25 14:50:57 +0000 UTC,dehghani-mehdi,,"Hey,

As I can not reopen issue #13790, I opened this.

If you don't like to fix/add my request, simply say `won't fox`, but don't close the issue with simple/not related answer, as @aweary did. React is pro library, you are pro, so act like pros.

Thanks.",,
13934,OPEN,Update release script to handle alpha react-reconciler deps,Component: Build Infrastructure; React Core Team,2020-01-08 19:15:21 +0000 UTC,bvaughn,,This commit 1a57dc6 broke it,,
13876,OPEN,"Uncontrolled input type=""checkbox"" reflects updating `defaultChecked` in Edge and Safari",Component: DOM; Type: Needs Investigation,2020-04-01 23:12:47 +0000 UTC,berlysia,,"Updating the value of `defaultChecked` causes a change DOM property's `checked` value.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/yjop5zwmr9

**What is the expected behavior?**

Updating the value of `defaultChecked` should not affect to DOM property's `checked` value.
(no log in codesandbox is expected)

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

reproduce in React v15.2.0 and v16.5.2, ReactDOM v15.2.0 and v16.5.2.
not reproduce in v15.1

browser: Safari 12 on macOS Sierra, Edge 42 on Windows 10
not reproduce in Chrome(70, beta), Chrome(72, canary), Firefox(62), IE11 on Win10
smartphone browsers are not checked.",,
13838,OPEN,head > meta > content escaping issue,Component: Server Rendering; Type: Needs Investigation,2021-03-24 23:25:34 +0000 UTC,oliviertassinari,,"
The following source code,

```jsx
<meta property=""og:image"" content=""https://onepixel.imgix.net/60366a63-1ac8-9626-1df8-9d8d5e5e2601_1000.jpg?auto=format&q=80&mark=watermark%2Fcenter-v5.png&markalign=center%2Cmiddle&h=500&w=500&s=60ec785603e5f71fe944f76b4dacef08"" />
```

, is being escaped once server side rendered:
```jsx
<meta property=""og:image"" content=""https://onepixel.imgix.net/60366a63-1ac8-9626-1df8-9d8d5e5e2601_1000.jpg?auto=format&amp;q=80&amp;mark=watermark%2Fcenter-v5.png&amp;markalign=center%2Cmiddle&amp;h=500&amp;w=500&amp;s=60ec785603e5f71fe944f76b4dacef08""/>
```

You can reproduce the behavior like this:
```jsx
const React = require(""react"");
const ReactDOMServer = require(""react-dom/server"");
const http = require(""http"");

const doc = React.createElement(""html"", {
  children: [
    React.createElement(""head"", {
      children: React.createElement(""meta"", {
        property: ""og:image"",
        content:
          ""https://onepixel.imgix.net/60366a63-1ac8-9626-1df8-9d8d5e5e2601_1000.jpg?auto=format&q=80&mark=watermark%2Fcenter-v5.png&markalign=center%2Cmiddle&h=500&w=500&s=60ec785603e5f71fe944f76b4dacef08""
      })
    }),
    React.createElement(""body"", { children: ""og:image"" })
  ]
});

//create a server object:
http
  .createServer(function(req, res) {
    res.write(""<!DOCTYPE html>"" + ReactDOMServer.renderToStaticMarkup(doc)); //write a response to the client
    res.end(); //end the response
  })
  .listen(8080); //the server object listens on port 8080
```
editor: https://codesandbox.io/s/my299jk7qp
output : https://my299jk7qp.sse.codesandbox.io/

**What is the expected behavior?**

I would expect the content not being escaped. It's related to https://github.com/zeit/next.js/issues/2006#issuecomment-355917446.
I'm using the `og:image` meta element so my pages can have nice previews within Facebook :).

![capture d ecran 2018-10-12 a 14 15 26](https://user-images.githubusercontent.com/3165635/46868650-52076f00-ce29-11e8-892f-cfbf924bba82.png)

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.5.2",,
13798,OPEN,JAWS reads non-interactive elements as Clickable,Type: Bug,2019-01-29 20:48:00 +0000 UTC,Lily418,,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
1. I create an app using [create-react-app](https://github.com/facebook/create-react-app)
2. I use JAWS Professional Edition Version 2018 (build 1710.42 ILM) and Internet Explorer 11 on Windows 7
3. I use arrow keys to navigate to paragraph ""Edit src/App.js and save to reload.""
4. Jaws announces ""Edit src/App.js and save to reload. **clickable**""

**What is the expected behavior?**
This paragraph is non interactive, it should not be announced as clickable.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
- JAWS Professional Edition Version 2018 (build 1710.42 ILM) 
- Internet Explorer 11
- Windows 7
- create-react-app 2.0.3

**suspected cause**
Using Chrome Event Listener Breakpoints I observed there's a function called `trapClickOnNonInteractiveElement` which is the onclick handler for non interactive elements. This noop function is causing JAWS to think this is an interactive element

**possible solution**
In [trapClickOnNonInteractiveElement](https://github.com/facebook/react/blob/8a8d973d3cc5623676a84f87af66ef9259c3937c/packages/react-dom/src/client/ReactDOMComponent.js#L245) there is a comment which reads 
```
// TODO: Only do this for the relevant Safaris maybe?
```
I think that this would fix this issue.",,
13681,OPEN,How to prevent ReactDOM.render errors from bubbling when otherwise explicitly handled,Type: Discussion,2019-10-02 00:27:48 +0000 UTC,jneander,,"**Do you want to request a *feature* or report a *bug*?**

This is a bug. Ordinarily, this would probably be considered a feature request. However, the stated purpose of the feature referenced below is being violated in certain environments.

**What is the current behavior?** 

React 16+ surfaces an uncaught error during render, even when using `componentDidCatch` as designed or using try/catch around the render. As described in the comment [above the related code](https://github.com/facebook/react/blob/master/packages/shared/invokeGuardedCallbackImpl.js#L32:L49), this is a convenience provided for developers using DevTools for debugging purposes. However, the convenience provided for development debugging is changing behavior in specs, causing failures for otherwise protected code paths, which goes against this statement from the comment description for the code:

> But because the error happens in a different event loop context, it does not interrupt the normal program flow.

When the error occurs, a spec runner such as Mocha will fail the test with the uncaught error, then continue with the next test. After advancing, the second render of the component will complete and call the ReactDOM.render callback, which continues code from the already-failed test while a subsequent test is in progress. This pollutes the spec suite and leads to other issues that are not produced when using the Production version of React.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

All relevant code and content has been included in [this CodeSandbox](https://codesandbox.io/s/vvmv7q7o7y). Due to the use of karma/mocha, tests must be run locally. Inline comments add detail to behavior and expectations.

To see the tests pass, switch ""test"" to ""production"" in the `karma.js` file.

**What is the expected behavior?**

Typically, DevTools are used in a different context from running specs—automation vs investigation, for lack of more precise terms. It should be an option rather than the default when using React in a non-production environment. At least in an environment of `test`, where spec runners are conditionally sensitive to global errors, developers must have the option to disable or disallow this behavior as it is implemented at this time.

For a second, perhaps more intuitive option, refer to this portion of the mentioned comment, talking about ""pause on caught exceptions"":

> This is untintuitive, though, because even though React has caught the error, from the developer's perspective, the error is uncaught.

When an exception during render is captured using `componentDidCatch` or try/catch as mentioned above, the exception should be considered ""caught,"" as the developer has explicitly created an error boundary around this render. In this case, expected behavior would be for the error to not be surfaced globally and for the developer to debug any exceptions within the error boundary they defined.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

This is present only in the non-production version of React 16+. The `development` or `test` environments of React 16+ feature this behavior. React 15.* and below do not have this issue. Prior to React 16, explicit try/catch handlers were solely responsible for being an error boundary during render.",,
13651,OPEN,input[type='number'] value isn't updated,Component: DOM; Type: Needs Investigation,2020-11-14 18:10:13 +0000 UTC,youen123,,"**Do you want to request a *feature* or report a *bug*?**
bug
**What is the current behavior?**
when I enter ""01"" into input[type=number]，I set the value to 1, but it doesn't work. It still show ""01""

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/20ywk1x71n

**What is the expected behavior?**
when I enter ""01"", it should show ""1""

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
15.6.2.   I think it should update in ""updatewrapper"" in  https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMInput.js.",,
13567,OPEN,Consider stopping auto-adding `px` to number style values (except for a small whitelist),Component: DOM; Type: Discussion,2019-05-14 14:49:38 +0000 UTC,mgol,,"
React automatically adds the `px` suffix for numerical values passed to the `style` prop. As some CSS properties accept unitless values, React maintains a blacklist of properties that shouldn't get `px` auto-appended.

The problem is that this solution doesn't scale. It requires us to add more & more properties to the list as CSS specs expand and recently the list grows faster; Flexbox & Grid added quite a few of them. What's more confusing, some of those props would work both with & without the `px` suffix and that changes the meaning (`lineHeight` is suffering from that).

Although I'm a React newbie I'm quite familiar with this issue due to being a member of the jQuery Core team. jQuery has the same logic as React here and we keep having to add to the list. We've actually exposed the list at [jQuery.cssNumber](https://api.jquery.com/jQuery.cssNumber/) so that people don't always have to wait for us to add support for a property and do a release.

That's why we decided that in jQuery 4 we'll drop the auto-prefixing blacklist and turn to a whitelist that lists only a few most common properties to which we want to auto-append `px` (mostly because they're extremely common and we don't want to break the world too much); we plan to _not_ expand that list unless we missed something really common. You can see the current plan in my PR: https://github.com/jquery/jquery/pull/4055. In particular, see the proposed whitelist in a (visualized) regexp in:
https://github.com/jquery/jquery/blob/03e9dba3882868e1ee79f1fb0504326da925644f/src/css/isAutoPx.js.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

**What is the expected behavior?**

I propose that React could do the same thing jQuery is planning to and switch the ever-expanding blacklist of CSS props that shouldn't have the `px` suffix applied to a small whitelist that should have the suffix applied.

This topic has been initially described in #13550.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

All browses & OSs. I don't know how old this logic is in React.",,
13560,OPEN,Remove Factory Components,Component: Reconciler; React Core Team; Type: Breaking Change,2020-01-08 19:16:13 +0000 UTC,gaearon,,"We support a very unusual kind of components that look like functional components but return an *instance*.

```js
function Hello(props) {
  return {
    componentDidMount() {
      alert('wow')
    }
    render() {
      return <div>Hi, {this.props.name}</div>
    }
  };
}
```

Note these are *not* functional components. They're pretty exotic and don't offer any practical benefits over classes. At the time they were added (I think 0.14?) it was because we thought other type systems might want to compile to a format like this instead of ES classes-like output. But that didn't happen.

There's some complexity associated with continuing to support this. Since this is more confusing than useful, I think we should deprecate them in 16.x and remove in 17.x.",,
13559,OPEN,scheduler package umbrella,React Core Team; Type: Umbrella,2020-01-08 19:16:13 +0000 UTC,bvaughn,,"### Short term
- [x] #13561: Replace the [`__getInteractionsRef` and `__getSubscriberRef` methods](https://github.com/facebook/react/blob/fb88fd9d8c9f72b8e2e7e1ae89652d2a6a707562/packages/schedule/src/Tracking.js#L84-L90) with direct ~~mutable~~ exports  (`__interactions` and `__subscriber`)  and [update the `ScheduleTracking` UMD fork](https://github.com/facebook/react/blob/master/packages/shared/forks/ScheduleTracking.umd.js).
- [x] #13561: Remove `__getInteractionsRef` and `__getSubscriberRef` from the `schedule/tracking` UMD [dev](https://github.com/facebook/react/blob/master/packages/schedule/npm/umd/schedule-tracking.development.js) and [prod](https://github.com/facebook/react/blob/master/packages/schedule/npm/umd/schedule-tracking.production.min.js) bundles since it's not part of the public API.
- [x] Fix interaction-tracking reference count bug (#13574)
- [ ] Split subscriptions entry point apart from tracking (e.g. break `scheduler/tracking` into `scheduler/tracking` and `scheduler/subscriptions`)

### Long term
- [ ] Move `scheduler` to is own git repo (maybe even its own org) prior to a 1.0 release.
- [ ] Enable it to be used without a build step by replacing the dev/prod check with a single export.
- [ ] Add an ES module entry point as well as the CJS and UMD entry points",,
13508,OPEN,Relax ToString consistency guarantees,Component: DOM; React Core Team; Type: Enhancement,2020-01-08 19:16:11 +0000 UTC,gaearon,,"We recently chatted about https://github.com/facebook/react/pull/13367 and related work (e.g. https://github.com/facebook/react/pull/13394) with @sebmarkbage, and he raised a good point.

It seems like overall treating them consistently is adding significant overhead in the implementation readability. And there’s undoubtedly runtime overhead to it too. There are two separate issues here:

* **warning** for invalid values
* ensuring that the output for invalid values is **consistent** (e.g. functions are always skipped)

The conclusion we came to is that we should keep **warning** for bad values, but **as long as we warn, consistency is not necessary**. It's fine if we sometimes stringify a function, and sometimes skip it, as long as we always warn for those cases

**Our guiding principle for invalid inputs should be that we handle them with the least amount of overhead** (both at runtime, and in terms of code size), not that they’re always handled the same way.

One exception to this is probably Symbols because they throw when stringified. So it seems like skipping them is actually desirable — unless we're okay with errors.",,
13499,OPEN,"Number input breaks when letter ""e"" is entered",Component: DOM; Type: Needs Investigation,2020-01-10 16:26:31 +0000 UTC,vahnag,,"
The ""e"" is even being filled when the input is controlled. The only way I can think of to work around this bug right now is to use `onKeyDown` and `preventDefault` when ""e"" or ""E"" is pressed.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
https://codesandbox.io/s/ov3ql3ljwz

**What is the expected behavior?**
It should pass anything that is being filled into the input to the onChange handler and should not break controlled component.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React: 16.4.2
Chrome: 68.0.3440.106
Windows 10",,
13450,OPEN,UMD builds are not enabled on UNPKG,Type: Discussion,2020-09-03 19:52:10 +0000 UTC,nickmccurdy,,"Visiting https://unpkg.com/react displays the CJS build (https://unpkg.com/react@16.4.2/index.js) when the UMD build (https://unpkg.com/react@16.4.2/umd/react.development.js) should be displayed instead. I also noticed this issue with react-dom, so I assume all packages need to be fixed.

Please refer to the usage instructions at the bottom of https://unpkg.com/.",,
13424,OPEN,onChange doesn't fire if input re-renders due to a setState() in a non-React capture phase listener,Component: DOM; React Core Team; Type: Bug,2020-11-04 17:11:52 +0000 UTC,gaearon,,"Extracting from https://github.com/facebook/react/issues/12643.

This issue has always been in React. I can reproduce it up to React 0.11. However **it's probably extremely rare in practice and isn't worth fixing**. I'm just filing this for posterity.

Here is a minimal example.

```js
class App extends React.Component {
  state = {value: ''}
  handleChange = (e) => {
    this.setState({
      value: e.target.value
    });
  }
  componentDidMount() {
    document.addEventListener(
      ""input"",
      () => {
        // COMMENT OUT THIS LINE TO FIX:
        this.setState({});
      },
      true
    );
  }
  render() {
    return (
      <div>
        <input
          value={this.state.value}
          onChange={this.handleChange}
        />
      </div>
    );
  }
}

ReactDOM.render(<App />, document.getElementById(""container""));
```

Typing doesn't work — unless I comment out that `setState` call in the capture phase listener.

Say the input is empty and we're typing `a`.

What happens here is that `setState({})` in the capture phase non-React listener runs first. When re-rendering due to that first empty `setState({})`, input props still contain the old value (`""""`) while the DOM node's value is new (`""a""`). They're not equal, so we'll set the DOM node value to `""""` (according to the props) and remember `""""` as the current value.

<img width=""549"" alt=""screen shot 2018-08-17 at 1 08 42 am"" src=""https://user-images.githubusercontent.com/810438/44241204-4b0e0880-a1ba-11e8-847d-bf9ca43eb954.png"">

Then, `ChangeEventPlugin` tries to decide whether to emit a change event. It asks the tracker whether the value has changed. The tracker compares the presumably ""new"" `node.value` (it's `""""` — we've just set it earlier!) with the `lastValue` it has stored (also `""""` — and also just updated). No changes!

<img width=""505"" alt=""screen shot 2018-08-17 at 1 10 59 am"" src=""https://user-images.githubusercontent.com/810438/44241293-e0110180-a1ba-11e8-9c5a-b0d808f745cd.png"">


Our `""a""` update is lost. We never get the change event, and never actually get a chance to set the correct state.",,
13413,OPEN,Umbrella: Chopping Block,React Core Team; Type: Umbrella,2020-01-08 19:16:11 +0000 UTC,sebmarkbage,,"I wanted to create a list of things whose existence makes React bigger and more complicated than necessary. This makes them more likely to need to be deprecated and actually removed in a future version. No clue of when this will happen and what the recommended upgrade path will be so don't take this issue as advice that you should move away from them until there's clear upgrade advice. You might make it worse by doing so.

(This has some overlap with https://github.com/facebook/react/issues/9475 but those seem more longer term.)

- [ ] __Unsafe Life Cycles without UNSAFE prefix__ - We'll keep the ones prefixed UNSAFE indefinitely but the original ones will likely be deprecated and removed.

- [ ] __Legacy context__ - `.contextTypes`, `.childContextTypes`, `getChildContext` - The old context is full of edge cases for when it is accidentally supposed to work and the way it is designed requires all React code to become slower just to support this feature.

- [ ] __String refs__ - This requires current owner to be exposed at runtime. While it is likely that some form of owner will remain, this particular semantics is likely not what we want out of it. So rather than having two owners, we should just remove this feature. It also requires an extra field on every ReactElement which is otherwise not needed.

- [ ] __Module pattern components__ - This is a little used feature that lets you return a class instance from a regular function without extending `React.Component`. This is not that useful. In practice the ecosystem has moved around ES class like usage, and other language compiling to JS tries to comply with that model as well. The existence of this feature means that we don't know that something is a functional component by just testing if it's a function that is not extending `React.Component`. Instead we have to do some extra feature testing for every functional component there is. It also prevents us from passing the ref as the second argument by default for all functional components without using `forwardRef` since that wouldn't be valid for class components.

- [ ] __Uncontrolled onInput__ - This is described in #9657. Because we support uncontrolled polyfilling of this event, we have to do pretty invasive operations to the DOM like attaching setters. This is all in support of imperative usage of the DOM which should be out-of-scope for React.

- [ ] __setState in componentDidCatch__ - Currently we support error recovery in `componentDidCatch` but once we support `getDerivedStateFromCatch` we might want to consider deprecating the old mechanism which automatically first commits null. The semantics of this are a bit weird and requires complicated code that we likely get wrong sometimes.

- [ ] __Context Object As Consumer__ - Right now it is possible to use the Context object as a Consumer render prop. That's an artifact of reusing the same object allocation but not documented. We'll want to deprecate that and make it the Provider instead.

- [ ] __No GC of not unmounted roots__ - This likely won't come with a warning. We'll just do it. It's not a breaking behavior other than memory usage. You have to call `unmountComponentAtNode` or that component won't be cleaned up. Almost always it is not cleaned up anyway since if you have at least one subscription that still holds onto it. Arguably this is not even a breaking change. #13293

- [ ] __unstable_renderSubtreeIntoContainer__ - This is replaced by Portals. It is already problematic since it can't be used in life-cycles but it also add lots of special case code to transfer the context. Since legacy context itself likely will be deprecated, this serves no purposes.

- [x] __ReactDOM.render with hydration__ - This has already been deprecated. This requires extra code and requires us to generate an extra attribute in the HTML to auto-select hydration. People should be using ReactDOM.hydrate instead. We just need to remove the old behavior and the attribute in ReactDOMServer.

- [ ] __Return value of `ReactDOM.render()`__ - We can't synchronously return an instance when inside a lifecycle/callback/effect, or in concurrent mode. Should use a ref instead.

- [ ] __All of `ReactDOM.render()`__ - Switch everyone over to `createRoot`, with an option to make `createRoot` sync.",,
13400,OPEN,Boolean DOM properties coerce empty string to false; contrary to HTML standard,Type: Discussion,2018-08-15 00:22:01 +0000 UTC,motiz88,,"
**Do you want to request a *feature* or report a *bug*?**

Depends on interpretation 😅  This is possibly a bug, definitely an inconsistency worth mitigating IMHO.

**What is the current behavior?**

React normalises values supplied to [known DOM boolean props](https://github.com/facebook/react/blob/69e2a0d732e1ca74f6dc5df9d0ddd0bf24373965/packages/react-dom/src/shared/DOMProperty.js#L278-L331) (e.g. `readOnly`) such that passing the empty string `""""` (being falsy in JavaScript) results in the corresponding attribute being omitted from the HTML output. However, in [HTML](https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attribute), the empty string is a truthy value in this context; it's one of the values that the standard specifically allows in boolean attributes.

The above is a potential source of confusion in itself, but React 16's handling of unknown attributes gives rise to the following hypothetical scenario: a new DOM boolean attribute `foobar` is introduced, some people write JSX code that uses it as `foobar=""""` (passed through to HTML, truthy), and later React adds `foobar` to its internal whitelist in a minor/patch version and starts processing it as a boolean (JS falsy, omitted from HTML); this would _technically_ be a breaking change for those people.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**

https://codesandbox.io/s/y0pmz9149x

**What is the expected behavior?**

There is definitely a clash of expectations here at the interface of JS and HTML.

1. Coming from JS, `""""` is falsy and treating it as such in a ""boolean"" prop is fine; from this perspective, the current behaviour is justifiable.
2. Coming from HTML, it might not be obvious that React is doing this ""extra"" processing and deviating from what's clearly stated in the HTML spec; from this perspective, the current behaviour is surprising.

There probably isn't justification for changing React's actual handling of `""""` (not least for fear of breaking code that relies on this long-standing behaviour, see version information below), but perhaps a warning about the ambiguity is warranted, a la #13372?

Note that a warning won't fully mitigate the worst-case scenario I mentioned above (since we can't warn about a prop that we don't _know_ is a DOM boolean), but at least it would give some signal _after_ the React version update that the code might not be doing the expected thing anymore.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Versions of React as far back as 0.14 (and probably way older) process whitelisted boolean DOM props the same way.",,
13342,OPEN,RFC: Omit end tags when possible in ReactDOMServerRenderer,Component: Server Rendering; Type: Discussion,2018-10-05 20:56:08 +0000 UTC,tvler,,"# Background

There are a lot of instances defined in the HTML spec where end tags can be omitted while still maintaining valid markup.

Some examples:

> An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.

> A p element’s end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, main, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.

You can see all of them over at https://www.w3.org/TR/html5/syntax.html#optional-tags

Utilizing these rules, I think it may be possible to reduce the amount of html needed to be initially downloaded by the user for serverside rendering.

Depending on what's being rendered, there could be a significant decrease in html size. Here's an example I pulled from the W3C of a table element utilizing these rules. The difference is 464 bytes compared to 629 – about a **26% decrease** in size.

```html
<table>
<caption>37547 TEE Electric Powered Rail Car Train Functions (Abbreviated)
<colgroup><col><col><col>
<thead>
<tr>
  <th>Function
  <th>Control Unit
  <th>Central Station
<tbody>
<tr>
  <td>Headlights
  <td>✔
  <td>✔
<tr>
  <td>Interior Lights
  <td>✔
  <td>✔
<tr>
  <td>Electric locomotive operating sounds
  <td>✔
  <td>✔
<tr>
  <td>Engineer’s cab lighting
  <td>
  <td>✔
<tr>
  <td>Station Announcements - Swiss
  <td>
  <td>✔
</table>
```

# Caveats

- Even though these rules are in the spec, they still feel like quirks to me. There probably are some browser-to-browser differences in how these are handled.
- Should this even be handled by React? I could see a babel plugin or something like that being a good fit for an optimization like this too.

# Possible roadmap

- Research what end tags would be stable to omit (https://www.w3.org/TR/html5/syntax.html#optional-tags)
- Roll out this optimization for a subset of tags
- Gauge real-world load time improvements and continue adding omission cases if everything is looking good",,
13332,OPEN,Support cross-renderer portals,Component: Reconciler; React Core Team; Type: Big Picture; Type: Feature Request,2020-11-12 22:31:18 +0000 UTC,gaearon,,"Currently `createPortal` only works within the current renderer.

This means that if you want to embed one renderer into another (e.g. `react-art` in `react-dom`), your only option is to do an imperative render in a commit-time hook like `componentDidMount` or `componentDidUpdate` of the outer renderer's component. In fact that's exactly how `react-art` works today.

With this approach, nested renderers like `react-art` can't read the context of the outer renderers (https://github.com/facebook/react/issues/12796). Similarly, we can't time-slice updates in inner renderers because we only update the inner container at the host renderer's commit time.

At the time we originally discussed portals we wanted to make them work across renderers. So that you could do something like

```js
<div>
  <Portal to={ReactART}>
    <surface>
      <rect />
    </surface>
  </Portal>
</div>
```

But it's not super clear how this should work because renderers can bundle incompatible Fiber implementations. Whose implementation takes charge?

We'll want to figure something out eventually. For now I'm filing this for future reference.",,
13306,OPEN,[Umbrella] Releasing Time Slicing,React Core Team; Type: Umbrella,2020-01-08 19:16:10 +0000 UTC,gaearon,,"Let's use this to track what's missing before Time Slicing is usable internally and in open source.
**This list is probably very incomplete, feel free to add more.**

## Initial release (MVP)

### Core
- [x] Decide on the recommended low/high pri split pattern
- [x] Fix `unstable_deferredUpdates` not being respected in interactive event handlers (reproducible in the fixture) https://github.com/facebook/react/pull/13488
- [x] Fix or provide a workaround for an issue with a chain of synchronous commits on expiration (reproducible in the fixture) https://github.com/facebook/react/pull/13483
- [ ] Resuming
- [ ] Off-screen `<div hidden>` API

### Scheduler

- [ ] Decide on naming (@flarnie, React Core team)
- [ ] Adding support for priority (@flarnie)
    * May involve bikeshedding, iteration
    * Will require changes to React Fiber Scheduler
    - [ ] Add a fixture showing using JS Scheduler with React and also external JS
- [ ] Better handle when tab is backgrounded (@flarnie)
- [ ] Improvements to polyfill for rAF
- [ ] Integrate and dogfood with internal FB products - see internal task T32773869 (@flarnie)
- [ ] Create final API which is not renderer-dependent 
- [ ] Make `react-dom` depend on it, and publish it in open source (@flarnie, others internally)



---

Related: Suspense Umbrella (https://github.com/facebook/react/issues/13206)",,
13212,OPEN,Investigate IE/Edge select rendering bug,Browser: IE; Component: DOM; Type: Needs Investigation,2020-04-01 21:08:37 +0000 UTC,nhunzaker,,"This is a follow up from an issue related to change events on selects in IE/Edge (https://github.com/facebook/react/issues/4672). It looks like this is no longer an issue, but there's a visual regression on IE/Edge that might be avoidable.

**Reproduction**

https://codepen.io/nhunzaker/pen/qybxmz

**Observation**

From @jasonwilliams (https://github.com/facebook/react/issues/4672#issuecomment-404534681):

> change and MouseUp both fire for me in Microsoft Edge 42.17134.1.0 @nhunzaker
Although, the rendering of the select box is weird, it doesn't appear to expand when i click on it

**We need to:**

- [ ] Capture a GIF of the behavior for documentation purposes (this can just live in this thread)
- [ ] Reproduce the test case outside of React, so that we can isolate the mechanics involved
- [ ] Fix it :)",,
13206,OPEN,[Umbrella] Releasing Suspense,React Core Team; Type: Umbrella,2021-04-07 22:47:37 +0000 UTC,acdlite,,"Let's use this issue to track the remaining tasks for releasing Suspense to open source.

## Initial release (MVP)

### Core
- [x] API to read context from within any render phase function (@acdlite) [#13139]
- [x] Hide timed-out content instead of deleting it  (@acdlite) [#13120]
- [ ] Automatic injection of context providers per React root (@acdlite) [#13293]
- [ ] Remove `unstable_` prefix from `AsyncMode` (maybe?)
- [ ] Support for synchronous thenables, and for promises that resolve before the render phase is complete.
  - [ ] Confirm that a synchronous thenable that throws an error is handled correctly
- [ ] Confirm it works with `<div hidden>` [#13089]
- [ ] Why does clicking on several detail links in the fixture one by one eventually causes a big placeholder even if I wait for each of them for less than the placeholder delay before clicking the next one ([see tweet](https://mobile.twitter.com/niklasbostrom/status/1025278135082934272))?

### Simple Cache Provider
- [ ] Cache invalidation (@acdlite) [#13337]
- [ ] Subscriptions (@acdlite) [#13337]
- [ ] Decide on actual name

### Code splitting
- [x] Support promise as a component type
- [x] (maybe) Open source `lazyLoadComponent`?

### Test renderer
- [ ] Finalize public APIs for `flushAll`, `yield`, etc
  - Tentative plan is to publish custom matchers for each of the major testing frameworks, a la #13236.

### Docs
- [ ] Blog post
- [ ] `React.Placeholder`
- [ ] simple-cache-provider
- [ ] Unnamed code-splitting library

## Follow ups

### Soft expiration (https://github.com/facebook/react/issues/14248)
- [ ] Implement an API for in-place loading indicators that aren't ancestors
- [ ] Make sure there's a way to avoid flashing the inline spinner if it's fast enough

### Streaming server renderer
- [ ] Implement a streaming server renderer like the one in @acdlite's ZEIT talk
- [ ] Partial hydration

------

Related: Time Slicing Umbrella (https://github.com/facebook/react/issues/13306)",,
13204,OPEN,Longterm support for Internet Explorer,Type: Discussion,2019-02-01 23:07:14 +0000 UTC,a-reuss,,,,
13115,OPEN,onMouseLeave false triggering when using svg <use> in IE11,Browser: IE; Component: DOM; Type: Needs Investigation,2020-04-01 21:06:37 +0000 UTC,kuzkokov,,"**Do you want to request a *feature* or report a *bug*?**
Bug.

**What is the current behavior?**
As you can see in the example below, onMouseLeave of parent element get triggered every time, when you hover the svg which is get element to render by `<use>` in IE11 (and probably lower).  
It works as expected in other browsers and with regular `<path>` inside svg. And also, the native event work as expected too (as you can see in expample), so I identify the bug as React's.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
https://codesandbox.io/s/jnn8w7940w

**What is the expected behavior?**
To not trigger onMouseLeave when mouse doesn't leave the parent element.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Tested on React 16.3.2 and 16.4.1.",,
13104,OPEN,add support for SyntheticKeyboardEvent#isComposing,Component: DOM; Type: Feature Request,2021-01-16 17:32:00 +0000 UTC,mattkrick,,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
Synthetic keyboard events do not contain `isComposing`.
They should if the value is true, per the w3 spec 4.7.5: https://www.w3.org/TR/uievents/#events-compositionevents
 
**What is the expected behavior?**
`event.isComposing === event.nativeEvent.isComposing`

SyntheticKeyboardEvent#isComposing is true when a keydown even is fired after compositionstart and before compositionend.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
all versions, up through at least 16.4.1",,
13097,OPEN,Add support for hydrating portals,Type: Feature Request,2021-03-19 01:25:31 +0000 UTC,marcusdarmstrong,,"
I've attempted my best effort at a fiddle that shows off the particular issue. Obviously server side rendering is impossible via JSFiddle, but the markup should be equivalent to having rendered `Test` into a div with id `test-1` during server side render.

https://jsfiddle.net/y8o5n2zg/

As seen in the fiddle, an attempt to ReactDOM.hydrate() a portal results in:
> `Warning: Expected server HTML to contain a matching text node for ""Hello World"" in <div>.`

Additionally, after failing to hydrate, React renders the component and appends it resulting in a duplicated section of DOM:
> `<div id=""test-1"">Hello WorldHello World</div>`

**What is the expected behavior?**

In an ideal world, calling hydrate on a component that has portals would allow those DOM containers to hydrate into the components they were rendered with.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

I've only tested this in 16.4.1, but I've confirmed the behavior in Chrome and Firefox. Given that I'm really looking at an edge case here I doubt it worked previously.


#### *Why* I'm doing this edge-case-y nonsense:

We're currently using multiple React roots on our pages (as some portions of the pages are not rendered by React yet), most of which are server-side rendered. We'd like to be able to hydrate them into a single React root on page, so that we can share contexts between them without difficulty and without repeating those context components in memory (in some cases we can have a good number of roots on the page—20-30, perhaps?).

In searching, I found a few potentially related bugs (#12615, #10713, #11169), but it seemed like these really didn't line up with my (hopefully valid?) use case.

Thanks!
",,
13044,OPEN,Allow Portals to be used for Reparenting,Type: Feature Request,2021-02-05 00:18:15 +0000 UTC,philipp-spiess,,"**Do you want to request a *feature* or report a *bug*?**

feature

**What is the current behavior?**

[Reparenting](https://github.com/facebook/react/issues/3965) is an unsolved issues of React(DOM). So far, it was possible to hack around the missing support for it by relying on unstable API (`unstable_renderSubtreeIntoContainer`) to render **and update** a subtree inside a different container. It's important to note that this API was using React's diffing algorithm so that, similar to `ReactDOM.render()`, it is possible to keep components mounted.

```js
ReactDOM.render(<Foo />, container);
// This won't get <Foo /> to be unmounted and mounted again:
ReactDOM.render(<Foo />, container);

ReactDOM.unstable_renderSubtreeIntoContainer(
  parentComponent,
  <Foo />,
  container
);
// This also won't get <Foo /> to be unmounted and mounted again, no matter if 
// we change parentComponent (and thus call it from a different parent):
ReactDOM.unstable_renderSubtreeIntoContainer(
  parentComponent,
  <Foo />,
  container
);
```

However this unstable API is [going to be deprecated soon](https://github.com/facebook/react/issues/10143) and recent features like the introduction of the new context API introduced [additional issues](https://github.com/facebook/react/issues/12493).

As an alternative to this unstable API, `ReactDOM.createPortal(children, container)` was introduced. However this API is unsuitable for the reparenting issue since it will always [create a new mount point](https://github.com/facebook/react/issues/10713) inside the `container` instead of applying the diffing _when called from a different parent_ (Check out this [CodeSandbox](https://codesandbox.io/s/91o7oovo54) where calling the portal from a different portal will cause the `<Leaf />` to have a new uuid). The reason for this is that we want multiple portals to be able to render inside the same `container` which makes perfect sense for more common use cases like popovers, etc.

Before we're going to remove `unstable_renderSubtreeIntoContainer`, I suggest we find a way to portal into a specific node instead of appending to it so that we can diff its contents instead (or implement a solution for #3965 although that seems to be more complicated), similar to `unstable_renderSubtreeIntoContainer`.",,
12989,OPEN,Consider removing Mobile Safari empty onclick hack,Component: DOM; React Core Team; Type: Needs Investigation,2021-04-03 15:01:47 +0000 UTC,gaearon,,"See https://github.com/facebook/react/issues/238 and https://github.com/facebook/react/pull/1536 for historical context.

Is that still relevant? The code is here:

https://github.com/facebook/react/blob/52fbe7612e0527b8c86decac519c344626f6bd72/packages/react-dom/src/client/ReactDOMFiberComponent.js#L244-L245

Even if it's relevant, can we just feature test it, and not do this hack on other browsers? Seems like a waste of memory for event handlers (even though the function is the same every time).",,
12749,OPEN,"IE 11 ""prompt to remember password"" regression bug since 15.2.0",Browser: IE; Component: DOM; Type: Needs Investigation; Type: Regression,2019-03-04 12:21:15 +0000 UTC,luisrudge,,"
## Note: this issue seems solved for Edge but not for IE 11, see https://github.com/facebook/react/issues/12749#issuecomment-412671171



This issue was [already raised](https://github.com/facebook/react/issues/7328), but since it was closed, I'm opening a new one so we can get more traction on this.

I'm still having this issue with both IE and Edge:

Works with 15.1.0: https://codesandbox.io/s/lpvz0zy9wq
Doesn't work with 15.2.0: https://codesandbox.io/s/o9kl2jzo1q
Doesn't work with 15.6.2: https://codesandbox.io/s/38kp95wl96
Doesn't work with 16.3.1: https://codesandbox.io/s/xjpk3wr55p

In order to test this effectively, you have to follow a few steps:

### Using Edge, go to **Settings** >> **View Advanced Settings**, under **Privacy and Services**

- make sure you have **Offer to save passwords** enabled:
![image](https://user-images.githubusercontent.com/941075/38700796-9c04a542-3e72-11e8-9aa5-b7e068c300b3.png)

- make sure you don't have any passwords saved in the codesandbox.io domain:
![image](https://user-images.githubusercontent.com/941075/38700921-ee497666-3e72-11e8-8b27-8e64fb6a4e2e.png)


## Steps to reproduce when IT WORKS (15.1.0)

- go to the [15.1.0](https://codesandbox.io/s/lpvz0zy9wq) sandbox
- type a username and a password and hit submit
- you'll see a confirmation panel about saving passwords:
![image](https://user-images.githubusercontent.com/941075/38701037-409fdc70-3e73-11e8-8997-ec8ecc082163.png)
- refresh the page
- type another username and a password and hit submit
- you'll see another confirmation panel about saving passwords:
![image](https://user-images.githubusercontent.com/941075/38701037-409fdc70-3e73-11e8-8997-ec8ecc082163.png)
- refresh the page
- click on the first input
- you'll see a list of the previously used usernames: ![image](https://user-images.githubusercontent.com/941075/38701545-8b5e1e2e-3e74-11e8-932a-ccf18b6a07fc.png)

## Steps to reproduce when IT DOESN'T WORK (15.2.0, 15.6.2, 16.3.1)

- remove previously saved passwords from the codesandbox.io domain:
![image](https://user-images.githubusercontent.com/941075/38700921-ee497666-3e72-11e8-8b27-8e64fb6a4e2e.png) 
- go to any of the non-working sandboxes ([15.2.0](https://codesandbox.io/s/o9kl2jzo1q), [15.6.2](https://codesandbox.io/s/38kp95wl96), [16.3.1](https://codesandbox.io/s/xjpk3wr55p)
- type a username and a password and hit submit
- there will be no password confirmation panel
- refresh the page
- click on the first input
- there will be no list of previously used usernames",,
12717,OPEN,onMouseDown causes splash on real ios browsers,Browser: Safari; Component: DOM; Type: Bug,2018-08-06 23:10:50 +0000 UTC,huhaixiao,,"
unexpected **grey splash** caused by `onMouseDown` on real ios device's browsers, both safari and chrome.
[Please checkout this **grey splash** issue first](https://github.com/mui-org/material-ui/issues/11154)
I did some trial later, and find out that vanilla html `<button onmousedown="""">btn</button>` doesn't cause **grey splash**, but with React's jsx `<button onMouseDown={()=>{}}></button>`, there is a noticeable **grey splash**

**What is the expected behavior?**

who wants a splash?

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

""react"": ""^16.3.2""
",,
12615,OPEN,Unexpected warning when hydrating with portal and SSR,Difficulty: medium; Type: Bug; good first issue,2020-09-25 23:50:56 +0000 UTC,majelbstoat,,"**Do you want to request a *feature* or report a *bug*?**

*bug*

**What is the current behavior?**

Given the following (simplified) snippet:

```jsx
class HoverMenu extends React.Component {
  render() {
    if (typeof document === 'undefined') return null
    const root = document.getElementById('root')
    return ReactDOM.createPortal(<div>Hello World</div>, root)
  }
}

class Para extends React.Component {
  render() {
    return (
      <span>
        Some Text
        <HoverMenu />
      </span>
    )
  }
} 
```

where `div#root` is a valid `div` that exists, the following error is shown when hydrating after SSR:

`Warning: Expected server HTML to contain a matching <div> in <span>`

The warning goes away if I update the definition of `HoverMenu` to:

```jsx
class HoverMenu extends React.Component {
  componentDidMount() {
    this.setState({ isActive: true })
  }
  render() {
    const { isActive} = this.state
    if (!isActive) return null
    const root = document.getElementById('root')
    return ReactDOM.createPortal(<div>Hello World</div>, root)
  }
}
```

I'd prefer not to do that because of the double rendering caused by `setState` in `componentDidMount`.

I don't quite understand what that error is telling me. No `<div />` is rendered server-side in either case. The error is particularly confusing, as the `HoverMenu` DOM `div` is not even rendered inside a DOM `span`. (I wonder if this is happening because `HoverMenu` is nested inside a React `span`.)

**What is the expected behavior?**

No error is thrown. Or, at least that the error message is clearer.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Chrome 65
React 16.2
(SSR through Next 5.1)
",,
12525,OPEN,Provide a way to detect infinite component rendering recursion in development,Type: Feature Request,2021-01-20 17:31:50 +0000 UTC,josh-degraw,,"I've been trying out the new Context API in my project and it's awesome. However, in my haste to start using it, I managed to stumble into a situation where every time I would try and render a certain component which was making use of a few different contexts, the app would completely freeze, and the only thing that would let me get out of this error state was to forcefully kill the process via the chrome task manager.

Nothing would be logged to the console, the app would just completely freeze, and when I opened up the task manager and saw the CPU spiked up every time i would go to this component, and the only way I could stop it was to crash the tab. 

I finally threw some `console` statements in and saw that it had just entered into an infinite loop between these providers. I managed to get the app to stop crashing, but I'm still unsure as to why exactly this was happening. I'm sure I was just using this API incorrectly somehow, but this was a very confusing problem to diagnose, and some error checking here would be incredibly useful

**What is the expected behavior?**

It would be very beneficial to have some sort of checks in place, similar to what happens with too many `setState` calls happening too closely when you call it from `componentDidUpdate`, for example. That way, instead of freezing everything up permanently, the app could at least crash and report some sort of information and help me realize where I'd gone wrong.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
- React `16.3.0`
- Chrome `65.0.3325.181`

",,
12441,OPEN,Dangerous strings can reach browser builtins,Component: DOM; Type: Discussion,2019-04-24 15:28:16 +0000 UTC,mikesamuel,,"
```jsx
var x = 'javascript:alert(1)';
ReactDOM.render(
  (<a href={x}>Link</a>),
  document.getElementById('container')
);
```

produces a link that alerts.


**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

* [Load the code above in the codepen REPL](https://jsfiddle.net/Luktwrdm/202/)
* After the REPL loads, click the ""Run"" button at the top left.
* You should see a blue ""link"" in the bottom-right pane.
* Click it.  An alert will popup.

The alert should not pop up.

A simple string that reaches an `href` attribute should not cause arbitrary code execution even with user interaction.


**What is the expected behavior?**
A string that reaches a browser builtin like the `HTMLAElement.prototype.href` setter should not cause code execution.

**Discussion**

[Polymer Resin](https://docs.google.com/presentation/d/1hepAXMroHSNTM0NV1aGlntjHrw0a0QOM5X5JvfXv_N0/edit#slide=id.g227691820f_0_198) uses hooks in another webcomponents framework to intercept value before they reach browser builtins where they can be vetted.  A similar approach could work for React.

It allows values to reach browser builtins when they are innocuous or have a runtime type that indicates that the author intentionally marked them as safe for that kind of browser builtin.

For example, an `instanceof SafeURL` would be allowed to reach `HTMLAElement.prototype.href` as would any string that is a relative URL, or one with a whitelisted protocol in (`http`, `https`, `mailto`, `tel`) but not `javascript:...`.

Many developers know that `<a href={...}>` is risky, but if the link is an implementation detail of a custom React element, then developers don't have the context to know which attributes they need to be careful with.  They shouldn't have to either since it is an implementation detail.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

I believe this is widespread across versions.

An earlier REPL I tried showed that it worked on version 16.2.0 from https://unpkg.com/react-dom/umd/react-dom.development.js but I don't know what version the jsfiddle above uses.
",,
12363,OPEN,React onBlur events not firing during unmount,Component: DOM; Type: Bug; Type: Needs Investigation,2020-07-08 10:47:47 +0000 UTC,taj-codaio,,"**Do you want to request a *feature* or report a *bug*?**

bug

**What is the current behavior?**

If a DOM element rendered by a React component has focus, and the React component unmounts, the React `onBlur` event does not fire on parent DOM elements.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/134wrzy6q7

**What is the expected behavior?**

I would expect that, just like the browser fires a `focusout` event when removing a DOM node, React would fire an `onBlur` events up to parent nodes when the focused node is removed / unmounted.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React: 16.2
Mac OS X: 10.13.2
Browser: Chrome 67.0.3366.0, Chrome 64.0.3282.186

No idea if this worked in earlier versions of React.",,
12334,OPEN,"For Controlled Input; step does not work as expected unless initialized with null or """".",Component: DOM; Type: Bug,2019-01-12 18:45:17 +0000 UTC,andyboyne,,"*BUG*

**What is the current behavior?**
For input type=""number"", step does not work as expected if there is an initial value set. Step only seems to get honored if the initial value is """" or null.

Example:
https://codepen.io/anon/pen/MQMBmX

The example uses a controlled input binding value and step. Step is 1/10th of the value. If you edit the value in the textbox to 50000 and increment using the stepper, it will increment to 50100 (i.e. by the initial value and not by the current step).

Edit the code so initial value is """" or null. Edit textbox to 50000 and step up - value goes to 55000 as expected.

**What is the expected behavior?**
It should be possible to render a number input that honors step without having to initialize the input component value to null or """" first.

It seems when there is an initial value provided, it will write a value attribute into the DOM (e.g. value=""100"").  When initial value is """" or null then just the value attribute is written to DOM with no assignment. e.g. (value).


**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.3.0-alpha.1  (ported to this version to confirm if still an issue)
0.14.7 (originally found in this version)

Seems to affect Chrome only (confirmed windows and mac, versions 59 and 64). Bug does not appear in Safari (on a mac at least).",,
12235,OPEN,Extracting a Context Stack,Component: Reconciler; React Core Team; Type: Feature Request,2020-01-08 19:17:21 +0000 UTC,sebmarkbage,,"A useful feature of context is creating a custom stack of things to see what your component is embedded in side.

I think the primary use case is logging explicitly.

Currently that is pretty expensive to maintain just *in case* you need it. See #12234 as an example.

We could provide an API that lazily extracts a whole path of contexts from the tree.

```js
<FooContext.Provider value={""foo""}>
  <FooContext.Provider value={""bar""}>
    <FooContext.Provider value={""baz""}>
      <App />
    </FooContext.Provider>
  </FooContext.Provider>
</FooContext.Provider>
```

```js
class App extends React.Component {
  log() {
    var stack = this.getContextStack(FooContext);
    logToServer(stack); // [""foo"", ""bar"", ""baz""]
  }
  render() {
    return <div onClick={this.log} />;
  }
}
```

It would basically synchronously rerender the shortest path to recreate the context at the time of the call to create the stack lazily.

cc @acdlite ",,
12073,OPEN,Fabric Todos,React Core Team; Type: Umbrella,2020-01-08 19:17:20 +0000 UTC,sebmarkbage,,"For my own notes here are some spill-overs from the Fabric renderer commit.

- [ ] Update currentProps for updates in the commit phase. Needs a host effect to be marked and we need a hook to do host updates in the persistent mode.
- [x] Actually use currentProps when extracting events in the component tree.
- [ ] Resuming will need to be able to not reuse host nodes used by another thread.
- [ ] Should always clone direct siblings of a changed node, in case they will relayout.",,
11972,OPEN,Consider removing mouseenter/mouseleave polyfill,Component: DOM; React Core Team; Type: Breaking Change,2020-01-08 19:17:20 +0000 UTC,gaearon,,"As suggested in https://github.com/facebook/react/pull/10247.
Not sure we want to do it, but I decided to create an issue to track future attempts (the PR is stale).",,
11949,OPEN,Output JUnit XML test metadata for CircleCI,Component: Build Infrastructure; Difficulty: medium; Partner; good first issue,2021-03-25 14:18:44 +0000 UTC,sophiebits,,"# @benbraou has claimed this issue. Please give them a chance to work on this.

---

Here's a screenshot of a CircleCI build for another (private) project I'm a part of:

![image](https://user-images.githubusercontent.com/6820/34494194-1d3d3f70-efa4-11e7-87b7-0ca9961b2934.png)

It clearly highlights the parts of the build that failed.

In contrast, see one of our builds: https://circleci.com/gh/facebook/react/8402. In this one the ./scripts/circleci/upload_build.sh step failed but you need to scroll through the output a significant amount to see that. This is in part because we have a custom entry point for all our CI steps ([scripts/circleci/test_entry_point.sh](https://github.com/facebook/react/blob/v16.2.0/scripts/circleci/test_entry_point.sh)) to make it easier for us to parallelize some build steps.

I'd like us to change that test_entry_point.sh script to output JUnit XML metadata for CircleCI as described in https://circleci.com/docs/2.0/collect-test-data/. Then I believe the CircleCI build results page will show exactly which step failed.

(Bonus: If we can show individual Jest tests that would be even cooler. But I think the most important part is breaking out jest vs flow vs prettier, etc. into separate chunks.)",,
11935,OPEN,Consider a more specific warning for key={undefined},Component: Core Utilities; React Core Team; Type: Enhancement,2020-01-30 13:30:33 +0000 UTC,gaearon,,"Proposed in [this comment](https://dev.to/k1sul1/comment/1o68):

>I had changed the casing of ""ID"" in the response, but forgot to commit it aaaaaand I ended up with it happening.

>Basically I was doing key={undefined}. Could React warn user when this happens, something like ""Looks like you tried to supply a key, but the value supplied is undefined. Check the render..."" and so on?

I think it might make sense to give a more specific warning in this case. Open to suggestions about specific wording and in which case it would be used.",,
11896,OPEN,Stop syncing value attribute for controlled inputs,Component: DOM; Type: Breaking Change; Type: Discussion,2018-10-04 06:30:59 +0000 UTC,aweary,,"Opening this as a follow up to some quick discussions in https://github.com/facebook/react/issues/11881. Syncing the `value` attribute has been a consistent source of bugs for us, and the benefits of doing so seem minimal. There's some previous discussion on the topic in https://github.com/facebook/react/pull/7359 and in other issues, I can't remember right now 😄 

This would be a breaking change, so it would have to be done in a major release. 

## Reasons to keep syncing

* It prevents `form.reset()` from putting controlled form inputs into a weird state
* Some browser extensions (not sure which) read from the `value` attribute in some cases (not sure which)
* It can be useful for querying inputs with a specific value using an attribute selector

## Reasons to stop syncing

* It will reduce the complexity of `react-dom` in a non-trivial way
* In turn, it will likely reduce bundle size as well
* We remove a whole class of bugs (fighting with browsers that want to be helpful about input values)
* Syncing the input value to the attribute potentially exposes sensitive data to third party tools ([1](https://www.reddit.com/r/analytics/comments/7ukw4n/mixpanel_js_library_has_been_harvesting_passwords/))

______

What do we think? Are these reasons good enough to keep syncing the `value` attribute? Are there other more critical reasons we should keep doing so?


cc @nhunzaker @jquense @gaearon ",,
11881,OPEN,backspace fails to clear values on input type='email',Component: DOM; Type: Bug,2019-10-03 01:16:07 +0000 UTC,codeangler,,"
**If the current behavior is a bug, demo**

no bug in React 15.0.0
no bug in React 15.1.0
bug on React 15.2
[React~15 fiddle](https://jsfiddle.net/cburnett/79z43qxn/9/)

bug on React 16 
[React~16 fiddle](https://jsfiddle.net/cburnett/q1297t5w/2/)

**What is the expected behavior?**

When a user presses down the backspace key and holds it, all values in the input are removed, including the whitespaces  

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Works on 15.1.0
bug at >= 15.2.0 
testing on Chrome 63
MacOs Sierra 10.12
",,
11877,OPEN,Number input gets cleared when typing period as decimal mark,Component: DOM; Type: Bug,2019-03-25 23:38:32 +0000 UTC,Hilzu,,"
My OS and browser are configured to a locale that uses comma as the decimal mark (Finland for those interested). In the codepen below when I accidentally type a period after some number the whole input gets cleared. This is somehow related to the parent component's state being updated because if the `defaultValue` prop is removed from the `<Input>` component the input doesn't get cleared.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template for React 16: https://jsfiddle.net/Luktwrdm/, template for React 15: https://jsfiddle.net/hmbg7e9w/).**

https://codepen.io/anon/pen/aEOgNL?editors=0010

**What is the expected behavior?**

The input should retain its visible value even if it would be invalid (can't be converted to a number).

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

React 16.2.0 and Chrome 63 on macOS 10.12.6.

Tested in Safari 11.0.2 and typing a period kinda works. After typing the first number after the period it gets converted to a comma but the cursor jumps to the beginning.

Also tested in Firefox 57.0.1 but it seems to think that period is the correct decimal mark.",,
11827,OPEN,Cursor jumps when backspacing in a number input (with ShadowDOM),Component: DOM; Difficulty: medium; Type: Bug; good first issue,2021-04-02 18:40:06 +0000 UTC,YellowKirby,,"
Super low-quality gif (sorry):
<img src=""https://thumbs.gfycat.com/TautIncredibleEkaltadeta-size_restricted.gif""/>

This issue appears to be similar to the problem here: https://github.com/facebook/react/pull/7359, but in this case it's only custom elements with a shadow root that exhibit the problem.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template for React 16: https://jsfiddle.net/Luktwrdm/, template for React 15: https://jsfiddle.net/hmbg7e9w/).**
1. Have a React component render a number input: `<input type=""number"" />`.
2. Attach that React component as part of the ShadowDOM node of a custom element.
3. Enter in some decimal value (e.g., `88.88`) into the input.
4. Slowly backspace in the input. As soon as the decimal point would be the last character, the decimal point is removed and the cursor position jumps to the beginning of the input.

Demo: https://jsfiddle.net/69z2wepo/94566/

**What is the expected behavior?**

The ShadowDOM case behaves like the other cases: when backspacing in the input, the cursor does not jump to the beginning of the input and the decimal point is not unexpectedly deleted.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React 16.2.0 + Chrome 62.0.3202.62 + OSX 10.12.6
",,
11826,OPEN,React does not call onBlur callback,Component: DOM; Type: Bug,2020-06-18 16:55:56 +0000 UTC,nbob,,"**Do you want to request a *feature* or report a *bug*?**
**Bug**

**What is the current behavior?**
When input control becomes disabled, React does not call onBlur callback

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal https://jsfiddle.net/c22pez5z/

**What is the expected behavior?**
1. Focus on input element
2. Press Enter button (it makes input disabled)
3. `Blur counter` and `Native blur counter` should be equal.",,
11799,OPEN,Consider removing XML compatibility from SSR or hiding it behind an option,Component: Server Rendering; React Core Team; Type: Breaking Change,2020-08-25 13:43:07 +0000 UTC,gaearon,,"See https://github.com/facebook/react/pull/11708#issuecomment-349953542.
Not sure if it's important but seems suboptimal to send extra markup if most people don't need XML.",,
11734,OPEN,value|defaultValue={Symbol|Function} should be ignored; not stringified,Component: DOM; Difficulty: starter; React Core Team; Type: Bug; good first issue,2021-03-30 01:32:43 +0000 UTC,gaearon,,"Regression in master from https://github.com/facebook/react/pull/11534.
Found it thanks to the attribute fixture snapshots.",,
11678,OPEN,Disabled button click event propagates in IE11,Browser: IE; Component: DOM; Type: Bug,2020-01-10 19:00:30 +0000 UTC,Blasz,,"The event is swallowed/not fired in all other major browsers.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template for React 16: https://jsfiddle.net/Luktwrdm/, template for React 15: https://jsfiddle.net/hmbg7e9w/).**
https://codesandbox.io/s/r0q76vqjwn

**What is the expected behavior?**
The event should not fire or bubble.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React 15.6.2 - IE11",,
11674,OPEN,Resetting a form containing a focused controlled number input puts it out of step with state,Component: DOM; Type: Bug,2018-08-30 23:27:11 +0000 UTC,aweary,,"Here's a fixture demonstrating the issue (first test case): http://react-number-input-form-reset-bug.surge.sh/number-inputs

If you have a controlled number input within a form containing a reset button, hitting Enter can trigger that reset event. This causes the focused input to be reset to the `defaultValue`, which won't be in sync with the tracked value because we do that work on blur for number inputs to avoid triggering validation warnings. This doesn't affect other input types, since the tracked value is updated immediately.

This might be a viable tradeoff for avoiding those validation warnings, so I'm not sure if this is actionable, but I wanted to at least document it for future reference.


cc @nhunzaker @gaearon 

",,
11667,OPEN,RFC: Drop isAttributeNameSafe() check in React 17,React Core Team; Type: Breaking Change; Type: Enhancement,2020-01-08 19:17:55 +0000 UTC,gaearon,,"We currently validate DOM attributes on the client and ignore the ones with invalid names:

https://github.com/facebook/react/blob/0c164bb4851e78e5f789dd8619f17ffcfee0221f/packages/react-dom/src/client/DOMPropertyOperations.js#L202-L204

This check used to be important for safety when we did `innerHTML` rendering on the client side, but it's not anymore. If we just let it call `setAttribute`, the browser would throw on a bad attribute name.

This check used to run very infrequently (only for data attributes and custom elements), but now more attributes follow this code path (since any ""simple"" attributes with the same names are effectively treated as unknown attributes). So even though we cache the result, it seems unfortunate to do the work that the browser is already doing for us.

While this would be a breaking change (so it has to go in 17), I think we should just remove this check, and let the browser throw. This does make spreading props blindly a bit more dangerous, but we have a warning so it should be visible.",,
11609,OPEN,Undo operation on text input throws exception in IE9,Browser: IE; Component: DOM; Type: Bug,2018-06-02 21:35:39 +0000 UTC,nhunzaker,,"**Do you want to request a *feature* or report a *bug*?**

This is a bug report. It looks like IE9 is unmounting text nodes when undoing text input operations. If the display value of the input is rendered in another component, it raises an exception because IE9 does not allow changes to `nodeValue` on unmounted text nodes.

I think that's the issue, anyway. It is documented here:

https://connect.microsoft.com/IE/feedbackdetail/view/944330/invalid-argument-error-when-changing-nodevalue-of-a-text-node-removed-by-setting-innerhtml-on-an-ancestor

**What is the current behavior?**

1. Open http://react-dom-test-fixtures.surge.sh/number-inputs in IE9
2. Change the text in the first controlled text input
3. Start debugging in the IE9 developer tools
4. Press ctrl+z to undo your text change
5. IE9 raises an exception when setting the nodeValue of the text label to the right of the input ""invalid arguments"":

**What is the expected behavior?**

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

This affects IE9 when using React 16. It is also an issue on master.

--- 

The issue springs up in ReactDOM.js:

https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOM.js#L392-L398

I think there just needs to be a wrapper around the text node to see if it has a parent before updating. Maybe something like:

```javascript
commitTextUpdate(
  textInstance: TextInstance,
  oldText: string,
  newText: string,
): void {
  // IE9 will raise an exception if modifying a detached text node
  // https://connect.microsoft.com/IE/feedbackdetail/view/944330/invalid-argument-error-when-changing-nodevalue-of-a-text-node-removed-by-setting-innerhtml-on-an-ancestor
  if (textInstance.parentNode) {
    textInstance.nodeValue = newText;
  }
}
```

But that feels like a band-aid solution. I'm curious what is causing the text node to unmount to begin-with.",,
11570,OPEN,"Reword ""unknown property"" warning to be less obnoxious",Component: DOM; React Core Team; Type: Enhancement,2020-01-08 19:17:54 +0000 UTC,gaearon,,"I thought before it might cause knee jerk reactions, and it does in practice: https://twitter.com/freeformflo/status/928454078903894016

I think we should change the phrasing to a more neutral one. Potentially explaining *why* we prefer camel case. ",,
11566,OPEN,[Umbrella] New algorithm for resuming interrupted work,Component: Reconciler; React Core Team; Type: Umbrella,2020-01-08 19:17:54 +0000 UTC,acdlite,,"*Resuming* is the ability to re-use fibers after they are interrupted by a higher-priority update. Take the following scenario: A component is updated at a normal, async priority. Before the update is finished processing, a higher-priority update is scheduled (let's say it's synchronous, though it could also be a higher-priority async update). The sync update *interrupts* the async update, leaving it unfinished. After the sync update finishes, we go back to processing the interrupted, async update. It's possible, and even likely, that the interrupted work wasn't touched by the sync work and can be *resumed* without starting over completely.

This is an important optimization for several async features we have in mind, including error handling, blockers, pre-rendering, and hidden priority.

We used to have an implementation of resuming that mostly worked but had some bugs. A few months ago, I spent some time [identifying the bugs using fuzz testing](https://github.com/facebook/react/pull/9952) and fixing them by iterating on the existing algorithm. I eventually got a [version working that passed all the tests](https://github.com/facebook/react/pull/9695). But even this version didn't have all of the features we wanted, and the algorithm seemed inherently flawed. So we decided it would be best to scrap the existing algorithm and revisit resuming in the future.

We now believe we have a better idea of how resuming should work. I'm going to split the work into multiple PRs, and use this issue to keep track of our progress.

My apologies if some of my descriptions are hard to follow. It can be difficult to describe without resorting to jargon. I'll iterate on this issue as I work.


Always reconcile against current child set (#11564)
---------------------------------------------------

This is a small refactor that reflects what we already do without resuming: the set we reconcile against is always the current set. In the reverted resuming algorithm, the set we reconcile against was sometimes a work-in-progress set, and there are a few code paths that are left over from that implementation.

Stash interrupted children
--------------------------

When cloning a work-in-progress fiber from current, and there is already an existing work-in-progress that was interrupted, stash the interrupted work-in-progress children (and corresponding fields) in case we can reuse them later. In begin phase, add an additional check to see if incoming props/state match the interrupted props/state. If so, bail out and re-use the interrupted children. If not, the interrupted children are no longer useful, because we're about to re-render the parent and overwrite them. (Unmounted fibers actually can be re-used even if we re-render the parent; see next step.)

This gets us back to the same functionality we had in the old resuming algorithm. We can now resume interrupted children if we come back to it at the same priority at which it was originally rendered. The main limitation is that the work is lost if the parent is re-rendered at a higher priority.

**Need a way to distinguish between a work-in-progress fiber and the ""previous current"" fiber*

Pool unmounted, interrupted children so they can resume even if parent re-renders at higher priority
------------------------------------------------------------------------------------

When a fiber is about to be re-rendered, and there are interrupted children that could not be reused, search through the interrupted children and find the ones that are unmounted (don't have an alternate). Stash the unmounted children in a separate set; they can be kept around indefinitely without being overwritten. This set acts like a pool of children. The next time the parent is re-rendered at the priority of the interrupted children, check the pool for matches before creating new fibers.

",,
11565,OPEN,React-test-renderer: support for portal,Component: Test Renderer; Type: Feature Request,2021-03-18 19:05:28 +0000 UTC,alansouzati,,"**Do you want to request a *feature* or report a *bug*?**

Report a bug

**What is the current behavior?**

This test

```javascript
import React from 'react';
import { createPortal } from 'react-dom';
import renderer from 'react-test-renderer';

const Drop = () => (
  createPortal(
    <div>hello</div>,
    this.dropContainer
  )
);

test('Drop renders', () => {
  const component = renderer.create(
    <div>
      <input />
      <Drop />
    </div>
  );
  const tree = component.toJSON();
  expect(tree).toMatchSnapshot();
});
```

fails with

> Invariant Violation: Drop(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.

This test passes if I wrap createPortal in a container.

```javascript
<div>
  {createPortal(
    <div>hello</div>,
    this.dropContainer
  )}
</div>
```

**What is the expected behavior?**

The code without the parent container works fine in the browser. So it seems that I'm adding the  parent `div` just for the test to pass. I believe `react-test-renderer` should support empty returns?

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Lastest
",,
11503,OPEN,Formalize top-level ES exports,Component: Build Infrastructure; React Core Team; Type: Breaking Change; Type: Discussion,2021-01-09 14:52:19 +0000 UTC,gaearon,,"Currently we only ship CommonJS versions of all packages. However we might want to ship them as ESM in the future (https://github.com/facebook/react/issues/10021).

We can't quite easily do this because we haven't really decided on what top-level ES exports would look like from each package. For example, does `react` have a bunch of named exports, but also a default export called `React`? Should we encourage people to `import *` for better tree shaking? What about `react-test-renderer/shallow` that currently exports a class (and thus would start failing in Node were it converted to be a default export)?",,
11461,OPEN,[RN] Don't receive events on unknown tags,React Core Team; Type: Needs Investigation,2020-01-08 19:17:53 +0000 UTC,gaearon,,"Flow uncovered this:

https://github.com/facebook/react/blob/92b7b172cce9958b846844f0b46fd7bbd8c5140d/packages/react-native-renderer/src/ReactNativeEventEmitter.js#L174-L175

Need to verify if we can just return early and not process the events in this case.",,
11417,OPEN,Treat value={null} as empty string,Component: DOM; Type: Discussion,2019-03-15 17:10:34 +0000 UTC,IndifferentDisdain,,"Per @gaearon's request, I'm opening up a new issue based on https://github.com/facebook/react/issues/5013#issuecomment-340898727.

Currently, if you create an input like `<input value={null} onChange={this.handleChange} />`, the null value is a flag for React to treat this as an uncontrolled input, and a console warning is generated. However, this is often a valid condition. For example, when creating a new object (initialized w/ default values from the server then passed to the component as props) in a form that requires address, Address Line 2 is often optional. As such, passing null as value to this controlled component is a very reasonable thing to do.

One can do a workaround, i.e. `<input value={foo || ''} onChange={this.handleChange} />`, but this is an error-prone approach and quite awkward.

Per issue referenced above, the React team has planned on treating null as an empty string, but that hasn't yet occurred. I'd like to propose tackling this problem in the near future.

Please let me know if I can help further.",,
11387,OPEN,createPortal: support option to stop propagation of events in React tree,Component: DOM; Type: Feature Request,2021-04-08 07:37:41 +0000 UTC,kib357,,"**Do you want to request a *feature* or report a *bug*?**
Feature, but also a bug cause new API breaks old `unstable_rendersubtreeintocontainer`

**What is the current behavior?**
We cannot stop all events propagation from portal to its React tree ancestors. Our layers mechanism with modals/popovers completely broken. For example, we have a dropdown button. When we click on it, click opens popover. We also want to close this popover when clicking on same button. With createPortal, click inside popover fires click on button, and it's closing. We can use stopPropagation in this simple case. But we have tons of such cases, and we need use stopPropagation for all of them. Also, we cannot stop all events.

**What is the expected behavior?**
createPortal should have an option to stop synthetic events propagation through React tree without manually stopping every event. What do you think?
",,
11369,OPEN,React should recognize the `valueAsDate` property on DOM elements,Component: DOM; Type: Feature Request,2021-03-20 17:18:06 +0000 UTC,kreba,,"The `valueAsDate` property on the ES6 definition of `HTMLInputElement` is not yet recognized by React. It should be, though.

The `valueAsDate` property relieves the pain of having to deal with both browsers that support HTML5 date inputs and those who don't; the former require the `value` property to be of the form `""YYYY-MM-DD""` and the latter require a nicely formatted date (e.g. `""MM/DD/YYYY""`) since the user will see exactly that. (React won't even allow that in conjunction with `type=""date""`, though, and proclaim that the machine readable format should be used.) 
The browsers that do support HTML5 date input (should) alternatively support the date being passed in through the `valueAsDate` property. If we use that, we can always put a nicely formatted date in the `value` property. Pain relieved! (And also React should allow any format in the `value` property in that case.)

As indicated above, browser support is still lacky at best, even with the most avant garde browsers. Hence this is not an urgent issue for React. It will get relevant, though, and is herein duly noted.",,
11347,OPEN,RFC: Plan for custom element attributes/properties in React 18,Component: DOM; Type: Discussion,2021-03-07 18:59:42 +0000 UTC,robdodson,,"This is meant to address #7249. The doc outlines the pros and cons of various approaches React could use to handle attributes and properties on custom elements.

# TOC/Summary

- Background
- Proposals
  * Option 1: Only set properties
    + Pros
      - Easy to understand/implement
      - Avoids conflict with future global attributes
      - Takes advantage of custom element ""upgrade""
      - Custom elements treated like any other React component
    + Cons
      - Possibly a breaking change
      - Need ref to set attribute
      - Not clear how server-side rendering would work
  * Option 2: Properties-if-available
    + Pros
      - Non-breaking change
    + Cons
      - Developers need to understand the heuristic
      - Falling back to attributes may conflict with future globals
  * Option 3: Differentiate properties with a sigil
    + Pros
      - Non-breaking change that developers can opt-in to
      - Similar to how other libraries handle attributes/properties
      - The system is explicit
    + Cons
      - It’s new syntax
      - Not clear how server-side rendering would work
  * Option 4: Add an attributes object
    + Pros
      - The system is explicit
      - Extending syntax may also solve issues with event handling
    + Cons
      - It’s new syntax
      - It may be a breaking change
      - It may be a larger change than any of the previous proposals
  * Option 5: An API for consuming custom elements
    + Pros
      - The system is explicit
      - Non-breaking change
      - Idiomatic to React
    + Cons
      - Could be a lot of work for a complex component
      - May bloat bundle size
      - Config needs to keep pace with the component

# Background

When React tries to pass data to a custom element it always does so using HTML attributes.

```jsx
<x-foo bar={baz}> // same as setAttribute('bar', baz)
```

Because attributes must be serialized to strings, this approach creates problems when the data being passed is an object or array. In that scenario, we end up with something like:

```html
<x-foo bar=""[object Object]"">
```

The workaround for this is to use a `ref` to manually set the property.

```jsx
<x-foo ref={el => el.bar = baz}>
```

This workaround feels a bit unnecessary as the majority of custom elements being shipped today are written with libraries which automatically generate JavaScript properties that back all of their exposed attributes. And anyone hand-authoring a vanilla custom element is [encouraged to follow this practice](https://developers.google.com/web/fundamentals/web-components/best-practices#attributes-properties) as well. We'd like to ideally see runtime communication with custom elements in React use JavaScript properties by default.

This doc outlines a few proposals for how React could be updated to make this happen.

# Proposals

## Option 1: Only set properties

Rather than try to decide if a property or attribute should be set, React could *always* set properties on custom elements. React would **NOT** check to see if the property exists on the element beforehand.

**Example:**

```jsx
<x-foo bar={baz}>
```

The above code would result in React setting the `.bar` property of the `x-foo` element equal to the value of `baz`.

For camelCased property names, React could use the same style it uses today for properties like `tabIndex`.

```jsx
<x-foo squidInk={pasta}> // sets .squidInk = pasta
```

### Pros

#### Easy to understand/implement

This model is simple, explicit, and dovetails with React’s [""JavaScript-centric API to the DOM""](https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#why-are-we-changing-this).

Any element created with libraries like Polymer or Skate will automatically generate properties to back their exposed attributes. These elements should all ""just work"" with the above approach. Developers hand-authoring vanilla components are encouraged to [back attributes with properties](https://developers.google.com/web/fundamentals/web-components/best-practices#always-accept-primitive-data-strings-numbers-booleans-as-either-attributes--or-properties) as that mirrors how *modern* (i.e. not oddballs like `<input>`) HTML5 elements (`<video>`, `<audio>`, etc.) have been implemented.

#### Avoids conflict with future global attributes

When React sets an attribute on a custom element there’s always the risk that a future version of HTML will ship a similarly named attribute and break things. This concern was [discussed with spec authors](https://github.com/w3c/webcomponents/issues/654) but there is no clear solution to the problem. Avoiding attributes entirely (except when a developer explicitly sets one using `ref`) may sidestep this issue until the browsers come up with a better solution.

#### Takes advantage of custom element ""upgrade""

Custom elements can be lazily [upgraded](https://developers.google.com/web/fundamentals/web-components/customelements#upgrades) on the page and some PRPL patterns rely on this technique. During the upgrade process, a custom element can access the properties passed to it by React—even if those properties were set before the definition loaded—and use them to render initial state.

#### Custom elements treated like any other React component

When React components pass data to one another they already use properties. This would just make custom elements behave the same way.

### Cons

#### Possibly a breaking change

If a developer has been hand-authoring vanilla custom elements which only have an attributes API, then they will need to update their code or their app will break. The fix would be to use a `ref` to set the attribute (explained below).

#### Need ref to set attribute

By changing the behavior so properties are preferred, it means developers will need to use a `ref` in order to explicitly set an attribute on a custom element.

```jsx
<custom-element ref={el => el.setAttribute('my-attr', val)} />
```

This is just a reversal of the current behavior where developers need a `ref` in order to set a property. Since developers should rarely need to set attributes on custom elements, this seems like a reasonable trade-off.

#### Not clear how server-side rendering would work

It's not clear how this model would map to server-side rendering custom elements. React could assume that the properties map to similarly named attributes and attempt to set those on the server, but this is far from bulletproof and would possibly require a heuristic for things like camelCased properties -> dash-cased attributes.

## Option 2: Properties-if-available

At runtime React could attempt to detect if a property is present on a custom element. If the property is present React will use it, otherwise it will fallback to setting an attribute. This is the model Preact uses to deal with custom elements.

**Pseudocode implementation:**

```js
if (propName in element) {
  element[propName] = value;
} else {
  element.setAttribute(propName.toLowerCase(), value);
}
```

**Possible steps:**

* If an element has a defined property, React will use it.

* If an element has an undefined property, and React is trying to pass it primitive data (string/number/boolean), it will use an attribute.

    * Alternative: Warn and don’t set.

* If an element has an undefined property, and React is trying to pass it an object/array it will set it as a property. This is because some-attr=""[object Object]” is not useful.

    * Alternative: Warn and don’t set.

* If the element is being rendered on the server, and React is trying to pass it a string/number/boolean, it will use an attribute.

* If the element is being rendered on the server, and React is trying to pass it a object/array, it will not do anything.

### Pros

#### Non-breaking change

It is possible to create a custom element that only uses attributes as its interface. This authoring style is **NOT** encouraged, but it may happen regardless. If a custom element author is relying on this behavior then this change would be non-breaking for them.

### Cons

#### Developers need to understand the heuristic

Developers might be confused when React sets an attribute instead of a property depending on how they’ve chosen to load their element.

#### Falling back to attributes may conflict with future globals

Sebastian [raised a concern](https://github.com/facebook/react/issues/10399#issuecomment-320847065) that using `in` to check for the existence of a property on a custom element might accidentally detect a property on the superclass (HTMLElement).

There are also other potential conflicts with global attributes [discussed previously](#avoids-conflict-with-future-global-attributes) in this doc.

## Option 3: Differentiate properties with a sigil

React could continue setting attributes on custom elements, but provide a sigil that developers could use to explicitly set properties instead. This is similar to [the approach used by Glimmer.js](https://www.emberjs.com/blog/2017/10/10/glimmer-progress-report.html#toc_component-attributes).

**Glimmer example:**

```html
<custom-img @src=""corgi.jpg"" @hiResSrc=""corgi@2x.jpg"" width=""100%"">
```

In the above example, the @ sigil indicates that `src` and `hiResSrc` should pass data to the custom element using properties, and `width` should be serialized to an attribute string.

Because React components already pass data to one another using properties, there would be no need for them to use the sigil (although it would work if they did, it would just be redundant). Instead, it would primarily be used as an explicit instruction to pass data to a custom element using JavaScript properties.

*h/t to @developit of Preact for suggesting this approach :)*

### Pros

#### Non-breaking change that developers can opt-in to

All pre-existing React + custom element apps would continue to work exactly as they have. Developers could choose if they wanted to update their code to use the new sigil style.

#### Similar to how other libraries handle attributes/properties

Similar to Glimmer, both Angular and Vue use modifiers to differentiate between attributes and properties.

**Vue example:**

```html
<!-- Vue will serialize `foo` to an attribute string, and set `squid` using a JavaScript property -->
<custom-element :foo=""bar” :squid.prop=”ink”>
```

**Angular example:**

```html
<!-- Angular will serialize `foo` to an attribute string, and set `squid` using a JavaScript property -->
<custom-element [attr.foo]=""bar” [squid]=”ink”>
```

#### The system is explicit

Developers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.

### Cons

#### It’s new syntax

Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.

#### Not clear how server-side rendering would work

Should the sigil switch to using a similarly named attribute?

## Option 4: Add an attributes object

React could add additional syntax which lets authors explicitly pass data as attributes. If developers do not use this attributes object, then their data will be passed using JavaScript properties.

**Example:**

```jsx
const bar = 'baz';
const hello = 'World';
const width = '100%';
const ReactElement = <Test
  foo={bar} // uses JavaScript property
  attrs={{ hello, width }} // serialized to attributes
/>;
```

This idea was [originally proposed](https://gist.github.com/treshugart/2fb509a8828adf7fee5245bfa2a54ba7) by @treshugart, author of Skate.js, and is implemented in the [val](https://github.com/skatejs/val) library.

### Pros

#### The system is explicit

Developers can tell React exactly what they want instead of relying on a heuristic like the [properties-if-available](#option-2--properties-if-available) approach.

#### Extending syntax may also solve issues with event handling

*Note: This is outside the scope of this document but maybe worth mentioning :)*

Issue [#7901](https://github.com/facebook/react/issues/7901) requests that React bypass its synthetic event system when declarative event handlers are added to custom elements. Because custom element event names are arbitrary strings, it means they can be capitalized in any fashion. To bypass the synthetic event system today will also mean needing to come up with a heuristic for mapping event names from JSX to `addEventListener`.

```js
// should this listen for: 'foobar', 'FooBar', or 'fooBar'?
onFooBar={handleFooBar}
```

However, if the syntax is extended to allow attributes it could also be extended to allow events as well:

```js
const bar = 'baz';
const hello = 'World';
const SquidChanged = e => console.log('yo');
const ReactElement = <Test
  foo={bar}
  attrs={{ hello }}
  events={{ SquidChanged}} // addEventListener('SquidChanged', …)
/>;
```

In this model the variable name is used as the event name. No heuristic is needed.

### Cons

#### It’s new syntax

Developers need to be taught how to use it and it needs to be thoroughly tested to make sure it is backwards compatible.

#### It may be a breaking change

If any components already rely on properties named `attrs` or `events`, it could break them.

#### It may be a larger change than any of the previous proposals

For React 17 it may be easier to make an incremental change (like one of the previous proposals) and position this proposal as something to take under consideration for a later, bigger refactor.

## Option 5: An API for consuming custom elements

*This proposal was offered by @sophiebits and @gaearon from the React team*

React could create a new API for consuming custom elements that maps the element’s behavior with a configuration object.

**Pseudocode example:**

```js
const XFoo = ReactDOM.createCustomElementType({
  element: ‘x-foo’,
  ‘my-attr’: // something that tells React what to do with it
  someRichDataProp: // something that tells React what to do with it
});
```

The above code returns a proxy component, `XFoo` that knows how to pass data to a custom element depending on the configuration you provide. You would use this proxy component in your app instead of using the custom element directly.

**Example usage:**

```jsx
<XFoo someRichDataProp={...} />
```

### Pros

#### The system is explicit

Developers can tell React the exact behavior they want.

#### Non-breaking change

Developers can opt-in to using the object or continue using the current system.

#### Idiomatic to React

This change doesn’t require new JSX syntax, and feels more like other APIs in React. For example, PropTypes (even though it’s being moved into its own package) has a somewhat similar approach.

### Cons

#### Could be a lot of work for a complex component

Polymer’s [paper-input](https://www.webcomponents.org/element/PolymerElements/paper-input/elements/paper-input) element has 37 properties, so it would produce a very large config. If developers are using a lot of custom elements in their app, that may equal a lot of configs they need to write.

#### May bloat bundle size

Related to the above point, each custom element class now incurs the cost of its definition + its config object size.

*Note: I'm not 100% sure if this is true. Someone more familiar with the React build process could verify.*

#### Config needs to keep pace with the component

Every time the component does a minor version revision that adds a new property, the config will need to be updated as well. That’s not difficult, but it does add maintenance. Maybe if configs are generated from source this is less of a burden, but that may mean needing to create a new tool to generate configs for each web component library.


cc @sebmarkbage @gaearon @developit @treshugart @justinfagnani",,
11211,OPEN,Use the native `beforeinput` event if it's supported,Component: DOM; Type: Feature Request,2021-02-01 09:06:04 +0000 UTC,ianstormtaylor,,"**Do you want to request a *feature* or report a *bug*?**

Improvement.

**What is the current behavior?**

Right now, the synthetic `onBeforeInput` event is being created based on two other events:

- `textInput` when possible—which is in Webkit.
- `keypress` as a fallback.

But these days in Chrome, Safari and Opera the spec'd `beforeinput` event is available and actually fires. And when it does, it includes other [spec'd properties](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent) which can be extremely helpful:

- `inputType` tells you whether the event is inserting text, replacing text, inserting a line break, etc.
- `getTargetRanges()` tells you where the input is taking place in the DOM.

Right now this information isn't exposed, because even if the browser supports `beforeinput`, it's not being checked for.

**What is the expected behavior?**

Instead React should treat `textInput` as a slightly-preferred fallback for native `beforeinput` support, but add `beforeinput` as the true goal. So we'd end up with a fallback stack of:

- `beforeinput`
- `textInput`
- `keypress`

Which guarantees that the `nativeEvent` will always be the most spec'd and have the most relevant information associated with it.

---

The `beforeinput` event's extra properties are critical in `contenteditable` situations, when you want to prevent the default browser behavior from firing but perform the logic on an internal model instead. (I'm looking to do this for [Slate](https://github.com/ianstormtaylor/slate).) 

Without that extra information you have to fallback to hackier behavior—allowing the event to occur, trying to parse the DOM for what the change was, then re-rendering to remove it, etc. I want to avoid this on the more modern browsers, because it results in reduced performance.

---

There is another situation that this fixes, which is that spellcheck right now doesn't trigger React's `onBeforeInput` handler, even though modern browsers fire the `beforeinput` event, because it's not being listened for right now.


",,
11101,OPEN,Type Fiber by tag as disjoint union,Component: Reconciler; React Core Team; Type: Enhancement,2020-01-08 19:18:25 +0000 UTC,gaearon,,"@sebmarkbage tried this in https://github.com/facebook/react/pull/8545 but Flow couldn't handle it well.
Might be worth trying again someday.",,
11097,OPEN,Umbrella: React DOM Bugs,React Core Team; Type: Umbrella,2020-01-08 19:18:24 +0000 UTC,gaearon,,"Since I was going through all open issues yesterday and today, I also compiled a list of things that seem broken in ReactDOM, grouped by areas.

I don’t think all of these issues are equally important but I’d like to start a discussion around how we can start attacking them—both in shorter and in longer term. For example any potential fixes to the onChange event logic would need to take https://github.com/facebook/react/issues/9657 into account (or even inform it).

I think it would be a good topic for our next chat, cc @jquense @aweary @nhunzaker. Maybe we could also broadcast it this time? 😃  

## Autofill

* [ ] https://github.com/facebook/react/issues/1159 Provide a way to handle browser-autocompleted form values on controlled components
* [ ] https://github.com/facebook/react/issues/7328 IE 11 and Edge no longer prompt to remember password on controlled form
* [ ] https://github.com/facebook/react/issues/10468 DOM Fixture Form Coverage: Restored State and Auto-fill 

## Composition Events

### Issues

* [x] https://github.com/facebook/react/issues/10217 Incorrect data in compositionend event when typing Korean on IE11
* [ ] https://github.com/facebook/react/issues/3926 Change event fires too many times when inputing Chinese characters
* [ ] https://github.com/facebook/react/issues/8423 onChange does not work well with IE11 at Japanese IME. in React 15.4.0

### PRs

* [x] https://github.com/facebook/react/pull/7926 Try to generate a beforeInput event for buggy composition scenarios in IE
* [x] https://github.com/facebook/react/pull/8438 Handle composition events in ChangeEventPlugin

## Mouse Enter / Leave

* [ ] https://github.com/facebook/react/issues/4251 mouseenter fires on disabled inputs whereas mouseleave does not
* [ ] https://github.com/facebook/react/issues/10109 Mouseenter event not triggered when cursor moves from disabled button
* [ ] https://github.com/facebook/react/issues/7135 onMouseEnter propagation in double reactroot
* [ ] https://github.com/facebook/react/issues/6807 onMouseLeave not working as expected
* [ ] https://github.com/facebook/react/issues/13956 onMouseEnter doesn't fire under removed node

## Input, Checkbox, and Select

* [x] https://github.com/facebook/react/issues/4672 Change event does not fire in IE and Edge under certain circumstances
* [x] https://github.com/facebook/react/issues/4854 Pressing spacebar on a checked radio button only fires click in some browsers
* [x] https://github.com/facebook/react/issues/6368 Input type 'email' as controlled component does not control white spaces
* [ ] https://github.com/facebook/react/issues/6951 Changing state in onFocus and onChange for a select multiple element does not work in Firefox
* [x] https://github.com/facebook/react/issues/7024 select onChange not firing when using keyboard
* [ ] https://github.com/facebook/react/issues/7281 Input onChange not triggered every time in IE11 if e.preventDefault() used
* [ ] https://github.com/facebook/react/issues/7489 input element `setSelectionRange` after backspace does not work in IE10
* [x] https://github.com/facebook/react/issues/7630 Radio buttons are not correctly checked when using multiple lists of radio buttons
* [ ] https://github.com/facebook/react/issues/7769 input autoFocus causes focus to be emitted before ref
* [ ] https://github.com/facebook/react/issues/8514 Undo behavior in controlled textareas works differently from the default behaviour in chrome
* [ ] https://github.com/facebook/react/issues/8531 IE10 triggers onChange twice when replacing a text selection 
* [x] https://github.com/facebook/react/issues/8642 textarea + onFocus + stopPropagation = incorrect cursor rendering on Firefox
* [x] https://github.com/facebook/react/issues/8876 onBeforeInput fires after Edge updates the DOM
* [ ] https://github.com/facebook/react/issues/8938 Clear button on iOS date input does not return correct event value 
* [ ] https://github.com/facebook/react/issues/9023 event.preventDefault in click handler does not prevent onChange from being called 
* [x] https://github.com/facebook/react/issues/11010 Reset of select ignores defaultValue
",,
11073,OPEN,Performance enhancements in niche situations,Component: Reconciler; Type: Discussion,2017-11-03 15:25:10 +0000 UTC,dakom,,"I hit on a couple things that were a bit surprising to me... not sure what I'm really asking here, other than if these things are documented somewhere. Also kinda just going with the flow where this seems to be the place to raise generic ""issues"" even if they're not bugs :)

1. keys can make things slower

I had a bunch of items, and the only thing that changed was their x/y positions. adding a key with index made rendering slower. It's possible this is short-sighted though since it could very well change once that ""layer"" has more items changing above/below it, but I found it interesting.

2. rendering null makes a _huge_ difference

I had two test cases - a full graphics pipeline vs. an essentially empty POJO renderer. The difference in speed didn't matter about the data or graphics, but rather about what was returned in the components `render()`. For DOM this doesn't work of course - but for custom renderers, when it's known that a certain type of element will be an edge node - doing the side effects in render() (or some other lifecycle) and then returning `null` is _significantly_ faster than even a straight functional component that returns a simple element (which does the same side effects). This makes sense, since react then has less branches to consider (even if those branches point to nothing other than simple objects).




",,
10871,OPEN,Multiple onFocus events fired on single focus in Safari,Component: DOM; Type: Bug,2019-04-08 21:40:50 +0000 UTC,mbryla,,"I'd like to report a possible bug.

1. Brief description
OnFocus synthetic event is fired multiple times on single focus occurrence in Safari. Expected behaviour is for it to be fired only once per focus.

2. Live demo: https://codesandbox.io/s/101pnjxq27

3. Minimal steps to reproduce
- install create-react-app
`$ npm install -g create-react-app`

- create an example application
`$ create-react-app input-focus-test`
`$ cd input-focus-test`

- edit application file and add input with onFocus event handler
`$ vi src/App.js`

```javascript
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  handleOnFocus = evt => {
        console.log('handleOnFocus', evt);
  }

  render() {
    return (
      <div className=""App"">
        <header className=""App-header"">
          <img src={logo} className=""App-logo"" alt=""logo"" />
          <h1 className=""App-title"">Welcome to React</h1>
        </header>
        <p className=""App-intro"">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
        <p>
          Input
          <input onFocus={this.handleOnFocus}/>
        </p>
      </div>
    );
  }
}

export default App;
```

- start application
`$ npm run start`

- open up locahost:3000 in Safari
- click on the input field with developer’s console opened
- notice focus event fired multiple times

4. Additional info
This issue has been found in the following environment:
- macOS Sierra version 10.12.6 (also tested and found on High Sierra)
- Safari 10.1.2 (also tested and found in Safari 10.0 and Safari 11, seems to work on latest Safari mobile, Chrome and Firefox)
- React JS 15.5.4 (also tested and found in React 16)
- example steps to reproduce above generated with create-react-app version 1.4.1

Some of our observations that might come in handy:
- this issue seems to behave randomly to some extent
- event is usually fired twice when changing focus from input to input (so first click on input fires two events, consequential fire only one, but when changing focus to a different input field it fires twice again)
- additional interesting behavior happens with multiple input fields; for instance with input fields 1 and 2, first focus on input 1 generates two events onFocus with input 1, but then focus on input 2 sometimes generates three events: onFocus with input 1, then input 2, then input 1 again as targets.
",,
10713,OPEN,What should portals do when container has a child managed by React?,Component: DOM; Type: Discussion,2019-11-12 13:38:00 +0000 UTC,siddharthkp,,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
`ReactDOM.unstable_createPortal(<Component/>, target)` appends the rendered component in the target instead of replacing the contents of the target

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/ebsrpraL/).**

https://codesandbox.io/s/pjx8x9z2o7

**What is the expected behavior?**

It should replace the contents of the target with the new rendered component

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

react@16.0.0-rc.3
react-dom@16.0.0-rc.3


Note: I might have completely misunderstood how portals work. @gaearon [encouraged me](https://twitter.com/dan_abramov/status/908443416173924352) to open this issue 😄 ",,
10703,OPEN,A faster diff algorithm,Component: Reconciler; Type: Discussion,2020-12-29 04:00:26 +0000 UTC,thomas-jeepe,,"This is an invitation to discussion...

So, react is pretty freaking awesome and I used it quite a bit. One thing unfortunately where react is not as strong is in performance, which gave roots to Inferno and Preact. Although, this is generally a non-issue on desktop, while mobile might be a bottleneck.

I know many members of the team have been working on improving bundle size (I believe through rollup support in a talk I heard), asynchronous scheduling, etc. I am also aware that @trueadm (the creator of inferno) joined the React team and is working on improving it.

The point I want to bring up is this library [petit-dom](https://github.com/yelouafi/petit-dom). It uses, is a diff algorithm (links that explain it provided in the README) and it seems to score incredibly on [vdom performance tests](https://github.com/krausest/js-framework-benchmark). In fact, it is only beat by 2 technologies, vanillajs and surplusjs [per the benchmark snapshot](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html).

petit-dom beats inferno, preact, mithril, vue, angular, etc. Of course, it is not a proper js framework, however the point I am trying to make is that it is far faster and a major difference between the other frameworks seems to be its diff algorithm.

I realize this would mean a rewrite of a good portion of react-dom, which is why it is simply a discussion :D.

If this is unfeasible, or simply going after the wrong target/bottleneck, let me know as it is after all a discussion.",,
10657,OPEN,BFcache; SSR and form elements,Component: DOM; Type: Bug; Type: Feature Request,2020-01-09 21:52:46 +0000 UTC,oliviertassinari,,"**Do you want to request a *feature* or report a *bug*?**

 Bug

**What is the current behavior?**

Let's say you start filling a form input type text or a select element with `foo`. Then you click on a link and press the back button. The browser back-forward cache will kick in and change the initial value of the form elements. We will get our `foo` value back.
However, React doesn't account for it when the component is controlled.

I have tried reproducing the behavior with jsfiddle with [react@latest](https://jsfiddle.net/d4fovwxx/) and [react@next](https://jsfiddle.net/vm5vouqo/) with no luck as the BFcache doesn't kick in without SSR.

**What is the expected behavior?**

I expect React triggering a `onChange` event to replicate the actual form value.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

- React `@latest`.
- Chrome `@latest`

We have been [using the following hack](https://github.com/callemall/material-ui/blob/v1-beta/src/Input/Input.js#L349-#L356) on Material-UI:
```js
  componentDidMount() {
    // Fix SSR issue with the go back feature of the browsers.
    // Let's say you start filling the input with ""foo"", you change the page then after comes back.
    // The browser will reset the input value to ""foo"", but we also need to tell React about it.
    this.handleChange({
      target: this.input,
    });
  }
```

But it comes with issues: https://github.com/callemall/material-ui/pull/8110.
So instead, we tried simulating a change event [as suggested in StackOverflow](https://stackoverflow.com/questions/23892547/what-is-the-best-way-to-trigger-onchange-event-in-react-js) but it doesn't work anymore
```js
var event = new Event('input', { bubbles: true });
element.dispatchEvent(event);
```

So for now, we are going to disable the BFcache with `<form autoComplete=""off"">`.",,
10580,OPEN,Implement Silent Updates in the State Update Queue,React Core Team; Type: Feature Request,2020-01-08 19:18:23 +0000 UTC,sebmarkbage,,"[Reason React](https://github.com/reasonml/reason-react) has silent updates. Meaning it's a normal update in the state queue that can be reverted. The only difference is, it doesn't need a rerender by itself. If props have changed, it does rerender.

Unclear if we expose this to the existing ClassComponent API or make it a feature of new APIs.",,
10506,OPEN,Symbol Tagging for dangerouslySetInnerHTML to Help Prevent XSS,Component: DOM; React Core Team; Type: Discussion,2020-01-08 19:18:23 +0000 UTC,sebmarkbage,,"If you're spreading props from a user provided source we have a XSS. E.g.

```js
var data = JSON.parse(decodeURI(location.search.substr(1)));

function Foo(props) {
  return <div><div {...props} /><span>{props.content}</span></div>;
}

ReactDOM.render(<Foo {...data} />, container);
```

That's already true today because this URL is now an XSS hole:
```
?{""content"":""Hello"",""dangerouslySetInnerHTML"":{""__html"":""<a%20onclick=\""alert(%27p0wned%27)\"">Click%20me</a>""}}
```

This is very uncommon. There are many different ways to screw up getting user data. However doing that + also spreading is unusual. We decided in #3473 that React should add an extra layer of protection for these types of mistakes. This one is __much__ more uncommon than the one in #3473 though.

You should already have a pretty centralized way of sanitizing these objects so it seems to me that adding a Symbol to this object shouldn't be that big of a deal though.

Either:

```js
{ $$typeof:Symbol.for('react.rawhtml'), __html: myHTML }
```
or:
```js
{ [Symbol.for('react.rawhtml')]: myHTML }
```",,
10474,OPEN,The fake event trick for rethrowing errors in DEV fires unexpected global error handlers and makes testing harder,Component: DOM; Type: Discussion,2019-01-29 08:07:08 +0000 UTC,brandonbloom,,"I'm trying to make use of componentDidCatch in the React 16 beta. I already had a global window error handler which was working fine, but it unexpectedly catches errors that I would expect componentDidCatch to have handled. That is, component-local errors are being treated as window-global errors in dev builds.

The problem seems to stem from `invokeGuardedCallbackDev` in `ReactErrorUtils.js`. I think that this entire `__DEV__` block of code is problematic. The stated rational is:

```
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // ""Pause on exceptions"" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
```

This is misguided because it's not about pausing on exceptions, it's about ""pause on _uncaught_ exceptions."" However, `componentDidCatch` makes exceptions _caught_!

Rather than switching on prod vs dev and using try/catch in prod and window's error handler in dev, React should always use try/catch, but rethrow if you reach the root without hitting a componentDidCatch handler. This would preserve the correct ""pause on uncaught exceptions"" behavior without messing with global error handlers.",,
10441,OPEN,Cross-origin error passed to componentDidCatch incorrectly,Component: DOM; React Core Team; Type: Needs Investigation,2020-02-13 18:32:29 +0000 UTC,bvaughn,,"tl;dr React is passing ""A cross-origin error was thrown"" to `componentDidCatch` when there are no cross-origin scripts.

See [this discussion thread](https://github.com/facebook/react/pull/10353#issuecomment-321528685) and [this repro case](https://github.com/tessin/tessin-mini).

I was able to confirm the behavior. A quick look at `onError` showed a null `event.error`.",,
10389,OPEN,<video /> attribute needed but not guaranteed by React,Component: DOM; HTML; Type: Feature Request,2021-04-05 18:02:20 +0000 UTC,elrumordelaluz,,"As @gaearon [mentioned](https://twitter.com/dan_abramov/status/893511715463340033), React does not guarantee an *attribute* will be set, so probably this is not a bug.

If I understand well, react will ensure the property is set anyway. 

**Current behaviour**
React renders the html `<video />` element without the attribute `muted` when explicitly passed.

**Demo time**
In [this pen](https://codepen.io/elrumordelaluz/pen/ba4b5294cec7ea455c66e9b9d0a6c889?editors=0010) I made a simple example setting `muted` to the element and obtaining the result below:
![pen-screen-shot](https://user-images.githubusercontent.com/784056/28986491-7b2dd45e-7967-11e7-9f63-b4db88db9989.png)

Actually the property is set well, since the [original medial file](http://clips.vorwaerts-gmbh.de/VfE_html5.mp4) has an audio track and in the pen result is muted.

**The point**
I think is most a _specific need_ than the _expected behaviour_.
From the functionality POV, it is absolutely ok, my _Component_ renders a `<video />` muted as requested and so on.

But there are _browsers_ and _policies_, more specifically related to this issue, Webkit and the [New <video> Policies for iOS](https://webkit.org/blog/6784/new-video-policies-for-ios/) updated one year ago, with some interesting changes for the `<video />` element.
The part interested is
> `<video muted>` elements will also be allowed to autoplay without a user gesture.

So, the _specific need_ is to have the _explicit_ `attribute` to tell the browser that this video could be `autoPlay`ed.

There's a similar [issue](https://github.com/facebook/react/issues/6544)",,
10382,OPEN,Too much unnecessary updates when a child element is moved to the front,Component: Reconciler; Type: Discussion,2018-03-01 13:28:14 +0000 UTC,yelouafi,,"**Do you want to request a *feature* or report a *bug*?**

Not sure if it's a bug or an 'accepted' behavior. But this can affect performance in some situations or even 'break the expectations' in others (e.g. animating moved elements [i.e. simple moves]) 

**What is the current behavior?**

When a child element moves from the end of the list to the front  React actually moves all the other elements after the moved/last element instead of simply inserting the moved element at the front of the list.

This also can be stated more generally for an element or a block of elements moving backward with a significant shift.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/84v837e9/).**

Here is a [demo](https://codesandbox.io/s/wjZkrGVzJ) that shows the DOM operations performed on DOM nodes (moves & insertions) during reconciliation. To reproduce the issue

- type '0123456789x' in the input field then click `Patch!`

- now type 'x0123456789' (move the last 'x' to the front) then click `Patch!` again

Here's the output

![image](https://user-images.githubusercontent.com/5453835/28969007-affc2dae-791a-11e7-951a-37856bc53f00.png)

Instead of moving the 'x' to the front. React actually moves all the other elements after the 'x'

*Note: the demo uses MutationObserver api to find out the operations. But you can also verify this behavior directly by commenting out the code that activates the dom observer (in componentDidMount) and watch the dom operations manually in the devtools element inspector*

**What is the expected behavior?**

React should perform the minimal number of operations. I know that the 'minimum' will vary for each situation and not trivial to infer for the general case. But for some common cases like this one it should be feasible.

For info this use case is handled in most of the other virtual dom libs like preact, snabbdom. Inferno is a remarkable case as it will always infer the minimum number of operations (it uses an algorithm to find the [longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) on an array containing the indexes of the old elements).

I found this behavior while working on a demo to find out how vdom libs rearrange nodes during children reconciliation. For example here is the same output for other libs ([demo](https://codesandbox.io/s/BkLpXYQn))

![image](https://user-images.githubusercontent.com/5453835/28969902-567219c0-791e-11e7-9f3d-29bf988cdab1.png)

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

The demo uses the 0.16 version. But I tried with 0.15 and it has the same behavior",,
10143,OPEN,Remove unstable_renderIntoContainer,Component: Reconciler; React Core Team; Type: Breaking Change; Type: Discussion,2020-01-08 19:18:58 +0000 UTC,gaearon,,My hunch is we want to remove it before 16 because `unstable_createPortal` accomplishes the same thing. I remember `unstable_renderIntoContainer` adding a bunch of complexity that would be nice to get rid of before committing to support it for another release cycle.,,
10109,OPEN,Mouseenter event not triggered when cursor moves from disabled button,Component: DOM; Type: Bug,2020-12-03 02:03:14 +0000 UTC,stepancar,,"BUG.

Mouseenter event not triggered when cursor moves from disabled button
see [example](https://alfa-laboratory.github.io/arui-feather/styleguide/#playground/code=%3Cdiv%3E%0A%20%0A%20%20%20%20%3Cdiv%20className='row'%3E%0A%20%20%20%20%20%20%20%20Hover%20on%20%20right%20button%20and%20then%20move%20cursor%20to%20left%20button%0A%20%20%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cbutton%20onMouseEnter=%7B()=%3E%7Balert('Hey!');%7D%7D%20%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Not%20Disabled%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C/button%3E%0A%20%20%20%20%20%20%20%20%3C/div%3E%0A%20%20%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cbutton%20disabled=%7B%20true%20%7D%3EDisabled%3C/button%3E%0A%20%20%20%20%20%20%20%20%3C/div%3E%0A%20%20%20%20%3C/div%3E%0A%0A%20%20%20%20%3Cdiv%20className='row'%3E%0A%20%20%20%20%20%20%20%20Hover%20on%20%20right%20button%20and%20then%20move%20cursor%20to%20left%20button%0A%20%20%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cbutton%20onMouseEnter=%7B()=%3E%7Balert('Hey!');%7D%7D%20%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Not%20Disabled%0A%20%20%20%20%20%20%20%20%20%20%20%20%3C/button%3E%0A%20%20%20%20%20%20%20%20%3C/div%3E%0A%20%20%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cbutton%3ENot%20Disabled%3C/button%3E%0A%20%20%20%20%20%20%20%20%3C/div%3E%0A%20%20%20%20%3C/div%3E%0A%20%0A%3C/div%3E)


**What is the expected behavior?**
Should trigger Mouseenter event

React 15.5.3
Latest Chrome
MacOs 10.12.5",,
10021,OPEN,"Feature request: Add a ""module"" entry in package.json to export ES2015 version of React",Component: Build Infrastructure; Type: Feature Request,2021-02-23 05:28:39 +0000 UTC,misterfresh,,"**Do you want to request a *feature* or report a *bug*?**
Request a feature

**What is the current behavior?**
React ecosystem was promoting ES6 classes and modules since 2014 and many packages like react-router, redux and so on, have an ""es"" folder in the npm package with source code in ES2015 modules. Unless I am missing something, it is strange that React itself does not offer that option.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/84v837e9/).**
Install react and try to import it in a browser with native modules enabled.

**What is the expected behavior?**
Have an ""es"" folder in the npm package with ES2015 modules source code, like most React ecosystem projects do. Allow to import react from ES2015 native modules to make developer workflow more simple.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
All versions",,
9999,OPEN,False positive getDefaultProps warning when mixing development and production versions,Component: Core Utilities; Difficulty: medium; Type: Bug; good first issue,2020-02-03 08:00:19 +0000 UTC,mondwan,,"As migrating from 15.4 to 15.5, I am rewrite original react components with `create-react-class`. 

However, there is a warning.

```
react-15.5.4.js?bust=1497843639843:3287 Warning: getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.
```

 As I am really transferring from a **classic** `React.createClass` definition, I would like to ask is this warning appropriate? Or, this is a depreciation sames as the level of migrating to `create-react-class`?

Ooops, I get ticket #9999  :D",,
9866,OPEN,Add More Cases to Server Rendering Fixture,Component: Server Rendering; Difficulty: medium; React Core Team,2020-01-08 19:18:57 +0000 UTC,sebmarkbage,,"Server rendering has a lot of quirks that are easy to break. We have a fixture set up for it in [/fixtures/ssr](https://github.com/facebook/react/tree/master/fixtures/ssr).

This could be expanded to have more stuff in it. A few things we should have in the fixture and test for:

- `<input />`, `<select />`, `<option />` and `<textarea />` controlled and uncontrolled. All types of inputs, including dates, numbers etc.
- Where children is a single string/number, children array with multiple string/numbers, children with interleaved nodes and string/numbers.
- Event handlers on hydrated nodes that does something useful when clicked. Reused event handlers on multiple different nodes etc.
- onLoad event handlers.
- Special properties that don't map directly to attribute names like `className`.
- `<div hidden>...</div>` subtrees. (Subtrees with the ""hidden"" attribute set on it. Tests deprioritization.)

We probably need some on-screen options to turn on/off these things in the test suite to test under these conditions:

- Server and Client differences. Turn on a flag that makes the server and client differ in minor ways.
- Async hydration. Use Fiber's async features to hydrate the tree.
- Defer hydration for some time. This is useful to test slow loading conditions where the user may have changed state of form controls before hydration. When combined with async, it can make the async rendering artificially slow. It should reveal issues such as a patching or event handlers being attached too early (before commit phase).

It's ok to start small. You don't have to do it all at once.",,
9832,OPEN,Error when `__source` is provided to production build,Component: Developer Tools; React Core Team; Type: Enhancement,2020-01-08 19:18:57 +0000 UTC,sebmarkbage,,"Currently if the `__source` transform is enabled together with the production build there are no indicators of a poorly performant configuration. https://facebook.github.io/react/ even has it.

We already check for the [existence of a `__source` field](https://github.com/facebook/react/blob/master/src/isomorphic/classic/element/ReactElement.js#L203). So we can just reuse the same check to issue something in prod mode if it exists.

The problem is that we don't have any warning module in prod and it is unclear if it would get attention or even considered to spammy in prod.

We could throw but that might be too extreme since a misconfiguration would kill the site.

We could also use this to set a flag on the `__REACT_DEVTOOLS_GLOBAL_HOOK__` object. The icon in the devtools extension could use this to indicate a misconfigured build.",,
9821,OPEN,Children forEach filters functions,Type: Discussion; Type: Feature Request,2019-03-26 06:01:47 +0000 UTC,neytema,,"**React v15.5.4**

Unexpected behaviour of `React.Children.forEach` – silently filters functions.

**Current behavior:**

```jsx
const element = (
  <div>
    {() => {}}
    {() => {}}
  </div>
);
console.log(React.Children.toArray(element.props.children))
// Output: []
```

**Expected behavior:**

Children.forEach should throw *Invariant* error then *function* type child is met.

or

Children.forEach shouldn't filter *function* type children.
",,
9657,OPEN,[RFC] onChange -> onInput; and don't polyfill onInput for uncontrolled components,Component: DOM; React Core Team; Type: Breaking Change; Type: Discussion,2020-06-15 08:02:30 +0000 UTC,sebmarkbage,,"`onChange` is a nicer name for what `onInput` does and the fact that it has propagated up to other high-level components as the default name is much nicer than `onInput` as a high level event name.

Generally it has been helpful for the many new-comers to React that don't know the DOM well (which is a lot more than the inverse). However, that doesn't change the fact that it can be confusing for people that are familiar.

Unfortunately, changing it now would cause confusion for everyone that already knows React.

The reason I'd like to change it now is because I'd like to get away from polyfilling it for __uncontrolled__ components. This use case is filled with all kinds of imperative code which leads to edge cases. E.g. reading/setting `e.target.value` or reading/setting `ref.value`.

When you use __controlled__ components you shouldn't need to touch them imperatively and therefore won't hit the edge cases. Ideally we should get away from reading from `e.target.value` and instead just pass the `value` directly to the event handler.

## Proposal:

__Controlled Components__

- `onInput`: Polyfilled and works like `onChange` does today. It is allowed to over-fire many events even if nothing changed. May have special Fiber rules regarding synchronous flushing. _Optional: Pass `value` as second arg._
- `onChange`: Works like `onInput` for one version but warns about being deprecated and suggests switching to `onInput`. In next version it works like the browser but still warns and tells you to use `onInput` forever.

_Optional: Add a getter/setter on DOM `.value` in development mode and warn if this is used directly._

__Uncontrolled Components__

- `onInput`: Not polyfilled. Works however the browser works. Warns about browser differences if you don't also specify `onClick`, `onKeyDown` and/or `onKeyUp`. The warnings suggests implementing those listeners to cover more edge cases, or switch to a controlled component.
- `onChange`: Not polyfilled. Works however the browser works.
",,
9475,OPEN,Seb's Deprecation Wishlist Umbrella,React Core Team; Type: Umbrella,2020-01-08 19:18:56 +0000 UTC,sebmarkbage,,"I have a list of breaking changes that I'd like to see because I think they're not strictly necessary features, can often be replaced by other APIs and their very existence makes implementations more constrained, even when they're not used.

This list is not meant to be anything we're planning on actively doing. It's just a drop point where I can add things as I think of them.

- [ ] Shallow freeze the `defaultProps` object and make the `defaultProps` property non-configurable/non-writable after the first `createElement` or `createFactory` call. (Enables inlining/resolution of defaults statically.)

- [ ] Treat `key`/`ref` as a separate namespace in JSX. Meaning that objects that are spread onto JSX don't transfer `key` and `ref`. Enables inlining of props object even if spread type is unknown. E.g.

```js
let x = <Foo {...{key:'bar'}} />;
x.key; // null
x.props.key; // 'bar'
let y = <Foo key=""bar"" />;
y.key; // 'bar'
y.props.key; // undefined
```

- [ ] Drop support for string refs.

- [ ] Drop support for `ReactDOM.findDOMNode(...)` and `ReactNative.findNodeHandle(...)`. These are slower in Fiber and requires a tree to be materialized/stateful/introspectable at arbitrary times/threads even before we know if this will ever get called. Less automatic cleanup. Could possibly have an alternative API that works more like refs. However, just ref forwarding probably solves all legit use cases better.

- [ ] Make `.type` and `.props` private on `ReactElement`s so that they can't be introspected (just like bound functions/closures). This makes optimizations like automatic making components asynchronous/synchronous safe or inlining components several levels deep.",,
9402,OPEN,A number input will always have left pad 0 though parseFloat value in onChange,Component: DOM; Type: Bug,2020-10-07 18:38:38 +0000 UTC,HaydnChen,,"**Do you want to request a *feature* or report a *bug*?**
bug

**What is the current behavior?**
I have a number input with defalut value 0 and in onChange function I'll parse value to float to avoid invalid input, but I'll always get left pad 0 on input UI. But in previouse version, my code works.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/84v837e9/).**
<input type=""number"" value={this.state.value} onChange={e=>this.setState({value: parseFloat(e.target.value)? parseFloat(e.target.value) : 0})}

**What is the expected behavior?**
Should not have left pad 0.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
react 15.5.3, all browser / all OS. It works in 15.4.2",,
9301,OPEN,Define specific browser support guidelines,Component: DOM; Type: Discussion,2017-10-06 12:30:31 +0000 UTC,aweary,,"As it stands the only real solid guideline we have for browser support is that we support IE9+. But there are so many other outdated browser versions that are unreasonable to support or worry about.

It would be useful if we had more specific guidelines on what browsers we should target. Does Safari on iOS 3 matter? FireFox 4? You get the idea.

If we had a well-documented range of browser version that we *know* should work it would make it a lot easier to run through our DOM fixtures in BrowserStack and know we're safe.

Maybe the internal core team can work internally with analytics to see what browsers Facebook needs to support and work forward from there?

cc @gaearon @nhunzaker ",,
9230,OPEN,Boolean attributes on Web Components,Component: DOM; Type: Discussion,2019-12-07 23:48:31 +0000 UTC,nickdima,,"When setting boolean attributes on Web Components
`<x-search somebool name={this.props.name} />`
they get rendered as attribute/value pairs instead
`<x-search somebool=""true"" name={this.props.name}>`

This causes problems with some AMP components, for eg. `<amp-iframe />` which has a `resizable` attribute that gets rendered as `resizable=""true""`. This results in non valid AMP content and developers crying with blood tears on their keyboards :)
> The attribute 'resizable' in tag 'amp-iframe' is set to the invalid value 'true'. (see https://www.ampproject.org/docs/reference/components/amp-iframe)

Is there any reason for the current behaviour? Will changing this break something else?",,
9223,OPEN,Compiler Optimization Umbrella,Component: Optimizing Compiler; React Core Team; Type: Umbrella,2020-01-08 19:19:29 +0000 UTC,sebmarkbage,,"Spinoff from https://github.com/reactjs/react-future/issues/50

I wanted to create an umbrella task for when we start working on compiler level optimizations. We've had [a tag](https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22Component%3A+Optimizing+Compiler%22) open for a while but these are fairly primitive optimizations. We want to be able to go further.

I don't think we'll start this project immediately but soon after the Fiber stuff is in place.

__Compiler Infra__

- [ ] Base-line cross-module full JavaScript AOT compiler.
- [ ] Compiler infra structure that fits well into existing tooling at FB, Webpack, Rollup based ecosysem etc. Support parallelism and incremental builds.
- [ ] Solve things like what the npm ecosystem should do. Compile before publishing or after? Probably after.

__Optimizations__

- [ ] Enable multiple levels of host instances / DOM elements to be managed by a single Fiber. I think this is probably a key requirement for many optimizations. I'm not sure if that Fiber's children will have a single placement point (the parent that they get inserted into) or if it could have multiple insertion points. If it manually does the insertion of its children, then the later would work.
- [ ] Optimizing pure host/DOM elements (""string"" components). Can be reasoned about at the core compiler level.
- [ ] Inlining pure functional components so that now the result can be reasoned about as a flat component.
- [ ] Basic constant folding for static configuration.
- [ ] Optimizing across component boundaries without inlining.
- [ ] Optimizing stateful functional components.

__Runtime Optimizations__

- [ ] Dead-code elimination of library code that isn't needed by a particular application. Such as certain events, controlled components or complex attributes.

__Stretch Goals__

- [ ] Computing delta updates after code changes and lets Service Workers update based on that.

More to come...",,
9142,OPEN,No blur event fired when button is disabled/removed,Component: DOM; Type: Bug,2020-10-07 18:38:44 +0000 UTC,OliverJAsh,,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
When a focussed button becomes disabled, React does not dispatch a blur event.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**
1. Attach a blur event to a button
2. Focus the button
3. Make the button disabled or remove it from the DOM

**What is the expected behavior?**
A blur event will be dispatched.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
15.1.0, not sure if it worked in previous versions.

Isolated test case: http://jsbin.com/fuvite/1/edit?html,css,js,output",,
9128,OPEN,Switch to using createFactory in compiler steps,Component: Optimizing Compiler; React Core Team,2021-01-10 19:30:34 +0000 UTC,sebmarkbage,,"```js
var Foo = require('Foo');
function Bar() {
  return <Foo x={1}>Hi</Foo>;
}
```

Originally we intended to compile JSX to this format:

```js
var Foo = require('Foo');
var Foo_ = React.createFactory(Foo);
function Bar() {
  return Foo_({ x: 1, children: ""Hi"" });
}
```

That allows us to generate a factory that can be more optimized and resolves `defaultProps`.

There are some problems with generating an optimized factory in many cases because it can slow down start up. However, if you have an optimizing compiler that can resolve that, we can turn that on in those cases.

Another thing we can do is that if the function is a simple functional component then we can just return the functional component itself. So that it becomes just a straight through function call. At least if the element doesn't have a key. (Slight change in semantics but mostly not.)

An optimizing compiler or VM (that is aware of the type of ""Foo"" which not known to the Babel transform) can then infer that this function is just a function call and can then proceed to actually inline it.

For heavy functions it would be bad to do this though since it can expand the time a render is executed and work against the time slicing mechanism of Fiber.

Therefore, we might want to use a heuristic to determine if a functional component gets to be ""inlined"" or not. E.g. function length or something.

A good data point to use in a heuristic is whether the component is part of a loop or a closure (such as being part of a map);

```js
var Foo = require('Foo');
function Bar({ data }) {
  var children = [];
  for (var i = 0; i < data.length; i++) {
    children.push(<Baz>{data[i]}</Baz>);
  }
  return <Foo x={1}>{children}</Foo>;
}
```

or

```js
var Foo = require('Foo');
function Bar({ data }) {
  return <Foo x={1}>{data.map(d => <Baz>{d}</Baz>)}</Foo>;
}
```

We could change the transform to treat these special and flag them as part of a hot path by calling a special createFactory:

```js
var Foo = require('Foo');
var Baz = require('Baz');
var Foo_ = React.createFactory(Foo);
var Baz_ = React.createFactoryHot(Baz);
function Bar({ data }) {
  return Foo_({ x: 1, children: data.map(d => Baz_({ children: d })) });
}
```

The neat part of this model is that the transform can be pretty simple and readable.

The optimization itself is in createFactory and createFactoryHot.

It also doesn't have to reason about cross-module transforms. That's all taken care of by the optimizing compiler or VM.",,
9100,OPEN,Pasting text in text box does not fire change event on IE11.,Browser: IE; Component: DOM; Type: Bug,2018-08-18 01:50:55 +0000 UTC,mashimonator,,"I found a bug in IE11.
React version is 15.4.0.

Pasting text in text box does not fire change event on IE11.

https://jsfiddle.net/mashimonator/uh699v8d/6/",,
9046,OPEN,Disabling or destroying event's target stops further event propagation.,Component: DOM; Type: Discussion,2017-10-04 18:08:51 +0000 UTC,cristian-eriomenco,,"Disabling a submit button within a form on `onClick`, stops the event propagation to the forms `onSubmit` handler.

The fiddle:
 ```
import React from ""react"";

class SomeForm extends React.Component {
    constructor(props){
       super(props)
       this.state = {
          disabled:false
       }
    }
    handleClick() {
        this.setState({
          disabled:true
        });
        console.log(""Clicked button"");
    }
    handleSubmit(e){
      alert(""Submitted the form"")
    }
    render() {
        let opts = {};
        opts.disabled = this.state.disabled; // disabling the button stops the event propagation
        
        return (<form onSubmit={this.handleSubmit.bind(this)}>
              <button {...opts} 
                type=""submit"" 
                onClick={this.handleClick.bind(this)}>
                Continue
              </button>
         </form>)
    }
}

ReactDOM.render(<SomeForm />, document.getElementById('a'));
```
[JsBin with the live example](http://jsbin.com/kidabifono/1/edit?js,output)

Expected behavior: The event gets propagated unless explicitly swallowed via `e.preventDefault() && e.stopPropagation()`

**React version:** 15.4.2
**Browser:** Chrome 56.0.2924.87 x64

Unfortunately I cannot tell if this happens with older versions.",,
9023,OPEN,event.preventDefault in click handler does not prevent onChange from being called,Component: DOM; Type: Bug,2020-11-30 10:13:00 +0000 UTC,aweary,,"**Do you want to request a *feature* or report a *bug*?**

Bug!

**What is the current behavior?**

When rendering an `input` element of type `checkbox` with an `onClick` and `onChange` handler, `onChange` is still called even though `event.preventDefault()` is called in the `onClick` handler.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem via https://jsfiddle.net or similar (template: https://jsfiddle.net/reactjs/69z2wepo/).**

http://jsfiddle.net/rf3w7apc/

**What is the expected behavior?**

Calling `event.preventDefault` in the `onClick` handler should prevent the default action  from occurring (or undo its effect), which is to update the value of the `input` element. This should stop any `change` event listener from being invoked. See https://jsfiddle.net/L1eskzsq/ for expected behavior

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Tested using a build from master, macOS 10.12.2, verified in:

* Chrome  56.0.2924.87 (64-bit)
* Firefox 51.0.1 (64-bit)

Safari 10.0.2 calls the `change` event listener in both cases.
",,
8938,OPEN,Clear button on iOS date input does not return correct event value,Component: DOM; Type: Bug,2019-08-28 19:02:25 +0000 UTC,ro-savage,,"**Bug**
For iOS only.
When pressing `clear` on a date input, the `onChange` event is fired but` event.target.value` is showing the original value rather than an empty string.

**What is the current behavior?**
On Chrome and Android, when the clear button is pressed the onChange event has a value of `''`.
On iOS when the clear button is pressed the onChange event has a value of `previousValue`.

**Demo**
https://output.jsbin.com/zojuteloto/5/
Try on Chrome/Android. Then on iOS.

**What is the expected behavior?**
Value should be returned an an empty string.

**Versions**
Affects React 15+ & iOS 10. Unsure of previous versions.
",,
8733,OPEN,[Fiber] Should we clear an error boundary's update queue whenever it captures an error?,Component: Core Utilities; React Core Team; Type: Discussion,2020-01-08 19:19:27 +0000 UTC,acdlite,,Seems like we should at least do this on the root.,,
8531,OPEN,IE10 triggers onChange twice when replacing a text selection,Browser: IE; Component: DOM; Type: Bug,2020-12-16 20:02:50 +0000 UTC,jfschwarz,,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
- Type text ""123"" in an input
- Select the whole text
- Type the `A` key

When hitting the `A` key, `onChange` is triggered twice. One time `event.target.value` is `""""`. The second time it's `""A""`.

This only happens in IE10. IE9 and IE11 both behave correctly.

**Demo fiddle**

https://jsfiddle.net/69z2wepo/64637/

![ie10onchange](https://cloud.githubusercontent.com/assets/524089/21014764/8883c6fa-bd5f-11e6-8e9c-65a957bbca7e.gif)

**What is the expected behavior?**
When hitting the `A` key, `onChange` is triggered only one time. `event.target.value` should be `""A""`.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

- React 15.4.1 (possibly also older versions)
- IE10 / Windows 7
",,
8514,OPEN,Undo behavior in controlled textareas works differently from the default behaviour in chrome,Component: DOM; Type: Bug,2020-09-30 02:44:24 +0000 UTC,fabsor,,"If you control a textarea with **value**, it behaves differently when you use undo. When the textarea is controlled, you can only undo one letter at a time. This is not how undo works normally with an uncontrolled component. Undo seems to work as expected with input components.

With a controlled textarea component, you can only undo one letter at a time. The normal undo works with some kind of algorithm for how much is going to be un- or redone.

You can try the difference in this codepen:

https://codepen.io/fabsor/pen/LbmBOv

Tested with React 15.3.1 and Chrome 54 and Chrome Canary. Works as expected in Firefox and Safari. It might be a Chrome bug?",,
8423,OPEN,onChange does not work well with IE11 at Japanese IME. in React 15.4.0,Browser: IE; Component: DOM; Type: Bug,2019-10-04 01:40:05 +0000 UTC,mashimonator,,"![untitled2](https://cloud.githubusercontent.com/assets/2460942/20637058/b744111c-b3bd-11e6-97ba-5529639730f0.gif)

I'm trying to make a simple text box component with a suggestion feature.
However, in IE 11, there is an event that the Japanese IME conversion arbitrarily decides (I did not press the Enter key ...).
I examined it a little by myself, but this seems to have occurred only in IE 11, it seems that it has not occurred in other browsers such as Chrome and old Ver such as IE 10.
React version is 15.4.0.
There seemed to be similar issues in the past（https://github.com/facebook/react/issues/7027）, but that bug has already been fixed.
Is this another bug? Or maybe I do not like how to make it?

```
/**
 * SuggestTextBox
 */
const SuggestTextBox = React.createClass({
	timer: null,
	getInitialState: function(){
		return {
			focus       : false,
			suggestList : [],
			value: ''
		};
	},
	/**
	 * getSuggestListFromApi
	 */
	getSuggestListFromApi: function(value){
		// Request API and get response
		Common.apiCall({
			type     : 'GET',
			url      : '/api/hoge',
			dataType : 'json',
			data     : {
				Keyword: value
			},
			cache    : false,
			callback : function(result){
				// set the state
				this.setState({
					suggestList: result.data.list,
					activeItem: null
				});
			}.bind(this)
		});
	},
	/**
	 * handleTextboxChange
	 */
	handleTextboxChange: function(e){
		this.setState({
			value: e.target.value,
			suggestList: []
		});
		if (this.state.focus) {
			if (e.target.value) {
				if (this.timer) {
					window.clearTimeout(this.timer);
				}
				this.timer = window.setTimeout(function(){
					this.getSuggestListFromApi(e.target.value);
				}.bind(this), 300);
			}
		}
	},
	/**
	 * handleFocus
	 */
	handleFocus: function(e){
		this.setState({
			focus: true
		});
	},
	/**
	 * getSuggestNodes
	 */
	getSuggestNode: function(){
		var listNode = this.state.suggestList.map(function(item, idx){
			return (
				<li
				  key={'fuga_suggestItem_'+item.id}
				  data-id={item.id}
				  data-name='fuga'
				  data-value={item.name}>
					{item.name}
				</li>
			);
		}.bind(this));
		if (listNode.length > 0) {
			return (
				<ul className=""suggestList"">
					{listNode}
				</ul>
			);
		} else {
			return null;
		}
	},
	render: function(){
		let suggestNode = this.getSuggestNode();
		return (
			<label>
				<input
				  type=""text""
				  name=""fuga""
				  value={this.state.value}
				  onChange={this.handleTextboxChange}
				  onFocus={this.handleFocus} />
				{suggestNode}
			</label>
		);
	}
});
```
https://jsfiddle.net/mashimonator/u3b0f1xj/1/",,
8012,OPEN,[Fiber] Formalize States,Component: Reconciler; React Core Team; Type: Enhancement,2020-01-08 19:19:27 +0000 UTC,sebmarkbage,,"In Fiber there are a number of states that a component can be in. However, it is not formalized in the code right now. Instead, the state is inferred. This leads to hard to follow code. Instead we can organize the code in terms of explicit states - which is what the original prototype did.

Before componentDidMount (i.e. `current === null`):
- Never begun.
- Have been begun before but never completed.
- Have been completed before, not committed, but hasn't begun this time around.
- Begun but not yet completed.
- Completed but not yet committed.

After componentDidMount (i.e. `current !== null`):
- Haven't begun an update yet
- Have been begun before but never completed.
- An update have been completed before, not committed, but hasn't begun this update.
- Begun update but not yet completed.
- Completed update but not yet committed.

The ""children"" set of a component also have some states:
- Never reconciled.
- The current set last committed.
- A previously reconciled set that hasn't committed yet.
",,
7901,OPEN,Bypass synthetic event system for Web Component events,Type: Discussion; Type: Feature Request,2020-01-16 19:02:58 +0000 UTC,staltz,,"To use a Web Component in React, you must directly attach an event listener to the React ref for that WC. We could change the implementation so that when React detects a custom element (tag names with dashes, like `my-component`), it will bypass the synthetic event system (and the whitelist) and just attach the event listener on the element itself.

Why bypass the synthetic event system? Because _anyway_ we already need to bypass it manually when using a Web Component. I'm not so familiar with the React codebase, but this naive approach seems to work. Whoever uses Web Components in React can be responsible for whatever downsides that would cause, maybe in performance, I don't know. They are already having those (supposed) downsides, this issue is just about the convenience of WC usage inside React.

I was about to send a PR for this, but thought of opening an issue. I looked through the issues and didn't see any existing one related to the handling of WC events.

**What is the current behavior?**

A WC custom event (e.g. `flipend`) must be handled by attaching the event listener directly to the element in componentDidMount using a ref.

http://jsbin.com/yutocopasu/1/edit?js,output

React v15.1.0

``` js
class HelloMessage extends React.Component {
  handleHelloClick() {
    this.refs['foo'].toggle();
  }

  handleFlipend(ev) {
    console.log('Handle flip end');
  }

  componentDidMount() {
    this.refs['foo'].addEventListener('flipend', ev =>
      this.handleFlipend(ev);
    );
  }

  render() {
    return (
      <div>
        <div onClick={ev => this.handleHelloClick()}>
          Hello {this.props.name}, click me!
        </div>
        <brick-flipbox class=""demo"" ref=""foo"">
          <div>front</div>
          <div>back</div>
        </brick-flipbox>
      </div>
    );
  }
}
```

**What is the expected behavior?**

A WC custom event can be handled with `onMyEvent={ev => this.handleMyEvent(ev)}` on the ReactElement corresponding to the WC.

``` js
class HelloMessage extends React.Component {
  handleHelloClick() {
    this.refs['foo'].toggle();
  }

  handleFlipend(ev) {
    console.log('Handle flip end');
  }

  render() {
    return (
      <div>
        <div onClick={ev => this.handleHelloClick()}>
          Hello {this.props.name}, click me!
        </div>
        <brick-flipbox onFlipend={ev => this.handleFlipend(ev)} class=""demo"" ref=""foo"">
          <div>front</div>
          <div>back</div>
        </brick-flipbox>
      </div>
    );
  }
}
```

PS: this snippet above still has the `ref`, but for unrelated reasons. Ideally we wouldn't need refs for handling events of WCs.
",,
7769,OPEN,input autoFocus causes focus to be emitted before ref,Component: DOM; Difficulty: challenging; Type: Bug,2019-06-18 12:33:12 +0000 UTC,syranide,,"https://jsfiddle.net/nnwd2c34/

Can reproduce on Chrome, but not in IE11.
",,
7711,OPEN,[bug] click not disabled on <fieldset disabled><button onClick={() => alert('clicked')}><span>click me</span></button></fieldset>,Component: DOM; Type: Bug,2021-01-18 21:46:30 +0000 UTC,brillout,,"**bug**

In the following

``` jsx
const Component = () =>
        <fieldset disabled>
            <button
              onClick={() => alert('clicked by React')}
            >click me here and <span style={{color: 'red'}}>here</span></button>
        </fieldset>;
```

clicking on `click me here and` will not trigger `alert('clicked by React')` whereas clicking on the red `here` will trigger `alert('clicked by React')`.

Demo: https://jsfiddle.net/ropbvL3y/

Thanks for React, it's an incredibly well designed tool.
",,
7489,OPEN,input element `setSelectionRange` after backspace does not work in IE10,Browser: IE; Component: DOM; Type: Bug; Type: Needs Investigation,2018-08-17 20:16:38 +0000 UTC,msafi,,"**Do you want to request a _feature_ or report a _bug_?**

Report a bug.

**What is the current behavior?**
1. Open [this demo](https://jsfiddle.net/c49bj73v/6/) in IE10
2. Type any five character text
3. Caret should be at position `2` (i.e. `12|345`) because it is forced there after every change with `setSelectionRange`
4. Use arrow or mouse to move caret to position `5` (i.e. `12345|`).
5. Press backspace
6. Caret goes to position `4` (i.e. `1234|`)

**What is the expected behavior?**

Caret should obey `setSelectionRange` and go to position `2` even after backspace on IE10.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

This bug started at React v15.0.0. React v14.8 did not have this problem.

This issue was reported here https://github.com/msafi/text-mask/issues/133. @Heymdall found out that if you wrap `setSelectionRange` in a `setTimeout(..., 0)`, it sets the position correctly, though the user would have to type slowly to ensure this always happens, so that is not a workaround.
",,
7387,OPEN,Attach Stack at setState Calls in DEV Mode,Component: Core Utilities; React Core Team; Type: Enhancement,2020-01-08 19:19:56 +0000 UTC,sebmarkbage,,"We have a queue for state transitions. There is a natural place for a `new Error()` stack frame to be stored there.

We could use this information to work our way back from errors to show information about which `setState` call was the source of the error.

Because of batching, it is not always possible to make the correct attribution. It could be one of several possible sources.

(Specifically I'd like to use this in Fiber when the starvation protection kicks in. We can show which state transition was kept getting deferred due to higher priority work.)
",,
7328,OPEN,IE 11 and Edge no longer prompt to remember password on controlled form,Component: DOM; Type: Bug,2018-08-29 23:50:29 +0000 UTC,lPadier,,"**Do you want to request a _feature_ or report a _bug_?**
Bug (regression) IE/Edge

**What is the current behavior?**
On React > v15.2.0, Edge and IE11 do not prompt the user to save the password for the form

**Steps to reproduce**
With react 15.1.0:
https://jsfiddle.net/69z2wepo/49876/
With React 15.2.0:
https://jsfiddle.net/69z2wepo/49877/

**What is the expected behavior?**
The browser prompts the user to save their password for the form

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React > 15.2.0. It worked in React 15.2.0
IE 11, Edge
",,
7324,OPEN,Optimizing Compiler: Compiling to Internals,Component: Optimizing Compiler; React Core Team,2020-01-08 19:19:56 +0000 UTC,sebmarkbage,,"This optimization is a renderer specific optimization. It is about knowing how React will process a particular component in its internals and then inlining that internal work into the user code.

It comes in two flavors.
# Known Host Component

``` js
function Foo(props) {
  if (props.data.type === 'img') {
    return <img src={props.data.src} className={props.className} />;
  }
  return <span className={props.className}>{props.children}</span>;
}
```

Into this:

``` js
function Foo_optimizedMount(props) {
  if (props.data.type === 'img') {
    var img = document.createElement('img');
    img.className = props.className;
    img.src = props.data.src;
    return {
      node: img,
      listeners: ReactEventListeners.trap(img, 'error', 'load')
    };
  }
  var span = document.createElement('span');
  span.className = props.className;
  var children = ReactChildren.mountNestedChildrenIntoParent(this.props.children, span);
  return { node: span, children };
}

function Foo_optimizedUpdate(instance, oldProps, newProps) {
  if (oldProps.data.type !== newProps.data.type) {
    Foo_optimizedUnmount(instance);
    return Foo_optimizedMount(newProps);
  }
  if (props.data.type === 'img') {
    img.className = props.className;
    img.src = props.data.src;
    return instance;
  }
  span.className = props.className;
  ReactChildren.updateNestedChildrenInParent(this.props.children, instance);
  return instance;
}

function Foo_optimizedUnmount(instance) {
  if (oldProps.data.type !== newProps.data.type) {
    Foo_optimizedUnmount(instance);
    return Foo_optimizedMount(newProps);
  }
  if (props.data.type === 'img') {
    ReactEventListeners.release(instance.listeners);
  }
  ReactChildren.unmountNestedChildrenInParent(instance);
}
```
# Composite Components

Similarly, composite components can pick different code branches to imperatively update its children. For example, a known constant value wouldn't be considered, and comparison of a single property can potentially bail out a tree.

Although it is unclear if this has significant benefits over these two other optimizations:

https://github.com/facebook/react/issues/3227
https://github.com/facebook/react/issues/7323
",,
7323,OPEN,Optimizing Compiler: Component Folding,Component: Optimizing Compiler; React Core Team,2020-06-09 03:09:06 +0000 UTC,sebmarkbage,,"This is like the final frontier for React but I never really wrote anything about it so I figured I'd create an issue.

Basically, the idea is to utilize information about how React works to do [constant folding](https://en.wikipedia.org/wiki/Constant_folding) and [inlining](https://en.wikipedia.org/wiki/Inline_expansion) of components under certain conditions.

Example Source:

``` js
function Foo(props) {
  if (props.data.type === 'img') {
    return <img src={props.data.src} className={props.className} alt={props.alt} />;
  }
  return <span>{props.data.type}</span>;
}
Foo.defaultProps = {
  alt: ""An image of Foo.""
};
```

``` js
var CSSClasses = {
  bar: 'bar'
};
module.exports = CSSClasses;
```

``` js
var Foo = require('Foo');
var Classes = require('Classes');
function Bar(props) {
  return <Foo data={{ type: 'img', src: props.src }} className={Classes.bar} />;
}
```

By knowing what Foo and Classes is made up of, we can turn the Bar component into this:

``` js
var Foo = require('Foo');
var Classes = require('Classes');
function Bar(props) {
  return <Foo data={{ type: 'img', src: props.src }} className={Classes.bar} />;
}
function Bar_optimized(props) {
  return <img src={props.src} className=""Bar"" alt=""An image of Foo."" />;
}
```

[Dead-code elimination](https://en.wikipedia.org/wiki/Dead_code_elimination) then strips it down to just:

``` js
function Bar_optimized(props) {
  return <img src={props.src} className=""Bar"" alt=""An image of Foo."" />;
}
```

Now there are a bunch of different cases where this needs to bail out. For example, we need to know that the `CSSClasses` object and the `defaultProps` object is immutable, or we need to infer that it is immutable using [Escape analysis](https://en.wikipedia.org/wiki/Escape_analysis).

With classes these bail out cases are even more complex.

The problem is that current JS infrastructure is particularly bad at this kind of whole program or whole package linking. Node doesn't have a notion of per package private modules so anything can mutate anything by default. Transpilers such as Babel are set up to work on a single file at a time. They don't have access to the source of other files to do this analysis. [Rollup](https://github.com/rollup/rollup) is closer but is limited to a small set of static primitives.

However, once smarter compilers become more prevalent in the JS world or we find ways to hack around the limitations, we can start building out more of these smarter compiler optimizations.
",,
7281,OPEN,Input onChange not triggered every time in IE11 if e.preventDefault() used,Browser: IE; Component: DOM; Type: Bug,2018-08-18 01:50:02 +0000 UTC,jmullo,,"Input onChange not triggered every time if e.preventDefault() is called in onChange handler.

Occurs when typing fast: some characters are lost.

React 5.0.2 & IE11.
",,
7249,OPEN,Attributes and properties for Custom Components,Component: DOM; Type: Feature Request,2021-04-03 18:45:26 +0000 UTC,edoardocavazza,,"**Do you want to request a _feature_ or report a _bug_?**
Feature
**What is the current behavior?**
Custom component's properties are always set as attribute.
**What is the expected behavior?**
Maybe React should watch at the static `observedAttributes` property  for custom elements (https://w3c.github.io/webcomponents/spec/custom/) and then decide to set an attribute or an instance property. Otherwise, objects and array could be always passed as properties, in order to avoid `<custom-element prop=""[object Object]""></custom-element>`.
",,
7221,OPEN,Consider exposing an opaque component path somehow,React Core Team; Type: Big Picture,2020-01-08 19:19:55 +0000 UTC,sebmarkbage,,"This is something I've thought about in regard to focus, hover and selection.

If you implement hover as a top level state value with the currently hovered root component as `hoverID: component` and currently focused component as `focusID: component`.

Now anything in between gets rerendered and can respond to those things changing. However, that also means that everything gets rerendered. Not just the previous and next path.

The ideal would be that you store the path to that component, or extract the path from internal state.

That way we can quickly rerender only the previous and next path, while still letting anything in between react to focus/hover changing.

Maybe this is more generally useful.

Selection is a bit special because it might need to rerender anything in between two paths but that can also be optimized similarly - by checking if any child node corresponds to a start and end path and anything between is selected or unselected.
",,
7135,OPEN,onMouseEnter propagation in double reactroot,Component: DOM; Type: Bug,2019-10-20 11:39:57 +0000 UTC,dsvgit,,"I think it is bug

Now onMouseEnter event handler calls in child element when there are several reactroots. 

To reproduce - run fiddle and move mouse from white square to red and back. In console you can see log when you do it. Link - https://jsfiddle.net/47sn3j5c/ . It works wrong.

Expected behavior: handler has to call just when mouse enter to red square. See here simiar example but with one reactroot - https://jsfiddle.net/bs3rc2wp/1/ . It works right.

React 15.1.0
",,
6951,OPEN,Changing state in onFocus and onChange for a select multiple element does not work in Firefox,Component: DOM; Type: Bug,2021-02-12 12:37:27 +0000 UTC,skleeschulte,,"I want to use a controlled `<select multiple={true} />` component in React. In addition to the value I also want to keep the focused state of the select in the state. To do this, I update the state with `setState` in the `onChange`, `onFocus` and `onBlur` event handlers. Unfortunately there is an issue in Firefox: Firefox will only update the value on a change event after the select has gained focus. This means that a user has to click twice on the select element to change its value when it does not have focus. I would expect the select to gain focus and change the value at the same click.

I created a jsFiddle to demonstrate the prolem: [React select multiple issue in Firefox demonstration](https://jsfiddle.net/fugf1kw9/2/)

I only see this problem in Firefox and with select multiple. In IE and Chrome it is working as expected, and in Firefox it is working as expected for other form elements (simple select, checkbox, radio, text input, textarea).

My environment:
- Firefox 46.0.1 under Win7 x64
- React 15.1.0
",,
6927,OPEN,Change event fires too many times when inputing Chinese characters in IE 9,Browser: IE; Component: DOM; Type: Bug,2018-08-18 01:49:55 +0000 UTC,suhaotian,,"like #3926, but in ie9
",,
6807,OPEN,onMouseLeave doesn't work if the node gets detached,Component: DOM; Type: Question,2021-03-27 20:17:26 +0000 UTC,,,"I have a problem with this kind of component:

``` JavaScript
class onHover extends Component {

  constructor(props) {
    super(props);
    this.state = {
      bool: false,
    }
  }

  render() {
    return (
      <div onMouseEnter={() => this.setState({ bool: true })} onMouseLeave={() => this.setState({ bool: false })}>
        {
          this.state.bool ? (
            <span>[OPTION1] show after onMouseEnter</span>
          ) : (
            <div>[OPTION2] show after onMouseLeave</div>
          )
        }
      </div>
    )
  }
}
```

Notice that the first option1 is a `span`, option2 is a `div`.

This works fine when I move the mouse slowly.
Though, if I ""cut"" through this with the mouse very fast, only the `onMouseEnter` event gets triggered, but not the `onMouseLeave` event.

It is always working though, if both options have the same tag (if both are `div` or both are `span`). 

EDIT:
I think it has something to do with rerendering. When the components are of the same type, but I force a rerender, it causes the same issues. 

``` JavaScript
class onHover extends Component {

  constructor(props) {
    super(props);
    this.state = {
      bool: false,
    }
  }

  render() {
    return (
      <div onMouseEnter={() => this.setState({ bool: true })} onMouseLeave={() => this.setState({ bool: false })}>
        {
          this.state.bool ? (
            <div key={Math.random()}>[OPTION1] show after onMouseEnter</div>
          ) : (
            <div key={Math.random()}>[OPTION2] show after onMouseLeave</div>
          )
        }
      </div>
    )
  }
}
```
",,
6683,OPEN,RFC: Configure Warning Levels Using ENV Variable,React Core Team; Type: Enhancement,2020-01-08 19:19:55 +0000 UTC,sebmarkbage,,"Would it be feasible to specify the version of warnings you want through a static environment variable?

That would silence new warnings so that you can safely update minor versions without worrying about warning spew.

Dynamic configuration creates stateful shared module dependencies which we're very close to getting rid of for the isomorphic package (ReactCurrentOwner being the last one).
",,
6541,OPEN,Iframe load event not firing in Chrome and Safari when src is 'about:blank',Component: DOM; Type: Bug,2018-01-29 18:59:51 +0000 UTC,pirelenito,,"See: https://jsfiddle.net/pnct6b7r/

It will not trigger the alert in Chrome and Safari, but it will work in Firefox and even IE8.

Is this a React issue or Webkit issue? If it is a Webkit issue, should we ""fix it"" in React given that we want [consistent events across browsers](http://facebook.github.io/react/docs/events.html)?

ps: The JSFiddle was based on the isuse #5332.
",,
6436,OPEN,Support Passive Event Listeners,Component: DOM; React Core Team; Type: Big Picture; Type: Feature Request,2020-08-19 14:35:25 +0000 UTC,sebmarkbage,,"https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md

It would be good to have everything be passive by default and only opt-in to active when needed. E.g. you could listen to text input events but only preventDefault or used controlled behavior when you have active listeners.

Similarly, we could unify this with React Native's threading model. E.g. one thing we could do there is synchronously block the UI thread when there are active listeners such as handling keystrokes.

cc @vjeux @ide
",,
6325,OPEN,Consider Special Casing Certain DOM Attributes to Accept Elements,Component: DOM; React Core Team; Type: Feature Request,2020-01-08 19:20:28 +0000 UTC,sebmarkbage,,"The use case is for example, translation components rendering string content.

The HTML spec has some unfortunate attributes that behave kind of like content. It seems like they should be able to accept React elements. If I were to design a similar React component I would allow it to accept React elements.

Since we normalize usage we could in theory have it built-in to React that certain attributes like `placeholder`, `aria-label`, etc. could accept React components that render into strings.

That would probably have to go in after we figure out a way to render strings at the root of a React composite component.
",,
6284,OPEN,Form input name='nodeName' breaks onSubmit event handling,Component: DOM; Type: Bug,2020-04-16 02:43:04 +0000 UTC,insonifi,,"It happened that I stumbled on following edge case. If you add `name='nodeName'` attribute to form's _input_, at some point of React event handling (`ChangeEventPlugin.js: shouldUseChangeEvent()`) it will call: `elem.nodeName && elem.nodeName.toLowerCase()`, but coincidentally `nodeName` property refers to _input_ and invocation fails.

Here's a [jsFiddle example](https://jsfiddle.net/tLd7xvwc/)
",,
6217,OPEN,onResponderGrant called before onResponderTerminate,Component: DOM; Type: Bug,2017-11-21 14:12:50 +0000 UTC,aleclarson,,"When a responder captures the active responder, it seems that `onResponderTerminate` is not called until after `onResponderGrant`. This seems like the wrong thing to do. Are there reasons for this behavior?
",,
5700,OPEN,DataTransfer's dropEffect not working on IE/Edge with not minified version react.js,Browser: IE; Type: Bug,2020-05-06 15:41:06 +0000 UTC,srayuws,,"code exmaple: [Non-minified version](https://jsfiddle.net/sy7eja68/) and [Minified version](https://jsfiddle.net/sy7eja68/1/)

Both have the same code, html and js, the only difference is referenced to different version of react.js files.

There are three boxes.  Dragging the ""**drag me**"" box will show a ""**start**"" at the top, then show a ""**over**"" if it is dragged over either ""**normal drop**"" or ""**drop react**"" box, and show a ""**end**"" with a drop to the two drop boxes.

Everything works fine on my Firefox(43.0.1), and the the [Minified version](https://jsfiddle.net/sy7eja68/1/) works fine on my IE 11, and Edge(13).

The only thing dose not work is the  [Non-minified version](https://jsfiddle.net/sy7eja68/) on IE/Edge.

When dragging over the  ""**drop react**"" box, there shows **NO** ""over"".  In the F12 console, I can see lines of ""`SCRIPT16389: Unspecified error.`"". And with `console.log(ev.dataTransfer)`, I get this result: 

```
[object DataTransfer] {
   dropEffect: <Permission denied>,
   effectAllowed: ""all"",
   files: FileList {...}, 
   items: DataTransferItemList {...}, 
   types: DOMStringList {...}
}
```

I thought the `dropEffect` should also be accessible on IE/Edge with non-minified version react.js files?
",,
4751,OPEN,Play Nicely with The DOM Event System (because it's legacy anyway),React Core Team; Type: Big Picture,2020-01-08 19:20:27 +0000 UTC,sebmarkbage,,"Currently React implements its own plugin system and event bubbling rules. This is important for systems like the responder system since the DOM event system is incapable of implementing proper event negotiation support.

However, on desktop, we don't really take full advantage of our custom event system other than to polyfill mouseenter/leave and implement more bubbling.

There are plenty of other things that are wrong with the DOM but instead of patching it, maybe it would be better to build a new view system on top of the DOM that integrates with the custom event system. Similarly to how React Native handles things.

That way, the lowest level could just do what the DOM would do, however broken it may be.

Question though: How do we handle things like onChange?

cc @spicyj and @syranide since I know you always wanted this.
",,
4595,OPEN,Externalize the State Tree (or alternatives),React Core Team; Type: Big Picture,2020-02-03 21:23:59 +0000 UTC,sebmarkbage,,"React provides the notion of implicitly allowing a child component to store state (using the `setState` functionality). However, it is not just used for business logic state. It is also used to remember DOM state, or tiny ephemeral state such as scroll position, text selection etc. It is also used for temporary state such as memoization.

This is kind of a magic black box in React and the implementation details are largely hidden. People tend to reinvent the wheel because of it, and invent their own state management systems. E.g. using Flux.

There is still plenty of use cases for Flux, but not all state belongs in Flux stores.

Manually managing the adding/removing of state nodes for all of this becomes a huge burden. So, regardless you're not going to keep doing this manually, you'll end up with your own system that does something similar. We need a convenient and standard way to handle this across components. This is not something that should be 100% in user space because then components won't be able to integrate well with each other. Even if you think you're not using it, because you're not calling setState, you still are relying on the capability being there.

It undermines the ecosystem and eventually everyone will reconverge on a single external state library anyway. We should just make sure that gets baked into React.

We designed the state tree so that the state tree data structure would be opaque so that we can optimize the internals in clever ways. It blocks many anti-patterns where external users breaks through the encapsulation boundaries to touch someone else's state. That's exactly the problem React's programming model tries to address.

However, unfortunately this state tree is opaque to end users. This means that there are a bunch of legitimate use cases are not available to external libraries. E.g. undo/redo, reclaiming memory, restoring state between sessions, debugging tools, hot reloading, moving state from server to the client and more.

We could provide a standard externalized state-tree. E.g. using an immutable-js data structure. However, that might make clever optimizations and future features more difficult to adopt. It also isn't capable of fully encapsulating the true state of the tree which may include DOM state, it may be ok to treat this state differently as a heuristic but the API need to account for it. It also doesn't allow us to enforce a certain level of encapsulation between components.

Another approach is to try to add support for more use cases to React, one-by-one until the external state tree doesn't become useful anymore. I've created separate issues for the ones we we're already planning on supporting:
#4593 Debugger Hooks as Public API
#4594 Hibernating State (not the serialized form)

What else do we need?

Pinging some stake holders:

@leebyron @swannodette @gaearon @yungsters @ryanflorence
",,
4594,OPEN,Hibernating State (Not Necessarily Serialized),React Core Team; Type: Big Picture,2020-01-08 19:20:27 +0000 UTC,sebmarkbage,,"Relay and others currently abuses some internals to get some persistent identity of a component. This effectively is used to restore the state of a component after it has been temporarily unmounted. It is also common to abuse Flux stores for this use case. Basically, since this capability doesn't currently exists, you're encouraged to use Flux for everything just in case you need this capability later on.

The purpose of this issue is to discuss a public API for hibernating the state of a component and then restoring it once the component remounts.

The use cases can be broken down into three scenarios:
- **List Item Out of View**:  E.g. Infinite scrolling (such as ""table views"") where one row eventually needs to be reclaimed to save the memory used by the tree that is out of view.
- **Detail View**: In a master-detail view, clicking one item in the list switches the state of the detail view. When you click on the original view again.
- **Back/Forward Button**: You want to save a snapshot of the state when you navigate. The new view can then change the state and when you hit the back button to return to a previous state, you want to restore the original state of the subtree.

We would like to support this at least in a non-serialized form. You could imagine having an API that serializes this to JSON or some other data structure too but that's a potential follow up and not necessarily part of this.

One potential API:

``` js
class View {
  state = { stateKeys: [{}, {}, {}] }
  render() {
    return <ChildView key={this.state.stateKeys[this.props.index]} />;
  }
}
```

Basically, an object is used as a key. Unlike the normal key semantics, the state of the subtree is kept in memory indefinitely. We use a WeakMap to keep the state. If the object ever goes away, the GC will collect the state of that subtree. This solves all three use cases.
",,
4593,OPEN,Include DevTools as Public API,React Core Team; Type: Big Picture,2020-01-08 19:20:26 +0000 UTC,sebmarkbage,,"The idea is to have a multi-version extension that allow you to attach a ""debugger"" to a running React instance. This debugger protocol injects intercepted functions into a particular version of React which exposes development hooks.

Effectively this: https://github.com/facebook/react-devtools/tree/devtools-next/backend/integration

This is not intended to expose stateful reflection APIs in production use since it will negatively affect performance.
",,
4166,OPEN,Use Inline Event Handlers for trapBubbledEventsLocal and the iOS Safari Click Hack,Component: DOM; React Core Team; Type: Enhancement,2020-01-08 19:20:56 +0000 UTC,sebmarkbage,,"We currently do a lot of work at the end of mount to find all the nodes and attach listeners after the fact. This is severely impacting initial rendering performance of `<form />`, `<img />` and click handlers.

Instead we can just use inline event handlers in the innerHTML string. For the iOS Safari hack it should be trivial. The handler doesn't even have to do anything.

The inline event handler would need to either redispatch the event, or call into some other event handler system. Probably a global listeners.

``` js
window._handleReactEvent = ...;
```

``` html
<img onload=""_handleReactEvent(event)"">
```

Since there could potentially be multiple Reacts, they should probably chain the handler if there already is one registered. (Although multiple Reacts in the same document is already pretty broken in this regard.)

It doesn't have to be a global. Since inline event handlers gets the element added as a `with(element)` scope around itself. It is equivalent to add it to the prototype:

``` js
Element.prototype._handleReactEvent = ...;
```

or

``` js
HTMLImgElement.prototype._handleReactEvent = ...;
```

This makes them a bit more hidden, unobtrusive.

We still need to render this string for server-side rendering to avoid needing to change the HTML or wire up handlers after-the-fact on the client.

Since these events can fire before React has loaded, we need to check for the existence of the handler before it is used.

``` js
<img onload=""this._handleReactEvent&&_handleReactEvent(event)"">
```

It is critical that this string is short - for innerHTML string concat performance and network performance. Yet it needs to be unlikely to collide with anything else.

Is there a unicode character we could use?
",,
3965,OPEN,Support for reparenting,Component: Component API; Resolution: Backlog; Type: Feature Request,2021-01-19 02:08:00 +0000 UTC,dantman,,"When writing a component that contains a set of large subtrees that stay relatively the same, but are simply moved around such that React's virtual DOM diffing can't detect the movement, React will end up recreating huge trees it should simply be moving.

For example, pretend `blockA` and `blockB` are very large structures. They may be made of several levels of children and components. For example one could be the entire page contents and the other the sidebar, while this `render()` is the page root.

``` jsx
render() {
    var blockA = <div>AAA</div>,
        blockB = <div>BBB</div>;

    if ( this.props.layoutA ) {
        return <div>
            <div className=""something"">{blockB}</div>
            <div className=""something"">{blockA}</div>
        </div>;
    } else {
        return <div>
            {blockA}
            {blockB}
        </div>;
    }
}
```

Because the blocks aren't at the same level React cannot see the relation between these blocks and `key` cannot be used to give React any hints. As a result, when `layoutA` is changed, instead of the two blocks being moved to their new location the entire page is essentially completely unrendered and then re-rendered from scratch.

I understand why this is the case. It would be far to expensive for React to be able to detect movement of nodes like this.

But I do believe we need a pattern to hint to React that this component has large blocks that may be moved around at different levels.

Note that there may be a component in between the rendering component root and the block. So parent semantics scoped to the nearest component won't work. This'll need owner scoping.

I understand that React is trying to eliminate the need for React.createElement to be used and owner scoping within special attributes interferes with that. So instead of a component scoped `key=""""` variant I think a method/object style interface kind of like `React.addons.createFragment` might work.
",,
3926,OPEN,Change event fires extra times before IME composition ends,Component: DOM; Type: Bug,2020-09-28 07:56:20 +0000 UTC,chenxsan,,"### Extra details

* Similar discussion with extra details and reproducing analysis: https://github.com/facebook/react/issues/8683
* Previous attempt to fix it: https://github.com/facebook/react/pull/8438 (includes some unit tests, but sufficient to be confident in the fix)

------

### Original Issue


When I was trying this [example](https://jsfiddle.net/reactjs/n47gckhr/light/) from https://facebook.github.io/react/blog/2013/11/05/thinking-in-react.html, any Chinese characters inputted by Chinese pinyin input method would fire too many renders like:

![screen shot 2015-05-21 at 14 04 36](https://cloud.githubusercontent.com/assets/1091472/7742565/2c8625b0-ffc3-11e4-8ac2-d7eb22a3aef3.png)

Actually I would expect those not to fire before I confirm the Chinese character.

Then I tried another kind of input method - wubi input method, I got this:

![screen shot 2015-05-21 at 14 17 15](https://cloud.githubusercontent.com/assets/1091472/7742657/42c27bac-ffc4-11e4-8a3a-7d4550e88a59.png)

It's weird too. So I did a test [in jQuery](http://jsbin.com/yepogahobo/1/edit?html,js,console,output):

![screen shot 2015-05-21 at 14 05 12](https://cloud.githubusercontent.com/assets/1091472/7742591/71da6842-ffc3-11e4-9d7a-a8438721029c.png)

Only after I press the space bar to confirm the character, the `keyup` event would fire.

I know it might be different between the implementation of jQuery `keyup` and react `onChange` , but I would expect the way how jQuery `keyup` handles Chinese characters instead of react's `onChange`.
",,
3227,OPEN,Optimizing Compiler: Tagging ReactElements,Component: Optimizing Compiler; React Core Team; Resolution: Backlog,2020-01-08 19:20:55 +0000 UTC,sebmarkbage,,"We can make more optimized reconciliation by tagging ReactElements with the ""hidden class"" of their props.

For example, this is guaranteed to always have three props: `className`, `width`, `children`.

``` javascript
<div className=""foo"" style={{ width: w, height: 100 }}>{c}</div>
```

If we could tag every element with these properties with a unique ID:

``` javascript
{ __t: 7, type: 'div', props: { className: 'foo', style: { width: w, height: 5 }, children: c } }
```

Then we could use the hidden class to generate an optimized diffing algorithm for these instead of iterating over the properties. Presumably, we would only need to do this for `type: <string>` since we only diff native components.

Bonus points if we can determine which properties are constant. Perhaps using a property descriptor object:

``` javascript
// Constant properties are annotated as 1, other properties are excluded and inferred by props.
var t = { className: 1, style: { height: 1 } };
{ __t: t, type: 'div', props: { className: 'foo', style: { width: w, height: 5 }, children: c } }
```

We would use a heuristic inside React to determine when to create an optimized differ. For example, after 10+ updates to the same component. Just like a JIT would do.

``` javascript
if (oldElement.__t === newElement.__t) {
  numberOfUpdates++;
} else {
  numberOfUpdates = 0;
}

if (numberOfUpdates === 10) {
  optimizedDiffer = generateOptimizedDiffer(newElement);
  optimizedDiffer(oldElement, newElement);
} else if (numberOfUpdates > 10) {
  optimizedDiffer(oldElement, newElement);
} else {
  manualDiffing(oldElement, newElement);
}
```
",,
2193,OPEN,getEventKey implementation inconsistent with DOM3 spec / Firefox implementation,Component: DOM; Type: Bug,2018-06-25 18:11:25 +0000 UTC,Daniel15,,"There are some inconsistencies between `getEventKey` and the DOM3 keyboard event spec (as well as what Firefox has implemented):
- `key` property is not correctly set for printable characters on `keydown` and `keyup` events. This works properly in Firefox, and my interpretation of the standard is that Firefox's behaviour is correct here. From the spec: _If the key generates a printable character, and there exists an appropriate Unicode code point, then the KeyboardEvent.key attribute must be a string consisting of the char value of that character._
- Enter key only fires keydown in Firefox, but fires both keydown and keypress in Chrome. This should be consistent across browsers
- CapsLock key only fires keydown when it is toggled on. When caps lock is toggled from on to off, no keydown event is fired (this may be a browser limitation in Chrome)

Repro: Test this page in Firefox and compare the result to Chrome: http://jsfiddle.net/63ycmLhe/1/
",,
1791,OPEN,Add api for focus management,Component: DOM; Resolution: Backlog; Type: Feature Request,2020-01-08 18:31:17 +0000 UTC,bmeck,,"There are currently a couple of problems with focus management in React.
## current problems
- `this.getDOMElement().focus()`

does not guarantee the node is on a document/visible. visibility can be hard to detect due to other components firing render().
- `this.refs.x.getDOMElement().focus()`

does not guarantee that x has finished any pending renders. if `x` renders, focus is lost.
- `componentDidUpdate`

this fires on the child nodes before parents so in the case of:

```
<ul style=""display:none"">
  <li><button>can't focus</button></li>
</ul>
```

if we want to show the `<ul/>` and focus the button.

the component of the `<button/>` focusing during componentDidUpdate has no affect because the `<ul/>` is still hidden.
## discussion

if looks like some of the PRs to react are using raf or timeouts to achieve fixes to the problems listed. This can cause race conditions, and can be fixed with a lifeCycle addition, or just a hidden lifeCycle purely for focus management.

The issue comes down to not having a lifecycle able to fire a function after _all_ rendering is done, not just an individual component.

I would suggest we add a simple API of component.blur()/component.focus() that queues the requests and fires them after all rendering is done. The fix is fairly simple, but I wonder how people feel about this.
",,
1739,OPEN,Support asynchronous server rendering (waiting for data before rendering),Component: Component API; Component: Server Rendering; Resolution: Backlog; Type: Feature Request,2021-04-01 21:58:12 +0000 UTC,fdecampredon,,"It would seriously ease the process of building something isomorphic if componentWillMount could return a promise and that react would delay rendering until that promise is resolved. I have seen attempt of doing something like that in react-router and rrouter, however giving this responsibility to each component instead of a router module would make more sense for me.
",,
1355,OPEN,touchmove doesn't fire on removed element,Component: DOM; Partner; Type: Enhancement,2020-08-18 10:56:23 +0000 UTC,sophiebits,,"If you have

```
{this.state.show &&
  <div onTouchStart={this.hideTheDiv} onTouchMove={...} />}
```

such that the onTouchStart handler removes the div (and maybe replaces it with another one in the same place, useful in certain draggable interactions), the onTouchMove handler doesn't fire because the events of a detached element no longer bubble to document. We should probably bind the touchmove handler when the element receives touchstart instead of delegating to document.

Sort of related to #1254.

cc @merbs @eater
",,
1259,OPEN,Stop doing data-*; aria-*; start using dataSet,Component: DOM; Partner; Resolution: Backlog; Type: Feature Request,2020-01-08 23:44:58 +0000 UTC,zpao,,"The DOM already exposes `data-*` as `dataset` but it's doing transformation from hyphenated to camelCase. [From MDN](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.dataset):

```
<div id=""user"" data-id=""1234567890"" data-user=""johndoe"" data-date-of-birth>John Doe
</div>

var el = document.querySelector('#user');

// el.id == 'user'
// el.dataset.id === '1234567890'
// el.dataset.user === 'johndoe'
// el.dataset.dateOfBirth === ''

el.dataset.dateOfBirth = '1960-10-03'; // set the DOB.

// 'someDataAttr' in el.dataset === false

el.dataset.someDataAttr = 'mydata';
// 'someDataAttr' in el.dataset === true
```

We should just start supporting `dataSet` (because camelCase). This will allow a couple things:
- easier reasoning about data attributes (`Object.keys(this.props.dataSet)`)
- easier merging (`<div dataSet={merge(this.props.dataSet, {extra: 'value', override: 'value'})} />`)
- easier (potentially faster?) updates (just modify `node.dataset`)

We'll want to do the reverse of what the DOM is doing. eg `<div dataSet={{dateOfBirth: 'val', foo: 'bar'}} />` becomes `<div data-date-of-birth=""val"" data-foo=""bar""></div>`.

To the best of my knowledge, `aria-*` doesn't have a corresponding API, but we should make it work the same way. I think `ariaSet` makes sense.
",,
1253,OPEN,iframe contents cause invariant violation,Component: DOM; Type: Bug,2017-10-01 22:40:24 +0000 UTC,matthewwithanm,,"When using server rendering, putting an `<img>` in an `<iframe>` seems to invariably cause an invariant violation (it can't find the image).

This is related to #1252, but not identical. In both cases, the browser isn't aware of the inner elements however, in this case, it's because browsers that support iframes are actually mutating the DOM (by replacing the contents with the document specified in the `src` attribute).
",,
1159,OPEN,Provide a way to handle browser-autocompleted form values on controlled components,Component: DOM; Type: Bug,2021-01-14 12:55:27 +0000 UTC,ericflo,,"When there's a controlled component for form names that the user has saved in their browser (common with username/password fields), the browser will sometimes render the page with values in those fields without firing onChange events.  If the user submits the form, the component state does not reflect what is showing to the user.

In experimenting with this, it appears that the data is there on load (tested by logging this.refs.myinput.getDOMNode().value)
",,
285,OPEN,Declarative API for installing global DOM event handlers,Component: DOM; Partner; Resolution: Backlog; Type: Feature Request,2020-08-10 17:58:43 +0000 UTC,sophiebits,,"#284 reminded me that one thing I've sometimes wanted is to install a handler on window for `keypress` (for keyboard shortcuts) or `scroll`. Right now I can just do `window.addEventListener` in `componentDidMount` but since React is listening already, it would be nice if there were some way for me to intercept those events. (In addition, receiving normalized synthetic events is generally more useful.)
",,
