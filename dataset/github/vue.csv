Issue id,Status,Summary,Issue Type,Created,Author,Resolution,Resolved,Description,Creator,Labels,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary,Comment author,Commentary
11990,OPEN,Incorrect type for AsyncComponentFactory,,2021-03-31 14:23:12 +0000 UTC,Esurnir,In progress,,"### Version
2.6.11

### Reproduction link
[https://github.com/Esurnir/repro-types-vue](https://github.com/Esurnir/repro-types-vue)







### Steps to reproduce
clone the repo and do yarn followed by a yarn serve, open the browser.

The test case is in App.vue

### What is expected?
`MyComponent1` which is a correctly typed `AsyncComponent` should render. It contains a component property which is of type `AsyncComponentPromise` which is a fonction that returns a promise.

`MyComponent2` which is incorrectly typed as `component` is of type `Promise<EsModuleComponent>` should not load properly.

### What is actually happening?
The opposite.

---
This is due to [this line](https://github.com/vuejs/vue/blob/b51430f598b354ed60851bb62885539bd25de3d8/src/core/vdom/helpers/resolve-async-component.js#L122)
which checks wether component is a promise, not a function which returns a promise. 

Among the two ways this could be fixed :
component could be of type `Promise<Component | EsModuleComponent>` instead of the maybe confusingly named AsyncComponentPromise. Or resolveAsyncComponent could have a third case where if res.component is of type Function, it should call res.component(resolve, reject) and test if -that- is a promise before failing.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
~~FYI you should use `defineAsyncComponent()`: https://v3.vuejs.org/api/global-api.html#defineasynccomponent~~ nvm I thought you were using Vue 3
--

--
there is already an opened PR to fix this
--
",Esurnir,"
--
Ah sorry my bad. My googlefoo failed me this time.
--
",,,,,,,,
11984,OPEN,<v-show> style.display is incorrect when reusing the elm,bug; has workaround,2021-03-29 11:39:58 +0000 UTC,casperdai,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/CasperDai/mred18vo/7/](https://jsfiddle.net/CasperDai/mred18vo/7/)







### Steps to reproduce
click 'change'

### What is expected?
el.style.display is 'flex'

### What is actually happening?
el.style.display is ''

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Use a `key` on the `<div>` as a workaround.
--
",,,,,,,,,,
11925,OPEN,`.once` modifier on input event prevents v-model from updating value on input element.,bug,2021-03-02 04:50:40 +0000 UTC,Nicolas-Yazzoom,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/fxdez9qh/](https://jsfiddle.net/fxdez9qh/)







### Steps to reproduce
Type some text in the input field.

### What is expected?
The input handler is executed and the value in the input is updated.

### What is actually happening?
The input handler is executed but the first update to the model is not applied. This means the first character typed will not show up.

---
I found this issue: https://github.com/vuejs/vue/issues/6552 It's a few years old and it was fixed but it seems to be the same problem.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It seems like the change on micro tasks on v2.6.0 brought back this bug.

Note: this bug is fixed on Vue 3
--
",ruyi789,"
--
use  v-model.var=""variable"" just update this variable ,not needs update components
--
",,,,,,,,
11894,OPEN,Checking whether v-on handler is a function invocation is broken,feat:compiler; improvement,2021-02-23 16:58:07 +0000 UTC,adamsol,In progress,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/adamsol/pknr8dae/](https://jsfiddle.net/adamsol/pknr8dae/)







### Steps to reproduce
Click the buttons.

### What is expected?
All the buttons should behave in the same way: a message should appear below.

### What is actually happening?
Only the first button works correctly.

---
See #11893 for the origin of the issue.

The problem lies probably here: https://github.com/vuejs/vue/blob/5255841aaff441d275122b4abfb099b881de7cb5/packages/vue-template-compiler/build.js#L3801

The regexes used do not take into account cases such as additional spaces, parentheses, or chained function invocations. As a result, a promise is correctly returned only in the first case in the repro, and in all the other cases `errorHandler` won't capture the exception thrown in the async method.

The difference in the generated code (`return` is present only in the first case): https://template-explorer.vuejs.org/#%3Cdiv%20id%3D%22app%22%3E%0A%20%20%3Cbutton%20%40click%3D%22click(1)%22%3E%0A%20%20%20%20click(1)%0A%20%20%3C%2Fbutton%3E%0A%20%20%3Cbutton%20%40click%3D%22click%20(2)%22%3E%0A%20%20%20%20click%20(2)%0A%20%20%3C%2Fbutton%3E%0A%20%20%3Cbutton%20%40click%3D%22click((3))%22%3E%0A%20%20%20%20click((3))%0A%20%20%3C%2Fbutton%3E%0A%20%20%3Cbutton%20%40click%3D%22(click(4))%22%3E%0A%20%20%20%20(click(4))%0A%20%20%3C%2Fbutton%3E%0A%20%20%3Cbutton%20%40click%3D%22click(5).then()%22%3E%0A%20%20%20%20click(5).then()%0A%20%20%3C%2Fbutton%3E%0A%3C%2Fdiv%3E

Suggested solution: either add `return` in every case, or don't add it at all, so that the behaviour is consistent. If checking for the function invocation is crucial, then the code must be parsed in some other way.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
See https://github.com/vuejs/vue/issues/7628

Handling all possible cases will require a parser instead of a regex but realistically speaking, people won't write `@click=""method((2))""`. The only that would be worth adding support for is `@click=""click(5).catch(() => {})""` but it has the same problem, it requires a full parsing to deduce make it fully consistent. You can wrap the call with a function: `() => method().catch(() => {})` or add a method to your component, which is prefered in such scenarios because the code becomes difficult to read. The same for more complicated expressions where parentheses are required, like mathematical expressions.

That being said, Vue 3 does support these syntaxes but it has a full parser built in it. So maybe someone finds a way to improve the existing regex
--
",adamsol,"
--
The documentation (https://vuejs.org/v2/api/#errorHandler) says:

> In 2.6.0+, [...] if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.

So I think the current behaviour should be considered a bug, since `v-on` is one of the covered hooks, `.then` and `.catch` create promise chains, but errors are not handled. Also, the behaviour is inconsistent even between `method()` and `method ()`, which is very surprising. Together with #10009, this makes `errorHandler` hardly usable with regard to async methods.

---

For anyone who stumbles upon this issue: to catch all errors in promises, use `unhandledrejection` event as described here: https://stackoverflow.com/a/52076738. Note that you still need to set up `Vue.config.errorHandler`, since in the default handler Vue silences the errors that it manages to catch.
--
",,,,,,,,
11881,OPEN,keep-alive component's `include` prop cannot trim blank space if there's any,,2021-01-22 01:27:50 +0000 UTC,JerryYuanJ,Opened,,"### Version
2.6.11


### Steps to reproduce

following code makes a simple example:
```
<keep-alive include=""a,    b,c"">
    <router-view> </router-view>
</keep-alive>
```

### What is expected?
component a, b, c should all be cached.

### What is actually happening?
`a` and `c` are fine except `b` with blank is failed to be kept alive.

---
When do the matching, should consider this situation because some devs like to add a space between words or formatted by some tools.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11864,OPEN,Avoid inline styles in server-side directives (SSR) to allow nonce-based CSPs,,2021-02-04 18:05:27 +0000 UTC,aKzenT,In progress,,"### What problem does this feature solve?
Currently when using the v-show directive server-side it produces style=""display:none;"" attributes on HTML elements. These collide with using a nonce-based CSP (content security policy level 2) setup as CSP Level 2 does not have a method to whitelist inline style attributes. CSP Level 3 allows this by using 'unsafe-hashes' and whitelisting the hash-value of the generated style attribute, but is not supported yet by all browsers (e.g. Safari). This makes it currently impossible to use a nonce-based CSP when using v-show and server-side rendering.

### What does the proposed API look like?
E.g. Allow configuration of a custom class name that is used by v-show instead of the inline-styles.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Not sure what is the exact problem here and what cannot be achieved but the proposed solution using a custom class name for `v-show` looks more like a patch.

Is this what you are looking for https://github.com/vuejs/vue/pull/11826 ?
--
",aKzenT,"
--
Not exactly. The referenced issue is about adding nonces to generated style or script element. While also an important aspect in complete CSP support, it does not solve the issue described here which is about inline style attributes.

Inline Attributes (`style=''`) cannot be whitelisted with nonces because nonces only work on `<style>` and `<script>` elements, not on individual attributes. The usual guideline is therefore to never use inline-style-attributes at all and use other means instead. Note that you can still set style properties via javascript as the CSP tries to protect against injections into the DOM itself. However in the case of SSR this does not help obviously as the style-attributes need to be transferred to the client somehow.
--

--
I think you are mostly right. However there are some problems with this approach:

Using hashes for inline-attributes is a CSP Level 3 feature and requires the 'unsafe-hashes' attribute, which is not supported in Safari for example. This leaves you no other choice than falling back to domain whitelists and 'unsafe-inline' for styles. Domain whitelists are hard to maintain however and can open security vulnerabilities e.g. when whitelisting CDNs too broadly.
--

--
Are you suggesting to not use any CSP rule for styles (just allowing everything)? Or do you still see a value in using a domain whitelist? Because it's not possible to use a 'nonce' for external styles and 'unsafe-inline' for attributes. Using nonces automatically disables 'unsafe-inline'.

We will probably take the route of using a domain whitelist for now, but this is a configuration PITA because we already have all the infrastructure to propagate nonces through all loaded scripts and styles, but we would still need to change to domain whitelists as 'unsafe-inline' does not support anything else in combination.
--
",blake,"
--
@aKzenT 

Preventing inline styles is a pretty strict CSP directive, I'd only recommend this setting in highly secure settings. 

An alternative is to do a hash of the style content that v-show produces and add that as a safe value. This will mean you don't need to specify the nonce wherever v-show may appear. 

I'd still highly recommend allowing inline styles, especially if you have a strict CSP policy for scripts. As far as I know scripting would be required to inject inline styles, so I can't see the benefit of preventing inline styles at this stage. 
--

--
@aKzenT indeed which is why I recommend just allowing `unsafe-inline` for styles. Especially if your scripts are safely protected as this is the main entry point to injections of styles. So without the ability to embed harmful scripts they can do little with styles. 

https://csp-evaluator.withgoogle.com/

Even enabling `unsafe-eval` for styles isn't a red flag when valuated.

I would say that if you really care for protection against styles then I'd question the use of any dependency in your project as they pose more risk than inline styles.
--

--
Our CSP policy for style is `'self' https: 'unsafe-inline'` - it works well for us and should for most cases. As-long as the scripts have a safe policy then no foul play can occur. 
--
",,,,,,
11856,OPEN,empty slot does not render as default if there is v-if as evaluated false more than 1,has workaround; improvement,2021-02-28 15:06:55 +0000 UTC,KSH-code,Opened,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/ksh-code/pen/wvzXmEB](https://codepen.io/ksh-code/pen/wvzXmEB)







### Steps to reproduce
click update button multiple times then value'll be set 0.

### What is expected?
if value 0, then render ""no data"".

### What is actually happening?
empty component as comment created.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,KSH,"
--
I'm going to fix soon.
--

--
Thank you for proposal!
By the way, people could mistake using v-if more than once instead of using v-else-if.
--

--
@andacistan 
No, I want to actually use slot using shorthand. :)
It does not need to name id
--
",posva,"
--
~~As a workaround,~~ The proper code should use `v-else-if`
--
",andacistan,"
--
hey!  The problem is that you misnamed the template. 
#default should be replaced with id = 'default'

<template **id='default'**>
    ----
</template>
--
",,,,,,
11849,OPEN,Hot relaod does not work in functional component ;How to fix it?,,2021-01-12 12:54:28 +0000 UTC,jackchoumine,Opened,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/brave-field-m1quc?file=/src/App.vue](https://codesandbox.io/s/brave-field-m1quc?file=/src/App.vue)







### Steps to reproduce
A functional component in script  with render.
Hello.vue
```vue
<script>
 export default {
   name:'Hello',
   functional:true,
   render(){
     return <h1>
              Does hot reload with functional:true  in script and render?Noo
              </h1>
   }
 }
</script>
```
> The component does not hot reload when I change something in render.

But this does hot reload:
Hi.js
```js
export default {
	name: 'Hi',
	functional: true,
	render(h, { props }) {
		const children = [h('h'   props.level, '这是标题'   props.level)]
		return h('div', children)
	},
}
```
How to fix  it?

### What is expected?
I want all components  can hot reload.


### What is actually happening?
I have to reload page by hand when Hello.vue  componet changed.

---
you can get this repo:
https://github.com/jackchoumine/vue-demo

you change Hello.vue . It does not hot reload.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sirlancelot,"
--
Vue's hot-reload API only gets applied to `.vue` files. Use the first syntax in your example. All Vue components (functional or otherwise) should be in `.vue` files for maximum compatibility with developer utilities like hot-reload.

You could even use a functional template if you want:

```vue
<template functional>
  <div>
    <component :is=""`h${props.level}`"">Header {{ props.level }}</component>
  </div>
</template>

<script>
export default {
  functional: true,
  props: {
    level: { type: Number, default: 1 }
  }
}
</script>
```
--
",,,,,,,,,,
11839,OPEN,click handle problem in Tizen Tv 2.4,,2020-12-23 14:01:40 +0000 UTC,xtoolkit,Opened,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/flamboyant-hopper-tg554](https://codesandbox.io/s/flamboyant-hopper-tg554)







### Steps to reproduce
1. click `toggle` botton
2. click `test` botton

### What is expected?
call `clickHandle` method and show `clicked` alert;

### What is actually happening?
in samsung smart tv (tizen os 2.4) when we set click event to a child element in condition element (v-if) and run steps to reproduce, `clickHandle` method not fire.

---
`clickHandle` method not fire, because that element has child. when `open` data set true, @click simulated to @click.self.
and we have to fix this problem use css z-index...

sry 4 my bad english

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is likely a bug of the browser, you should be able to `.capture` on the inner div: https://vuejs.org/v2/guide/events.html#Event-Modifiers

Seems similar to https://github.com/vuejs/vue/issues/10366 and https://github.com/vuejs/vue/issues/10515

It's worth identifying the browser version so we can test
--
",,,,,,,,,,
11837,OPEN,SSR: missing class and style attributes with dynamic async components,,2021-03-31 17:01:56 +0000 UTC,realityfilter,In progress,,"### Version
2.6.11

### Reproduction link
[https://github.com/realityfilter/bugreport-dynamic-components-ssr](https://github.com/realityfilter/bugreport-dynamic-components-ssr)







### Steps to reproduce
- clone the repository: https://github.com/realityfilter/bugreport-dynamic-components-ssr
- `npm install`
- `npm run dev`

### What is expected?
All class and style attributes set on dynamic async components are present in server side generated html.

### What is actually happening?
The generated html is missing style and class attributes set on parent components.

The generated html should look like ![correct](https://github.com/realityfilter/bugreport-dynamic-components-ssr/blob/master/static/correct.png?raw=true)

But the generated html is missing class and style attributes and actually looks like: ![ssr](https://github.com/realityfilter/bugreport-dynamic-components-ssr/blob/master/static/ssr.png?raw=true)


---
This is a test case derived from a nuxt project.

- We use global objects to be able to use them dynamically.

- Nuxt loads them asynchronously under the hood via `() => import('~/components/global/Component.vue')`


The parent component sets classes and styles:

```vue
<template>
  <div>
    <h2>Container</h2>
    <DynamicComponent
      v-for=""blok in body""
      :key=""blok.id""
      :blok=""blok""
      class=""child""
      style=""border: 1px solid black""
    />
  </div>
</template>

<script>
export default {
  inheritAttrs: false,
  props: {
    body: Array
  }
};
</script>
<style>
.child {
  background-color: red;
}
</style>
```

With DynamicComponent:

```vue
<template>
  <component :is=""blok.component"" v-bind=""blok"" :blok=""blok""></component>
</template>

<script>
export default {
  inheritAttrs: false,
  props: {
    blok: Object
  }
};
</script>
```

There are some workarounds for this issue:

- avoiding async components via manual registering the components in a plugin
- wrapping the DynamicComponent with a div

<!-- generated by vue-issues. DO NOT REMOVE -->",,,realityfilter,"
--
The incorrect DOM looks like: 

<img width=""615"" alt=""ssr-dom"" src=""https://user-images.githubusercontent.com/626228/102796617-d44b3080-43ae-11eb-973d-ecf6da8e9f7a.png"">

--
",yshrsmz,"
--
I'm having the same issue.

when manually bind `$attrs` like below, it seems to render attributes while SSR.
but I can't render class and style for some reason

```
<component is=""SomeComponent v-bind=""$attrs"" />
```
--
",pi0,"
--
I've managed to create bare minimum reproduction: https://replit.com/@pi0/vuejsvue11837#index.js

Even without dynamic components, an async component fails to inherit a class from the two-level upper parent (check the difference between `<child>` and `<async-child>` classes). 

Once made a fix PR can ensure these two issues are the same (root cause) but my guess is they are.


--
",,,,,,
11828,OPEN,Building to Vue 2 and 3: Version mismatch error from vue-template-compiler,,2020-12-17 21:16:55 +0000 UTC,privatenumber,In progress,,"### What problem does this feature solve?
`vue-template-compiler` runs a version check against the `vue` specifier Node.js resolves as soon as it's imported [here](https://github.com/vuejs/vue/blob/dev/packages/vue-template-compiler/index.js).

Because of this:
1. I'm getting a vue-loader recommendation in a rollup build
2. I can't have a setup that builds to both Vue 2 and 3. I think it's important to support this use-case for the eco-system as more apps migrate to Vue 3.

I'm interested in building a component to both Vue 2 and 3, but the version mismatch error from above gets thrown as soon as `rollup-plugin-vue@5` is imported.


<img width=""824"" alt=""Screen Shot 2020-12-16 at 3 06 55 PM"" src=""https://user-images.githubusercontent.com/1075694/102400783-666ac780-3fb0-11eb-9d02-d2aa217f6929.png"">



My `package.json` looks like this:

```json5
{
  ...,
  ""devDependencies"": {
    ""@vue/compiler-sfc"": ""^3.0.4"",
    ""rollup"": ""^2.35.1"",
    ""rollup-plugin-vue2"": ""npm:rollup-plugin-vue@^5.1.9"",
    ""rollup-plugin-vue3"": ""npm:rollup-plugin-vue@^6.0.0"",
    ""vue"": ""^3.0.4"",
    ""vue-template-compiler"": ""^2.6.12"",
    ""vue2"": ""npm:vue@^2.6.12""
  }
}
```

My `rollup.config.js` looks like this:

```js
import vue2 from 'rollup-plugin-vue2';
import vue3 from 'rollup-plugin-vue3';

const rollupConfig = [
    {
        input: 'src/MyComponent.vue',
        plugins: [
            vue3(),
        ],
        output: {
            format: 'es',
            file: 'dist/my-component.vue3.esm.js',
        },
    },
    {
        input: 'src/MyComponent.vue',
        plugins: [
            vue2(),
        ],
        output: {
            format: 'es',
            file: 'dist/my-component.vue2.esm.js',
        },
    },
];

export default rollupConfig;
```


### What does the proposed API look like?
Wondering if this can be changed to a run-time check or moved to the appropriate loader/plugin.

A run-time check might be a good idea as I'm sure a lot of people may be accidentally trying to import Vue 2 components into a Vue 3 app and vice-versa.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
In your specific scenario, you could swap vue2 and vue to have `vue` point to Vue 2 and `vue3` to point to Vue 3. Moving the error to runtime would just delay the error but still happen. Note it's not a problem in applications as they will only run one version of Vue.

Maybe you have a PR proposal and I think it's worth exploring but, in general, I would say it's easier to handle different versions of the package for different versions of Vue **if you need to compile templates**. If you don't need to compile templates, you can install only one version of it like https://github.com/posva/vue-promised
--
",privatenumber,"
--
You're right, that worked for my use-case. Thanks @posva!

I have a few component repos I want to start supporting Vue 3 for as well, but I don't think it's a great dev experience for everyone to need to make a breaking release to support Vue 3. Phasing Vue 2 out will be a long process so I'd still like to support Vue 2 users without maintaining two different branches.

I'm also considering exporting SFCs via [vue-compile](https://github.com/egoist/vue-compile).


> Moving the error to runtime would just delay the error but still happen.

Yes, I think the error should still happen. I'm suggesting that the error be shown to the component user rather than the builder.

> Note it's not a problem in applications as they will only run one version of Vue.

I think it will be as we migrate to Vue 3. eg. I work in a very large Vue 2 codebase and we won't be able to immediately upgrade everything to Vue 3. We're waiting on the compat build, but I'm working on [vue-2-3](https://github.com/privatenumber/vue-2-3) as a potential solution to this problem.


--
",,,,,,,,
11794,OPEN,"SSR ""context.styles"" is not defined on webpack 4",,2020-11-26 19:19:36 +0000 UTC,dszymon,Opened,,"### Version
2.5.22

### Reproduction link
[https://github.com/Szymon-D/VueSsrStylesReproduction](https://github.com/Szymon-D/VueSsrStylesReproduction)







### Steps to reproduce
1. Clone the repository
2. Run `npm install`
3. Run `npm run build`
4. Run `npm start`
5. Open http://localhost:8080
6. Check `head` tag, there are no inline styles from the current route

### What is expected?
There should be `style` tags with data-vue-ssr-id attribute

### What is actually happening?
Output includes only `link` tags to external CSS files

---
The issue is related to replacement of `extract-text-webpack-plugin` with `extract-css-chunks-webpack-plugin`. 
It seems that with newer plugins, `vue-style-loader` doesn't get called in all cases where it would as the value of the `fallback` option to the legacy plugin.
There is no `styles` field on the context after rendering the app, as you can see here
https://github.com/vuejs/vue/blob/4f81b5db9ab553ca0abe0706ac55ceb861344330/packages/vue-server-renderer/build.dev.js#L9397
it's defined only in case if there's a `_renderStyles` function, which comes from the `vue-style-loader`
https://github.com/vuejs/vue-style-loader/blob/477c25e1a506c54e18cb443f7981aed6d4e80e65/lib/addStylesServer.js#L16

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11787,OPEN,Remove IE11 support for v-html SVGs when IE support is not needed,,2020-11-30 18:09:07 +0000 UTC,blimmer,In progress,,"### What problem does this feature solve?
I'm a developer working on a browser extension that uses Vue.js. I'm currently working on porting my extension over to Firefox. Mozilla has an automated validation process that determines whether or not your extension requires manual review before the extension is released to users.

One issue I'm running into is that the Vue runtime bundle includes assignment to innerHTML ([src](https://github.com/vuejs/vue/blob/v2.6.12/src/platforms/web/runtime/modules/dom-props.js#L54)), which generates this warning:

![Screen Shot 2020-11-23 at 10 32 47 AM](https://user-images.githubusercontent.com/630449/99995198-452f0680-2d77-11eb-8fef-3372f612d1f6.png)

From what I can tell from the [code comment](https://github.com/vuejs/vue/blob/v2.6.12/src/platforms/web/runtime/modules/dom-props.js#L52) and the [PR where this logic was added](https://github.com/vuejs/vue/pull/8652), it's only there for IE11 support.

It would be nice if there were a way for us to opt-out of this behavior since our browser extension doesn't support IE11. What I mean by ""opt-out"" is that the `innerHTML` assignment would not be included in the `vue-cli-service build` output.

### What does the proposed API look like?
Ideally, this switch could be based on the browsers we have configured in our `.browserslistrc`. We currently only support the last 5 versions of Firefox and Chrome, so we don't need any IE11 fallbacks. Though, I'm not sure if any introspection/updating of the Vue distfiles are done at build-time, so that might be a challenge.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Would changing that line with `svgContainer[key]` bypass the warning? Can you try editing the final bundle?
--

--
Is this warning blocking for extensions or not? @blimmer 
--
",blimmer,"
--
Clever! Indeed, it does not appear as a warning if I change the line in my bundle from

```js
(ri = ri || document.createElement('div')), (ri.innerHTML = '<svg>' + r + '</svg>');
```

to

```js
(ri = ri || document.createElement('div')), (ri['innerHTML'] = '<svg>' + r + '</svg>');
```
--

--
I haven't submitted the extension yet, so I'm not 100% sure. Similar to what @Justineo was saying, I think it won't block me for submitting, though it does flag the extension to send it through the review process which slows things down.

Vue is certainly not alone in this, I've also filed an issue with lodash for another warning: https://github.com/lodash/lodash/issues/4985
--

--
The VDOM patching link above is reading from `innerHTML`, not assigning it. The warning is only generated when assigning `innerHTML`. With Vue's runtime version, the linked code is the only place Vue is assigning `innerHTML` (from what I can tell from the lint output).

I don't think this is a huge deal necessarily, but it would be nice not to trigger Mozilla review since we don't support IE11.
--
",sirlancelot,"
--
I think changing the access to `svgContainer[""innerHTML""]` in Vue's source won't work in the long run though because minifiers will rewrite that expression to `a.innerHTML` anyway.
--
",Justineo,"
--
According to my own experience of maintaining a Firefox add-on, the warning will not block the submission process. There are many add-ons relying on jQuery or other 3rd party libs, you can clarify the situation in your comments to reviewers and this should be fine. I don't think it's necessary to handle this in Vue's source code.
--

--
The use of `innerHTML` is required in Vue, not only in this case but also core features like [VDOM patching](https://github.com/vuejs/vue/blob/bd6cea0973247e2a8e1d4a2250614c0bf44f0b26/src/core/vdom/patch.js#L627). I don't think it makes sense to bypass the code check when the code itself needs further review. We shouldn't pretend it doesn't exist.
--
",,,,
11780,OPEN,staticClass on wrapped async component not rendered on the server by vue-server-renderer,,2020-11-19 09:04:14 +0000 UTC,maoberlehner,Opened,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/vue-issue-staticclass-on-wrapped-async-component-not-rendered-on-the-server-by-vue-server-renderer-nur3o?file=/_LOOK_HERE/test.html](https://codesandbox.io/s/vue-issue-staticclass-on-wrapped-async-component-not-rendered-on-the-server-by-vue-server-renderer-nur3o?file=/_LOOK_HERE/test.html)

### Steps to reproduce
0. Ignore all the Nuxt.js stuff in the repo. I needed a Container CodeSandbox, so I started with a Nuxt.js template. Only focus on the files I mention in the following steps. The error has nothing to do with Nuxt.js! Also ignore the browser output of the CodeSandbox! It is only about the HTML in `./_LOOK_HERE/test.html`!
1. In the `./_LOOK_HERE/test.html` file you can see `<div class=""AsyncDiv""></div>` does not have `test-class` but `<div class=""SyncDiv test-class""></div>` does. **Both should have `test-class`.**
2. In `./main.js` you can see the `AsyncDiv` and `SyncDiv` components. They are almost the same but **the first one is an async factory component.**
3. The `WrapperAsync` and `WrapperSync` components are exactly the same but rendering the two respective components. This is important; **if I render `AsyncDiv` directly without the wrapper, everything works as expected.**
4. In `App` we render both wrappers with the same `staticClass`.
5. In`./render.js` you can see the code that produces `./_LOOK_HERE/test.html`. You can run it in the terminal with `node render.js` but it is a little buggy on CodeSandbox if you have opened `test.html` before. Close the `test.html` tab before running the script. Or just believe me that it produces `./_LOOK_HERE/test.html`.
6. Not in the reproduction: If the server rendered code is hydrated client-side, `test-class` is appended to `AsyncDiv`. So it seems as if on the client-side this case is handled correctly.

### What is expected?
In `test.html` both components should be rendered with the `test-class`.

```html
<div class=""AsyncDiv test-class""></div>
<div class=""SyncDiv test-class""></div>
```

### What is actually happening?
Only the `SyncDiv` component correctly renders `test-class`.

```html
<div class=""AsyncDiv""></div>
<div class=""SyncDiv test-class""></div>
```

---
I ran into this problem working on [vue-lazy-hydration](https://github.com/maoberlehner/vue-lazy-hydration). There I use a wrapper around an async component to delay the hydration of the async component.
I realize that this is an edge-case and I can and will work around it in `vue-lazy-hydration` (by resolving the async component and rendering the resolved sync component) but I thought this maybe can be valuable for others.
I also realize that there is probably not a lot of focus on v2 currently but I think this is still important because there will be huge legacy projects running on v2 for years to come.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11775,OPEN,Enable performance measuring in production; at the user's request,feature request,2020-11-17 16:02:17 +0000 UTC,vegerot,Opened,,"### What problem does this feature solve?
Similar to devtools, `Vue.config.devtools` is enabled by default for development and disabled by default for production.  However, the developer can choose to override that behavior (for example, for debugging) by manually setting `Vue.config.devtools = true`.  However, this same lenience is not afforded to `Vue.config.performance`.  Even if explicitly enabling it, the developer's setting will be overridden by Vue in production.

### What does the proposed API look like?
This proposed solution brings `Vue.config.performance` in line with `Vue.config.devtools`, by disabling it by default in production, but gives the developer the ability to explicitly enable it; for example, for debugging performance issues.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11772,OPEN,Consider detecting browser environment just-in-time,discussion,2020-11-16 20:25:24 +0000 UTC,sebamarynissen,In progress,,"### What problem does this feature solve?
When testing Vue components on Node with [@vue/test-utils](https://www.npmjs.com/package/@vue/test-utils), it is important that you mock a browser environment with [jsdom-global](https://www.npmjs.com/package/jsdom-global) *before* vue is loaded. If you fail to do this, you get a `TypeError: Cannot read property 'child' of undefined` (see https://github.com/vuejs/vue-test-utils/issues/1192) when trying to mount your component.

The reason is that when Vue is loaded, it checks the environment as
```js
const inBrowser = typeof window !== 'undefined';
```
It would be useful - at least for the mounting of components - if this check is performed just in time so that the order of loading is not important here.

While one could argue that this is not a problem if you simply get the loading order correct, there is actually a problem when trying to load `.vue` files natively in Node. I've written an experimental library for this, call [vue-esm-loader](https://www.npmjs.com/package/vue-esm-loader). The problem I had when trying to get this to work with [@vue/test-utils](https://www.npmjs.com/package/@vue/test-utils) is that there's a cyclic problem: [vue-esm-loader](https://www.npmjs.com/package/vue-esm-loader) needs [vue-template-compiler](https://www.npmjs.com/package/vue-template-compiler), which in turn loads Vue first to check for a version mismatch. However, as the loader is loaded as the very first file, this means it's impossible to mock the browser environment before vue is loaded the first time.

I was able to bypass this by directly requiring the build of vue-template-compiler which does not provide the version check, but this is not a good solution (see https://github.com/sebamarynissen/vue-esm-loader/commit/252f1df2337684613346373727f0f6203ac6aea9#diff-5dfe38baf287dcf756a17c2dd63483781b53bf4b669e10efdd01e74bcd8e780aR7). Therefore it would be useful if the environment check in Vue is done on the fly.

### What does the proposed API look like?
I propose to replace the `inBrowser` constant by an `env` object, which can look like
```js
const env = {
  get inBrowser() {
    return typeof window === 'undefined';
  }
};
```
Subsequently the `$mount` method can use this as 
```js
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && env.inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sebamarynissen,"
--
I did some additional tests and found out that the `inBrowser` check in the `$mount` function was not the problem. It looks like there are two functions that need would need to be updated for the just-in-time check to work:
```js
// This
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// Would need to become
function patch (oldVnode, vnode, hydrating, removeOnly) {
  if (!env.inBrowser) return;
}
Vue.prototype.__patch__ = patch;

// And
function isUnknownElement (tag) {
  if (!inBrowser) {
    return true;
  }
}

// Has to become
function isUnknownElement (tag) {
  if (!env.inBrowser) {
    return true;
  }
}
```
The key here being the `__patch__` function that cannot be set upon loading. I have to admit that I have no idea what the impact would be on SSR.
--

--
Yes, I figured this as well some time after opening this issue. I've solved it in a slightly different way, using 
```js
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

export function getCompiler() {
  return require('vue-template-compiler');
}
```
See https://github.com/sebamarynissen/vue-esm-loader/blob/master/lib/utils.js#L32 and https://github.com/sebamarynissen/vue-esm-loader/blob/master/lib/load.js#L27. This does indeed solve my problem so I no longer have to circumvent the version check. It makes this issue slightly less relevant. Of course the user is still responsible for loading `jsdom-global` before loading any `.vue` files though.
--
",sirlancelot,"
--
This is really cool! I'm looking forward to your work on `vue-esm-loader`. This is just a theory, but I'd think that because `vue-template-compiler` has a dependency check on `vue`, you might have luck lazy-loading it during the `transformSource()` subroutine. Since `transformSource()` can be async, you can then do one-time loading of your `compileTemplate` function.

```js
// `lib/loader.js`
let compileTemplate
export async function transformSource(source, ctx, defaultTransformSource) {
  const { url } = ctx
  
  if (templateRegex.test(url) || htmlRegex.test(url)) {
    // Lazy-load the compiler due to compatibility checking with Vue module.
    if (!compileTemplate) compileTemplate = (await import(""./compile-template.js"")).default

    const source = compileTemplate(source, ctx)
    return { source }
  }

  return defaultTransformSource(source, ctx, defaultTransformSource)
}
```

And then remove the static import at the top of that file. By doing this, you should be safe by not loading too much ahead of what the code requires.

**Edit:** It would seem that your module is also importing `vue-template-compiler` in other areas. I would suggest the same process for those: lazy-load only when the code demands it.
--

--
> Of course the user is still responsible for loading jsdom-global before loading any .vue files though.

Yes well, that can easily be done during setup (`mocha --require ./test/_setup.js`). If you want to keep everything async, I think you can use `await import()` these days instead of `createRequire()`. I haven't kept up in that area of Node.js development though...
--
",,,,,,,,
11771,OPEN,Strange ssr behavior in v-for loop with if-else and v-text,bug; feat:ssr; has workaround,2021-02-11 22:38:22 +0000 UTC,TrueCarry,Opened,,"### Version
2.6.11

### Reproduction link
[https://github.com/TrueCarry/linktest](https://github.com/TrueCarry/linktest)







### Steps to reproduce
Run server, open localhost:8080. Problem is in components/textWrapper.vue file. I've used some vue ssr template and removed almost everything unneeded. Same error as before.

### What is expected?
ssr and client side versions are the same. It works if we don't use v-text on span. I changed it to v-text1, to test.
No hydration errors with v-text1
![image](https://user-images.githubusercontent.com/5431520/99122979-58700280-2610-11eb-8b5c-0952d78fe951.png)


### What is actually happening?
Server doesn't render custom element.
Console output: 
![image](https://user-images.githubusercontent.com/5431520/99123015-70e01d00-2610-11eb-8196-28840adbdfc8.png)
Server generated html:
![image](https://user-images.githubusercontent.com/5431520/99123039-7b9ab200-2610-11eb-85e4-2fcce636ae34.png)


---
Can you give me few hours to respond next time you decide to close issue please? 

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
As a workaround, you can avoid `v-text`.

> Can you give me few hours to respond next time you decide to close issue please?

Read https://new-issue.vuejs.org/?repo=vuejs/vue#why-repro
--
",4eveRS,"
--
Any updates?
--
",sirlancelot,"
--
Replace your `<span v-text=""val"" />` with `<span>{{ val }}</span>`.
--
",,,,,,
11760,OPEN,Memory leaking components on asynchronous return calls after destruction,,2020-11-09 14:29:43 +0000 UTC,badpunman,Opened,,"### Version
2.6.11

### Reproduction link
[https://github.com/badpunman/vuememoryleak](https://github.com/badpunman/vuememoryleak)







### Steps to reproduce
Clone repository
npm install
npm run serve
open localhost:8080
Open chrome memory tab or other tool for analysis
Click button multiple times.

### What is expected?
Vue should release components and the memory.

### What is actually happening?
Components are not released.

---
Continuation to https://github.com/vuejs/vue/issues/11755 which was closed with too much haste. 

Now demonstrated with $nextTick so we dont have any nasty arguments about whether or not it's due to not cleaning up asynchronous HTTP calls or setTimeouts. $nextTick does not provide a cancellation method so either it's broken in this regard or this is a valid issue.

Vue should not depend its watchers on component if it has already been destroyed.

If this is still not a valid bug, all vue's documentation needs an overhaul as it encourages to write code in a way that allows for memory leaks. $nextTick should then also be removed from codebase.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11757,OPEN,when use key in Object.prototype carelessly as prop; it will work wrong way,discussion; feature request,2020-11-10 08:22:05 +0000 UTC,LongTengDao,Opened,,"### Version
2.6.12

### Steps to reproduce
```html
<div></div>
<script>
new Vue({
  el: 'main',
  template: '<MyDatetime :value=""datetime"" />',
  data: {
    datetime: Date.now(),
  },
  components: {
    MyDatetime: {
      template: `
        <div>
          expect undefined: {{ toString + """" }}<br />
          expect default: {{ toLocalString + """" }}<br />
        </div>`,
      props: {
        value: {
          type: Number,
        },
        toString: {
          validator: mode => [ 'date-time', 'date', 'time' ].includes(mode),
        },
        toLocalString: {
          validator: mode => [ 'date-time', 'date', 'time', 'default' ].includes(mode),
          default: 'default',
        },
      },
    },
  },
});
</script>
```

### What is expected?

They are all keys match the uni simple rule: not start with `_` or `$`

### What is actually happening?

If parent component doesn't pass the prop, then the component will get neither `undefined` nor `default`, but the value in `Object.prototype`.

---

1. `{}` in these two lines need to be replaced to `Object.create(null)`, the first line is required for two cases, and the second line is required for `default` case,

https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/vdom/helpers/extract-props.js#L24

https://github.com/vuejs/vue/blob/33e669b22f69a1f9c9147528360fe0bba85534f0/src/core/instance/state.js#L66

2. there still leave `constructor` which can't be used, it need `delete Vue.prototype.constructor`, and give an alternative way to do what `vm.constructor` (`Sub.prototype.constructor = Sub`) do in current source code.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
As said in vue-next repo, creating props named like existing functions seems like a bad idea because it could break any code relying on native object functions. It's also unrealistic from a naming perspective.
Because of that, I don't think it's reasonable to use `Object.create(null)` as proposed
--
",,,,,,,,,,
11747,OPEN,It's Impossible to Rename an Inherited Slot,,2021-01-09 15:33:04 +0000 UTC,rodrigogs,In progress,,"### Version
2.6.11

### Reproduction link
[https://github.com/rodrigogs/slots-inheritance-renaming-problem](https://github.com/rodrigogs/slots-inheritance-renaming-problem)







### Steps to reproduce
I created a self-explanatory example in this repository: https://github.com/rodrigogs/slots-inheritance-renaming-problem

But basically, you can't rename inherited slots from a child component. I'm not exactly sure if it should work, so I'm not even sure about it being an issue. But anyway, would be nice to have this working, so I can reuse `vuetify` component slots more sanely.

### What is expected?
Expected to rename the inherited slot by
```html
    <template v-for=""(_, slot) of $scopedSlots"" v-slot:[slot]=""scope"">
      <slot :name=""`renamed-${slot}`"" v-bind=""scope""></slot>
    </template>
```

### What is actually happening?
When using `<template v-slot:renamed-slot1>` the renamed slot is not replaced

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sirlancelot,"
--
This doesn't strike me as something that should be abstracted. I've been been able to successfully ""rename"" slots by using a wrapper component with manually written slot names. By doing so, you create a stronger connection that is well documented.

```vue
<template>
  <some-third-party-component>
    <template #weird-slot-name=""props"">
      <slot name=""sane-name"" v-bind=""props"">Sane Default Slot Content</slot>
    </template>
  </some-third-party-component>
</template>
```
--

--
I think the core of your issue though is that you might be mixing the _direction_ the slots need to be named. Take my example, `weird-slot-name` is a named slot _inside_ `some-third-party-component`. Additionally, `sane-name` is the name of the slot in this component. `$scopedSlots` is a map of slots on _this_ component, not `some-third-party-component`.
--
",rodrigogs,"
--
In my case I'm creating a simples generic CRUD component, and it would be nice to have access to the slots vuetify components already offers me to customize some specific entity fields.

Thing is... in the case of a data table for instance, I do get a dynamic `item.<name>` slot for each item property, so I would have to map everything that I want to expose as slots. Why can't I just rename them dynamically with a js expression since it actually works to expose them with their original names?
--

--
I mean... maybe I'm not doing something that you would recommend at this point. But you have to agree that it would definitely make my life much easier since I'll end up having to map everything dynamically, by basically redoing the work vuetify already does under the hood, or by just using the original slot names and praying to never have a conflicting name.
--

--
> Hi @rodrigogs Is it extremely necessary that you code works with the v-for?
> it, works just fine by doing the following. It did not work with de v-for though.
> 
> ```
> `<template>
>   <ComponentWithSlots>
>     <template v-slot:slot1=""scope"">
>       <slot :name=""`renamed-slot1`"" :scope=""scope""></slot>
>     </template>
>     <template v-slot:slot2=""scope"">
>       <slot :name=""`renamed-slot2`"" :scope=""scope""></slot>
>     </template>
>   </ComponentWithSlots>
> </template>`
> ```
> 
> Did not understand why it doesn't works with v-for.

I'm using slots like this, but the thing is: Not being able to rename dynamic slots seems like a bug to me. Don't you think?
--
",franciscouemura,"
--
Hi @rodrigogs Is it extremely necessary that you code works with the v-for?
it, works just fine by doing the following. It did not work with de v-for though.


```
`<template>
  <ComponentWithSlots>
    <template v-slot:slot1=""scope"">
      <slot :name=""`renamed-slot1`"" :scope=""scope""></slot>
    </template>
    <template v-slot:slot2=""scope"">
      <slot :name=""`renamed-slot2`"" :scope=""scope""></slot>
    </template>
  </ComponentWithSlots>
</template>`
```

Did not understand why it doesn't works with v-for.
--

--
Yeah, I believe it may be a bug. Couldn't make it work dynamically too. We might have to go deeper on this. I've seen another issue that is similar to your problem. I'll leave it here so we have it in mind. Still didn't have the time to read it with full concentration but it seems they might have some common points.

https://github.com/vuejs/vue/issues/11478
--
",,,,,,
11718,OPEN,vuejs/vue-ssr-webpack-plugin and webpack 5,feat:ssr; feature request,2021-04-06 16:34:36 +0000 UTC,borodadada,In progress,,"### What problem does this feature solve?
github missing repository vuejs/vue-ssr-webpack-plugin, i update webpack to version 5 and have error
[vue-server-renderer-webpack-plugin] webpack config `output.libraryTarget` should be ""commonjs2"".


### What does the proposed API look like?
in my output.libraryTarget is libraryTarget: 'commonjs2'

<!-- generated by vue-issues. DO NOT REMOVE -->",,,darkangel081195,"
--
I am facing same issue when updated to webpack 5 today. My current versions are""webpack"": ""5.0.0-rc.6"", ""vue-server-renderer"": ""2.6.10"".
--
",borodadada,"
--
yep.... problem not quit, i use
""webpack"": ""^4.44.2"",
""webpack-cli"": ""^3.3.12""
so sad
--

--
Danail-Irinkov, this fix work fine.  node_modules/vue-server-renderer/  search in files. BUT work only on build mode, my dev mode die. New version webpack-dev-middleware, i don't know how fix.
--
",efremenkovan,"
--
I am facing the same problem. What I found out is that it seem like in webpack 5 ```compiler.options.output.libraryTarget``` was replaced with ```compiler.options.output.library.type```.  Not sure if it's always so 'cause I didn't find any information about that in changelog. To pass the validation I had to change validation function of the loader like this: 
```diff
var validate = function (compiler) {
  if (compiler.options.target !== 'node') {
    warn('webpack config `target` should be ""node"".');
  }
-  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
+  if (compiler.options.output && compiler.options.output.library.type !== 'commonjs2') {
    warn('webpack config `output.libraryTarget` should be ""commonjs2"".');
  }

  if (!compiler.options.externals) {
    tip(
      'It is recommended to externalize dependencies in the server build for ' +
      'better build performance.'
    );
  }
};
```

Also, again, in my case,  entry points are now objects with ```name``` and ```size``` fields. So I had to modify stuff below:

```diff
- var entryAssets = entryInfo.assets.filter(isJS);
+ var entryAssets = entryInfo.assets.filter(file => isJS(file.name));

if (entryAssets.length > 1) {
  throw new Error(
    ""Server-side bundle should have one single entry file. "" +
    ""Avoid using CommonsChunkPlugin in the server config.""
  )
}

var entry = entryAssets[0];
- if (!entry || typeof entry !== 'string') {
+ if (!entry || typeof entry.name !== 'string') {
  throw new Error(
    (""Entry \"""" + entryName + ""\"" not found. Did you specify the correct entry option?"")
  )
}

var bundle = {
+ entry: entry.name,
  files: {},
  maps: {}
};
``` 

After these changes my bundle compiled correctly.
--

--
Also, I think it's worth mentioning that even after my build succeeded I couldn't launch my bundle due to this error: 
```
TypeError: Cannot read property 'file' of undefined
    at {{YOUR_PATH_TO_PROJECT}}/node_modules/vue-server-renderer/build.dev.js:9074:24
```

The problem was in function that starts on line `9056`:
```diff
TemplateRenderer.prototype.renderScripts = function renderScripts (context) {
  var this$1 = this;

  if (this.clientManifest) {
    var initial = this.preloadFiles.filter(function (ref) {
        var file = ref.file;

        return isJS(file);
      });
    var async = (this.getUsedAsyncFiles(context) || []).filter(function (ref) {
        var file = ref.file;

        return isJS(file);
      });
-   var needed = [initial[0]].concat(async, initial.slice(1));
+   var needed = (initial.length ? [initial[0]] : []).concat(async, initial.slice(1));
    return needed.map(function (ref) {
        var file = ref.file;

      return (""<script src=\"""" + (this$1.publicPath) + file + ""\"" defer></script>"")
    }).join('')
  } else {
    return ''
  }
};
```

It failed 'cause for some reason `initial` is now empty.
So `var needed = [initial[0]].concat(async, initial.slice(1));` ended up as `[undefined]`. I fixed this as shown above. And only after that my build launched fine.
--

--
@se22as checkout [this](https://github.com/vuejs/vue/issues/11718#issuecomment-717786088) comment.


> (1)
> `[vue-server-renderer-webpack-plugin] webpack config `output.libraryTarget` should be ""commonjs2"".`
> 
> My libraryTarget does have commonjs2.

This problem is resolved by this code adjustment:
```diff
-  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
+  if (compiler.options.output && compiler.options.output.library.type !== 'commonjs2') {
```
---
 
> (2)
> Error: Entry ""main"" not found. Did you specify the correct entry option?
>     at C:\MY_APP_FOLDER\node_modules\vue-server-renderer\server-plugin.js:76:13
> ```
> 
> I do have the main.js file at src/server/main.js as what is specified in the webpack config

This problem is resolved by this code adjustment:
```diff
- if (!entry || typeof entry !== 'string') {
+ if (!entry || typeof entry.name !== 'string') {
```


**P.S.** You should probably check the comment I linked above to resolve all issues related to this package.
--

--
@se22as yeah, you are right about it being impractical, but there is no other workaround for now. The best thing you can do in case you really want to use webpack 5 in your project - create your own git repo with fixes and use it as plugin placeholder 'till it's updated. But I am not sure if it's worth it. I guess for prod. it's still better to use webpack v4 'cause it's wide support.
--
",wensiyuanseven,"
--
> ### What problem does this feature solve?
> github missing repository vuejs/vue-ssr-webpack-plugin, i update webpack to version 5 and have error
> [vue-server-renderer-webpack-plugin] webpack config `output.libraryTarget` should be ""commonjs2"".
> 
> ### What does the proposed API look like?
> in my output.libraryTarget is libraryTarget: 'commonjs2'

How to solve this problem？
--

--
> I am facing the same problem. What I found out is that it seem like in webpack 5 `compiler.options.output.libraryTarget` was replaced with `compiler.options.output.library.type`. Not sure if it's always so 'cause I didn't find any information about that in changelog. To pass the validation I had to change validation function of the loader like this:
> 
> ```diff
> var validate = function (compiler) {
>   if (compiler.options.target !== 'node') {
>     warn('webpack config `target` should be ""node"".');
>   }
> -  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
> +  if (compiler.options.output && compiler.options.output.library.type !== 'commonjs2') {
>     warn('webpack config `output.libraryTarget` should be ""commonjs2"".');
>   }
> 
>   if (!compiler.options.externals) {
>     tip(
>       'It is recommended to externalize dependencies in the server build for ' +
>       'better build performance.'
>     );
>   }
> };
> ```
> 
> Also, again, in my case, entry points are now objects with `name` and `size` fields. So I had to modify stuff below:
> 
> ```diff
> - var entryAssets = entryInfo.assets.filter(isJS);
> + var entryAssets = entryInfo.assets.filter(file => isJS(file.name));
> 
> if (entryAssets.length > 1) {
>   throw new Error(
>     ""Server-side bundle should have one single entry file. "" +
>     ""Avoid using CommonsChunkPlugin in the server config.""
>   )
> }
> 
> var entry = entryAssets[0];
> - if (!entry || typeof entry !== 'string') {
> + if (!entry || typeof entry.name !== 'string') {
>   throw new Error(
>     (""Entry \"""" + entryName + ""\"" not found. Did you specify the correct entry option?"")
>   )
> }
> 
> var bundle = {
> + entry: entry.name,
>   files: {},
>   maps: {}
> };
> ```
> 
> After these changes my bundle compiled correctly.

thanks
--
",Danail,"
--
Hi guys, facing the same issue. Is an update coming soon?
--

--
Sure I applied the changes in local, but will have to fork for the main server if thats the solution.
however I am still unable to render my routes....
[ { message: '[prerender-spa-plugin] Unable to prerender all routes!',
    details: undefined,
    stack:
     'Error: [prerender-spa-plugin] Unable to prerender all routes!\n    at PrerendererInstance.initialize.th
en.then.then.then.then.then.then.then.catch.err (F:\\PROmo\\PROmo\\promo\\node_modules\\prerender-spa-plugin\
\es6\\index.js:147:33)\n    at process._tickCallback (internal/process/next_tick.js:68:7)' } ]


I am prerendering just my login and signup pages..., I tried excluding some imported elements, but still cant prerender the login page...

It used to work fine before I updated to webpack5

    new PrerenderSPAPlugin({
      staticDir: path.join(__dirname, '../dist'),
      routes: ['/login', '/signup'],
      renderer: new PrerenderSPAPlugin.PuppeteerRenderer({
        renderAfterTime: 5000,
        captureAfterTime: 5000,
        maxConcurrentRoutes: 2,
      }),
      server: {
        port: 5000
      },
      minify: {
        collapseBooleanAttributes: true,
        collapseWhitespace: true,
        decodeEntities: true,
        keepClosingSlash: true,
        sortAttributes: true
      },
    }),
--
",OskarLebuda,"
--
@yyx990803 will you accept Pull Request if we fix it? 
--
"
11715,OPEN,Warn about `this.` used in templates,discussion; feat:compiler; feature request,2020-10-21 08:55:51 +0000 UTC,tstriker,Opened,,"### What problem does this feature solve?
Sometimes when moving the code around, the `this.` can end up traveling with it. Or the finger memory will just type in the `this.` where none is required.

Due to a side-effect, the `this` context is indeed present, but it breaks when it's used deeper in templates (haven't looked exactly, but i think it breaks in v-if's or somewhere around there.

To avoid inadvertent breakages, it would be nice if vue could warn about it.


### What does the proposed API look like?
a `this.` spotted in javascript bits of template would show a warning in the javascript console

<!-- generated by vue-issues. DO NOT REMOVE -->",,,axx0622,"
--
https://github.com/vuejs/vue/issues/11715












艾欣欣
2134328478@qq.com

web前端

---Original---
From: ""Tom Striker""<notifications@github.com&gt;
Date: Thu, Oct 8, 2020 17:35 PM
To: ""vuejs/vue""<vue@noreply.github.com&gt;;
Cc: ""Subscribed""<subscribed@noreply.github.com&gt;;
Subject: [vuejs/vue] Warn about `this.` used in templates (#11715)




 
What problem does this feature solve?
 
Sometimes when moving the code around, the this. can end up traveling with it. Or the finger memory will just type in the this. where none is required.
 
Due to a side-effect, the this context is indeed present, but it breaks when it's used deeper in templates (haven't looked exactly, but i think it breaks in v-if's or somewhere around there.
 
To avoid inadvertent breakages, it would be nice if vue could warn about it.
 
What does the proposed API look like?
 
a this. spotted in javascript bits of template would show a warning in the javascript console
 
—
You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub, or unsubscribe.
--
",,,,,,,,,,
11714,OPEN,$scopedSlots is empty until render(),bug; has PR,2020-10-17 13:47:23 +0000 UTC,KaelWD,Opened,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/kaelwd/pen/rNLNYGL?editors=1011](https://codepen.io/kaelwd/pen/rNLNYGL?editors=1011)







### Steps to reproduce
Open the console

### What is expected?
`""ScopedComponent beforeMount"" true` to be logged

### What is actually happening?
`""ScopedComponent beforeMount"" false`

---
This was discovered in vuetify: https://github.com/vuetifyjs/vuetify/issues/11533#issuecomment-705058227

The real setup is a watcher on a computed property that depends on `$slots`. The watcher is called before mount to get an initial value, causing the computed property to be executed and return an incorrect value. 

Minimal example with the watcher if that helps: https://codepen.io/kaelwd/pen/vYKYWbV?editors=1010

This works as expected in vue 3: https://codepen.io/kaelwd/pen/gOMOXoB?editors=1011

The bug seems to have existed since scoped slots were introduced in v2.1, but it wasn't a problem here until v2.6 when scoped slots started being used everywhere with `v-slot`

<!-- generated by vue-issues. DO NOT REMOVE -->",,,shadowings,"
--
Hello, I fix this bug in PR #11726 .
In before mount, Vue2 will always create an empty object when init render. And in this PR, it will normalize scoped slots when parent vnode is not undefined.
--
",,,,,,,,,,
11713,OPEN,Computed fields for named slots stop working if I add watchers to them,bug,2020-11-17 07:32:30 +0000 UTC,awulkan,In progress,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/serene-thunder-0hxw2?file=/src/components/HelloWorld.vue](https://codesandbox.io/s/serene-thunder-0hxw2?file=/src/components/HelloWorld.vue)







### Steps to reproduce
1. Click the buttons to see that the computed fields work.
2. Uncomment the watcher.
3. Click buttons again and notice that computed fields don't work, and the watcher is never triggered.

### What is expected?
Computed fields work and watcher is triggered.

### What is actually happening?
Computed fields don't work and watcher is never triggered.

<!-- generated by vue-issues. DO NOT REMOVE -->



### Code
App.vue
```vue
<template>
  <div id=""app"">
    <button @click=""slotOneActive = !slotOneActive"">toggle slot</button>

    <HelloWorld>
      <template v-slot:one>
        <span v-if=""slotOneActive"">I am active</span>
      </template>
    </HelloWorld>
  </div>
</template>

<script>
import HelloWorld from ""./components/HelloWorld"";

export default {
  name: ""App"",
  components: {
    HelloWorld,
  },
  data() {
    return {
      slotOneActive: true,
    };
  },
};
</script>

<style>
#app {
  text-align: center;
  margin-top: 60px;
}
</style>
```
HelloWorld.vue
```vue
<template>
  <div>
    <slot name=""one"" />
    <p><strong>computedSlotValue:</strong> {{ computedSlotValue }}</p>
  </div>
</template>

<script>
export default {
  name: ""HelloWorld"",
  computed: {
    computedSlotValue() {
      return !!this.$slots.one;
    },
  },
  // watch: {
  //   computedSlotValue() {
  //     console.log(""watch triggered"");
  //   },
  // },
};
</script>
```

Edit: I updated the code example to make it easier.",,,xiaoyao316,"
--
@awulkan I don't think this is a bug, you should use it like this.  https://vuejs.org/v2/guide/computed.html#Computed-Setter
--
",awulkan,"
--
@xiaoyao316 Thanks for the help, I did not know about computed setters. Wouldn't it be considered bad practice in this case though? In the code above I just do a console.log() in the watcher, but in reality the point was to trigger other methods, which means its sole purpose is to perform side effects.

I wonder how that will work with this ESLint rule: https://eslint.vuejs.org/rules/no-side-effects-in-computed-properties.html

I'll try out your code when I get back to work next week.
--
",jacekkarczmarczyk,"
--
This rule refers only to getters, not setters @awulkan 
--
",xincept,"
--
@awulkan I also think it's a bug. in your code, with watch options, it run like:
#### 1. init computedSlotValue
 add a lazy watcher①, `dirty` is `true` 

#### 2. add custom watcher② for computedSlotValue 
in this step, this watcher② is not lazy, so the getter of `computedSlotValue` is called, watcher①‘s `dirty` is set to be `false`, since `this.$slots` has not be inited (slot is initing in mount func), so no deps is collected for watcher①

#### 3. mount components
`this.$slot` is inited. the getter of `computedSlotValue` is called again. since watcher①‘s `dirty` is  `false`, cached value is used. so, there is still no deps is collected for watcher①
>without watch options, watcher①‘s `dirty` is still `true`, and a dep of `slotOneActive` will be add to watcher① in this step

#### 4. click toggle button
`slotOneActive` changed, but watcher① has not depend on it, so `computedSlotValue` can't be computed again

-----
> P.S.
> you can use `this.$watch('computedSlotValue', ()=>console.log('done'))` in `mounted` hook instead. it works well

--
",,,,
11696,OPEN,Build warnings in Mac OS and Node v12 (development),contribution welcome,2020-10-01 17:19:54 +0000 UTC,markjszy,In progress,,"### Version
2.6.11

### Reproduction link
[https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup)







### Steps to reproduce
On Mac OS Catalina (and probably prior versions), with Node v12 installed, follow the developer build instructions: 

* Clone the repository
* Run `yarn`

### What is expected?
Successful report from `yarn` that all dependencies have been installed, with no warnings or errors

### What is actually happening?
The following warning, followed by a slew of details (errors) concerning `fsevents` and one of its dependencies, `nan`

`warning Error running install script for optional dependency: ""/Users/mark/dev/vue/node_modules/fsevents: Command failed.`

---
Dev dependency installation works fine with Node v10. I think I understand the problem and am curious about the right solution. 
Vue currently specifies `webpack` 4.x and `karma` 3.x as devDependencies, both of which ultimately bring in `chokidar` 2.x, which lists `fsevents` 1.2.x as an optional dependency. 

Old `fsevents` is really the problem, in two ways:
* It references entities that have been removed in Node 12.x (e.g. v8::Handle; see https://github.com/fsevents/fsevents/blob/v1.2.2/fsevents.cc#L89) 
* It relies on `nan` 2.9.x, which also references deprecated/removed entities from the v8 API (e.g. `isNearDeath`). Newer versions of `nan` have addressed this issue. 

I imagine the easiest solution, assuming nothing else breaks, would be to update the `karma` and `webpack` dependencies to some minimal viable version that does away with reliance on these older libs without breaking other expectations. In the meantime, we could also put a note in the build instructions for Mac users noting that they may need to move down to Node v10 if they want to avoid this problem. I understand that this might be obvious to some audience that intends to pitch in with Vue development in the first place, but it might help some.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Contribution welcome to update the minimal dependencies in package.json (without committing changes to `yarn.lock`) so the project works on Node.js 12
--
",ArjunDandagi,"
--
@posva  i can take this up ,please guide me what needs to be updated
--
",markjszy,"
--
@ArjunDandagi unless @posva  thinks otherwise, I believe the two deps that need to be bumped up (due to their own indirect deps on old fsevents) are `webpack` and `karma`
--
",,,,,,
11666,OPEN,Add feature to catch errors in a production build for compatibility with external error tracking,feature request,2020-09-28 15:30:23 +0000 UTC,ssmulders,In progress,,"### What problem does this feature solve?
Currently all warnings are suppressed when Vue is built with `process.env.NODE_ENV === production`. However,  many warnings are more severe than a warning - they break functionality. Duplicate keys are a good example. These are hard to filter out in a development environment because the production data could be different. 

I'm currently working on a project where parts of the API and corresponding data are over 15 years old.

This means that when a user triggers an error, we're flying blind. No errors are reported. We recently implemented Sentry (which we already ran for Laravel) but again, no errorHandler or warningHandler is triggered.

What I would have liked was a way for us to see the error in production, but not show it to the user in their console. The error and warning handlers are perfect for this purpose, but lack this feature.

After extensively digging through the code and making alterations I've been able to create a production build that outputs warnings and errors. Without activating development features (like devtools, perf traces etc.) - just the warnings. No loss in performance. But it took tweaking both the Vue core files and the `component-compiler-utils`.

Still, it's possible, and for us, running Vue at scale, with many unknown variables - it's a must have. With these Sentries (or whatever bug tracker someone would choose) it's easy to quickly zero in on production bugs. So I'd love to improve on our solution, push it to the main repo and give back to your awesome framework :-)



### What does the proposed API look like?
My proposal is to add a new `process.env` variable called `DEBUG_LEVEL`, `WARN_LEVEL` or something along those lines. Maybe a config setting. Something simple. With it you can pick your desired verbosity. When set to FULL, it's identical to the development build. When set to HANDLER it will only trigger custom handlers (which would then be where you'd call the Sentry / error tracker). This allows for more granular control over what is triggered, and how it's shown. And then the final setting would be NONE. Which would be identical to the current production build.

Currently the `process.env.NODE_ENV` controls both the warnings _and_ the debug tools. My proposal is to separate the two. 

I've already done most of the leg-work. With your thumbs-up I will clean things up, write tests and push it to the dev branch.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This probably should go through a detailed RFC (vuejs/rfcs)
--
",ssmulders,"
--
Will do. Currently still exploring and mapping the full scope of the issue. Even compile errors get ignored leading to non-functioning output without any feedback. To me, this feels weird. Granted, compile errors will surface in a local dev build. But still, if you run a CI/CD pipeline with a build test (like we do), it undeservedly passes.
--

--
Still working on this. Another thing I discovered is the lack of warning / debug information on IE11 due to the usage of Proxy. One of the few things you can't polyfill. The errorHandler works, but the warningHandler, doesn't - it's unsupported. Couldn't find any mention of this in the documentation.
--
",,,,,,,,
11654,OPEN,transition-group with flex parent causes removed items to fly,transition,2020-09-29 10:20:09 +0000 UTC,turbosheep44,In progress,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/turboSheep/pen/OJNQGEG](https://codepen.io/turboSheep/pen/OJNQGEG)







### Steps to reproduce
Click the 'Remove Multiple' or 'Remove First 2' buttons and observe the movement of the items.

### What is expected?
The rectangles being removed should fade out on the spot.

### What is actually happening?
The rectangles fade out and also move to various locations on the canvas.

---
Observe that if the items 1 and 2 are to be removed, then the events fired in the following order:

```
before-leave#1
leave#1
before-leave#2
leave#2
```

This means that `beforeLeave` for the second element is called after `leave` is called for the first element. So when `beforeLeave` is called for the second element, the first element already has `position: absolute`. This means that (while the DOM has not yet rendered the change) the position of the second element has moved to be where the first element used to be, meaning that `el.offsetLeft` is now 'incorrect'. The visual effect is that the first two elements both float to the same position. 

This can be shown clearly by clicking the 'Remove First 2' button.

<!-- generated by vue-issues. DO NOT REMOVE -->

Similar behaviour has been documented by issue #9713 but the issue was quickly closed in March 2019 with a workaround posted in Jan 2020. ",,,codewithbug,"
--
if i understood correctly , when the element inside the ""transition"" component is removed  , firstly the transition classes will be added to that element. it mentions in the documentation:

    When an element wrapped in a transition component is inserted or removed, this is what happens:

    Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition 
    classes will be added/removed at appropriate timings.

    If the transition component provided JavaScript hooks, these hooks will be called at appropriate timings.

    If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or 
    removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue’s concept of 
    nextTick).

--
",turbosheep44,"
--
Yes, I agree that this behaviour is correct as far as documentation is concerned. However, this visually causes the fading elements to jump around as described above. 

I want to know whether there is a way to get the desired effect (no elements jumping around when transitioning out) using the current Vue version and if not, to bring this to the attention of a developer who knows to/can point me in the direction of adding the necessary feature.
--
",,,,,,,,
11652,OPEN,slot is reused with v-if/v-else,bug; has PR; has workaround,2020-11-27 09:22:03 +0000 UTC,jiankafei,In progress,,"### Version
2.6.12

### Reproduction link
[https://codepen.io/jiankafei/pen/jOqZdpG](https://codepen.io/jiankafei/pen/jOqZdpG)







### Steps to reproduce

Click the switch button, it will switch between two components with slots and without slots. The components without slots should not appear the slots passed to the components with slots

### What is expected?

Should display the fallback slot

### What is actually happening?

Displays the previous slot

---


<!-- generated by vue-issues. DO NOT REMOVE -->",,,jacekkarczmarczyk,"
--
https://codepen.io/jkarczm/pen/WNwMmZy
--
",posva,"
--
The workaround is to use a `key` on `alert-box` so Vue doesn't reuse it
--

--
as long as no PR has been submitted anybody can take any bug and give it a try 🙂 
--
",jiankafei,"
--
@jacekkarczmarczyk @posva 三克油
--
",piotrzarycki,"
--
hmm, this bug should be fixed, if yes, can i take this? :) 
--
",,,,
11635,OPEN,`vnode.data.on` is empty for custom components,,2020-09-02 07:42:50 +0000 UTC,posva,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/ck6qgezv/](https://jsfiddle.net/ck6qgezv/)







### Steps to reproduce
- check the logs

### What is expected?
Both should be able to log `vnode.data.on`

### What is actually happening?
Only the component with a native event attached does

---
From https://github.com/vuejs/vue-router/issues/3308

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11612,OPEN,TemplateRender.renderScripts breaks when there are no preloaded files (empty array),,2020-08-25 22:25:57 +0000 UTC,john-ko,Opened,,"### Version
2.6.11

### Reproduction link
[https://github.com/john-ko/vue/commit/f955d9e96ef35fa8609c126501ac0d7f90ee9bc4](https://github.com/john-ko/vue/commit/f955d9e96ef35fa8609c126501ac0d7f90ee9bc4)







### Steps to reproduce
the client manifest must have its `inital` array empty

### What is expected?
not to crash due to empty array

### What is actually happening?
in `src/server/template-renderer/index.js` line 227~

`const needed = [initial[0]].concat(async, initial.slice(1))`
given initial as empty array needed becomes

```
[ undefined, {...}, {...}]
```

when it destructures `{ file }` which is transpiled down to 
ref.file it fails

<!-- generated by vue-issues. DO NOT REMOVE -->",,,john,"
--
created a pull request along with a unit test
https://github.com/vuejs/vue/pull/11613
--
",,,,,,,,,,
11601,OPEN,Native modifier for props,discussion; feature request,2020-10-04 10:45:57 +0000 UTC,Tofandel,In progress,,"### What problem does this feature solve?
Consider the following component
```vue
<template>
 <div>
  {{title}}
 </div>
</template>

<script>
export default {
  name: 'awesomeTitle',
  props: {
    title: String
  }
}
</script>
```

When using this component it now becomes impossible to set the title html attribute on the div

```html
<awesomeTitle title=""Hello world"" title.native=""Oopsy""/>
```

This would just output
```html
<div title.native=""Oopsy"">Hello world</div>
```
Instead of 
```html
<div title=""Oopsy"">Hello world</div>
```

Adding the native modifier for props would permit to avoid collision between html attributes and vue props.
It already exists for event listeners so it would also be more coherent.

Sometime libraries will forget that html attributes inheritance is a thing and adding some html attributes becomes impossible in those components, it will also make the component more future proof in case new html attributes are added in the spec as you don't have to worry about future collisions anymore

### What does the proposed API look like?

```html
<awesomeTitle title=""Hello world"" title.native=""Oopsy""/>
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Using a prop with the same name as a native attribute when you want to allow that attribute is confusing. But I think this is worth going through an RFC to gather feedback: https://github.com/vuejs/rfcs
--

--
The prop modifier is not a hack. It will work with attributes that have a property equivalent
--
",jacekkarczmarczyk,"
--
`.prop` seems to work, but only with binding, not sure if it's intended
https://codepen.io/jkarczm/pen/rNeLyLG?editors=1010
--
",Tofandel,"
--
@jacekkarczmarczyk Pretty sure it's not and is just a weird side effect but at least this issue got a very hackish workaround for now
--

--
@jacekkarczmarczyk Modifiers for props only seem to apply for bindings and not normal attribute, seems like a bug in which case this issue could be solved using the prop modifier which apparently already exist
--

--
@posva I just mean it's hackish that it works only with binding so you have to use quotes and single quote
--
",,,,,,
11569,OPEN,Safari doesn't see frame inside vue app,bug; has PR; has workaround,2020-08-08 17:58:20 +0000 UTC,dscherbakov,Opened,,"### Version
2.6.11

### Reproduction link

https://jsfiddle.net/posva/vczwh82g/2/







### Steps to reproduce

In Safari click different links to load iframes

### What is expected?

all iframes should load

### What is actually happening?

the one rendered inside vue doesn't load
<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is weird. I would guess Vue is adding some attribute or property that is making this fail in Safari but can't tell which one
--

--
for sure @christoph-schaeffer !
--
",christoph,"
--
Hey @posva may i give this a shot? i'd like to contribute
--

--
I've created a PR with a detailed explanation on what caused this.
--
",,,,,,,,
11533,OPEN,Vue SSR v-html on dynamic-component hydration warning,bug; feat:ssr; has workaround,2020-08-12 02:57:49 +0000 UTC,privatenumber,Opened,,"### Version
2.6.11

### Reproduction link
The reproduction is updated to use Vue SSR without NUXT
[https://github.com/privatenumber/vue-ssr-vhtml-dyncomp-bug](https://github.com/privatenumber/vue-ssr-vhtml-dyncomp-bug)

### Steps to reproduce
_Dynamic.vue_
```vue
<template>
  <component is=""div"">
    content necessary
  </component>
</template>
```

_App.vue_
```vue
<template>
  <dynamic v-html=""'<div>trigger hydration warning</div>'"" />
</template>
```

### What is expected?
The expected behavior is for there to be no hydration warning when the SSR and client markup are identical.


### What is actually happening?
Although there isn't a discrepancy in rendered HTML between client and SSR, it gives warnings that there is.

![warningD](https://user-images.githubusercontent.com/1075694/88136132-a28f2d00-cbb6-11ea-84db-f38d0bf3adf3.png)
![warningE](https://user-images.githubusercontent.com/1075694/88136136-a327c380-cbb6-11ea-81e6-b3830645de60.png)

### Work around
I used a [render function](https://vuejs.org/v2/guide/render-function.html) instead of a dynamic-component:
```
render(h) {
    return h(this.component, this.$slots.default);
}
```

### Other info
Previous issue: https://github.com/vuejs/vue/issues/11532


<!-- generated by vue-issues. DO NOT REMOVE -->",,,arshaw,"
--
nice bug report. very thorough
--
",,,,,,,,,,
11478,OPEN,Passing slots through in wrapper component,,2020-12-16 16:50:17 +0000 UTC,tminich,Opened,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/romantic-mahavira-1s4v6](https://codesandbox.io/s/romantic-mahavira-1s4v6)







### Steps to reproduce
See the content below ""Wrapper""

### What is expected?
All three variants, deprecated and new syntax in either order, should produce the same result

### What is actually happening?
All produce different results. In the example the final 'new syntax' variant seems fine, but it doesn't work with Vuetify (not sure if this should be considered their issue ore Vue's)

---
Passing slots through to child components is, according to what you usually find on the net, done with this syntax:

```
<slot v-for=""(_, name) in $slots"" :name=""name"" :slot=""name"" />
<template v-for=""(_, name) in $scopedSlots"" :slot=""name"" slot-scope=""slotData""><slot :name=""name"" v-bind=""slotData"" /></template>
```
Unfortunately this uses the slot and slot-scope attributes which are marked as deprecated.
As a current replacement, the following syntax seems to be the correct one:
```
<template v-for=""(_, name) in $scopedSlots"" v-slot:[name]=""slotData"">
  <slot :name=""name"" v-bind=""slotData""/>
</template>
<template v-for=""(_, name) in $slots"" v-slot:[name]>
  <slot :name=""name""/>
</template>
```
Unfortunately this does not give the same result as the old syntax. Depending on the order in which scoped and non-scoped slots are passed, either scoped slots are not passed at all or non-scoped slots are only passed in $scopedSlots, which Vuetify (and maybe other libraries?) ignores for slots that are not supposed to be scoped.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,nandin,"
--
I've achieved behavioral consistency among three variants by renaming second iteration element to something other than `name`. What I have noticed from analyzing AST generated from `TestWrapper` is: for some reason, likely a bug, `v-slot:[name]` in second iteration (i.e. `v-for`) unexpectedly overrides the former one and results in this inconsistency.

You are likely to be able to ""tweak"" your problem at hand by renaming the iteration variable:
```vue
<template v-for=""(_, name) in $scopedSlots"" v-slot:[name]=""slotData"">
  <slot :name=""name"" v-bind=""slotData""/>
</template>
<template v-for=""(_, someOtherName) in $slots"" v-slot:[someOtherName]>
  <slot :name=""someOtherName""/>
</template>
```

I'd dig deeper to find the underlying problem, but hope this tweak could help you meanwhile.

---

Update:

Following facts together lead to the inconsistency OP described:
1. Any slot content denoted by the new syntax `v-slot` is considered as scoped slot in AST (likely for performance optimization). 
https://github.com/vuejs/vue/blob/ef56410a2ca19641bd96bbc04056219fbc0bcb3e/src/compiler/parser/index.js#L665
2. Scoped slots are collected at their parent AST node (`test-component` node for this case), indexed by their name (i.e. the part after the colon in the `v-slot` syntax). And dynamic names (those surrounded by brackets) are not treated specially when being a map index.
https://github.com/vuejs/vue/blob/ef56410a2ca19641bd96bbc04056219fbc0bcb3e/src/compiler/parser/index.js#L663
https://github.com/vuejs/vue/blob/ef56410a2ca19641bd96bbc04056219fbc0bcb3e/src/compiler/parser/index.js#L142-L147
3. As for deprecated old syntax `<slot :slot=""name"">`, this `slot` node is treated as a child node of `test-component` node on AST, thus separated from the scoped slots collected by `test-component`.

Fact 1 and 2 causes second iteration in one `test-component` to override the first iteration's contribution to `scopedSlot` property of `test-component` node, as long as the second iteration uses same identifier as the first one for the iteration element.
Fact 3 happened to prevent this collision by treating `<slot :slot=""name"">` as a child node.

I want to ping @yyx990803 here to ask for a comment on this. Whether it should be considered ""working as intended"" or as a bug? 
--
",erichorne,"
--
I think I'm running into a similar issue here in 2.6.12. Using the `v-slot:[scopedSlot]=""slotData""` syntax in the template, slots provided without any slot properties do not get passed on. 
`<template v-for=""(_, scopedSlot) of $scopedSlots"" v-slot:[scopedSlot]=""slotProps""><slot :name=""scopedSlot"" v-bind=""slotProps""></slot></template>`

will not pass through when the parent stipulates: 
`<test-component><template #label>my label</template></test-component>`
but it will pass through when the parent stipulates:
`<test-component><template #item={item}>My item: {{item}}</template></test-component>`

However, the first stipulation (`#label`) will pass through if the test-component does not assign slotProps, like so:
`<template v-for=""(_, scopedSlot) of $scopedSlots"" v-slot:[scopedSlot]><slot :name=""scopedSlot""></slot></template>`

I've tried `v-slot:[scopedSlot]=""{p = {}}""`, `v-slot:[scopedSlot]=""p""`, `v-slot:[scopedSlot]=""p={}""` and `v-slot:[scopedSlot]=""{...p}""`, but none of these combinations work (and the raw `p={}` fails to compile even though that is a value function parameter expression). I was surprised that `{...p}` didn't work.  

For now, I use @Nandiin's workaround of different names with $scopedSlots and $slots even though we really aren't supposed to use $slots anymore, at least not in 2.6.x
--
",,,,,,,,
11454,OPEN,PropType doesn't take undefined for optional props into account,improvement; typescript,2020-06-20 01:24:14 +0000 UTC,jacekkarczmarczyk,In progress,,"### Version
2.6.11

### Steps to reproduce
Create component with optional prop being an object and try to access its property

```ts
import Vue, { PropType } from 'vue';

Vue.extend({
  props: {
    container: Object as PropType<{ n: number }>,
    // or container: Number
  },

  mounted () {
    // should fail because this.container could be undefined
    console.log(this.container.n);
  },
});
```


### What is expected?
TS error: Object is possibly undefined

### What is actually happening?
No error

### Note

It works as expected with Composition API plugin

![image](https://user-images.githubusercontent.com/15625235/84488979-496fd780-aca1-11ea-9cd1-3f96ebdbdc28.png)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,jacekkarczmarczyk,"
--
@posva you mean vue behaviour is correct and VCA behaviour is not?
--

--
I originally created this issue in vue repo (not vue-next), I'm not sure why @posva moved it here
In plain vue your example shows `number`, but IMHO it should be `number | undefined`, just like in VCA and vue-next

![image](https://user-images.githubusercontent.com/15625235/84495904-4b8b6380-acac-11ea-868e-8218b1f21f29.png)

--

--
Yeah, I guess I didn't emphasised actual problem clear enough, sorry and thanks 
--

--
BWT - since `type: Number` reproduces the problem as well I think `PropType` in the issue title is not necessary, not sure how what title would be more appropriate though
--
",antfu,"
--
Hi @jacekkarczmarczyk, what's the `Object as PropTypeVCA<{ foo: number }>` are for? 

Do you mean:

```ts
defineComponent({
  props: {
    foo: {
      type: Number
    }
  },
  setup (props) {
    console.log(props.foo) // number | undefined  in both VCA and vue-next
  },
})
```
--
",posva,"
--
Sorry, because you focused on the composition-api error, it confused me
--

--
I edited the code sample to reproduce to not include the Composition API plugin
--
",,,,,,
11449,OPEN,Double escaping of ssrNode in style attribute values,,2020-09-18 03:44:51 +0000 UTC,kamilic,In progress,,"### Version
2.6.11

### Reproduction link
[https://github.com/kamilic/vue/tree/style-attr-escaped](https://github.com/kamilic/vue/tree/style-attr-escaped)

### Steps to reproduce
You can add this unit test at `./test/ssr/ssr-string.spec.js` in Vue project.

```javascript
it('should not double escape style attribute values', done => {
    renderVmWithOptions({
      template: `
      <div>
        <div style=""background: url(https://foo.bar/foo.png) no-repeat center center;\nbackground-size: cover;""></div>
      </div>
      `
    }, result => {
      expect(result).toContain(`<div style=""background: url(https://foo.bar/foo.png) no-repeat center center;background-size: cover;""></div>`)
      done()
    })
  });
```

or

clone the library and checkout to `style-attr-escaped` branch and run.

```bash
npm run test:ssr
```

result:
![image](https://user-images.githubusercontent.com/8327041/84263892-e708c100-ab52-11ea-933c-151b484fe275.png)

### What is expected?
No double escaping of ssrNode in style attribute values

### What is actually happening?
style attribute will be escaped.

---
This issues may be related to #7224;  
https://github.com/vuejs/vue/pull/7224

<!-- generated by vue-issues. DO NOT REMOVE -->",,,kamilic,"
--
I tried to change this line (https://github.com/vuejs/vue/blob/dev/src/server/optimizing-compiler/modules.js#L109) to
```javascript
return [{ type: RAW, value: ` style=${JSON.stringify(staticStyle.replace(/\n/g, ''))}` }];
``` 

It works, but I don't know it whether match expected behavior. 

--

--
any reply?????
--

--
any reply?? 
--
",gaodeng,"
--
any news?
--
",,,,,,,,
11446,OPEN,Line breaks in textarea are excessively removed.,bug,2020-06-16 12:45:09 +0000 UTC,KUBOTAfumiya,Opened,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/kubotafumiya/pen/qBOwEOV](https://codepen.io/kubotafumiya/pen/qBOwEOV)







### Steps to reproduce
1. Set the el option to an element that contains a textarea (or pre) with a newline at the beginning, and  create a Vue instance.


```html
<div id=""app"">
<textarea>


Three line breaks are ignored.
</textarea>
</div>
```

```javascript
new Vue({
  el: '#app',
});
```

### What is expected?
The line breaks are removed.


### What is actually happening?
Line breaks are not deleted.

---
https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions

I think it's okay for a single line break to be ignored according to this specification.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,wonhyoung05,"
--
I found the reason. Can i take this issue.
--
",posva,"
--
@wonhyoung05 Yes, I couldn't find an existing issue or PR for this problem
--
",,,,,,,,
11410,OPEN,createCompileToFunctionFn uses unpurgable cache that can cause memory leaks,,2020-05-24 16:03:51 +0000 UTC,aKzenT,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/rhmcwgk9/](https://jsfiddle.net/rhmcwgk9/)







### Steps to reproduce
When using SSR from other frameworks such as ASP.NET it is not uncommon to pass templates to the render process that contain dynamic strings in itself (e.g. the template stirng itself is different for each call/user). The createCompileToFunctionFn uses an internal ""cache"" object which has no limitations and therefore creates a memory leak when used with such dynamic templates.

### What is expected?
The implementation uses a limited cache (e.g. LRU) or allows passing a custom cache object.

### What is actually happening?
The cache is a simple ""object"" created internally without any way to influence.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11398,OPEN,Node attribute value is not reactive after client side hydration,,2020-05-18 10:55:58 +0000 UTC,berniegp,In progress,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/ssr-reactivity-up6nh?file=/pages/index.vue](https://codesandbox.io/s/ssr-reactivity-up6nh?file=/pages/index.vue)







### Steps to reproduce
- The id attribute of the `div` does not match the myid value from the component (requires page refresh sometimes on first load).
- Notice that `$forceUpdate()` (first button) does not update the id attribute of the `div`
- Changing the value of the `val` data (second button) property triggers the reactivity


### What is expected?
Every reference to the `myid` computed property should match

### What is actually happening?
The id attribute of the `div` does not match the `myid` value

---
The same component used in client-side rendering does not exhibit this issue.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I don't think it's possible to use random values with hydration like that because the html rendered by the server should be the same as the one generated by the client. By using random values, you are pretty much forcing an hydration mismatch because they will (almost) always differ. But I don't understand why there is no error
--

--
> The point is that if val == X on the server side and val == Y on the client-side after hydration

It has to really be **after** hydration. In that case it might be related to one of these linked issues https://github.com/vuejs/vue/issues/10260 (see linked issues as well)
--
",cinsanity,"
--
The value of val in data is a certain value after initialization, so when run $forceUpdate() will not run Math.floor(Math.random() * 10000000), the value of val is not changed.
--
",berniegp,"
--
@posva Perhaps I shouldn't have used `Math.random()`. The point is that if `val == X` on the server side and `val == Y` on the client-side after hydration, most parts of the component are updated reactively while the `id` attribute of the `div` is not. I can modify the example to use something else than random values if it helps, but it doesn't materially change the (alleged) bug I'm describing.
--

--
@cinsanity I'm not sure I understand. I attached a screenshot to give more details.

![chrome_2020-05-18_12-34-22](https://user-images.githubusercontent.com/881558/82203922-4aad1f00-9904-11ea-9860-d528fb563049.png)

I expected `$forceUpdate()` to make all the id values match when forcing a re-render, but it does not. Only changing `val` successfully synchronizes all the ids.
--

--
@posva yeah it looks similar to #10260, but I'm not knowledgeable enough about Vue internals to be sure.

I did update my repro to use `Vue.prototype.$isServer` instead of `Math.random()` for greater clarity.
--

--
I am very curious about why `$forceUpdate()` doesn't update the `div`'s `id` though.
--
",,,,,,
11389,OPEN,RangeError: Maximum call stack size exceeded,,2020-09-22 12:22:45 +0000 UTC,sandipbiswasbehala,In progress,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/rwg4k2ns/](https://jsfiddle.net/rwg4k2ns/)


not working only in chorme desktop 81.XXX. working in firefox,edge , mobile chrome.




### Steps to reproduce
Below snippet in .js file not working and getting RangeError: Maximum call stack size exceeded
v-for=""n in 200000""
:key=""n"">Hello World {{ n }}

Workig : no error
v-for=""n in 100000""
:key=""n"">Hello World {{ n }}

### What is expected?
list will be shown

### What is actually happening?
getting RangeError: Maximum call stack size exceeded

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sandipbiswasbehala,"
--
please comment back any one form vue team
--

--
@mhrabiee 
thanks. 
--
",albertodeago,"
--
@sandipbiswasbehala I don't think opening an issue and asking the same day for a response is nice.
Anyway, you're saying the problem is trying to show 200,000 items...  
That's a large amount of items to render... Have you considered using a virtual scroller like [this](https://github.com/Akryum/vue-virtual-scroller) or [this](https://github.com/albertodeago/vue-virtualized-list)?
--
",mhrabiee,"
--
@sandipbiswasbehala As @albertodeago mentioned, it's not really a good idea to render such a large amount of items and it's better to change your UI design and/or architecture, however you can fix this particular issue simply putting your items inside a parent element. 

So instead of:
```js
var app = new Vue({
  el: '#app',
  template: `
  <div>
      <span>Details:</span>
      <div v-for=""n in 200000"" :key=""n"">Hello World {{ n }}</div>
  </div>
  `
});
```

You should use:
```js
var app = new Vue({
  el: '#app',
  template: `
  <div>
      <span>Details:</span>
      <div>
          <div v-for=""n in 200000"" :key=""n"">Hello World {{ n }}</div>
      </div>
  </div>
  `
});
```

Working Example (Tested in Chrome Desktop 81 and Chrome Desktop 83)
https://jsfiddle.net/mhrabiee/g8n7er60/7
--

--
This issue can be closed.
--
",czf1998,"
--
please comment back any one form vue team
--

--
This issue can be closed.
please comment back any one form vue team.
--
",chumager,"
--
Hi, my problem as in #11675 is not trying to deploy several components who does the same, my problem is more like complex components who uses several other components so I don't need to show 200k components to crush, just change page on my table and the error is the same...

Even tough, it applies to the sum of components shown in the SPA, I've tested it with 20, 50 and 100 items per page and in all options it crush sooner or later when move between pages (in the table).

maybe my case is more memleak than the capacity of render components and in the edge case looks the same.  

I've done several memory test and the DOM elements between pages keeps around 0 (X added and X deleted), but (array) and (closure) keeps growing.

I'll repeat the test and upload some screenshots, because the snapshots are around 0.5 GB.

Regards
--
",,
11376,OPEN,TransitionGroup transition doesn't work when elements are 3D transformed,,2020-10-05 21:56:23 +0000 UTC,davestewart,In progress,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/smoosh-worker-kx6vo](https://codesandbox.io/s/smoosh-worker-kx6vo)

### Steps to reproduce
Run the demo and click the buttons for the 2D / 3D and normal (red) and patched (green) versions of the list.

### What is expected?
The items in the 3D transformed list (red) should transition smoothly from the start to the end position.

### What is actually happening?
The transition is extremely wonky!

---
Transition Group uses `getBoundingClientRect()` to get the relative transforms of the transition items. Unfortunately, this uses document space, not the local (parent) space, which gives the wrong result for a transition when transformed:

https://github.com/vuejs/vue/blob/8a2dbf50105ea729125a42fecfe2c2f0371d7836/src/platforms/web/runtime/components/transition-group.js#L176

### Fix

Using a simple `getOffsetPosition()` function allows the transition to get the correct transformation values:

```js
function getOffsetPosition (el) {
  return {
    left: el.offsetLeft,
    top: el.offsetTop
  }
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,RedHoodJT1988,"
--
Hello, I would like to help with this issue but I am not sure what the issue is. It seems as though it has already been fixed. Please give more information on the issue if it is indeed still not fixed. Thanks.
--

--
Ok cool. I would like to try to work on this if that is ok?
--

--
I'm actually more interested in just contributing to Vue as a whole but if it counts towards Hacktoberfest then that is a bonus. 
--

--
Makes sense. No problem. 
--
",davestewart,"
--
Hey @RedHoodJT1988 - nope - still an in issue in the latest 2.x branch
--

--
Ah, Hactober fest?
--

--
I'd forgotten I'd posted this actually. Seeing as I also posted the fix, I'll probably just PR it myself.
--

--
Thanks for reminding me it exists!

I'm using a monkey patch in my project, so probably the perfect time pick it up again 👍 
--

--
Hey @RedHoodJT1988 - if you want to split the work; it looks like transition exhibits the same issue in Vue 3, and the monkey patch in the demo file doesn't work, so that would need investigating:

https://codesandbox.io/s/solitary-morning-80beb?file=/src/main.js

I don't have the time to find out why this is, so you could start on that if you like?
--
",,,,,,,,
11375,OPEN,.prop v-bind modifier shorthand throws DOMException,,2020-05-05 19:39:10 +0000 UTC,auzmartist,In progress,,"### Version
2.6.11

### Reproduction link
[Codesandbox: vue-hybrids .prop shorthand](https://codesandbox.io/s/vue-hybrids-prop-shorthand-dzis6?file=/src/App.vue)


### Steps to reproduce
If you uncomment the second <dynamic-prop-test> element, you'll see an error:

> DOMException: Failed to execute 'setAttribute' on 'Element': '.num' is not a valid attribute name.


### What is expected?
`.num` should be an equivalent shorthand for `:num.prop`

### What is actually happening?
Vue throws a DOMException when trying to set a `.num` attribute on the element during render.

---
It appears that this feature was added as a feature request for 2.6:
https://github.com/vuejs/vue/issues/7582

There, @trusktr documented that because `.` characters are disallowed in attribute names, the shorthand syntax would not ""...get in the way of DOM usage.""

I believe the error this time around is that the Vue render function is parsing the `.num` attribute and attempting to set the same attribute in the DOM without first checking for the .prop shorthand and attempting to set the property of the rendered element directly.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It looks like this was added on https://github.com/vuejs/vue/releases/tag/v2.6.0-beta.1 but never made it to the next release v2.6.0
--
",auzmartist,"
--
Oh bummer. Any indication as to why it didn't make it? It would be a killer syntax feature and much appreciated among Vue users looking to instrument their templates with components.
--
",,,,,,,,
11359,OPEN,Add option to keep whitespace between elements regardless of new lines (vue-template-compiler),,2020-06-17 01:53:05 +0000 UTC,troxler,In progress,,"### What problem does this feature solve?
The [`whitespace` option of vue-template-compiler](https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#options) currently allows `preserve` and `condense` (default in Vue CLI). While `condense` will result in smaller code size, it also breaks a common way to structure HTML as it removes all whitespace between elements *if it contains new lines*.

Please add an option that condenses all whitespace between elements into a single space *regardless of whether it contains new lines*. Such an option might also be the better default than `condense` as it is closer to what you would expect from your HTML.

Example using Vue CLI with the default `condense` option:

```html
<p>
  <span>1</span> <span>a</span>
</p>

<p>
  <span>2</span>
  <span>b</span>
</p>

<p>
  <span>3</span>
  <span>
    c
  </span>
</p>
```

This results in the following output in the browser:

```
1 a
2b
3 c 
```

As you can see, there is no whitespace between `2b`. While this behaviour is properly documented in the vue-template-compiler docs, it is not intuitive. Structuring HTML like in `2` is very common and it should not be necessary to restructure it like `3`. In addition to being unintuitive, it is currently very hard to find out which package with which configuration and which default options is actually responsible for that behaviour. It is thus super hard to reconfigure your setup according to your needs. And even if you manage to do that, you must decide between no minification with `preserve` and minification that might break your HTML with `condense`. I think there should be a middle ground.

### What does the proposed API look like?
Introduce an option `condense-keep` or similar. Using that instead of `condense` will always keep one whitespace between elements regardless of any new lines.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,troxler,"
--
When using the Vue CLI, the default `condense` option can be changed to `preserve` by adding the following configuration to vue.config.js:

```js
module.exports = {
    chainWebpack: config => {
        config.module
            .rule('vue')
            .use('vue-loader')
            .loader('vue-loader')
            .tap(options => {
                options.compilerOptions.whitespace = 'preserve';
                return options;
            });
    },
};
```

--
",diachedelic,"
--
`whitespace = 'preserve'` fixes the issue if you are only using `<span>` elements, but if I try either

```html
<p>
  <b>Name:</b>
  <span>Joe</span>
</p>

or

<p>
  <span>Stuff</span>
  <svg>...</svg>
</p>
```

the space is still removed (using `vue-template-compiler@2.6.11`)

Edit: actually, I needed to delete `./node_modules/.cache` for `'preserve'` to fully take effect
--
",,,,,,,,
11357,OPEN,`src` attribute of `img` inside `picture` should be set after `img` is appended to `picture` to avoid unnecessary requests,browser quirks; improvement,2020-07-15 09:41:58 +0000 UTC,CaseJnr,In progress,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/CaseJnr/pen/VwvWbPE](https://codepen.io/CaseJnr/pen/VwvWbPE)







### Steps to reproduce
1. Open the codepen link in safari

2. Inspect the element

3. Reduce the view width below 900px and refresh the page

4. You will notice that both the red and blue image is requested.

5. Comment out the vue instance and refresh the page.

6. You will notice only the red image is requested (as expected).




### What is expected?
Only the required picture resource is requested. 

### What is actually happening?
Both of the pictures resources are requested, causing redundant downloads.

---
In Safari, adding a vue instance to any page will cause redundant picture sources to be requested. The picture element will behave correctly if the vue instance is removed.


E.g.


&#x3C;picture&#x3E;
    &#x3C;source media=&#x22;(max-width: 900px)&#x22; srcset=&#x22;small.jpg&#x22;&#x3E;
    &#x3C;img src=&#x22;large.jpg&#x22; alt=&#x22;&#x22;&#x3E;
  &#x3C;/picture&#x3E;



By default, only the small.jpg should be requested when the view width is below 900px. However, if a vue instance is added to the page, then both the small.jpg and large.jpg are requested.

The mobile inspector shows the small.jpg request initiator as the page (expected). The large.jpg initiator is actually the vue instance.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It seems to happen with vanilla JS:

```js
if(document.getElementById(""app"")) {
  // new Vue({ el: '#app'});
}

let picture = document.createElement('picture')
let s1 = document.createElement('source')
s1.media = '(max-width: 900px)'
s1.srcset = ""https://www.abc.net.au/radionational/image/6289622-4x3-340x255.png""

let s2 = document.createElement('img')
s2.src = ""https://www.solidbackgrounds.com/images/2560x1440/2560x1440-brandeis-blue-solid-color-background.jpg""
s2.alt =''

picture.appendChild(s1)
picture.appendChild(s2)

window.app.innerHTML = 'new'
window.app.appendChild(picture)
```

Could you open a bug report at https://bugs.webkit.org please?
--

--
Good to know the order here matters. Did you find the section on the HTML spec defining this behavior? It's still surprising that Chrome handles it but Safari doesn't
--
",CaseJnr,"
--
@posva The issue is how vue is constructing the picture. Creating an img element and setting the src will initiate a request, as expected. To eliminate the redundant img request, the img element must first be added to a picture element before the img.src is set.

The following code eliminates the redundant img.src request for views with a width less than 900px

```
let picture = document.createElement('picture')
let source = document.createElement('source')
source.media = '(max-width: 900px)'
source.srcset = ""https://www.abc.net.au/radionational/image/6289622-4x3-340x255.png""

let img = document.createElement('img')
img.alt =''

picture.appendChild(source)
picture.appendChild(img) // Append img to picture before setting the src
 
img.src = ""https://www.solidbackgrounds.com/images/2560x1440/2560x1440-brandeis-blue-solid-color-background.jpg""

window.app.appendChild(picture)
```
 
--

--
@posva Any chance you could recommend a fix for this while I wait for a PR?
--
",,,,,,,,
11341,OPEN,Add user timing measurement for lifecycle hooks,improvement,2020-09-01 09:14:24 +0000 UTC,unarist,In progress,,"### What problem does this feature solve?
My app had performance issue due to some slow lifecycle hooks.
It would be easy to find an issue like that if `Vue.config.performance` API records lifecycle hooks too.

### What does the proposed API look like?
With `Vue.config.performance = true`, I can observe timings of lifecycle hooks as like `vue <Foo> mounted` in ""Timings"" section in the devtools as well as current `Vue.config.performance` behavior for init/compile/render/patch events.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,unarist,"
--
I think it would be achieved by adding mark/measure call in this function:

https://github.com/vuejs/vue/blob/0551226f8bf0884e31bb686b7116b60f1eaf77e6/src/core/instance/lifecycle.js#L336-L350

like this:

```
 export function callHook (vm: Component, hook: string) { 
   // #7573 disable dep collection when invoking lifecycle hooks 
   pushTarget() 
   const handlers = vm.$options[hook] 
   const info = `${hook} hook` 
   if (handlers) { 
     const name = vm._name
     const id = vm._uid
     const startTag = `vue-hook-perf-start:${id}`
     const endTag = `vue-hook-perf-end:${id}`
     mark(startTag)
     for (let i = 0, j = handlers.length; i < j; i++) { 
       invokeWithErrorHandling(handlers[i], vm, null, vm, info) 
     } 
     mark(endTag)
     measure(`vue ${name} ${hook}`, startTag, endTag)
   } 
   if (vm._hasHookEvent) { 
     vm.$emit('hook:' + hook) 
   } 
   popTarget() 
 } 
```
--
",Zlmdb,"
--
空间看空间
--
",,,,,,,,
11325,OPEN,nextTick implementation breaks with core-js@3 Promise polyfill on Tizen 2016,browser quirks; need repro,2020-04-20 09:07:56 +0000 UTC,victortwc,In progress,,"### Version
2.6.11







### Steps to reproduce
Just cross-linking the issues here, it was opened in core-js repo:
https://github.com/zloirock/core-js/issues/814

The reproduction is not easily doable as it requires a Samsung Tizen 2016 device (which I have because I develop specifically for TVs).

### What is expected?
UI updates correctly after events

### What is actually happening?
UI will only update if another task is queue.

---
In the nextTick implementation there's a check for `isIOS` to trigger an extra `setTimeout` which, while hacky, works also for Tizen 2016.

Perhaps a PR could be made adding an exception for Samsung Tizen as well?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
A boiled down repro is still required
--

--
The package could be useful for anybody who can reproduce it. A code sample would be useful
It’s unclear why core js plays a role here though. If you have a simple fix, I think it would be better to send a PR
--
",victortwc,"
--
Would you like me to prepare a Tizen package with minimal reproduction code @posva ?
--

--
Core-js plays a role in the sense that Vue-cli 4 is using core-js@3 by default for polyfills. The implementation breaks in core-js@3 but doesn't in core-js2, hence my confusion. 
--

--
@posva a simple fix would be to detect Tizen user agent and do the same trick as it's done for iOS (using a setTimeout), but I noticed an impact in performance while doing user interaction e.g with longpress. I'm curious to know why it worked with core-js@2 with no special quirks.

One solution for me to move forward now is to use core-js v2 on this project, but it seems like going against the grain, as v2 is already deprecated in favor of v3. I don't want to send a PR unless it's absolutely necessary.
--
",,,,,,,,
11321,OPEN,In Firefox; radiobuttons with `required` and `v-model` are marked as invalid immediately,browser quirks,2020-04-25 17:39:26 +0000 UTC,ThomasLandauer,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/t1po5sdh/](https://jsfiddle.net/t1po5sdh/)







### Steps to reproduce
In Firefox 75.0, I get the two radio buttons marked as invalid (i.e. surrounded by a red border) immediately on pageload. This does not happen if I either remove `required` or `v-model`

### What is expected?
The radios should only be marked as invalid after form submission - as with other required input controls.

### What is actually happening?
See above

---
I've been observing this for years already.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This seems to happen in js as well as soon as the property `checked` is touched: https://jsfiddle.net/Lz5u2wah/ which we need to do for `v-model`
--
",unbyte,"
--
Firefox will mark the **required** radio input with a red border if you had operated the radio input **without giving it a selected value**.
I guess vue had set the property `checked` of all the radio inputs to `false` when it created data bindings because of `null`, then the radio inputs had been marked as invalid by firefox.
--
",,,,,,,,
11315,OPEN,Components slots are not rendered inside svg foreignObject,bug; has PR,2021-03-24 11:13:35 +0000 UTC,Aleksandras-Novikovas,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/AleksandrasNovikovas/w042x1c8/](https://jsfiddle.net/AleksandrasNovikovas/w042x1c8/)







### Steps to reproduce
Run provided fiddle. There are three svg boxes with foreignObject:
1. contains simple html tags
2. contains simple vue component
3. contains complex (with slot) vue component


### What is expected?
All three boxes should show link and input elements

### What is actually happening?
Third box does not show link and input elements.

---
While inspecting DOM (in chrome or in firefox) you will find that elements of second box and third box are identical.
Problem is their types: (in chome dev console select element and tab properties)
select input element from second box and you will find following list: Object->EventTarget->Node->Element->HTMLElement->HTMLInputElement->input;
select input element from third box and you will find following list: Object->EventTarget->Node->Element->SVGElement->input;

<!-- generated by vue-issues. DO NOT REMOVE -->",,,zhangzhonghe,"
--
#11349 This is not a problem anymore because I have fixed it and submitted PR😁.
--
",,,,,,,,,,
11310,OPEN,List move transitions not working as expected in SVG elements,,2020-04-26 13:28:46 +0000 UTC,callumacrae,In progress,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/callumacrae/pen/eac1209c4a6f0dab5c75a3612145a465](https://codepen.io/callumacrae/pen/eac1209c4a6f0dab5c75a3612145a465)

### Steps to reproduce
Click the shuffle button

### What is expected?
Both transitions should be identical

### What is actually happening?
Some of the elements are reappearing at the top - possible being deleted from the DOM and new ones being created? Not sure how to debug this, but something isn't right!

It's not happening very time to every element - sometimes they work as expected.

Also, sometimes the flip-list-move class isn't being removed at all.

---
Copied the HTML example from the docs to make as similar as possible to a working example: https://vuejs.org/v2/guide/transitions.html#List-Move-Transitions

<!-- generated by vue-issues. DO NOT REMOVE -->",,,callumacrae,"
--
I've added a third column _without_ the transition-group as I figure it's actually not needed inside an SVG where the transform is being handled manually, and it looks like the issue could be different to what I initially thought it was - it looks like that despite the keys not changing, vue is removing some of the elements from the DOM and adding new ones.

It also seems to be related to where they are - the one that was previously at the top is always transitioned, the others sometimes transition and sometimes don't.
--

--
That's one way of doing it, but in my actual usage there are three elements inside the `<g>`  so it's better to have a transform on the `<g>` than to duplicate the `y` position three times (and in turn have three times the amount of transitions).

That does work though - I've added it as a 4th column on the codepen
--

--
Did some more digging and haven't found anything conclusive, but found that it's only the move transitions that aren't behaving as expected - adding and removing items is working as expected: https://codepen.io/callumacrae/pen/db11985ff39e92e8cd898a23e6eeda0e
--
",posva,"
--
Don't you need to provide the coordinates to the text:

```html
 <div>
      <p>svg:</p>
      <svg width=""400"" height=""400"">
        <transition-group name=""flip-list"" tag=""g"">
          <g v-for=""(item, i) in items"" :key=""item"" >
            <text :x=""40"" :y=""i * 40 + 50"">{{ item }}</text>
          </g>
        </transition-group>
      </svg> 
    </div>
```

otherwise the transform applied to the element won't be correct
--
",,,,,,,,
11299,OPEN,SSR fails to render component inside v-else of a v-if with v-html,bug; feat:ssr; has workaround,2020-12-04 19:04:13 +0000 UTC,tuomassalo,Opened,,"### Version
2.6.11

### Reproduction link
[https://github.com/tuomassalo/vue-ssr-v-html-bug](https://github.com/tuomassalo/vue-ssr-v-html-bug)


### Steps to reproduce
- clone the repo
- run `npm run dev`
- open `localhost:8080`
- observe Console log.


### What is expected?
I expect SSR to render ""bar: Bar!"", as the client-side does.

Or, I'd like to get an eslint warning that this is a bad idea (if that is the problem).

### What is actually happening?
`App.vue` fails to render `bar-component` on the server. Instead, it outputs `<bar-component></bar-component>`, and the dev server gives the warning ""The client-side rendered virtual DOM tree is not matching server-rendered content.""

---

The key part of `App.vue` is this:

```
<div v-if=""foo"" v-html=""'Foo.'""/>
<div v-else>
  bar: <bar-component/>
</div>
```

My original component was naturally longer. I ran into this problem after changing the `v-if` line from something like:

    <div v-if=""foo"">{{ foo }}</div>

To:

    <div v-if=""foo"" v-html=""foo""/>

... which *seemed* innocuous to me.

Finally, apologies for posting a very possible duplicate.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
A workaround is using a `template` tag:

```vue
<div id=""app"">
  <template v-if=""foo"" >
    <div v-html=""'Foo.'"" key=""hey""/>
  </template>
  <div v-else>
    bar: <BarComponent />
  </div>
</div>
```

For SSR repros, it's usually easier to do them with the bare minimum. Here is an example:

```js
const Vue = require('vue')

const BarComponent = {
  template: `
   <div>Bar!</div>
  `,
}

const app = new Vue({
  template: `
<div id=""app"">
  <div v-if=""foo"" v-html=""'Foo.'"" key=""hey""/>
  <div v-else>
    bar: <BarComponent />
  </div>
</div>
  `,
  data: () => ({ foo: false }),
  components: { BarComponent },
})

const renderer = require('vue-server-renderer').createRenderer()

renderer.renderToString(app, (err, html) => {
  if (err) throw err
  console.log(html)
})
```

It could also help anybody picking up the issue
--
",Lizhooh,"
--
me too
--
",simonmaass,"
--
having the same issue!
--
",MorevM,"
--
I also ran into an issue and spent half a day to figure out what was going on.
Finally, I feel like a fool but:
```
<div v-if=""smth === true"" v-html=""html""></div>
<component v-else ... />                        <----- doesn't work
// but...
<div v-if=""smth === true"" v-html=""html""></div>
<component v-if=""smth !== true"" />              <----- this works
```
Hope this helps someone who stuck with that too.
--
",,,,
11295,OPEN,Weird HMR behavior when using scoped slots,,2020-04-08 17:33:43 +0000 UTC,Bastczuak,Opened,,"### Version
2.6.11

### Reproduction link
[https://github.com/Bastczuak/vue-issue](https://github.com/Bastczuak/vue-issue)







### Steps to reproduce
1. yarn
2. yarn serve
3. open the file ""src/components/Test.vue""
4. copy the button multiple times or try for yourself to add and remove HTML tags.
5. save the file
6. open network in dev tools and see that the changes are transferred to the browser
7. see no or weird dom changes in the browser

### What is expected?
Doing changes in in my code are loaded and shown in the browser.

### What is actually happening?
No changes are shown in the browser.

---
It's a bit tricky to reproduce the bug. I found a way to copy the same HTML tags multiple times into the template to produce this effect. I am using a renderless component `ScopedSlots.vue` which exposes properties via scoped slots to children. Children HTML tags are hot reloaded in the browser but changes in code in other Vue components inside the slot are not updated properly. Also the weird thing is that the code changes are transferred to the browser but  the DOM will not change.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11281,OPEN,.once modifier did'nt perform as expected if my event handler return null,improvement,2020-04-19 18:34:47 +0000 UTC,LKL2017,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/q0v6m8dr/1/](https://jsfiddle.net/q0v6m8dr/1/)







### Steps to reproduce
1. bind a handler to an event which with a '.once' modifier 
3. set null for the hanlder's return value
2. trigger the event,  and  trigger again

### What is expected?
only the first trigger will invoke handler,  under '.once' influence

### What is actually happening?
subsequent trigger will also invoke handler beside the first one

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I'm unsure about this one since the condition is explicitly stated at https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js#L36 but I don't know if it's necessary.

@gebilaoxiong do you remember why you added the check for `(res !== null)` at https://github.com/vuejs/vue/pull/8036
--

--
Thanks @hulkyhawk, let's keep this open as the code could potentially be adapted to allow an event listener to return `null` when `.once` is added
--
",hulkyhawk,"
--
@posva  when deal with native once event, there is a `(res !== null)` guard just to make sure the 
`.self` modifier works. see the issure #4846.
but there is no such a problem when the event is component level, the problem should be solved maybe 
--
",gebilaoxiong,"
--
@posva I'm sorry I didn't notice the news;

This is not a broken change，The logic used here is the old one:
https://github.com/vuejs/vue/pull/8036/files#diff-2b06abcad137617975c484105ce8f5a7L26-L28

It looks like a signal value, But I can not find the test-case;

--
",,,,,,
11256,OPEN,[vue-server-renderer] support for `context.rendered` which returns a promise,,2020-03-27 17:18:20 +0000 UTC,eunjae-lee,Opened,,"### What problem does this feature solve?
Hi there,

In `vue-server-renderer`, there is a function `createRenderer`.
Inside it, it calls `context.rendered(context)`.
What if we allow `context.rendered()` to return a promise and resolve it if it does?

That's the exact timing between components render and template render.
I want to trigger an HTTP request at that point and include the response into the rendered template.

To rephrase it,
1. I'd like to see the component tree(which components are there and which props they have, etc)
2. accordingly fire an HTTP request to my server
3. and put the response into `__INITIAL_STATE__`.

Does this make sense? I tried to think of something else, but `context.rendered` seems to be the most perfect place for this usage.

`vue-server-renderer` already works fine with `serverPrefetch` and wait for all `serverPrefetch`s. Then later it can get vuex store or something to render the template.
But with my proposal, you can do something more than that, sort of in a centralized place which is `entry-server`.
It doesn't change the API at all, and I don't think it will introduce any confusion to developers.

### What does the proposed API look like?
It doesn't require a new API.

The existing code is this:

https://github.com/vuejs/vue/blob/a59e05c2ffe7d10dc55782baa41cb2c1cd605862/packages/vue-server-renderer/build.dev.js#L9187-L9189

We can, instead, have something like the following:

```js
new Promise((resolve, reject) => {
  if (context && context.rendered) {
    const res = context.rendered(context);
    if (isPromise(res)) {
      return res.then(resolve).catch(reject);
    }
  }
  resolve();
}).then(
  ...
)
```

It is totally compatible with previous usages.
Let me know if you want me to open a PR for this, or if you have other opinions.

Thanks!

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
11248,OPEN,refInFor searches upwards of inline-template boundary,bug,2020-03-26 15:43:06 +0000 UTC,mernst-github,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/b71adnym/2/](https://jsfiddle.net/b71adnym/2/)







### Steps to reproduce
Nest a component with an inline-template that has a ref in a v-for.


### What is expected?
component.$ref.ref should point to the respective element.

### What is actually happening?
component.$ref.ref is a singleton array with the element reference.


---
checkInFor loops over the element ancestors up to the document root, so it believes that the ref is in a loop, but it actually isn't.
The check should stop at the component root.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,mernst,"
--
A patch like this seems to fix the issue for me:
```
    function checkInFor(el) {
        var parent = el;
        while (parent) {
            if (parent.attrsMap['inline-template'] != null) {
                return false
            }
            if (parent.for !== undefined) {
                return true
            }
            parent = parent.parent;
        }
        return false
    }
```

--
",,,,,,,,,,
11243,OPEN,Customized built-in elements (Web Components) are not working in Single File Components,,2020-04-23 07:26:17 +0000 UTC,Philipp-M,Opened,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/confident-robinson-nl2c5](https://codesandbox.io/s/confident-robinson-nl2c5)







### Steps to reproduce
Define a customized built-in element and try to use it inside a template of a Single File Component.

It doesn't matter if `Vue.config.ignoredElements` defines the name of the component as it is just converted into the autonomous element syntax (which unfortunately doesn't work with browsers)

### What is expected?
Working customized built-in component using the template syntax in Vue Single File Components.

### What is actually happening?
Vue doesn't invoke the custom element constructor, and tries to render it as normal HTML element.

---
There is an issue about this on Stack Overflow: https://stackoverflow.com/questions/56162647/how-to-use-customized-built-in-element-in-vuejs
But even the proposed solution using a custom directive doesn't invoke the Custom Element constructor, see reproduction example.
I guess that is because previously the (non-customized) built-in constructor is invoked.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
https://github.com/vuejs/rfcs/blob/custom-elements-interop/active-rfcs/0000-custom-elements-interop.md should solve the problem you are experiencing 

The directive solution won't work because `is` should be provided when creating the element:

```js
const plasticButton = document.createElement(""button"", { is: ""plastic-button"" });
```

--
",aron,"
--
I have the same issue. When I create a built-in element via Web API ( document.createElement(""button"", { is: ""fancy-button"" }) ), the built-in element wasn't initialized.
--
",,,,,,,,
11241,OPEN,Object with prototype of `null` cannot be displayed using text interpolation,improvement,2020-03-25 19:00:23 +0000 UTC,hezedu,Opened,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/hezedu/pen/GRJYXGR](https://codepen.io/hezedu/pen/GRJYXGR)







### Steps to reproduce
vue: 2.6.11
https://github.com/vuejs/vue/blob/a59e05c2ffe7d10dc55782baa41cb2c1cd605862/dist/vue.runtime.js#L96-L102
```js
toString(Object.create(null);
```
Will crash: 
TypeError: Cannot convert object to primitive value

### What is expected?
TypeError

### What is actually happening?
error

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sirlancelot,"
--
What is the expectation here? Do you want it throw a certain kind of error? It is currently throwing `TypeError` which I feel is the most accurate. If a value doesn't contain the default `toString` property, it can't be trusted to output anything useful or more importantly, safe.

![image](https://user-images.githubusercontent.com/71916/77575073-331b6200-6e90-11ea-9a84-467bd3ab54ac.png)

--
",,,,,,,,,,
11182,OPEN,Vue form inputs broken on IE11 on browser refresh,browser quirks,2020-08-30 08:20:35 +0000 UTC,affemaen,Opened,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/affeman/pen/LYVzzYw](https://codepen.io/affeman/pen/LYVzzYw)







### Steps to reproduce
Not reproducible in CodePen but the code is the same used in the Vue official documentation (See below)

1. Go to https://vuejs.org/v2/guide/forms.html#Checkbox in Internet Explorer 11
2. Click the checkbox
3. Reload the page

### What is expected?
The checkbox is unchecked and the label is false

### What is actually happening?
The checkbox is checked and the label is false

---
The same issue applies to the other components on the page as well.

The issue is not applicable after a hard refresh.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,YeisonHunt,"
--
U still use IE? 🤣
--
",alanbosco,"
--
It seems like an issue for checkboxes in IE  in general.
https://stackoverflow.com/a/3176181
--
",mridul037,"
--
don't use that browser support is over in vue for that
--
",,,,,,
11171,OPEN,Swapping from functional to non-functional component using v-if does not change v-data-* attribute.,bug,2020-12-25 02:33:51 +0000 UTC,StefanCardnell,Opened,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/embed/heuristic-brown-u7rvw?fontsize=14&hidenavigation=1&theme=dark](https://codesandbox.io/embed/heuristic-brown-u7rvw?fontsize=14&hidenavigation=1&theme=dark)







### Steps to reproduce
Click the tick box.

### What is expected?
It should say ""BLUE BOX"" with a blue background colour.

### What is actually happening?
It says ""BLUE BOX"" with no background colour.

---
The issue stems from the data-v-* attribute not being re-set for the blue_block div when it is swapped to. It is still using the data-v-* attribute of the child div in the functional component. Thus the CSS class styling does not apply. 


https://imgur.com/a/gukDePJ


Swapping from a functional component to something else is useful. E.g. When showing a simple loading bar component before swapping to a more complex component.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sirlancelot,"
--
I think this may have something to do with how Vue recycles nodes during update. As a workaround, adding a `key` to both the component and the div yields the expected behavior.
--
",posva,"
--
Might be related to https://github.com/vuejs/vue/issues/10416
--
",PeterAlfredLee,"
--
I don't think this is a problem.

According to the comment [here](https://github.com/vuejs/vue/blob/dev/test/unit/features/options/_scopeId.spec.js#L92) :

> functional component with scopeId will not inherit parent scopeId

The functional components **should not** inherit parent if the parent is scoped.

I think we have a workarounds here: we can remove the `scoped` attribute in the parent component. Seems it works :
https://codesandbox.io/embed/vigorous-frost-t1f84
--
",,,,,,
11165,OPEN,Incorrect form field value in Chrome using the back button,browser quirks,2021-01-12 23:01:57 +0000 UTC,mvgn,In progress,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/jc26tewa/](https://jsfiddle.net/jc26tewa/)







### Steps to reproduce
1. Type ""Hello"" in the message input field.
2. Click on the link ""Another page"". 
3. Click on the browser back button.
4. Click on the ""Submit"" button. 

### What is expected?
It is expected that the input field be blank or that Vue recognises its current value and shows ""Submitted message: Hello"" after clicking on the Submit button.

### What is actually happening?
In Chrome, the input field contains the value it had before leaving the page, but Vue thinks the field is empty, so nothing happens when you click on the Submit button. In other browsers, the input field is blank after clicking on the back button.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This seems to be a regression on Chromium 79. I filled a bug there: https://bugs.chromium.org/p/chromium/issues/detail?id=1057463#makechanges
--

--
This problem affects every js framework, even raw javascript. As they said, the would look into fixing the regression if enough people at concerned. So please express the need in the reported issue
--
",sandipbiswasbehala,"
--
is there any solution from vue js end???
--

--
you can do something like this. Resolved my problem as of now. in main js.

window.addEventListener('pageshow', function() {

	new Vue({
	  render: h => h(App),
	}).$mount('#app')
	
})
--

--
@mvgn 
window.addEventListener('pageshow', function() {

new Vue({
  render: h => h(App),
}).$mount('#app')
})
--
",mvgn,"
--
I find it strange that this bug has received so little attention as Chrome is the most popular browser and this bug seems to affect every Vuejs form. Even the form on the official Vuejs documentation exhibits the same fault. At https://vuejs.org/v2/guide/forms.html#Text, fill the text box, click a link to another page, and then click the back button. You'll see that the message is blank but the text box is out of sync and contains the previous typed value.  

As the Chrome team as marked the related bug as WontFix, it seems it will be up to the Vuejs team to come up with a workaround. 
--

--
@posva, I've commented on the Chrome bug, but I don't know enough to make a technical argument — can only say that other browsers are behaving as expected with Vuejs while Chrome is not.

thanks @sandipbiswasbehala.  I'm using Vuejs in a rails app and the default initialisation is with the DOMContentLoaded event, so I'm keeping that for other browsers and changed to the pageshow event just for Chrome.

```js
if (navigator.userAgent.indexOf('Chrome/') > 0) {
  window.addEventListener('pageshow', () => {
    new Vue({
      render: (h) => h(App),
    }).$mount('#app');
  });
} else {
  document.addEventListener('DOMContentLoaded', () => {
    new Vue({
      render: (h) => h(App),
    }).$mount('#app');
  });
}
```
--
",Elvaleryn,"
--
Thanks to @sandipbiswasbehala and @mvgn for the solution, it works perfect on Chrome but unfortunately im having the same issue on Opera. This is quite weird because they are both Chromium based even their dev tools are same. There should be a work around for this, which will solve this problem regardless of which browser.
--

--
Okay i was digging down because this solution wasn't working for Opera, here is my work around: I found out that when i focus on one of the inputs all the other inputs was becoming empty or default(it is how it should be) So i tried to focus that input as soon as the component is mounted but it did not work. Then i set a time out to focus function then it worked. It seems like for some reason it needs a delay around 300ms to render the state normal. Basically i asynchronously rendered components which has forms now it seems like all of them works flawlessly here is one of them:<br>


```js
const MainComponent = () => ({
	component: import(""./Searchbox/MainComponent""),
	delay: 300,
});

```

Eventhough it works i have no clue why this behaviour exists in Chrome based browsers. Maybe someone else can explain it better.<br>

<br>
Here is the related link in vue docs: https://vuejs.org/v2/guide/components-dynamic-async.html
--
",euoia,"
--
On my machine at least, Chrome on OS X is showing the following user agent:
```
""Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1""
```

So the looking at user agent for the pageshow workaround doesn't work on Desktop (I haven't tested mobile yet).

I can modify my `app.js` to wrap my Vue initialisation in the a callback to the `pageshow` event, which seems to work in Chrome and Safari.

```
window.addEventListener(""pageshow"", () => {
  new Vue({
    el: ""#app"",
  });
});
```

But I do not know other implications of this, whether it works in all browsers, etc.

I have also noticed that this makes it so the prefilled form fields are reset to the components default values. Ideally Vue would pick up Chrome's prefilled form fields and bind them into its `data` fields.

I'm also surprised this issue doesn't have more traction.
--

--
Just thought I'd add a bit more information on this.

Wrapping `new Vue()` in the `pageshow` fixes Chrome but breaks Safari (iOS and desktop). The behaviour you'll see is that the input is empty, but the DOM is still the same as if the input had text.

I haven't found a way to reliably work around this issue in Chrome without breaking Safari. The Vue core contains this code:
```
export const isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge
```
https://github.com/vuejs/vue/blob/a9a303009a4267b7f12b956741b4e34dfdc6566f/src/core/util/env.js

Which implies that testing the user agent is reliable. So I wonder whether I was mistaken when I commented previously that the Chrome user agent did not contain the string ""chrome"". In any case, my version of Chrome now does contain ""chrome"" so I will go back to inspecting the user agent string.
--
",aarondfrancis,"
--
Also running into this.
--
"
11122,OPEN,Trailing whitespaces are trimmed from the end of inline <strong> element when page is being parsed by Vue,,2020-11-10 14:19:50 +0000 UTC,kfirba,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/kfirba2/us5h04f7/5/](https://jsfiddle.net/kfirba2/us5h04f7/5/)

### Steps to reproduce
1. Have a wrapper for Vue
2. Inside that wrapper, insert an inline element such as `<strong>` and leave trailing whitespace at the end of it:
```html
<div id=""#app"">
  This is <strong>BOLD </strong>text
</div>
```
3. After the page is parsed with Vue (and Vue has generated a Virtual DOM for the page), the words ""BOLD"" and ""text"" will be glued together (the whitespace after the word ""BOLD"" and before the enclosing tag of `<strong>` is removed.

### What is expected?
It is expected that the whitespace will remain in its place and not trimmed.

### What is actually happening?
The trailing whitespace is trimmed.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,despreston,"
--
I think https://github.com/vuejs/vue/pull/11065 pr will fix this.
--
",kfirba,"
--
@despreston I’m not sure it’s going to solve it. The PR focuses on the template compiler if I’m not mistaken. The issue here is the DOM that Vue mounts on and parses into virtual DOM on the fly
--

--
@Justineo Hey,

You are absolutely right that it is not natural, however, our website is Vue powered and some of the website's content is UGC. Users are using some sort of a WYSIWYG and never write HTML. Because of that reason, we, nor them, have any good control of the generated HTML. We tried solving that in some ways but it looks like we couldn't achieve a satisfiable solution.
--

--
@Justineo I wasn't aware of the `v-pre` directive so thanks for that.

However, it is not entirely true. The way we have it working is that the user (who is not always a ""random"" user, but may be an editor) has a WYSIWYG where he can also ""inject""  custom elements which are Vue elements, such as Lead Forms. So the UGC content has Vue elements within it For example:

```html
<div id=""#app"">
  <p>Text Text Text....</p>
  <lead-form></lead-form>
  <p>...</p>
  <another-element></another-element>
  ...
</div>
```
--

--
@Justineo Hey, is there anything new with that?
--

--
@s-gbz only subsequent spaces. Multiple spaces are “collapsed” into 1 space **visually**. In the source code you will find all of the spaces.

This is obviously a bug. Webpack has nothing do to with it as we are talking about Vue mounting on an existing DOM which has never gone any compilation/transpiration step (rendered with PHP)
--

--
@abrahamguo anything new regarding this issue?
--
",Justineo,"
--
Hi. What's your use case of using

```html
<strong>BOLD </strong>text
```

instead of this?

```html
<strong>BOLD</strong> text
```
--

--
I assume you won't need Vue to parse and compile the UGC code. You can try put a `v-pre` directive on the wrapper element around your UGC so that Vue will skip that part.
--
",s,"
--
Correct me if I'm wrong, but isn't skipping whitespaces default behaviour in HTML?
You usually have to insert whitespaces manualy as `&nbsp;`.
--
",Garito,"
--
Sometimes you will need something like <span v-html=""'&nbsp;'"" /> since webpack (if I recall correctly) removes all spaces
--
",abrahamguo,"
--
Is this something I can look into? @kfirba I agree, this seems like a bug.
--

--
After investigating this issue, I can see that it is caused by this function:

```
function trimEndingWhitespace (el) {
	// remove trailing whitespace node
	if (!inPre) {
		var lastNode;
		while (
			(lastNode = el.children[el.children.length - 1]) &&
			lastNode.type === 3 &&
			lastNode.text === ' '
		) {
			el.children.pop();
		}
	}
}
```

which removes ending whitespace. Does anyone know the reasoning behind this function?
--

--
Nope. I found the code for it in the core but I need the advice of people more knowledgeable than me to advise the purpose of this code. Otherwise, you could maybe dig through the history to find why this code was added.
--
"
11113,OPEN,Throw error/warn if watch path doesn't resolve to an existing property,feature request; warnings,2020-02-23 20:49:56 +0000 UTC,WofWca,In progress,,"### What problem does this feature solve?
Currently, if a watch path does not address an existing property, its handler would just silently never execute.
This may cause bugs due to a typo or refactoring that involves restructuring the app model. Especially if we want to watch something like `'$store.state.user.user.subscriptions'`.

Here's a JSFiddle to play with: https://jsfiddle.net/WofWca/50feyxn7

### What does the proposed API look like?
Just throw an error (or warn?) in such case. Like it would happen if we used `this.$watch(() => this.$store.state.user.user.subscriptions, () => { .... });`

<!-- generated by vue-issues. DO NOT REMOVE -->",,,jacekkarczmarczyk,"
--
Wouldn't it be better if watcher run when the property becomes available? Not sure if it's doable though.
--
",WofWca,"
--
> Wouldn't it be better if watcher run when the property becomes available? Not sure if it's doable though.

I think it's better to do this manually, in the handler.

Another possible option is optional chaining in watch path expression (like this `$store.state.user.user?.subscriptions`, with a question mark), but I feel like this would need a separate issue.
--
",despreston,"
--
@posva I have a PR for this but I'm sort of weary of adding it to the codebase because there's already a solution for watching non-existent properties using `Vue.set`. You can see a test case for it here:

https://github.com/vuejs/vue/blob/dev/test/unit/modules/observer/watcher.spec.js#L36
--

--
In other words, for a lot of users this is going to produce a warning for expected behavior.
--

--
@posva even for a non-declared object, you can create an object with `Vue.set` right? 

```js
Vue.set(this, 'completelyNew')
```
So you _could_ have watchers for 'completelyNew' even before it exists.
--

--
hm. ok. You're right, and the docs can back that up: https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats
--
",posva,"
--
@despreston yeah, the warning would only make sense if it's referring to a property of a non declared object (like the jsfiddle). Maybe this is indeed way too far for a warning
--

--
It doesn't seemed to work when I tried
--
",,,,
11109,OPEN,"Hydration fails when write like ""<div><span>123</span>{{value}}</div>"" in the template and the data ""value"" is a empty string",bug; feat:ssr; has PR,2020-04-13 02:01:26 +0000 UTC,deqwin,In progress,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/deqwin/pen/wvaMxoO](https://codepen.io/deqwin/pen/wvaMxoO)







### Steps to reproduce
open the reproduction above and you will see a red vue warning in the console

### What is expected?
a successful hydration

### What is actually happening?
the hydration fails and the app re-renders absolutely

---
this looks like the problem caused by the empty text node (src/core/vdom/patch.js line:646)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,enbo315,"
--
hello  do well 
--
",luohong123,"
--
Hello,Modify it so that there is no error,beacuse,The client-side rendered virtual DOM tree is not matching server-rendered content. You have one more {{value}} .
```html
<div id=""app"" data-server-rendered=""true""><span>123</span></div>
<template id=""tpl"">
  <div id=""app""><span>123</span></div>
</template>
```
--
",deqwin,"
--
> Hello,Modify it so that there is no error,beacuse,The client-side rendered virtual DOM tree is not matching server-rendered content. You have one more {{value}} .
> 
> ```
> <div id=""app"" data-server-rendered=""true""><span>123</span></div>
> <template id=""tpl"">
>   <div id=""app""><span>123</span></div>
> </template>
> ```

Yes, it works. But it's not easy to modify because i have written this many times in my project.
--
",,,,,,
11090,OPEN,"$http.delete shows warning ""avoid using JavaScript unary operator as property name""",feat:compiler; has workaround; improvement; warnings,2020-06-05 07:05:18 +0000 UTC,frOracle,Opened,,"### Version
2.6.11

### Reproduction link
[https://codepen.io/frOracle/pen/vYOEEVW](https://codepen.io/frOracle/pen/vYOEEVW)







### Steps to reproduce
use $http.delete in @click

### What is expected?
$http.delete is a function, not unary operator

### What is actually happening?
a warning ""avoid using JavaScript unary operator as property name""

---
Related https://github.com/vuejs/vue/issues/5464

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I think the point of this was to avoid problems by using keys in object with names like `delete` (looking at the commit where the file was changed to emit this error will probably have more info). Depending on that, we could avoid it on the expression if it's prefixed by an object.
It's still a warning, so it doesn't break the app.
The workaround is using `$http['delete']`, which is quite verbose

For anybody willing to give this a try: I marked this as a good first issue but it might be harder than I think because it depends on the logic that exists regarding the warning
--
",simwipado,"
--
created PR #11092 for this  #issue 
--
author:	
association:	none
edited:	true
status:	none
--
PR #11409
--
",d33p4k,"
--
PR #11409
--
author:	d33p4k-coder
association:	none
edited:	false
status:	none
--
because you can't use delete keyword as variable name.. these are reserve keywords but if you still want to use it then try brackets like this : ['delete'] : value
--
",,,,,,
11088,OPEN,Optional chaining in templates does not seem to work,contribution welcome; feature request,2021-01-04 06:28:20 +0000 UTC,DRoet,In progress,,"### Version
15.8.3

### Reproduction link

https://template-explorer.vuejs.org/#%3Cdiv%20id%3D%22app%22%20v-if%3D%22obj%3F.a%22%3E%7B%7B%20msg%20%7D%7D%3C%2Fdiv%3E







### Steps to reproduce
Use a v-if that uses optional chaining w/ `@vue/cli version 4.2.0`:

`v-if=""test?.length > 0""`

### What is expected?
no error is thrown

### What is actually happening?
following error is thrown:
```
  Errors compiling template:

  invalid expression: Unexpected token '.' in

    test?.length > 0

  Raw expression: v-if=""test?.length > 0""
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sodatea,"
--
As said in the release notes:
> // Note: scripts only, support in template expressions only available in Vue 3

https://vue-next-template-explorer.netlify.com/#%7B%22src%22%3A%22%3Cdiv%20id%3D%5C%22app%5C%22%20v-if%3D%5C%22obj%3F.a%5C%22%3E%7B%7B%20msg%20%7D%7D%3C%2Fdiv%3E%22%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22prefixIdentifiers%22%3Afalse%2C%22hoistStatic%22%3Afalse%2C%22cacheHandlers%22%3Afalse%2C%22scopeId%22%3Anull%7D%7D
--

--
Technically, to support such syntaxes in Vue 2, we need to:
1. tweak the codegen to not modify such expressions (currently it converts `obj?.a` to `obj ? .a`)
2. vue-template-es2015-compiler needs to be able to parse such syntaxes (not necessarily to transpile, to parse is enough)
3. backport this commit to vue-loader 15 https://github.com/vuejs/vue-loader/commit/4cb447426ec19c4e07f22ce73fe134f8abaf007c#diff-c735bef98c9338c75a676df1903d2afc
4. get ready for the possible numerous bug reports

We don't have the capacity to implement it yet. But contributions are welcome.
--
",DRoet,"
--
ah derp, totally read over that comment
--
",jacekkarczmarczyk,"
--
https://github.com/vuejs/vue-next/commit/8449a9727c942b6049c9e577c7c15b43fdca2867#diff-1cb91d3fc9313f91590cd27606eade47R402
--

--
> Same here. I thought this was getting fixed with the release of Vue 3. Guess not... 😔

It does work in Vue 3
--
",McPo,"
--
Potential workaround includes using lodash's get as stated in https://github.com/vuejs/vue/issues/4638#issuecomment-397770996

Another hack is to use `eval`.

As `$eval` was taken out in Vue 2, you'll have to create your own mixin so that it can be accessed in all components without having to import it into each one.

i.e.

``` This will allow $elvis to be accessed in all templates
Vue.mixin({
  methods: {
    $elvis: p => eval('this.'+p)
  }
});
```

Example template
```
<template>
<span>{{ $elvis('foo?.bar') }}</span>
</template>
```

Although its still no substitute for the real operator, especially if you have many occurrences of it


--

--
> > Although its still no substitute for the real operator, especially if you have many occurrences of it
> 
> @McPo Just how safe do you think this is? I'm about to use it in production code because I do not want to set computed properties for the numerous nested fields that may be `undefined` or `null`

As far as Im aware, it should be fine, as youre in control of the input. The only issues would be if the developer wasnt aware that its using eval and allows user input to it, but that doesn't really make sense in the case of the elvis operator.

It may have a performance impact though, in that Vue will probably recall the method on every update. I would also suspect theres some overhead in calling `eval` in the first place. Providing its not in a tight loop, realistically you're not likely to notice a difference.
--

--
> Please do _not_ use `eval` for that. It generally is bad practice and in this case specifically, it breaks in all browsers that do not support optional chaining. Whether or not you are using Babel or any other transpiler is irrelevant as they cannot transpile strings.
> 
> A better way to access properties in a fail-safe way (like with optional chaining) is the following:
> 
> ```
> <template><div>
>   {{getSafe(() => obj.foo.bar)}} <!-- returns 'baz' -->
>   {{getSafe(() => obj.foo.doesNotExist)}} <!-- returns undefined -->
> </div></template>
> 
> <script>
> export default {
>     data() {
>         return {obj: {foo: {bar: 'baz'}}};
>     },
>     methods: {getSafe},
> };
> function getSafe(fn) {
>     try { return fn(); }
>     catch (e) {}
> }
> </script>
> ```
> 
> The `getSafe` function catches any exceptions and implicitly returns `undefined` if the property access fails. You could also create a mixin (or use the new composition API) to reuse that function.

True I forgot to highlight the issue that it requires optional chaining to be supported in the browser. (Which isn't a major issue in my case, although I probably will stop using it anyway)
--
",Edmund1645,"
--
>Although its still no substitute for the real operator, especially if you have many occurrences of it

@McPo Just how safe do you think this is? I'm about to use it in production code because I do not want to set computed properties for the numerous nested fields that may be `undefined` or `null`
--
",troxler,"
--
Please do *not* use `eval` for that. It generally is bad practice and in this case specifically, it breaks in all browsers that do not support optional chaining. Whether or not you are using Babel or any other transpiler is irrelevant as they cannot transpile strings.

A better way to access properties in a fail-safe way (like with optional chaining) is the following:

```
<template><div>
  {{getSafe(() => obj.foo.bar)}} <!-- returns 'baz' -->
  {{getSafe(() => obj.foo.doesNotExist)}} <!-- returns undefined -->
</div></template>

<script>
export default {
    data() {
        return {obj: {foo: {bar: 'baz'}}};
    },
    methods: {getSafe},
};
function getSafe(fn) {
    try { return fn(); }
    catch (e) {}
}
</script>
```

The `getSafe` function catches any exceptions and implicitly returns `undefined` if the property access fails. You could also create a mixin (or use the new composition API) to reuse that function.
--
"
11084,OPEN,Slot wrapped in `v-if` disappears after re-render,bug; has workaround,2020-05-25 03:42:55 +0000 UTC,atomanyih,In progress,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/y9kmcbg6/](https://jsfiddle.net/y9kmcbg6/)







### Steps to reproduce
1. JSFiddle will render both elements.
2. After 3s, it will toggle off
3. After 3s, it will toggle on
4. To see it happen again, rerun the jsfiddle

### What is expected?
At step 3, the bottom slot content should re-appear when ToggleComponent toggles back

### What is actually happening?
The bottom slot never re-appears

---
Seems to be related to the `v-if` on line 21. I'm doing this b/c it's useful to have an optional slot, but I don't want an extra div to appear when the slot isn't used (for layout reasons). I'm fairly new to vue, so I don't know if there's a different recommended way to do this.

Not documented in the example, but if ParentComponent updates, the slot content will re-appear

example code included here for perusal:

```vue
const ToggleComponent = {
  data() {
    return {
      toggleEl: true,
    };
  },

  created() {
    setTimeout(() => this.toggleEl = false, 3000);
    setTimeout(() => this.toggleEl = true, 6000);
  },
  render(h) {
    return this.toggleEl ? h('div', this.$slots.default) : null
  }
};

const SlotComponent = {
  template: `
    <div>
      <slot></slot>
      <div v-if=""$slots.other"">
        <slot name=""other""></slot>
      </div>
    </div>
  `
}

const ParentComponent = {
  template: `
    <ToggleComponent>
      <SlotComponent>
        <template v-slot:default>
          I should have an element below me
        </template>
        <template v-slot:other>
          I am the element below you
        </template>
      </SlotComponent>
    </ToggleComponent>
  `,

  components: {
    ToggleComponent,
    SlotComponent
  },
}

var demo = new Vue({
  el: '#demo',
  template: `
    <ParentComponent/>
  `,

  components: {
    ParentComponent
  },
});

```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is because `v-slot` is like the old `slot-scope`. It seems that in this case `$slots` is not in sync with `$scopedSlots` but you can use `$scopedSlots` instead of `$slots` in the v-if you mentioned to workaround the issue
--
",atomanyih,"
--
@posva Thanks, that worked!
Questions:
- Are there any other implications of using `$scopedSlots` vs `$slots`?
- What do you mean by ""`v-slot` is like the old `slot-scope`""?
--
",john,"
--
I just had the same issue, where checking `$slots.default` to conditionally render between slot or `<form>` element will work fine, something like 
``` 
    // component <foo-bar>
    <template v-if=""$slots.default"">
      <slot v-bind:food=""'chicken'""/>
    </template>
    <form v-else>
    </form>
```
up until when consuming AND trying to utilize scoped slot props. (adding `v-slot:default=""slotProps`)
```
      <foo-bar>
        <template v-slot:default=""slotProps"">
          <p>slot stuff</p>
        </template>
      </foo-bar>

// even tried with foo-bar having v-if=""$slots.default' internally too
    <foo-bar v-slot=""slotProps"">
      <p>slot stuff</p>
    </foo-bar>
```

**TLDR**; Adding scoped slots to foo-bar (`<foo-bar v-slot=""slotProps"">`) breaks inner v-if condition based on `$slots.default` unless when applying @posva's [suggestion](https://github.com/vuejs/vue/issues/11084#issuecomment-582801325), see below

``` diff
    // component <foo-bar>
-    <template v-if=""$slots.default"">
+    <template v-if=""$scopedSlots.default"">
      <slot v-bind:food=""'chicken'""/>
    </template>
    <form v-else>
    </form>
```

I'm using the latest stable version,  2.6.11.
--
",,,,,,
11053,OPEN,False value cause aria boolean attributes to be removed from the DOM,,2020-04-21 16:40:39 +0000 UTC,falcon03,In progress,,"### Version
2.6.11

### Reproduction link
[https://www.dropbox.com/s/3ltqeent65djedw/problematic-false-aria-values.zip?dl=0](https://www.dropbox.com/s/3ltqeent65djedw/problematic-false-aria-values.zip?dl=0)







### Steps to reproduce
1. Extract the provided zip archive and enter the produced ""problematic-false-aria-values"" directory.
2. Install dependencies (i.e. `yarn install`).
3. Run the development server (i.e. `yarn serve`) and head to its url with your favorite browser.
4. Inspect the DOM of the page: the `aria-checked` and `aria-expanded` attributes won't be there.
5. Enable the checkbox and/or expand the toggle.
6. Inspect the DOM of the page: this time both `aria-checked` and `aria-expanded` will be there as expected.
7. Disable the checkbox and collapse the toggle.
8. Inspect the DOM of the page: the `aria-checked` and `aria-expanded` attributes won't be there, again.

### What is expected?
Aria attributes should be present in the DOM even if their value is false.

### What is actually happening?
Aria attributes are not present in the DOM when their value is false.

---
Unlike for html 5 boolean values, removing aria attributes from the DOM when their value is false changes the page semantics and degrades its accessibility, causing markup validation issues as well.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
I didn't check out the repro as i don't have access to dropbox.

But: 

* A value of `false` is the only way to tell Vue to actually remove an attribute - which you may also want to do with an aria attribute in some situtions.
* `aria-checked`values (like all html attribute values) are strings, not booleans: `'true'` and `'false'`, respectively, so you have to set them as strings:

`v-bind:aria-checked=""checked ? 'true' : 'false'""`

I don't think it makes sense to have aria attributes behave differently than other html attributes in this regard.

Also, we need a way to tell Vue *""remove that attribute""*, which is setting it to `false`.

We're aware that this works a bit differently than vanilla js: `setAttribute('aria-checked', false)` will set the attribute to `aria-checked=""false""`. But so will it do for `checked` or any other element:
```javascript
el.setAttribute('aria-selected', false)
<div aria-selected=""false"">

el.setAttribute('checked', false)
<div aria-selected=""false"" checked=""false"">

el.setAttribute('placeholder', false)
<div aria-selected=""false"" checked=""false"" placeholder=""false"">
```

So Vue treats `false` differently, but it does so consistently and for a reason.
--

--
> Also, the fact that an ARIA attribute has the false value can mean something different than completely omitting the attribute (think of aria-expanded, just to mention the one I used in the demo).

That's kind of my point: if we cast `false` to `'false'` for these category of attributes, then users have to be aware that to actually remove an aria attribute, they have to set it to `undefined`, whereas for all other attributes, setting it to `false` has the same effect.

But yeah I can see how casting would be helpful in practice. Will reopen just to discuss it further 
--
",posva,"
--
For Aria attributes you have to cast them to string:

```html
<button :aria-pressed=""isToggled.toString()"">
```

This is something I thought about but didn't take the time to make sure that

1. All existing boolean aria attributes take `true` and `false` string values
2. All new aria attributes will follow that rule

If those two points are true, I think it would make for aria attributes on HTML elements to be cast as strings
--
",falcon03,"
--
@LinusBorg thanks for your clarification. I do understand the reason behind this behavior, but I think that having to cast ARIA attributes to string manually is tedious and degrades the developer experience. In addition to this, even if they do appear as html boolean attributes conceptually, according to the [W3C specification](https://www.w3.org/TR/wai-aria-1.1/#typemapping)
>The suggested mappings for true/false values in HTML 5 use Keyword and enumerated attributes with allowed values of true and false, instead of using the HTML 5 boolean value type.

Together with the fact that if the value is to true you get a statement like `attr=""value""` instead of the preferred HTML 5 syntax, this is the reason why I think that Vue's behavior feels inconsistent.

Also, the fact that an ARIA attribute has the false value can mean something different than completely omitting the attribute (think of aria-expanded, just to mention the one I used in the demo).
--

--
@posva thanks for providing a code example, this is the workaround I am using right now. I think that automatically casting ARIA attribute values to strings makes sense. Regarding your first point I think that the answer is yes (see my previous comment), while the answer to your second point is yes unless W3C suggests different type mappings.
--
",Josh68,"
--
I was just looking at an older, closed issue on the same topic: https://github.com/vuejs/vue/issues/7422#issuecomment-617272952.

What about just addressing this in the docs? Maybe specifically calling out bindings of `aria-` attributes.
--
",,,,
11040,OPEN,v-bind with empty key,improvement; warnings,2020-04-05 05:06:05 +0000 UTC,andrewharvey,Opened,,"### Version
2.6.11

### Reproduction link
[https://jsfiddle.net/andrewharvey4/k6r3uzby/10/](https://jsfiddle.net/andrewharvey4/k6r3uzby/10/)

### Steps to reproduce
v-bind an object with a empty string key

### What is expected?
vue not to crash, it to either be silently ignored or a warning but not a fatal error

### What is actually happening?
an error is thown crashing the app

```
vue.js:4483 Uncaught DOMException: Failed to execute 'setAttribute' on 'Element': '' is not a valid attribute name.
    at baseSetAttr (https://unpkg.com/vue@2.6.11/dist/vue.js:6778:10)
    at setAttr (https://unpkg.com/vue@2.6.11/dist/vue.js:6753:7)
    at Array.updateAttrs (https://unpkg.com/vue@2.6.11/dist/vue.js:6708:9)
    at invokeCreateHooks (https://unpkg.com/vue@2.6.11/dist/vue.js:6064:24)
    at initComponent (https://unpkg.com/vue@2.6.11/dist/vue.js:5997:9)
    at createComponent (https://unpkg.com/vue@2.6.11/dist/vue.js:5980:11)
    at createElm (https://unpkg.com/vue@2.6.11/dist/vue.js:5920:11)
    at createChildren (https://unpkg.com/vue@2.6.11/dist/vue.js:6048:11)
    at createElm (https://unpkg.com/vue@2.6.11/dist/vue.js:5949:11)
    at Vue.patch [as __patch__] (https://unpkg.com/vue@2.6.11/dist/vue.js:6509:11)
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,elshuku,"
--
Exact same error is given when v-bind has an extra : infront of it 
`<my-comp v-bind:={prop1, prop2}> My Comp </my-comp> `

This is picked during run-time instead of compile with stack trace and message having no information about where it happened.

Not sure if it's worth re-opening this, or creating another issue. 

This happens in 2.6.11
--
",,,,,,,,,,
11032,OPEN,the string constructor cannot be used as a `key`,bug; discussion,2020-03-23 13:30:17 +0000 UTC,mightyguava,In progress,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/practical-shaw-br23c](https://codesandbox.io/s/practical-shaw-br23c)







### Steps to reproduce
Open the codesandbox and you'll see a warning like `[Vue warn]: Duplicate keys detected: 'constructor'. This may cause an update error.`

Click the ""swap"" button TWICE to swap the list in the data, triggering the error.

If the literal string ""constructor"" in the first list is changed for any other string, there are no errors or warnings.

### What is expected?
The list should swap between the ""first"" and ""second"" list

### What is actually happening?
""TypeError: Cannot read property 'key' of undefined""

---
:( this was a hard bug to track down.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,veaba,"
--
As same, key name don't use `__proto__'`
--
",posva,"
--
I'm not sure if it's possible to allow reserved properties like those in the current codebase.
Otherwise, the warning message should be different
--
",mightyguava,"
--
If the problem was that you can't do `v-bind:key=""foo.constructor""`, because `constructor` is a reserved property, that's probably an ok thing to not support. But the problem here is that `v-bind:key=""foo.name""` cannot resolve to the string `""constructor""`.

This seems like a fairly scary bug, since it can cause Vue's rendering loop to arbitrary break when trying to render valid data. If I had to guess Vue is probably using the value of the key as a lookup key in an `Object`, rather than in a proper `Map` type? I'm new to Vue, so I'm probably oversimplifying things.

For context, in my case, I'm using normalized names for some database entities as a unique key (with a unique constraint in the db). One of those entities happens to be called ""constructor"", and using the unique name as the key completely breaks Vue. I could use the primary key for the key, but I didn't really want to leak the db's primary keys to the frontend.

Also, what does the `discussion` label mean?
--
",yangguansen,"
--
Yes, Vue use `key` as a lookup key in an Object to avoid duplicate keys, and `constructor` is a original property in Object. So the `constructor` KEY has been exist in Object.
So, DO NOT use property of Prototype chain as key.

You can use like below:
```
<div v-for=""(topic,index) in topics"" :data-someKey=""topic.name"" v-bind:key=""index"">
    <div>{{ topic.name }}</div>
</div>
```

Then you can get the value of someKey by HTML5 DOM method.
 
--
",,,,
11023,OPEN,Generate distinct paths for supporting .vue files in sourcemaps,discussion; improvement,2021-03-20 18:12:53 +0000 UTC,connor4312,In progress,,"### What problem does this feature solve?
Hello Vue 👋

I'm working on our [new JavaScript debugger](https://github.com/microsoft/vscode-js-debug) for VS Code, and ran into some problems when trying out Vue. The default vue-cli setup creates several supporting .vue scripts. For instance, open the Chrome devtools and ctrl p for ""App.vue"" in a new project. The top entry is the correct Vue file, the others aren't.

![](https://memes.peet.io/img/Screen%20Shot%202020-01-17%20at%2011.47.46%20AM.png)

From the VS Code perspective, the user might ask us to set a breakpoint in a Vue file. We know which file the breakpoint is attached to on disk, and we need to figure out which loaded file that breakpoint gets mapped to. However, because all these paths are quite similar and all (in the context of a generic web app) possibly the file we want, we end up putting the breakpoint in the wrong file and breaking in the incorrect place. And often the supporting scripts evaluate before the 'real' script does, so we can't, for example, wait and pick the best match from the possible candidates.

### What does the proposed API look like?
The simplest solution would be to prefix the supporting files with some path like `__vue__`, or something along those lines. This would prevent the paths from incorrectly mapping to files that exist on disk.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Maybe @znck or @sodatea know more about where to do something here
--
",znck,"
--
This happens in vue-loader, right now I don’t have bandwidth to take it but I can guide if someone is interested. 
--

--
It is quite tricky to make source maps and hot reload work simultaneously. I understand it's a huge pain point and I'll revisit it (hopefully coming weekend).
--
",connor4312,"
--
I could probably find some time to help out. Code pointers or guidance would be appreciated 🙂 
--

--
This is turning out to be a little more tricky than I thought. Convincing webpack to resolve paths that don't actually exist on the filesystem is difficult; I've made some headway with the [virtual-module-webpack-plugin](https://github.com/rmarscher/virtual-module-webpack-plugin), though it's somewhat dangerous and there's more work to do to have imports from adjusted modules resolve correctly, I'm not really happy with this solution. Maybe there's a way to tweak change the locations in the sourcemaps for these files without needing to ask Webpack to treat them as entirely different disk files.

I've pushed some ugly scratch work to https://github.com/connor4312/vue-loader
--

--
In https://github.com/microsoft/vscode-js-debug/commit/2f3c93a08df0ceb09eda86251d0309d34bfb26ef I introduced a heuristic that seems to work very well for plain Vue with JS files, where the path is different (as in the screenshot above). However, with `lang=""ts""` in vue components the path of the generated code is entirely indistinguishable from that of the generated code.

E.g., only one of these is the right one:

![](https://memes.peet.io/img/20-07-4e60d034-c849-4f82-b699-f9b5f1e52ad5.png)

Without doing some kind of source code analysis, which is complex and fragile, I can't deterministically tell which one is the 'right' script to map back to the file.
--

--
@znck let me know what you think a good solution is. We've gotten continued reports of people running into this with VS Code 🙂 
--

--
@znck I would appreciate your input here. This continues to be a pain point for Vue users on VS Code. (most recently in https://github.com/microsoft/vscode-js-debug/issues/754)
--

--
Awesome, let me know if I can help with anything
--
",sirlancelot,"
--
Would be neat to see this fixed as well. It's difficult to know which one is correct even as a human looking at Chrome Devtools :shrug: 
--
",ariyuan,"
--
Looking forward to the fix
--
",jtsom,"
--
It's been almost 10 months with no indication of it being fixed...
--
"
11014,OPEN,Sometimes bubbling stops working on Safari,browser quirks,2020-04-02 11:13:01 +0000 UTC,R1ze13,In progress,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/vue-safari-error-tg4mm](https://codesandbox.io/s/vue-safari-error-tg4mm)







### Steps to reproduce
The bug reproduction is quite specific, so please be patient

- open ""App.vue"" in safari (my version is 13.0.4 (15608.4.9.1.3))
- open the console so that you can watch the logs (the values ​​of ""e.TimeStamp"" and ""attachedTimestamp"" from https://github.com/vuejs/vue/blob/dev/dist/vue.esm.js#L7549 are logged)
- make sure that the variable ""WITH_GENERATE_NEW_VUE"" is false
- wait a while. at least about a minute
- click the ""Press me"" button several times to make sure that everything works. most likely, in the console there will be ""e.timeStamp, attachTimestamp 0 0""

Now the difficult and not completely clear part
- change the value of the variable ""WITH_GENERATE_NEW_VUE"" to true
- without reloading the browser page, click on the button
- now, most likely, the log will change to something similar to ""e.timeStamp, attachedTimestamp 0 51478""
- this is Safari and ""e.timeStamp"" (the first number in the logs) is zero, but after some time or a few clicks, it will begin to grow and now until it becomes more than the value of ""attachedTimestamp"", the click will not work

### What is expected?
click and method on it works

### What is actually happening?
in the above case, this check is not performed
https://github.com/vuejs/vue/blob/dev/dist/vue.esm.js#L7549

---
This is a specific situation - something like emulating an application in which there is a lot of legacy. different sections can be written on different technologies and sometimes this bug is caught when switching between sections. Unfortunately, I can’t even suggest how this bug is related to the instantiation of a new vue, maybe this is a coincidence

I think this can be fixed by adding ""e.target.contains (e.currentTarget)"" to the conditions specified in https://github.com/vuejs/vue/blob/dev/dist/vue.esm.js#L7549 but I don’t know if this will not affect performance

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
Seems to be result of a bug in safari. Basically, the event.timestamp should never be 0, and it seems to be for Safari. It's not in other browsers.

Someone else came across something similar in vanilla js:

https://stackoverflow.com/questions/57744414/safari-event-timestamp-is-0

This is the only info in that direction that i could find quickly.


Basically, the event.timestamp should never be 0, and it seems to be for Safari. It's not in other browsers.
--
",R1ze13,"
--
Yes, you are right, this is an error exclusively in safari, but the case with a zero value is taken into account in the conditions. https://github.com/vuejs/vue/blob/dev/dist/vue.esm.js#L7559
The error occurs when zero for some reason starts to grow
--
",rx,"
--
@LinusBorg as can I see you use [chain of next rules](https://github.com/vuejs/vue/blob/dev/dist/vue.esm.js#L7549):

// crutch
`e.target === e.currentTarget`

// primary rule
`e.timeStamp >= attachedTimestamp`

// crutch
`e.timeStamp <= 0`

// crutch
`e.target.ownerDocument !== document`

Otherwise result is false, and event handler doesn't runs.

If you rely to timestamp rule why you not using `e.timeStamp >= attachedTimestamp` the first?

Rule `e.target === e.currentTarget` doesn't works in this case:

```
<button type=""button"" v-on:click=""myAwesomeHandler"">
    <i class=""fa fa-bars""></I>&nbsp;Menu
</button>
```

In this case when i make click on icon the `e.target` and `e.currentTarget` will be different.

I think the chain will should look like this:

// primary rule
`e.timeStamp >= attachedTimestamp`

// crutch
`e.timeStamp <= 0`

// crutch when event started from handler - binded element
`e.target === e.currentTarget`

// crutch when event started from child element
`e.currentTarget.contains(e.target)`

// crutch
`e.target.ownerDocument !== document`

--

--
I created the pull request https://github.com/vuejs/vue/pull/11031
--
",,,,,,
11009,OPEN,"VSCode ""auto import"" of ESM module broken in 2.6.11 with umd namespace",typescript,2020-01-17 08:53:35 +0000 UTC,chuckmah,In progress,,"### Version
2.6.11

### Reproduction link
[https://imgur.com/a/RxJz6fT](https://imgur.com/a/RxJz6fT)







### Steps to reproduce
Since the 2.6.11 my IDE (VSCode) now suggest me import Vue from  the 'vue/types/umd' namespace instead of the ESModule 'vue'

I'm using 
Vue 2.6.11
Vue-CLI  4.1.0
VScode 1.41.1
Typescript 3.7.4

### What is expected?
Prior 2.6.11, VScode was suggesting to `import Vue from 'vue'` 

### What is actually happening?
VSCode is suggesting me to `import Vue from 'vue/types/umd'` see screenshot

---
maybe it's releated to https://github.com/vuejs/vue/pull/9912 ?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
You should import it from vue-property-decorator like `import { Component, Vue } from 'vue-property-decorator'`

It looks like Vue is automatically imported within VSCode as creating an empty vue file already allows you to use Vue with correct typings, so I imagine it would make sense for the IDE to not be able to import automatically. I don't know if this is something we can improve. @octref do you know if this is possible to change here or somewhere else?
--

--
I reproduced it with the cli by creating a project with babel + ts and upgrading ts to its latest version (but it appears on 3.5.3 too)
--
",octref,"
--
Does this happen for TS file as well?
--

--
Then it's a typing/TS server issue, not Vetur specific. #9912 does seem related, /cc @ktsn.
--

--
Can you please be **more precise**, for example, I did this and it doesn't reproduce for me:

![image](https://user-images.githubusercontent.com/4033249/72538559-4b627580-387e-11ea-8090-6b684ef679c9.png)

![image](https://user-images.githubusercontent.com/4033249/72538692-7fd63180-387e-11ea-88ed-ca1959e04318.png)

```bash
mkdir foo
cd foo
yarn add vue vue-property-decorator
touch test.ts
code .
```

- Put below code into `test.ts`

  ```ts
  import { Component } from 'vue-property-decorator'

  export default class Foo extends Vue {

  }
  ```

- Have all extension diabled
- Complete on `Vue`
- I don't get the completion
- I'm on VS Code 1.41.0, `vue` 2.6.11, `vue-property-decorator` 8.3.0
--

--
Thanks, I can repro now, but this is not a Vetur problem, but a Vue types / TS Server issue.
--
",chuckmah,"
--
> Does this happen for TS file as well?

yes
--

--
> You should import it from vue-property-decorator like `import { Component, Vue } from 'vue-property-decorator'`
> 

vue-property-decorator simply re-export a named Vue from the default export of the 'vue' package. There are a lot of case in typescript when you don't you use the decorator (in a Vuex store for example) and don't want to import Vue fromthe vue-property-decorator package (ie.  code splitting)

I dont know if it's VSCode or TSServer related but the auto-import suggesting was always `import Vue from 'vue'`  prior 2.6.11 and that what we have everywhere our codebase. 
--

--
> > I reproduced it with the cli by creating a project with babel + ts and upgrading ts to its latest version (but it appears on 3.5.3 too)
> 
> That's strange. I did the same thing while I tested it. Maybe editor config or some env specific things differentiate the behavior?
> It does not suggest auto-import on my end even though I enabled auto-import config.
> <img alt=""Screenshot 2020-01-16 at 10 26 36 AM"" width=""783"" src=""https://user-images.githubusercontent.com/2194624/72489034-1e01d180-3856-11ea-997c-d67ecd96caca.png"">

You can try it directly in a .ts file , you should have auto-import
--

--
@octref from you example if you add Typescript you will have the auto-import suggesting by clicking on the 💡  from VSCode.

here's how i reproduced it using minimal deps (not the vue-cli)
```
mkdir foo
cd foo
yarn add typescript vue vue-property-decorator
npx tsc --init --module ""ES6"" --lib ""ES6"" --target ""ES6"" --types ""vue"" --moduleResolution ""Node""
touch TestVue.ts
code .
```

inside TestVue.ts
```
const component:Component = Vue.extend({});
```

The named import work i still get the suggestion to import from 'vue'

![NamedImport](https://user-images.githubusercontent.com/581365/72545582-3e7e5b80-3857-11ea-9550-6e7e153ba1f5.jpg)

But the default import do not appear
![DefaultImport](https://user-images.githubusercontent.com/581365/72545677-64a3fb80-3857-11ea-88a9-df8871a36bea.jpg)

If i revert back to 2.6.10 i get the correct suggestion from the 'vue'
![DefaultImport2610](https://user-images.githubusercontent.com/581365/72545823-a765d380-3857-11ea-934f-3183f6d998e8.jpg)


Maybe it's a TSServer issue 😕 .. but because some of my dev on my team just use the suggested import regardless, i had to revert back to 2.6.10 

--
",ktsn,"
--
I cannot reproduce it with the exact same versions of Vue, VSCode and TypeScript. Could you provide example project reproducing the issue as GitHub repo?
--

--
> I reproduced it with the cli by creating a project with babel + ts and upgrading ts to its latest version (but it appears on 3.5.3 too)

That's strange. I did the same thing while I tested it. Maybe editor config or some env specific things differentiate the behavior?
It does not suggest auto-import on my end even though I enabled auto-import config.
<img width=""783"" alt=""Screenshot 2020-01-16 at 10 26 36 AM"" src=""https://user-images.githubusercontent.com/2194624/72489034-1e01d180-3856-11ea-997c-d67ecd96caca.png"">

--
",,,,
10973,OPEN,Should `fill` and `copyWithIn` methods be intercepted (observed) now ?,discussion; feature request,2020-03-19 08:41:12 +0000 UTC,zjffun,In progress,,"### What problem does this feature solve?
`fill` and `copyWithIn` methods are also mutating methods and has Standard status currently [ECMAScript 2015 Language Specification – ECMA-262 6th Edition - copywithin](https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.copywithin) , but they aren't being intercepted in https://github.com/vuejs/vue/blob/237294d88f65d65dcb790246394f1d37d64856a0/src/core/observer/array.js#L11-L19. Should they join now ? 

### What does the proposed API look like?
null

<!-- generated by vue-issues. DO NOT REMOVE -->",,,abrahamguo,"
--
Is this something I could work on?
--
",zjffun,"
--
Sure @abrahamguo 
--
",,,,,,,,
10968,OPEN,serverPrefetch rejection with no value creates broken response,has workaround; improvement,2020-01-12 00:51:11 +0000 UTC,dsanders11,In progress,,"### Version
2.6.11

### Reproduction link
[http://sorry-no-can-do.com](Sorry, I don't have time to setup a reproduction case for SSR, that's not a 5 minute thing).







### Steps to reproduce
1. Use SSR
2. Add a `serverPrefetch` with `return Promise.reject()`

### What is expected?
An error to occur due to the rejection in `serverPrefetch`

### What is actually happening?
No error occurs, but the rendered result will not contain the component with the bad `serverPrefetch`.

---
Currently, rejecting a promise in `serverPrefetch` with no value will create a broken response from SSR. By broken I mean that no error will occur with `renderToString`, so it looks like it was successful, but the rendered DOM may be missing components, including the root component all together.

This is because the rejection value from `serverPrefetch` is wired straight through to the `done` callback on `render`, but that callback only considers an error to have occurred if a value is provided. Due to this straight wiring, any `serverPrefetch` which rejects without a value will allow rendering to continue, but will skip the rendering of the component on which the error occurs. If that's the root component, the rendered result has no element for hydration to use in the rendered result, which means there's no way for the client to recover. For a real-life example of this, see vuejs/vue-apollo#901.

Here's the relevant code, the `done` callback for `render`:

https://github.com/vuejs/vue/blob/42fdf3f8378e5dc379808a4fa67b39c4a74ae191/src/server/create-renderer.js#L84-L87

And where the rejection value from `serverPrefetch` is wired through:

https://github.com/vuejs/vue/blob/42fdf3f8378e5dc379808a4fa67b39c4a74ae191/src/server/render.js#L65

A fix could be as easy as expanding that `catch` to check for `err` and provide a default value if one is not provided. I'm punting on what that default would be, so I'm opening this as an issue rather than a PR.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
As a workaround, providing an error to `Promise.reject` should solve the problem. In practice, not providing a reason for a promise rejection is confusing for the developer themselves.
I think the fix you propose is good. We could use a `new Error('Missing rejection reason in serverPrefetch')`
--
",dsanders11,"
--
> As a workaround, providing an error to `Promise.reject` should solve the problem.

Yes, but any component library or plugin can provide a `serverPrefetch`, so it's often not in the developer's control to work around. See the `vue-apollo` example.

> We could use a new `Error('Missing rejection reason in serverPrefetch')`

Seems reasonable to me.
--

--
@posva, is there anything more that needs to be done here? I can open a PR with that rejection reason if that's all that needs to be done.
--
",,,,,,,,
10966,OPEN,Add line number and a snippet of the source template to template render error reports,,2020-07-07 03:02:26 +0000 UTC,davidkhess,In progress,,"### What problem does this feature solve?
It helps developers pinpoint template errors in larger templates.

At the moment, render errors look like this (from version 2.5.18):

```
vue.js:616 [Vue warn]: Error in render: ""TypeError: Cannot read property 'name' of undefined""

found in

---> <ASelectDate>
       <ALite>
         <TransitionGroup>
           <DbNavigation>
             <VContent>
               <VApp>
                 <Root>
warn @ vue.js:616
logError @ vue.js:1824
globalHandleError @ vue.js:1819
handleError @ vue.js:1808
Vue._render @ vue.js:4637
updateComponent @ vue.js:2893
get @ vue.js:3261
Watcher @ vue.js:3250
mountComponent @ vue.js:2900
Vue.$mount @ vue.js:8642
Vue.$mount @ vue.js:11045
init @ vue.js:4225
createComponent @ vue.js:5696
createElm @ vue.js:5643
addVnodes @ vue.js:5824
updateChildren @ vue.js:5951
patchVnode @ vue.js:6037
patch @ vue.js:6198
Vue._update @ vue.js:2775
updateComponent @ vue.js:2893
get @ vue.js:3261
run @ vue.js:3336
flushSchedulerQueue @ vue.js:3094
(anonymous) @ vue.js:1925
flushCallbacks @ vue.js:1844
Promise.then (async)
microTimerFunc @ vue.js:1892
nextTick @ vue.js:1938
queueWatcher @ vue.js:3186
update @ vue.js:3326
notify @ vue.js:727
mutator @ vue.js:879
goto_date @ lite.js:82
invoker @ vue.js:2128
Vue.$emit @ vue.js:2646
Vue.<computed> @ backend.js:1793
success @ select_year_trim.js:296
tryCatcher @ -internal.js:39
invokeCallback @ -internal.js:211
publish @ -internal.js:197
flush @ asap.js:80
characterData (async)
(anonymous) @ asap.js:54
asap @ asap.js:11
fulfill @ -internal.js:148
handleMaybeThenable @ -internal.js:113
resolve @ -internal.js:121
(anonymous) @ -internal.js:241
(anonymous) @ util.js:37
Request.callback @ superagent.js:1723
(anonymous) @ superagent.js:1550
Emitter.emit @ superagent.js:1080
xhr.onreadystatechange @ superagent.js:1817
XMLHttpRequest.send (async)
Request._end @ superagent.js:1884
Request.end @ superagent.js:1788
(anonymous) @ util.js:34
initializePromise @ -internal.js:236
Promise @ promise.js:142
superagent.Request.promise @ util.js:33
common_setup @ managers.js:33
self.get_availability @ managers.js:163
select_car @ select_year_trim.js:272
select @ VM2579:1
invoker @ vue.js:2128
Vue.$emit @ vue.js:2646
Vue.<computed> @ backend.js:1793
click @ VM2609:3
invoker @ vue.js:2128
Vue.$emit @ vue.js:2646
Vue.<computed> @ backend.js:1793
click @ VBtn.ts:114
invoker @ vue.js:2128
fn._withTask.fn._withTask @ vue.js:1913

vue.js:1828 TypeError: Cannot read property 'name' of undefined
    at Proxy.eval (eval at createFunction (vue.js:10785), <anonymous>:2:39)
    at VueComponent.Vue._render (vue.js:4635)
    at VueComponent.updateComponent (vue.js:2893)
    at Watcher.get (vue.js:3261)
    at new Watcher (vue.js:3250)
    at mountComponent (vue.js:2900)
    at VueComponent.Vue.$mount (vue.js:8642)
    at VueComponent.Vue.$mount (vue.js:11045)
    at init (vue.js:4225)
    at createComponent (vue.js:5696)
```

While `TypeError: Cannot read property 'name' of undefined` and the template it occurred in is of course quite useful information it could be better if there are many references to 'name' in `<ASelectDate>` and the exact location of the error is not obvious. I'm proposing a feature enhancement that would include a line number relative to the template itself (assuming it is not just a render function) and also output the line before, the line of the error and the line following it from the source template to provide context information to the developer.

I believe this can be achieved using the same techniques that are used in compilers when debugging information is enabled and generated. In development mode, as a template is compiled, context information is maintained (line numbers and the source lines of the template) and as each piece is compiled and converted into render function code this information is captured as ""debugging symbols"" (using compiler terms). If this debugging information is available when a render error occurs, the stack trace is examined and used with the debugging information to determine the line number and template lines to display with the warning.

The result would be an error report that looks something like:

```
vue.js:616 [Vue warn]: Error in render: ""TypeError: Cannot read property 'name' of undefined""

found in

---> <ASelectDate>
       <ALite>
         <TransitionGroup>
           <DbNavigation>
             <VContent>
               <VApp>
                 <Root>

on line 34

        <p class=""model-year"">{{ model.year }}</p>
--->    <p class=""model-name"">{{ model.name }}</p>
        <p class=""model-tagline"">{{ model.tag_line }}</p>

```


### What does the proposed API look like?
In terms of implementation details, this feature would be enabled in development mode. The debugging information would be generated during template compilation and could be attached to the render function itself when compiled and emitted so that no additional files need to be produced, packaged or loaded. If the debugging information is available, the error message as envisioned above is produced. If not, the current style of warning is emitted instead along with a message that says for better details, reproduce the error in development mode.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I don't think this will be technically possible for current Vue 2 but the source maps in Vue 3 does already allow breaking in the middle of the template so I think it might be possible to have this. @znck do you happen to know more?
--
",znck,"
--
You can write a custom directive but let me try it and confirm. 
--
",davidkhess,"
--
I wasn't aware of the source map support in Vue 3 - that's some good news!

Looks like this might be useful in that scenario:

https://www.stacktracejs.com/#!/docs/stacktrace-gps

It appears to load and parse a source map and convert a stack trace frame to a location in the context of the source map.

It also has an MIT license and isn't a lot of code so it could be readily adapted and integrated.
--
",literakl,"
--
I vote for this proposal as well
--
",pedro380085,"
--
This is a great idea, I don't know how people debug templates with hundreds of lines today.
--
",,
10964,OPEN,Event bubbling does not trigger on older iOS devices,browser quirks; need repro,2020-01-21 21:30:44 +0000 UTC,chenjiahan,In progress,,"### Version
2.6.11

### Reproduction link
https://github.com/chenjiahan/vue-event-bubble-issue


### Steps to reproduce
This is a browser quirk on iOS <= 11.3

1. Find an old iOS device. (I reproduced the issue on an iOS 8.4 device)
2. Binding click events on parent and child elements
3. Click child element
4. Event listener for parent element is not firing

### What is expected?
Correct event bubbling behavior

### What is actually happening?
Mobile safari has buggy event.timeStamp implementations, the value of event.timestamp is abnormal when the page is first loaded. But event.timestamp will return to normal value after refreshing the page.

We receive a lot of [feedback from vant users](https://github.com/youzan/vant/issues/3015), it is currently observed that the problem may occur on iOS 8.4、10.2、10.3、11.3 (mobile safari and wechat browser)

Screenshot: 
![](https://img.yzcdn.cn/vant/vue-bubble-log-code.png)

![](https://img.yzcdn.cn/vant/vue-bubble-log-info.jpeg)

---

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Tested on iOS 8, iPhone 6 Plus and it works fine:

```html
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <meta http-equiv=""X-UA-Compatible"" content=""ie=edge"" />
    <title>Document</title>

    <style>
      #app {
        font-family: 'Avenir', Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-align: center;
        color: #2c3e50;
        margin-top: 60px;
      }

      .father {
        width: 300px;
        height: 300px;
        background-color: red;
      }

      .child {
        width: 100px;
        height: 100px;
        background-color: blue;
      }
    </style>
  </head>

  <script src=""https://unpkg.com/vue""></script>

  <body>
    <div id=""app"">
      <div class=""father"" @click=""onClickFather"">
        Father
        <div class=""child"" @click=""onClickChild"">Child</div>
      </div>

      <ul>
        <li v-for=""event in events"">{{ event }}</li>
      </ul>
    </div>

    <script>
      new Vue({
        el: '#app',
        data: { events: [] },
        methods: {
          onClickFather: function() {
            this.events.push('father')
            console.log('father clicked')
          },
          onClickChild: function() {
            this.events.push('child')
            console.log('child clicked')
          },
        },
      })
    </script>
  </body>
</html>
```

Next time, please provide a runnable repro for the target device, code sandbox doesn't run on iOS 8
--

--
Thanks for the extra links! Let's keep this open in case someone manage to reproduce it more consistently or even do a PR to fix it
--
",chenjiahan,"
--
@posva Sorry about the codesandbox link, this is the a repository that reproduced the problem:

https://github.com/chenjiahan/vue-event-bubble-issue

The timeStamp is only incorrect in some cases. I am now looking for a way to reproduce the problem steadily, and found some possible related links:

- https://github.com/ftlabs/fastclick/issues/549
- https://github.com/zilverline/react-tap-event-plugin/issues/19
- https://stackoverflow.com/questions/26177087/ios-8-mobile-safari-wrong-timestamp-on-touch-events
--

--
event.timeStamp is unreliable, maybe we should use some alternatives.
--
",rx,"
--
@posva `event.timestamp` on safari devices  in some cases is more then 0 but less then attachedTimestamp.

It seems, that current issue is similar to [issue](https://github.com/vuejs/vue/issues/11014).

To resolve safari timestamp behavior, rule `e.target === e.currentTarget` is used.

But the rule, doesn't work when event started from child element.

I make [PR](https://github.com/vuejs/vue/pull/11031), but still no response.
--
",,,,,,
10946,OPEN,Inline style binding is NOT corporate with web standard,improvement,2019-12-21 10:44:06 +0000 UTC,haochenli,Opened,,"### Version
2.6.11

### Reproduction link
[https://codesandbox.io/s/thirsty-heisenberg-elvz6?fontsize=14&hidenavigation=1&theme=dark](https://codesandbox.io/s/thirsty-heisenberg-elvz6?fontsize=14&hidenavigation=1&theme=dark)







### Steps to reproduce
1. open the repo
2. check the style of the green box

### What is expected?
The green div's height should be 101px

### What is actually happening?
the green div's height is 22px, cause inline style didn't work on this component

---
I check the web standard that if I assigned a string to a node's style with either `""node.style.cssText""` or add style directly in devtools with this `""height: 100px; height:"" `,  the final height will be 100px. Obviously the invalid ""height: "" will be abandoned. 
Then I check the source code and find that the function `parseStyleText`  only uses regex to split the string and then assign it to result from value by value, no matter what the value is or if the value is valid. That is why the green box's height is incorrect.
Then I create a PR try to fix this issue in web rendering but not in SSR.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10926,OPEN,slot fallback content is always rendered even when not used,has workaround; improvement,2020-12-08 09:56:48 +0000 UTC,houfeng0923,In progress,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-test-default-slot-always-exec-syuny](https://codesandbox.io/s/vue-test-default-slot-always-exec-syuny)







### Steps to reproduce
when computed props or method  declared in slot fallback , looks like this: 

```
// XXX component

<slot>
       no render, but always run {{p}}, {{print()}} <Func/> 
</slot>

// use it 
<XXX>
 actual replaced content 
</XXX>
```


### What is expected?
computed and method not  invoked , because they can't  render 

### What is actually happening?
computed is invoked once change.
method is invoked once render .

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is expected behavior, methods get executed at every render
--

--
On a second thought, maybe this could optimized when compiling the template: https://template-explorer.vuejs.org/#%3Cdiv%20class%3D%22hello%22%3E%0A%20%20%20%20%7B%7Bmsg%7D%7D%20%0A%20%20%20%20%20%3Cslot%3E%0A%20%20%20%20%20%20%20no%20render%2C%20but%20always%20run%20%7B%7Bp%7D%7D%2C%20%7B%7Bprint()%7D%7D%20%3CFunc%2F%3E%0A%20%20%20%20%20%3C%2Fslot%3E%0A%20%20%3C%2Fdiv%3E

A workaround is to wrap the slot fallback with an if:

```html
<slot>
  <template v-if=""!$slots.default"">
       no render, but always run {{p}}, {{print()}} <Func/>
  </template>  
</slot>
```
--
",houfeng0923,"
--
ye, $slots.default works sometimes. but if component use scopedSlots,  the $slots.default is undefined . 

--
",VictorCazanave,"
--
If the component uses scoped slots, I think you can use `$scopedSlots`:
```html
<slot :data=""data"">
  <template v-if=""!$scopedSlots.default"">
       no render, but always run {{p}}, {{print()}} <Func/>
  </template>  
</slot>
```
--
",StefanCardnell,"
--
Hi @posva. Looking at the documentation around [fallback content in Vue it says specifically](https://vuejs.org/v2/guide/components-slots.html#Fallback-Content):

> Fallback Content
> There are cases when it’s useful to specify fallback (i.e. default) content for a slot, **to be rendered only when no content is provided**.

that the provided content is rendered only when no content is provided. This contradicts what is happening here - content is being provided but the fall-back is still being rendered along with its method calls.

Also the behaviour seems arbitrary: computed properties and (non-functional) components in the fallback content aren't rendered/called, yet the methods still are. It's confusing to know what to expect out of fallback content in terms of overhead; if I have an expensive method being run in the fallback content, I wouldn't expect it to still run if something is slotted over it.

I think the documentation might need to be updated to clarify this.
--
",,,,
10907,OPEN,Special spaces are replaced with a plain space,,2019-12-09 21:07:44 +0000 UTC,msklvsk,Opened,,"### Version
2.6.10

### Reproduction link
[https://github.com/msklvsk/vue-space-replacement-bug](https://github.com/msklvsk/vue-space-replacement-bug)







### Steps to reproduce
`yarn serve`

The repo was created by  `vue create vue-space-replacement-bug` and replacing `<div id=""app"">` content with `<p>d&thinsp;b</p><p>d b</p>`

### What is expected?
The space between the first ‘db’ pair is a [thin space](https://en.wikipedia.org/wiki/Thin_space) (code 8201).

### What is actually happening?
It is a usual code-32 space. 
<img width=""43"" alt=""image"" src=""https://user-images.githubusercontent.com/473012/70395689-f83d0d80-1a09-11ea-8067-a0d73c35ee97.png"">
<img width=""386"" alt=""image"" src=""https://user-images.githubusercontent.com/473012/70395768-d728ec80-1a0a-11ea-98cb-779616d844d9.png"">

---
Happens to other special spaces, e.g. for `&nbsp;`.
Not sure if it’s a vue (compiler) or vue-cli problem.
Setting the compiler option `whitespace` to `preserve` makes the symptoms go away.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10906,OPEN,v-once on template not working inside a v-for in two cases,bug; has workaround,2019-12-08 17:15:26 +0000 UTC,posva,Opened,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/xiangyuecn/pen/eYmmPNP](https://codepen.io/xiangyuecn/pen/eYmmPNP)

moved from https://github.com/vuejs/vue/issues/10892



### Steps to reproduce

The repro adds entries to an array, causing a re render that. The template intentionally displays the elapsed time to see which v-once work and which do not

### What is expected?

All v-once to never render again

### What is actually happening?

Test 3 first template with a `v-once` re renders all the time. **Workaround** is to append an empty `span`: `<template v-once>[{{ getTime() }}] {{ obj.msg }}<span/></template>`
Test 5: the second template with `v-once` still rerenders. **Workaround** is to use a different tag like a span or use the `v-once` on the parent.
<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10903,OPEN,When v-show render instruction is passed a reference object; the instruction will not work,discussion; has workaround,2020-01-09 11:26:07 +0000 UTC,SamirGuo,In progress,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/SamirGuo/pen/vYBezXz](https://codepen.io/SamirGuo/pen/vYBezXz)







### Steps to reproduce
```html
<div id=""app"">
<template>
  <div>
    <button @click=""visible = !visible"">显示/隐藏</button>
    <my-component :visible=""visible"" style=""border-bottom: solid 1px #ccc"" />
  </div>
</template>
</div>
```
```js
const directive = {
    name: 'show',
    value: true
};

Vue.component('MyComponent', {
    props: {
        mystyle: '',
        visible: true
    },
    render(h) {
        directive.value = this.visible;
        return h('div', {
            // do not work!
            directives: [directive],
            // work well!
            // directives: [{
            //     name: 'show',
            //     value: this.visible
            // }],
            domProps: {
                innerText: 'sssssss'
            },
            style: this.mystyle
        });
    }
});


var Main = {
    data() {
      return { 
        visible: true
      };
    }
  };
var Ctor = Vue.extend(Main)
new Ctor().$mount('#app')
```
### What is expected?

v-show to be applied

### What is actually happening?

v-show isn't applied

---
When the instruction update logic assigns oldValue, oldVnode.data.directives [""show""] and vnode.data.directives [""show""] are actually the same object.
So dir.oldValue = oldDir.value is actually equivalent to dir.oldValue = dir.value; in the later update event, dir.oldValue === dir.value

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
You can just spread the global object: `[{...directive}],`. What is the use case for a shared directive object?
--

--
Okay, so in your case, the code must be fixed in the library but what is the use case for a shared directive object?
--

--
Okay, I'm glad you found a solution for it :)
Is there a specific condition that forces you to use a shared directive declaration instead of creating a directive declaration inside of the `render` function like in the workaround I gave you?
--

--
This still needs a use case:

> Is there a specific condition that forces you to use a shared directive declaration instead of creating a directive declaration inside of the `render` function like in the workaround I gave you?
--
",SamirGuo,"
--
Thank you. But my components are dynamically generated from a library. We are passing in data, so there is no way to deconstruct it during generation.
--

--
Thanks for your response. This scenario was temporarily solved by hacking. However, this problem does exist. May be possible to consider whether there is a solution in Vue.
--

--
// component is dynamically created by config. 

render() {
  ......
  return (
      <component
        {...config}
      >
        { this.renderChild() }
      </component>
    );
}
--
",seadavis,"
--
@posva I started, too look into this. This is happening because the render function is returning a reference and not creating a new value. One solution is to just copy the value from the directive after,  vnode = render.call(vm._renderProxy, vm.$createElement) in render.js line 91, so something like vnode.data.directives[0].value = JSON.parse(JSON.stringify(vnode.data.directives[0].value)) and you would of course iterate over the list. That would work, but, doing it for directives seems like an odd special case. Do you know of a sensible way to copy all of the data into the new vnode,instead of just returning the results from the render function?
--

--
it almost seems to me like the memento pattern might be appropriate here.

--
",iamahuman,"
--
Note that the moment you return a VNode object from a render function, Vue.js claims ownership of objects you passed in to the `createElement` function, and some properties like `on`, `attrs` could even be modified.
--
",,,,
10878,OPEN,support computed as arrow function in typescript,typescript,2019-11-30 17:55:47 +0000 UTC,whbjzzwjxq,Opened,,"### What problem does this feature solve?
transform a project which has used lots of  ' xxx: vm => vm.prop ' as computed options to typescript easier

### What does the proposed API look like?
change vue/types/options.d.ts type Accessors<T> to 

```ts
export type Accessors<T> = {
  [K in keyof T]: (() => T[K]) | ComputedOptions<T[K]> | ((vm: any) => T[K])
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10866,OPEN,Class Binding Type Missing,discussion; typescript,2019-11-26 11:15:19 +0000 UTC,WORMSS,Opened,,"### What problem does this feature solve?
When writing a computed property for a class binding, I found I couldn't type it for typescript.
I made a temporary one and remembered, there are more possibilities, so instead of writing them myself, I thought best to use the built in ones.
Yet I can't seem to find a built in one. Am I being really dense and they are actually there right in front of my nose and I can't see them?

At any rate, I have wrote my own as 
```
export type VueClassBinding = string | readonly string[] | {
  readonly [className: string]: boolean,
};
```
Am I missing anything?
Is it possible someone can add this to the typings?

### What does the proposed API look like?
```
...
computed: {
  inputClassList(): VueClassBinding {
    if ( Math.random() > .5 ) return 'my-class-name';
    if ( Math.random() > .5 ) return ['my-class-name'];
    return {
      'my-class-name': true,
    };
  }
}
...
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10837,OPEN,Duplicate data-v-* attribute with render function scopedSlot and scoped styles,,2021-01-29 04:43:01 +0000 UTC,thomasv,Opened,,"### Version
2.6.10

### Reproduction link
[https://github.com/raWINce/nuxt-duplicate-data-v-attribute](https://github.com/raWINce/nuxt-duplicate-data-v-attribute)







### Steps to reproduce
- yarn install
- yarn dev or yarn start
- open localhost:3000


### What is expected?
Correct html without duplicate attributes that is valid according to https://validator.w3.org

### What is actually happening?
The div rendered inside the slot has a dupplicate data-v-* attribute. The html provided by the nuxt server is thus no valid html according to https://validator.w3.org

![duplicate-data-attribute](https://user-images.githubusercontent.com/28686577/65216037-e0f81f00-daaf-11e9-9bb7-f659eb0017d4.png)

This behaviour only occurs, when

- the parent of the component with the render function has scoped styles
- the render function directly returns the slot: return this.$scopedSlots.default()
- the child component has scoped styles and a slot


---
In [vue-template-compiler/build.js#L4661](https://github.com/vuejs/vue/blob/2.6/packages/vue-template-compiler/build.js#L4661) it seems that there is no check for already existing scopeIds in the segments array.

This issue has been posted as a [nuxt issue](https://github.com/nuxt/nuxt.js/issues/6401), originally - see also [nuxt/nuxt.js#6401 (comment)](https://github.com/nuxt/nuxt.js/issues/6401#issuecomment-531604783) and a [vue-loader issue](https://github.com/vuejs/vue-loader/issues/1590) - see also [vuejs/vue-loader#1590 (comment)](https://github.com/vuejs/vue-loader/issues/1590#issuecomment-552943931)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Christilut,"
--
Same problem here. 
![image](https://user-images.githubusercontent.com/3471363/78368529-0f5cc800-75c4-11ea-9e26-300f55340ca5.png)

It seems to get the parent data-v attribute. The child (`.stat-subscribers`) is loaded in a router-view.
--
",demsking,"
--
The issue seems to appear when using a nested component:
```html
<template>
   <ul>
     <li v-for=""item in items"">
        <span>Categories</span>
        <MenuList class=""nested"" :children=""item.children""/>
     </li>
   </ul>
</template>

<script>
  export default {
    name: 'MenuList'
    // ...
  }
</script>

--
",highoncarbs,"
--
Any fixes / workarounds ?

--

--
Oh alright. Thanks for the explanation . Actually I was running into hydration issues with no error messages . So thought this could be it.

--
",LinusBorg,"
--
To clarify: 

1. the original issue is that of adding exactly the same `data-v-*` attribute multiple times.
2. The ""same problem"" mentioned by someone else is actually not the same problem, it's having two different `data-v-*` attributes at the same time.

The former is a bug, but doesn't create problems in 99.9% of cases as browsers simply don't care about these duplicate attributes. So it's not something super critical.

The latter is actually expected behavior - in order for a parent with scoped styles to be able to style its children, it passes down its own data-v-* prop. 

But due to that, styles leak to the children and when both parent and child use the same class names, problems can occur.

Workarounds for the latter would be to :

* A: ensure class names don't collide manually, ie. by using a BEM-style named wrapper class
* B: use CSS modules instead of scoped styles.
--
",,,,
10825,OPEN,Allow accessing events registered via `vm.$on(...)` via a property; similar to `$listeners`,discussion,2019-11-15 19:20:13 +0000 UTC,tmorehouse,In progress,,"### What problem does this feature solve?

Currently, if an event is registered via `vm.$on('event-name', handler)`, it does not appear in the `this.$listeners` object (Vue 2.6.x)

In some instances you only want to handle the event processing if there is indeed a listener registered (for performance reasons).  But when component event listeners are registered programatically via `this.$on` (or `vmReference.$on`) it is not currently possible to see them in `this.$listeners`, e.g.:

```js
if (this.$listeners['event-name']) {
  // Do something computationally intensive
  // then emit event
  this.$emit('event-name', resultOfComputation)
}
```

![image](https://user-images.githubusercontent.com/2781561/68885711-1013c100-06ec-11ea-8c4b-a447d3612629.png)

### What does the proposed API look like?

No new API for the public.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It makes sense not to have listeners registered via `$on` onto `$listeners` as those are usually passed via `v-on` by the parent and can be relayed to an element of the component with `v-on=""$listeners""`. It could be on a different object but why should this be added to Vue while it can be handled in user land easily by extending `Vue.$prototype.on`?
--

--
By modifying the prototype you could add those events to a custom property like $onListeners 

Eduardo San Martin Morote

> On 15 Nov 2019, at 20:00, Troy Morehouse <notifications@github.com> wrote:
> 
> ﻿
> The case is where the application dynamically adds a listener after the instance has initialized (and may remove it later).
> 
> And there doesn't appear to be any way to determine if a custom event listener has been added dynamically via vm.$on(...) (and when removed via vm.$off(...)).
> 
> In our use case, when a certain prop is set to true, the listener handler is instantiated on demand, and when the prop is false the listeners are removed.
> 
> I don't think modifying the prototype would help in this situation.
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub, or unsubscribe.

--
",tmorehouse,"
--
The case is where the application dynamically adds a listener after the instance has initialized (and may remove it later).

And there doesn't appear to be any way to determine if a custom event listener has been added dynamically via `vm.$on(...)` (and when removed via `vm.$off(...)`).

In our use case, when a certain prop is set to `true`, the listener handler is instantiated on demand, and when the prop is false the listeners are removed.

I don't think modifying the prototype would help in this situation.

Adding a separate property would help if it isn't possible to place all the registered event listeners in the same object.
--

--
I suppose we could check the private object `vm._events`, which does have the the listeners from both `v-on` and `vm.$on(..)` registered (and check the array length), but since that is not a ""public"" API it wouldn't be as clean.
--
",,,,,,,,
10812,OPEN,vue-template-compiler module types do not express the correct optional properties,typescript,2019-11-09 14:25:34 +0000 UTC,emensch,Opened,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-template-compiler-module-type-bug-wl0wn](https://codesandbox.io/s/vue-template-compiler-module-type-bug-wl0wn)







### Steps to reproduce
Issue is surfaced by CodeSandbox' typescript linter - just load the sandbox.


### What is expected?
vue-template-compiler should accept modules with **0 or more** of the following properties:
- `preTransformNode`
- `transformNode`
- `postTransformNode`
- `genData`

### What is actually happening?
vue-template-compiler _requires_ modules to have all `transform` functions and `genData` defined. 

![codesandbox typescript error](https://puu.sh/ECk1R/7a7236e09e.png)

---
Ran into this while developing a custom template compiler module. It doesn't effect output or compiler functionality in any way, but it does impact developer experience.

Fixed by #10743

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10805,OPEN,Computed Setter Does Not Work In Scoped Slot,discussion,2019-11-07 10:15:00 +0000 UTC,pxwee5,In progress,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/jameswee/pen/BaaxLmE](https://codepen.io/jameswee/pen/BaaxLmE)

### Steps to reproduce
1. Create computed setter in parent and pass it into scoped slot
2. Attach computed setter via scoped slot into child's v-model
3. Test

A working example is available if you comment out line 2 and uncomment line 3. 

### What is expected?
Editing the input box should trigger the alert function

### What is actually happening?
Editing input box isn't triggering the computed setter.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is inherent to how reactivity works in Vue (by setting reactive keys in objects) and how slots receive the data as parameters in a function.
To make it work, you would have to wrap the variable in some kind of container that has reactive keys: 

```js
const parent = Vue.component('parent', {
  template: '<div><slot :container=""fooContainer"" /></div>',
  
  computed: {
    foo: {
      get: function() {
        return ""foo"";
      },
      set: function(value) {
        alert(value);
      }
    },
    fooContainer() {
      const o = {}
      Object.defineProperty(o, 'foo', {
        get: () => this.foo,
        set: foo => this.foo = foo
      })
      return o
    }
  }
})

new Vue({
  el: '#app',
  components: {
    parent
  },
  template: `
    <parent>
      <template #default=""{ container }"">
        <input v-model=""container.foo"" />
      </template>
    </parent>`,
})
```

For it to work without containers, we would have to make the object you named `slot` reactive but that would add a cost for every slot usage and I think that would impact more users than it helps
--
",pxwee5,"
--
Hmmm, this is tricky isn't it. At first glance it's really hard to understand the usage of `fooContainer` function, which eventually makes the code really hard to review. 

It'll be nice if there's a way to make these a bit more consistent. I wonder if this will be addressed in v3 ?
--
",,,,,,,,
10786,OPEN,Trigger a warning when v-show and other incompatible directives are used on <template>,discussion; warnings,2019-10-31 20:03:43 +0000 UTC,mrleblanc101,Opened,,"### What problem does this feature solve?
Hi,

I lost quite some time trying to figure out when my code didn't work.
The error was on my part, not vue, but i think Vue should trigger an error in this case.

The problem is that you CANNOT use `v-show` on a `<template>` tag, which make sense since `v-show` add inline style to the node and the `<template>` tag does not render a node.

### What does the proposed API look like?
A Vue warning/error should suggest changing the `v-if` (if possible) or change the `<template>` tag for a DOM element (like a `<div>`)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10780,OPEN,ssr renderScripts don't support custom attributes,,2019-10-31 09:45:50 +0000 UTC,hxlniada,Opened,,"### Version
2.6.10

### Reproduction link
[https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/build.dev.js#L9041](https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/build.dev.js#L9041)







### Steps to reproduce
see the code，it's hard coded to
```
return (""<script src=\""""   (this$1.publicPath)   file   ""\"" defer></script>"")
```

### What is expected?
renderScripts with configuable attributes


### What is actually happening?
It's hard coded

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Hey, could you please close this issue and open a new one as a feature request and provide:

- Multiple practical use cases where this would help (like the cross origin one and maybe others)
- Propose an api to pass that information
--
",,,,,,,,,,
10778,OPEN,Add non-passive event modifier,feature request,2020-12-17 01:41:22 +0000 UTC,tobyzerner,Opened,,"### What problem does this feature solve?
An event modifier to support `passive` events was added in #5132.

In the last couple of years, browsers have adopted the `passive` behavior by default for `touchstart` and `touchmove` events ([reference](https://www.fxsitecompat.dev/en-CA/docs/2018/touch-event-listeners-are-now-passive-by-default-making-scrolling-faster-on-mobile/)). Thus, to be able to cancel one of these events by calling `e.preventDefault()`, you need to explicitly pass `{ passive: false }` when adding the event listener.

With the current API this is impossible to achieve in a Vue template (as far as I can tell). You must manually add and remove the event listener in a component hook like so:

```js
this.$refs.someElement.addEventListener('touchstart', this.start, { passive: false });
this.$refs.someElement.addEventListener('touchmove', this.move, { passive: false });

// later
this.$refs.someElement.removeEventListener('touchstart', this.start);
this.$refs.someElement.removeEventListener('touchmove', this.move);
```

### What does the proposed API look like?
An event modifier that does the opposite of the `passive` event modifier, specifying the option as `false` instead of `true`.

Unsure of the naming - perhaps `nonPassive`, `active`, `assertive`, `intentional`.

```html
<div
  @touchstart.active=""start""
  @touchmove.active=""move""
></div>
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,kleinfreund,"
--
In [`vue/src/core/vdom/helpers/update-listeners.js:22`](https://github.com/vuejs/vue/blob/dev/src/core/vdom/helpers/update-listeners.js#L22), `normalizeEvent` always returns an object with a set `passive` property.

I’m not familiar with Vue’s source code, but does that mean that when the `.passive` modifier is not present, each event handler is **always declared as active**? This seems wrong in the light of browser’s changing the default for certain event types to be passive by default (see [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)). If `.passive` is not present, I don’t expect event handlers to be marked as not passive.

With regards to the feature request itself, I think “active” would be a natural choice here.
--
",WORMSS,"
--
nonPassive seems like the more logical opposite of passive.
Just wondering what wins if you do
```
@scroll.passive.nonPassive=""...""
```
vs
```
@scroll.nonPassive.passive=""...""
```
Any difference at all? which one wins?
If neither is passed, I believe passive should be left as undefined.
--
",inspire22,"
--
Any1 figure out a workaround to this?  touchstart & conditionally setting preventDefault in the running code doesn't seem to work to cancel the event.
--
",Kvothe1997,"
--
In Vue 3, the following code generates a ""passive : false"" event listener attached to that `div`.

```
<div
  @touchstart=""function""
></div>
```
--
",,,,
10776,OPEN,Property '$options' does not exist on type 'VueConstructor<Vue>'.,typescript,2020-03-10 17:48:29 +0000 UTC,zsluedem,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/jafbudpk/3/#&togetherjs=HlrrSLGnsb](https://jsfiddle.net/jafbudpk/3/#&togetherjs=HlrrSLGnsb)







### Steps to reproduce
```
import Vue, { PluginFunction } from 'vue';
interface PluginOptions {}

export const Plugin: PluginFunction<PluginOptions> = function Plugin(Vue, PluginOptions): void {
  Vue.mixin({
    created() {
      this.$options.socket = 1;
    }
  });
};

```

### What is expected?
The `$option` should be already type right.

### What is actually happening?
  Property '$options' does not exist on type 'VueConstructor<Vue>'.ts(2339)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,stuft2,"
--
Is there a reason that some public members of the Vue class are not included in the type definition? This is getting really messy for me as I'm having to create a vue-shim.d.ts that augments the VueConstructor type as a work around for this issue.
--
",,,,,,,,,,
10762,OPEN,Computed properties with getter/setter do not provide expected Typescript type annotation,typescript,2020-07-11 13:07:58 +0000 UTC,EvanSanderson,Opened,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/quiet-glitter-qk7fy?fontsize=14](https://codesandbox.io/s/quiet-glitter-qk7fy?fontsize=14)







### Steps to reproduce
1) Create a computed property in a single file component that is lang=""ts"" - call it myComputedProp

2) Add a get() and set() method for that computed prop

3) Annotate the get() method (for example get(): string)

4) Annotate the set() method (for example set(myValue: number): void ) 

5) Check the inferred types of myComputedProp - it looks like it will be string | number

### What is expected?
When the get() method of a computed property is annotated with a type, the computed properties type will correspond to that annotation. 

### What is actually happening?
When the get() method of a computed property is annotated with a type (A), and the set() methods parameter has been annotated with a type as well (B), the computed property has a type of A | B

---
This may very well be a user error on our part as well, and perhaps the community or Vue team has some suggestions for how to better handle this. We provide auto generated types from an api client, so having the ""or"" syntax with the computed annotation in this case means we need to use a type assertion to circumvent this. Thanks a ton! Happy to provide screenshots I took as well.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,KaelWD,"
--
Pretty sure this is intentional, otherwise you wouldn't be able to assign a number to it. 

```ts
this.myComputedProp = 1 // Type '1' is not assignable to type 'string'
```
--

--
If the types could be different then `this.myComputedProp = this.myComputedProp` would be an error. 
--
",ktsn,"
--
I don't think it's possible because TypeScript forbid having different types between `get` and `set`.

![image](https://user-images.githubusercontent.com/2194624/67925611-d4a6cc00-fbee-11e9-926e-9010dc09623f.png)

--
",WhyNotHugo,"
--
@ktsn Thank you! :pray: I didn't realise I was missing type annotations on my **setter**, I was getting like 50 errors all over the place just because of that missing annotation!
--
",,,,,,
10742,OPEN,Vue purposely removes vendor prefixes when using style binding,,2019-10-21 23:52:16 +0000 UTC,WisdomSky,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/80o2ef9w/](https://jsfiddle.net/80o2ef9w/)







### Steps to reproduce
Create an element and add style binding:

    <div :style=""{'-webkit-clip-path': 'some values'}"">example</div>

### What is expected?
    <div style=""-webkit-clip-path: some values"">example</div>

### What is actually happening?
    <div style=""clip-path: some values"">example</div>

---
In the docs, it is stated that Vue supposedly automatically adds vendor prefixes to CSS properties if it needs them, but not for `clip-path`. In Safari, the `-webkit-` prefix is required to be specified in order for it to work.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sirlancelot,"
--
Vue looks at exactly what the browser can support by examining the style property of a div. You should not prefix style properties yourself.

Detection logic here: [src/platforms/web/runtime/modules/style.js](https://github.com/vuejs/vue/blob/v2.6.10/src/platforms/web/runtime/modules/style.js) (line 32: `normalize`)
--

--
It looks like Safari has both `clipPath` & `webkitClipPath` on elements (tested on Safari v13.0.2)
--
",,,,,,,,,,
10739,OPEN,There is no a attribute like react's $$typeof to prevent XSS injection in the vnode of Vue.,,2019-10-26 04:55:55 +0000 UTC,ddosakura,In progress,,"### Version


### Reproduction link
[https://codepen.io/ddosakura/pen/eYYgYqZ](https://codepen.io/ddosakura/pen/eYYgYqZ)







### Steps to reproduce
vue 的 vnode 中，没有一个类似 react 的 $$typeof 属性来防止 XSS 注入。

```js
const inject = {
  tag: ""div"",
  children: [
    {
      text: ""injecting""
    }
  ]
}
const no_inject = ""no_inject""

const InjectTest = () => {
  return <div>
    { inject }
    { no_inject }
  </div>
}
```

### What is expected?
希望像 React 中一样，在 vnode 中添加类似 $$typeof 的 Symbol 属性来防止 XSS 注入。

### What is actually happening?
一个伪造的 vnode 对象，会被正常渲染成 dom。

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sirlancelot,"
--
I suspect this has to do with JSX and is not related to the Vue.js project
--

--
I think a couple well-placed `obj instanceof VNode` checks should do the trick. However, I am admittedly very weak in the vdom portion of the codebase.
--
",ddosakura,"
--
> I suspect this has to do with JSX and is not related to the Vue.js project

JSX仅仅是语法糖，不使用JSX依旧有该问题。
JSX is just a syntactic sugar. There is still a problem without JSX.

这是一个不使用JSX的例子。
This is an example without JSX.

[codepen](https://codepen.io/ddosakura/pen/mddRWBa)

问题的所在是Vue无法判断一个VNode是由createElement创建，或是被伪造的。
The problem is that Vue cannot judge whether a vnode is created by createElement or forged.

由于json无法反序列化出Symbol,使用类似React的添加$$typeof属性的方案可以规避这个问题。

[中文参考连接](https://juejin.im/post/5cecf286f265da1b83336dbe)

and [React Components, Elements, and Instances](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)

> All React elements require an additional $$typeof: Symbol.for('react.element') field declared on the object for **security reasons**. It is omitted in the examples above. This blog entry uses inline objects for elements to give you an idea of what’s happening underneath but the code won’t run as is unless you either add $$typeof to the elements, or change the code to use React.createElement() or JSX.
--

--
追加一个根据此问题在 [element-ui](https://element.eleme.cn) 中找到的注入：[codepen](https://codepen.io/ddosakura/pen/qBBRrzJ)
--
",Kingwl,"
--
Thanks for the reminder.
Add this check to avoid some kind of xss is not a bad idea.
The only question is, Symbol has terrible compatibility. All of IE does not support Symbol.

cc:/ @yyx990803
--
",,,,,,
10734,OPEN,Symbol-keyed properties non-reactive,feature request,2019-10-22 02:44:40 +0000 UTC,dansebcar,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/dansebcar/b75n0uw6/16/](https://jsfiddle.net/dansebcar/b75n0uw6/16/)







### Steps to reproduce
- Press update to change each item's name to ""b""

### What is expected?
The list re-renders with the new name

### What is actually happening?
The list does not change

---
If we instead define ""symbol"" as any non-empty string, the expected re-render is observed, so I think the cause is just the parent list (items) is accessed through a symbol.

Nesting the symbol property an additional level (IE in config, rather than directly on data) is necessary to render the list at all; I guess symbols from data aren't directly transferred?

I noticed in the devtools when I pressed ""refresh"" after mutating the items that I could see the new name, so I assumed something about the way I was setting the property didn't trigger the update, but even Vue.set did not help.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,xx1124961758,"
--
Because of the way defineproperty works, I don't know why. It should be OK to change defineproperty to proxy in vue 3.0 version.

![image](https://user-images.githubusercontent.com/13390985/67183448-11ffa280-f414-11e9-995c-dbe6f2be0690.png)

--

--
@Tipwheal  i made a mistake.
--
",Tipwheal,"
--

![image](https://user-images.githubusercontent.com/18046379/67197974-8cd6b680-f430-11e9-9217-82b5340dd904.png)

--

--
I tried to add some code in the function Observer.prototype.walk to support using Symbol, it works

```
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  if (Reflect.ownKeys) {
    Reflect.ownKeys(obj).filter(k => typeof(k) === 'symbol').forEach(k => keys.push(k));
  }
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};
```
--

--
https://jsfiddle.net/mwrjxLg8/ `Vue.set` helps
--
",,,,,,,,
10733,OPEN,vue-server-renderer: directive not applied to imported component,bug; contribution welcome; feat:ssr,2021-01-11 16:51:05 +0000 UTC,manniL,Opened,,"### What problem does this feature solve?
Currently, SSR directives are not applied to used (sub-)components but only to HTML-tags and elements.

### Reproduction

```js
// Step 1: Create a Vue instance
const Vue = require(""vue"");

const Test = {
  template: `<div>This should be red</div>`
}

const app = new Vue({
  template: `
  <div>
    <Test v-make-red/>
    <div v-make-red>This is red</div>
  </div>
  `,
  components: {
    Test
  }
});

const makeRed = (node, dir) => {
  const style = node.data.style || (node.data.style = {});
  if (Array.isArray(style)) {
    style.push({ backgroundColor: ""red"" });
  } else {
    style.backgroundColor = ""red"";
  }
};

// Step 2: Create a renderer
const renderer = require(""vue-server-renderer"").createRenderer({
  directives: {
    makeRed
  }
});

// Step 3: Render the Vue instance to HTML
renderer.renderToString(app, (err, html) => {
  if (err) throw err;
  console.log(html);
  // <div data-server-rendered=""true""><div>This should be red</div> <div style=""background-color:red;"">This is red</div></div>
  // But should include red background-color style for the first div as well
});
```

Related: https://github.com/nuxt/nuxt.js/issues/6575

<!-- generated by vue-issues. DO NOT REMOVE -->",,,dagadbm,"
--
hey guys. i use vue on a daily basis and i would like to contribute. I see here this is a contribution welcome label.
can someone help me so i can start to fix this if possible?

(i already forked installed and can run test and build.)
--
",Neodark7,"
--
Hi, any update on this ? still not working with nuxt 2.14
--
",Dryymoon,"
--
> Hi, any update on this ? still not working with nuxt 2.14

+1 
Still not working, 
nuxt@2.14.6
vue@2.6.12
vue-server-renderer@2.6.12 
--
",tylerforesthauser,"
--
I'm rather confused as to why [this fix](https://github.com/vuejs/vue/pull/11287) hasn't been implemented as it appears to completely resolve this issue...
--
",,,,
10731,OPEN,transition-group has stutter when component updated elsewhere,bug; transition,2020-11-01 01:32:05 +0000 UTC,719media,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/zncxud6q/](https://jsfiddle.net/zncxud6q/)







### Steps to reproduce
Use test1, test2, or test3 buttons to see transition without stutter.
Use test4, test5, or test6 buttons to see transition with stutter.

### What is expected?
No stutter

### What is actually happening?
While the DOM is updating, the transition restarts, even though the portion updating isn't a child of anything transitioning

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It's even more noticeable with non-linear transitions. As a workaround, you can wrap the content into a component and pass the content through a Store instead of props but that's quite cumbersome.
--
",underflow00,"
--
What's the workaround for this?
@posva Could you provide an example?
--
",,,,,,,,
10721,OPEN,Type Error while hot reloading,,2019-10-16 20:25:09 +0000 UTC,SimonSiefke,In progress,,"### Version
2.6.10

### Reproduction link
[https://github.com/SimonSiefke/vue-hot-reloading-issue](https://github.com/SimonSiefke/vue-hot-reloading-issue)







### Steps to reproduce
Inside the script section inside `App.vue`, do the following edits:

1. remove the return inside data
```js
export default {
    data() { }
};
```

2. return an empty object
```js
export default {
  data() {
    return {};
  }
};
```

3. return the original
```js
export default {
  data() {
    return {
      count: 2
    };
  }
};
```

### What is expected?
After doing the edits, the App looks normal since it is the same code as before.

### What is actually happening?
Hot reloading encounters multiple TypeErrors inside `updateComponent` from Vue and the App cannot recover from its state and doesn't update automatically anymore, it just shows a blank page.

Also, the command line shows `DONE Compiled successfully in 97ms` which suggests that everything is fine.

When the page is reloaded everything works again as expected.


---
### Additional Information:
I have included images inside the minimal reproduction sample that might be useful.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,SimonSiefke,"
--
The TypeErrors are happening in the following places: 
1. https://github.com/vuejs/vue/blob/78c3ce0ce0c2230f657cb7772a84fc7aa7ce0825/src/core/instance/proxy.js#L59

target.$data is undefined, therefore we get `TypeError: right-hand side of 'in' should be an object, got undefined`

2. https://github.com/vuejs/vue/blob/78c3ce0ce0c2230f657cb7772a84fc7aa7ce0825/src/core/instance/proxy.js#L61

basically the same as 1.

3. https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L119
vm.data is undefined, therefore we get `TypeError: ""vm._data is undefined""`
--
",,,,,,,,,,
10717,OPEN,<template> tag which inside v-pre directive; will be ignore if v-pre doesn't use at staticRoot,has workaround; regression,2020-04-07 19:21:05 +0000 UTC,cutPicturesMan,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/vuetest/c5uw870y/3/](https://jsfiddle.net/vuetest/c5uw870y/3/)







### Steps to reproduce
1、click jsfiddle link
2、you will see result is {{msg}}，is incorrect

### What is expected?
render template tag as html element, dom looks like that:
```html
<div>
  <p>
    <template>
      #document-fragment
      <span>{{msg}}</span>
    </template>
  </p>
</div>
```

### What is actually happening?
template tag disappeared
```html
<div>
  <p>
    <span>{{msg}}</span>
  </p>
</div>
```

---
when v-pre used at the staticRoot, template render correctly, fixed by [#8146](https://github.com/vuejs/vue/pull/8146). see this also: https://jsfiddle.net/vuetest/c5uw870y/5/

when v-pre does not used at the staticRoot, template tag will be skip, source code in `vue/src/compiler/codegen/index.js` is:
```js
export function genElement (el: ASTElement, state: CodegenState): string {
  // ...
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    // template tag run into here, directively render it's children instead of him
    return genChildren(el, state) || 'void 0'
  } // ...
```

how to slove this problem:
```js
export function genElement (el: ASTElement, state: CodegenState): string {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre; 
    // add this line
    state.pre = el.pre;
  }
```

I'm not  familiar with creating pr with test, someone else can help me?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
it seems that it was fixed in 2.5.18-beta-0 but regressed right after in 2.5.18
--

--
Found a workaround thanks to #11292. making a part of the template dynamic makes it work:


```html
<div>
  	<p v-pre>
    	<template><span>{{msg}}</span></template>
		</p>
    {{ '' }}
	</div>
```

the `{{ '' }}` outputs nothing but workarounds the problem
--
",michael,"
--
FYI @nmetulev and @vogtn
--
",,,,,,,,
10628,OPEN,Error compiling long string litteral (many + on many lines),bug; has workaround,2019-10-13 18:54:38 +0000 UTC,271ch,Opened,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/embed/vue-template-ysl83](https://codesandbox.io/embed/vue-template-ysl83)

### Steps to reproduce
Just click the link and you see the error and start editing.
Go to the second of the component and you see a red line (line no 24?)
It says that the string literal is not correct, but its because it loads just a piece of it.

### What is expected?
No compilation error

### What is actually happening?
A compilation error

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
it seems that the `</script>` string makes the SFC parser stop earlier than it should.
As a workaround you can escape the slash `<\/script>`
--
",,,,,,,,,,
10626,OPEN,transition-group with duration property doesn't work,discussion; feature request; transition,2019-10-18 18:14:12 +0000 UTC,Monchi,In progress,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-template-lcrsy](https://codesandbox.io/s/vue-template-lcrsy)







### Steps to reproduce
Click ""Move"" button.

### What is expected?
Both two lists move with animation.

### What is actually happening?
Only second list which is applied duration with css has animation.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
`duration` only exists in `transition`. Since `transition-group` has 3 types of animations, we could have something like:

**Number**: Applies the same duration to _enter_, _leave_ and _move_
```vue
<transition-group :duration=""500"">...</transition-group>
```

**Object**: Explicit for every type of animation but requires the three of them
```vue
<transition-group :duration=""{ enter: 500, leave: 800, move: 300 }"">...</transition-group>
```

--
",Monchi,"
--
@posva I tried to resolve this: https://github.com/vuejs/vue/pull/10627
Please merge if it looks good.
--
",,,,,,,,
10614,OPEN,when <select> model and the option list changed at the same time; model may incorrectly set to `undefined`,bug; has workaround,2020-01-20 01:07:33 +0000 UTC,xieranmaya,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/4fyrj95L/](https://jsfiddle.net/4fyrj95L/)







### Steps to reproduce
set model binded to select element and the array that iterated the option list at the same time

make sure the new model value do not match any of the new options

the model will be set to `undefined`

### What is expected?

model value to be set to `1`

### What is actually happening?
model's value set to `undefined`

---
This bug only appears when model and the options changed at the same and the new model value does not match any option, other situations behaves correctly as far as I tested.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
as a workaround you can set a `key` on the `select` element that changes alongside the selected list
--

--
A workaround is only a temporary fix for the problem for you or anybody to have a solution until a fix is released: The original problem has nothing to deal with keys yet, adding a `key` **does remove the bug**
--

--
It should keep the set value instead of changing it to `undefined`
--
",xieranmaya,"
--
It has nothing to do with the key, add key or keys do not resolve the problem.
Acturally the bug is triggered by an internal logic.
See the pr I created above.
@posva

--

--
This issue is owned by the logic of the code:
https://github.com/vuejs/vue/pull/10615/files
the `$selectedValue` variable in line 121 may be an empty array, but the subsequent code read its first element, if the code is in c/c++, that would be an error or index out of bound.
setting it to `undefined` is just an accident.
--
",despreston,"
--
@posva Maybe im reading the description incorrectly but this sounds like expected behavior. If i change the list of available options, and then change the value to something not in the list of available options, it _should_ be `undefined`, right?
--
",,,,,,
10596,OPEN,transition-group with v-move class not working properly for elements with immediate watchers that calls $set,transition,2019-10-04 15:49:00 +0000 UTC,bluwy,In progress,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-transition-group-bug-wnvwv](https://codesandbox.io/s/vue-transition-group-bug-wnvwv)







### Steps to reproduce
1. Open codesandbox.
2. Click the ""toggle transition"" checkbox.

### What is expected?
The enter transition should be animate smoothly.

### What is actually happening?
In transition group with v-move class, the elements with immediate watchers that calls $set interrupts the enter transition causing it to ""snap"".

---
In the codesandbox repro, I provided workarounds to fix this problem.

I found this bug in this [vuetify issue](https://github.com/vuetifyjs/vuetify/issues/9171).

This happened on vuetify's 2.0.19 release where [this code](https://github.com/vuetifyjs/vuetify/blob/v2.1.0/packages/vuetify/src/mixins/binds-attrs/index.ts) was added in to resolve issue #10115.

I'm not sure what is the direct cause as both the v-move class and the immediate watcher causes this issue.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Duplicate of https://github.com/vuejs/vue/issues/7879
--

--
Right, I didn't see the Test component having specific behavior
--
",bluwy,"
--
This isn't a duplicate of the linked issue. That issue had problems with the `v-show` directive with transition groups whereas this issue only uses `v-if`, but `v-if` isn't really the factor causing this issue though.

I tested the linked issue's jsfiddle and changed `v-show` to `v-if` and it works as expected. So I'm guessing both aren't directly related.
--
",,,,,,,,
10590,OPEN,"transitions with appear should be SSR with the ""-enter"" class",transition,2021-03-05 22:32:09 +0000 UTC,matthieusieben,In progress,,"### Version
2.6.10

### Reproduction link

```sh
mkdir vue-bug-repo
yarn init -y
yarn add vue vue-server-renderer
```


```js
// Step 1: Create a Vue instance
const Vue = require('vue')
const app = new Vue({
  data: () => ({ show: true }),
  template: `<div>
    <transition appear name=""fade"">
      <p v-if=""show"">
      Hello World
      </p>
    </transition>
  </div>`
})

// Step 2: Create a renderer
const renderer = require('vue-server-renderer').createRenderer()
renderer.renderToString(app).then(html => {
  console.log(html)
}).catch(err => {
  console.error(err)
})
```





### Steps to reproduce

- `node index.js`

### What is expected?

The server response should contain the `*enter` classes applied to the transitioning element. The `*active` classes should then be applied during the `hydration` so that the transition can appear smoothly.

### What is actually happening?

The element is first displayed, as if there were no transitions. Then then entire animation starts, causing wired animations.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,matthieusieben,"
--
This issue is still unresolved.
--
",milesingrams,"
--
I have this issue too. Expecting appear transitions to have the appear-from class applied on static generation and SSR so the initial position can be appropriately rendered until vue mounts
--
",drewbaker,"
--
Yeah I expected that `appear` works for initial animation when SSR or client side render occurs. Otherwise not sure the point of appear, if I need to toggle a v-if on mounted to get the initial animation to happen anyway. 
--
",,,,,,
10573,OPEN,Prevent Vue.use to be used without options parameter unless it's specified as optional (with `?`),improvement; typescript,2019-09-27 12:04:13 +0000 UTC,bitPogo,In progress,,"### What problem does this feature solve?
**Reproduction link**
Please see: https://tinyurl.com/y5mlgqqh

**Steps to reproduce**

1. write a plugin
2. overload Vue.use ( see the given link above for detail )

**What is expected?**
During compiling it fails, because the types are not matching.

**What is actually happening?**
It compiles without errors

### What does the proposed API look like?
A possible solution is to change the type in vue/types/vue VueConstructor to: 

` use(plugin: PluginObject<unknown> | PluginFunction<unknown>, ...options: unknown[]): VueConstructor<V>;`

See: https://tinyurl.com/y6anfs8b

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Vue.use is already typesafe. You shouldn't override it, Provide the `MessagePluginOptions` to the generic of PluginFunction like this: https://github.com/vuejs/vuefire/blob/master/packages/vuefire/src/firestore.ts#L104-L107
--

--
Okay, sorry, it took me some time to understand what you meant. Next time, make sure to correctly point what isn't working instead of saying _it compiles without errors_. I'm updating the title to reflect the intention. This is an easy PR and you already found the solution, can you send a PR with the change and the test? If you cannot that's fine, I will do it.
--

--
if you need help with the PR message me on Discord but you are pretty much done with  https://tinyurl.com/y6anfs8b 🙂 
--
",bitPogo,"
--
Thanks for the advise but it still not satisfy all constrains which are intended in the change. Please see: https://tinyurl.com/y2aksjmw
( It would be nice if you would not close the issue right away )
--

--
Thanks for your politeness! I try to make a more clearer description next time! Is there any chanel, if I have question, to poke you?
 
--
",,,,,,,,
10547,OPEN,Infinite loop in vue-template-compiler,bug; contribution welcome; has PR,2019-11-18 09:58:40 +0000 UTC,oguimbal,In progress,,"### Version
2.6.10

### Reproduction link
[https://github.com/oguimbal/vuebug](https://github.com/oguimbal/vuebug)







### Steps to reproduce
```
git clone git@github.com:oguimbal/vuebug.git
npm i
npm start
```

Wait a couple of seconds, and your compilation process will be frozen.

If you attach a debugger to the node process, you will see the infinite loop in `generateCodeFrame()` method of vue-template-compiler:

![bug](https://raw.githubusercontent.com/oguimbal/vuebug/master/bug.png)

### What is expected?
I would expect the compiler not to freeze

### What is actually happening?
The compiler is freezing

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Hey, in order to check we need a boiled down repro without any extra dependency (like storybook). Ping me when you get a boiled down repro so I can get a look
--

--
It shows an error instead of freezing:

```
ERROR in ./bug.vue?vue&type=template&id=20e40a56&lang=pug& (./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./bug.vue?vue&type=template&id=20e40a56&lang=pug&)
Module Error (from ./node_modules/vue-loader/lib/loaders/templateLoader.js):
(Emitted value instead of an instance of Error)

  Errors compiling template:

  Component template requires a root element, rather than just text.

  1  |
     |
  2  |  div Whatever
     |  ^^^^^^^^^^^^
  3  |

 @ ./bug.vue?vue&type=template&id=20e40a56&lang=pug& 1:0-202 1:0-202
 @ ./bug.vue
 @ ./main.js
```

The error comes from vue-loader though. It could maybe display a warning if the specified lang does not contain a rule in the webpack config but at the same time the need of using pre processors is explained on the very first paragraph
--

--
I see, you should use LF ending. It can be enforced through eslint via `linebreak-style`.
Let me check a bit more about this
--

--
Even when using CRLF endings in the bug.vue file (on osx), I get the same error as before, no infinite loop 🤔 
--
",oguimbal,"
--
@posva No problem... 

https://github.com/oguimbal/vuebug-simple

```
git clone git@github.com:oguimbal/vuebug-simple.git
cd vuebug-simple
npm i
code .
```

Then hit F5 (if using vscode, otherwise `npm start`) => freeze.

nb: I know that i forgot to include pug loader ... but thats the point, it freezes without error.

[edit]  NB: The tight loop is in [generateCodeFrame()](https://github.com/vuejs/vue/blob/77796596adc48d050beefd11e827e8e4d44c6b3c/src/compiler/codeframe.js), where  [line 16-17](https://github.com/vuejs/vue/blob/77796596adc48d050beefd11e827e8e4d44c6b3c/src/compiler/codeframe.js#L17) seems fishy to me
--

--
Not on my machine oO'  (see screenshot as ""proof"")

However, if you look at [this](https://github.com/vuejs/vue/blob/77796596adc48d050beefd11e827e8e4d44c6b3c/src/compiler/codeframe.js#L17) , it is kind of obvious that this loop can never finish in some circumstances.

For me, with my repo, it gets called that way:

```
generateCodeFrame(`
div Whatever
`, 2, 16)
```

Which freezes:  [https://codesandbox.io/embed/xenodochial-roentgen-5dbbq](https://codesandbox.io/embed/xenodochial-roentgen-5dbbq)

![image](https://user-images.githubusercontent.com/8973947/65412381-6866ca80-ddef-11e9-87d7-679ea8505db0.png)

--

--
@posva I know know if you dont believe me or if you dont have the time to look at it, but I think it is probably due to the fact that I'm on **Windows** and you might not: My line breaks are `\r\n` instead of `\n` ... 

Thus generateCodeFrame() gets called with ""16"" as length in the example above (which should be 14 without `\r`'s)

The split `const lines = source.split(/\r?\n/);` removes those two caracters.

But the line `count += lineLength + 1;`  does not take them into account (only adds 1 line return character), and there is no check that gets execution out of this infinite loop.

Anyway I wont bother you further with that, the problem is solved for me anyway :)

--

--
Created [a pull request](https://github.com/vuejs/vue/pull/10553) that should fix it.

Just a suggestion that is a bit more agnostic about wether if this funciton input has CR in source.
( @sodatea fix would work, but only if caller does not provide the `end` argument).

Plus it breaks out of the loop if `j >= lines.length` ... if i'm correct, there is no good reason to stick in the loop in this case :)
--
",sodatea,"
--
I just reproduced this issue… The repository URL in OP is different from the one in the screenshot. The correct one is https://github.com/oguimbal/vuebug-simple
After cloning this repo & change the line endings I can reproduce the frozen output bug.
--

--
So… I believe this is a bug. PR's welcome.
--

--
Well I have found the culprit 😂
https://github.com/vuejs/vue/blob/d2db6af1a55fdb4d65746fb67f7bfbced7d916f0/src/compiler/codeframe.js#L8

This line.
There're many warnings that do not provide the `end` position.
For those warnings, `end` is calculated by `source.length`. However, in the following for-loop, `count` is incremented by `lineLength + 1`, which is incorrect if the line ends with CRLF. Thus the infinite loop.

Also, this only happens when the template does not have an indentation because otherwise Vue would have [normalized the template source during de-indentation](https://github.com/vuejs/vue/blob/d2db6af1a55fdb4d65746fb67f7bfbced7d916f0/src/sfc/parser.js#L101)
--

--
The fix is as simple as
```
end: number = source.replace(/\r\n/g, '\n').length
```
--
",caiwang1993,"
--
哈哈
--
",webwhy,"
--
xx
--
",,
10536,OPEN,v-slot to be used in case a slot prop is undefined error,improvement,2020-01-27 20:54:30 +0000 UTC,gongph,In progress,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/gongph/pen/bGbQLGE?editors=1010](https://codepen.io/gongph/pen/bGbQLGE?editors=1010)


Reproduction code at below:

Javascript: 
```js
Vue.component('current-user', {
  data () {
    return {
      item: {
        user: {
          name: 'defualt name'
        }
      }
    }
  },
  template: `
    <div>
      <slot v-bind=""item""></slot>
    </div>
  `
})
new Vue({
  el: '#app'
})
```
Html:

```html
<div id=""app"">
  <current-user v-slot=""{ user }"">
   <!-- page print: `default name` -->
    {{ user.name }}
  </current-user>
  <current-user v-slot=""{ user = { name: 'gongph' } }"">
    <!-- page print: { 'name': 'default name' }-->
    {{ user }}
  </current-user>
</div>
```



### Steps to reproduce
1. open brower console
2. console print [Vue warn] is :  

```bash
[Vue warn]: Error compiling template:
invalid expression: Invalid shorthand property initializer in
v-slot=""{ user = { name: 'gongph' } }""
```

### What is expected?
if prop is undefined show `gongph` value. for example:

```js
Vue.component('current-user', {
  data () {
    return {
      item: '' // item is undefined
    }
  },
  template: `
    <div>
      <slot v-bind=""item""></slot>
    </div>
  `
})
```
```html
<current-user v-slot=""{ user = { name: 'gongph' } }""
 <!-- expected output `gongph` -->
  {{  user.name }}
</current-user>
```
### What is actually happening?
`gongph` value can normal render , but console show warn message: 

```bash
[Vue warn]: Error compiling template:
invalid expression: Invalid shorthand property initializer in
v-slot=""{ user = { name: 'gongph' } }""
```
<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
The default value passed via `v-slot` does displays if no value is passed' but the error message shouldn't appear
--
",gongph,"
--
I don't know why it show [Vue warn] @posva 
--
",albertodeago,"
--
I think this is already fixed with https://github.com/vuejs/vue/pull/9917
In fact I just tested this with a built version 2.6.11 and I see no warning
--
",sirlancelot,"
--
Note that argument defaults work **only** if the value is exactly `undefined`. In your component you are setting it to `''` (an empty string) which is not `undefined`.
--
",,,,
10530,OPEN,"test named ""vdom patch: children"" occasionally fails",contribution welcome,2019-10-15 20:11:37 +0000 UTC,Siegrift,In progress,,"### Version
2.6.10

### Reproduction link
[https://circleci.com/gh/vuejs/vue/13744?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link](https://circleci.com/gh/vuejs/vue/13744?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link)







### Steps to reproduce
Tests are flaky on CI and also sometimes locally. Re-running the tests seem to work

### What is expected?
Tests not to be flaky

### What is actually happening?
Tests are flaky

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
The test have been passing before without problems, so it may be something within the PR causing the test to fail, and in that case, tests should be updated within the PR.

Maybe someone will pick this up but the _Tests not to be flaky_ description is far from giving direction on when would you expect the test to fail or not
--
",Siegrift,"
--
Well, I don't think they are related. Also If I try to run `yarn test` couple of times, I can see some flaky tests.

But it's true that the description is rather vague. But I don't really know what is wrong, but someone else might :)
--
",mbpreble,"
--
I've seen this test fail locally (by using `fdescribe` to just run this suite) but I don't have a great handle on frequency since it was running in a loop without a counter.

Have not yet seen it fail when running in isolation(`fit` on the shuffle test) after 50 runs in a loop.

Tough to tell what's going wrong in a test that is explicitly randomized and never quite testing the same thing.

I've at least set up a harness that will allow me to run the suite until failure and capture some debugging logs, hopefully that will help clear things up.

--

--
The issue seems to be when the test generates an opacity value in the inclusive range 0.00001-0.00009. The assertion does not work because the patched element ends up with an opacity which is in scientific notation (e.g. 1e-05). With enough pulls on the slot machine this test will eventually produce such a value and fail.

Here's a minimal test which reproduces the ""problem"". It fails with ` Expected '1e-05' to be '0.00001'.`
```
import VNode from 'core/vdom/vnode'
import { patch } from 'web/runtime/patch'
it('should reproduce the flaky test', () => {
  const vnode1 = new VNode('div', { style: { opacity: '1' }})
  const vnode2 = new VNode('div', { style: { opacity: '0.00001' }})
  patch(null, vnode1)
  const elm = patch(vnode1, vnode2)
  expect(elm.style.opacity).toBe('0.00001')
})
```

If this is in fact the desired behavior and this test is useful, it should be possible to fix it by using less precision (four digits after the decimal) for the random opacity values.


--

--
Created a minimal PR to address. It reduce the number of post-decimal digits allowed in the random opacity values to 4, cutting out values in the range that case the test to fail. The previously failing assertion has been replaced with an equivalent, clearer assertion.
--

--
@posva Any interest in the patch here? Doing some math here, the random chance of failure for any given run of the test suite due to this issue is about 0.6% (70 chances to pull one of 9 'bad' values out of a pool of 100K). It doesn't seem likely to happen all that often, but if it's patched it shouldn't fail at all.


--
",,,,,,
10515,OPEN,Click Event Triggers on Complex Buttons are ignored in Pale Moon browser,browser quirks; has PR,2019-09-17 08:12:58 +0000 UTC,paulkamer,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/ye6vs8h3/](https://jsfiddle.net/ye6vs8h3/)

### Steps to reproduce
Install Pale Moon browser http://www.palemoon.org/
Open the jsfiddle (https://jsfiddle.net/ye6vs8h3/).

When clicking directly on the Vue logo image,  a click is not registered. 
When clicking just next to it, still on the grey background, a click *is* registered correctly.

### What is expected?
When clicking on a nested component, the click should bubble up to the parent element that has a `@click` handler.

### What is actually happening?
The click is not bubbled up, so takes no effect.

---
This issue is similar to several other bugfixes, for Adobe CEP and Mobile Safari:

https://github.com/vuejs/vue/issues/9462
https://github.com/vuejs/vue/issues/10366

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10506,OPEN,conflict between docs and typescript api,,2019-09-20 09:03:40 +0000 UTC,LongTengDao,Opened,,"### Version
2.6.10

### Reproduction link

### Steps to reproduce

### What is expected?

Figure out which is exact.

### What is actually happening?

doc:

https://github.com/vuejs/vuejs.org/blame/master/src/v2/guide/render-function.md#L142

doc said the first argument of createElement could be string/ComponentOptions or async return them (string/ComponentOptions),

tsd:

https://github.com/vuejs/vue/blame/dev/types/vue.d.ts#L18

while tsd file need string/ComponentOptions/ComponentConstructor (add ComponentConstructor) or sync return ComponentOptions/ComponentConstructor (both added) or async return ComponentOptions/ComponentConstructor (no string and add ComponentConstructor).

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10500,OPEN,`$forceUpdate` do not update checked status of checkbox-,regression,2021-01-19 05:36:06 +0000 UTC,xiaodemen,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/ahy27vu3/](https://jsfiddle.net/ahy27vu3/)







### Steps to reproduce
1. input[type=""text""] value is forced to` ''`, which is controlled completely
2. input[type=""checkbox""] checked does not work

### What is expected?
input[type=""checkbox""] checked is forced to `false`

### What is actually happening?
input[type=""checkbox""] checked keep the value last entered

---
Maybe this is designed on purpose，Could you please explain why？
https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/modules/dom-props.js#L67
https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/modules/dom-props.js#L42

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Please see https://github.com/vuejs/vue/issues/9535 and https://github.com/vuejs/vue/issues/9340
--

--
It is related to micro/macro task though as it used to work on 2.5

I'm realising the `$forceUpdate` doesn't work anymore though and that is a problem
--
",xiaodemen,"
--
@posva This issue has nothing to do with micro/macro task
--

--
@posva It is not related to micro/macro task, see:
https://github.com/vuejs/vue/blob/v2.6.0/src/platforms/web/runtime/modules/dom-props.js#L45
--
",Justineo,"
--
@posva I believe what @xiaodemen want is to implement a “fully controlled” checkbox.
--
",LinusBorg,"
--
You're probably both ""right"". The change that you link to, @xiaodemen, was done because it was expected that the check for ""checked"" should no longer be necessary after we did the microtaks changes  in 2.6. But appearantly that's not always the caase.
--
",benface,"
--
I know this issue is pretty old, and it might even have gotten fixed in Vue 3, but is there any chance it will be looked at at some point? 😇
--
",,
10480,OPEN,VueComponent instances retained after calling vm.$destroy,bug,2019-09-12 13:28:07 +0000 UTC,jukkakoskinen,In progress,,"### Version
2.6.10

### Minimal reproduction

```html
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <meta http-equiv=""X-UA-Compatible"" content=""ie=edge"" />
    <title>Document</title>
  </head>
  <body>
    <script src=""https://unpkg.com/vue""></script>

    <div id=""app"">
      <base-link>Link</base-link>
    </div>

    <button id=""action"">Load</button>

    <script>
      let vm
      const button = document.getElementById('action')
      button.addEventListener('click', () => {
        if (vm) {
          vm.$destroy()
          vm = null
          button.textContent = 'Load'
        } else {
          vm = new Vue({
            el: '#app',
            components: {
              BaseLink: {
                template: `<a href=""#"" @click=""onClick""><slot /></a>`,
                methods: {
                  onClick(evt) {
                    evt.preventDefault()
                    console.log('clicked')
                  },
                },
              },
            },
          })
          button.textContent = 'Destroy'
        }
      })
    </script>
  </body>
</html>
```

### Steps to reproduce

- Load the app by clicking the button and take a heap snapshot
- Load/unload the app multiple times by clicking the button
- End in loaded stat and take a heap snapshot
- Search `Vue` in the memory snapshot viewer

I've personally tested this in Chrome.

### What is expected?

Vue retained size should not increase

![Screen Shot 2019-09-06 at 09 42 58](https://user-images.githubusercontent.com/664177/64410231-de96cd80-d08a-11e9-968c-fee7ae1815a7.png)
![Screen Shot 2019-09-06 at 09 43 03](https://user-images.githubusercontent.com/664177/64410232-de96cd80-d08a-11e9-85d8-5ee29bc0818e.png)

### What is actually happening?

Vue retained size increases

---
**Background:** I'm using Vue and Turbolinks together in a project where the backend serves HTML with Vue templates inlined. This means I have to create and destroy Vue instances when navigating between pages.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I updated the issue @jukkakoskinen to be clear, I hope I didn't miss anything on the way, tell me if this is what you wanted to show in the first place
--
",jukkakoskinen,"
--
Thanks @posva! Not only Vue instance count increases, but I also see a dangling VueComponent instance. It has something to do with the BaseLink component's click handler, because without it the VueComponent instance gets collected.

![Screenshot 2019-09-06 at 11 40 56](https://user-images.githubusercontent.com/1039391/64414147-86b49280-d09b-11e9-88f8-1a683eaa7c34.png)
--

--
Thanks for the comment @kinow! In your example, you remove the dangling <a> element, which seems to ensure that the VueComponent instance gets garbage collected. Seems like that after calling `vm.$destroy()` the link element is still bound to the `onClick` method, thus leading into that the instance is retained in memory.

Possibly related: https://github.com/vuejs/vue/issues/7086
--
",kinow,"
--
I think the `VueComponent` is indeed the issue. I think a `VueComponent` is a child of `Vue`? (at least looks like it is responsible for the extra instance [from this call in the code](https://github.com/vuejs/vue/blob/95d8afa07c4a84d6c178e220913cec4b1afcf21d/src/core/global-api/extend.js#L36))

So when the `BaseLink` component is added, we get two `Vue` instances. After you have a heap snapshot with the 2x `Vue` instances, try this in the browser console:

```
Object.create(Vue.prototype)
```

Then take another snapshot, and you should have three instances.

When the instance is destroyed, the `<base-link>Link</base-link>` does not exist any longer. It was replaced by a link. So the next time you create the `Vue` app again, the component is not found, so now you will have only 1 instance of `Vue`, as the `VueComponent` was not instantiated.

But if you re-create the `<base-link>Link</base-link>`, the heap snapshot should be consistent. Always 0 when destroyed, and always 2 when loaded (1 for `Vue` app, 1 for `VueComponent`).

```html
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <meta http-equiv=""X-UA-Compatible"" content=""ie=edge"" />
    <title>Document</title>
  </head>
  <body>
    <script src=""vue.js""></script>

    <div id=""app"">
      <base-link>Link</base-link>
    </div>

    <button id=""action"">Load</button>

    <script>
      let vm
      const button = document.getElementById('action')
      button.addEventListener('click', () => {
        if (vm) {
          vm.$destroy()
          vm = null
          button.textContent = 'Load'
          // remove the dangling <a> element created by the VueComponent base-link...
          document.getElementById('app').children[0].remove()
          const baseLink = document.createElement('base-link')
          baseLink.innerHTML = 'Link'
          document.getElementById('app').appendChild(baseLink)
        } else {
          console.log('creating new instance!')
          vm = new Vue({
            el: '#app',
            components: {
              BaseLink: {
                template: `<a href=""#"" @click=""onClick""><slot /></a>`,
                methods: {
                  onClick(evt) {
                    evt.preventDefault()
                    console.log('clicked')
                  },
                },
                beforeDestroy () {
                  console.log('ciao!')
                }
              },
            },
          })
          button.textContent = 'Destroy'
        }
      })
    </script>
  </body>
</html>

```

So I think that's not really a bug.
--
",boutils,"
--
I noticed the same issue on our project. Issue reproduced with version 2.6.10, 2.6.9 and 2.6.0.
--
",,,,
10472,OPEN,Disable productionTip in a vue dev common.js version,,2019-09-08 18:48:59 +0000 UTC,rustyx,In progress,,"### Version
2.6.10

### Reproduction link
[https://github.com/rustyx/testapp-vue-mocha](https://github.com/rustyx/testapp-vue-mocha)







### Steps to reproduce
1. `vue create testapp`,  
 * **Manually select features**
 * Enable **Unit Testing** with **Mocha   Chai**

2. `cd testapp`
3. `yarn test:unit`

### What is expected?
The unit test runs with no warnings or errors.

### What is actually happening?
During webpack step, the following is printed on the screen:

```
 WEBPACK  Compiling...

  [===                      ] 11% (building)
Download the Vue Devtools extension for a better development experience:
https://github.com/vuejs/vue-devtools
You are running Vue in development mode.
Make sure to turn on production mode when deploying for production.
See more tips at https://vuejs.org/guide/deployment.html
  [====                     ] 14%
```

Afterwards, the unit test runs successfully.

---
This is caused by the fact that it's impossible to set `config.productionTip=false` in the Vue common.js version (see `vue/dist/vue.runtime.common.js` - the notice is printed unconditionally, since `config` is created in the same scope).
The notice should not be printed when NODE_ENV == `""test""`.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
If you use the esm build, then the tip is removed in test environments. Is there any reason to use the common js version instead of the esm one? Since you are using webpack, the esm version should be the one being picked up
--
",rustyx,"
--
I have no specific reason to use the common js version, it just looks to me like that's what is being used out of the box. I might be wrong though, so happy to hear about the actual root cause and especially possible fixes/workarounds. Although I wouldn't know how to switch the CLI `test:unit` config to the esm version, unfortunately.
--
",msdlisper,"
--
Can I fix it ??
--

--
@posva [This PR ](https://github.com/vuejs/vue/pull/10495)
--
",,,,,,
10458,OPEN,(programmatically added) destroyed hooks retain on new instances,has workaround,2020-12-17 16:57:32 +0000 UTC,pimlie,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/h86atdq4/](https://jsfiddle.net/h86atdq4/)







### Steps to reproduce
Open linked jsfiddle, open console and click toggle.

### What is expected?
That the logged destroyed hook count is always 0 similar to the other hooks

### What is actually happening?
The destroyed hook count keeps incrementing as it seems to retain hooks from already destroyed components

---
Note: I didnt check if this also happens with destroyed hook defined on the component itself

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sqal,"
--
I wouldn't consider it a bug. You are modifying component's options before component's instance is created. If you need to programmatically add some lifecycle hook, you should do that in `created` hook using `$on('hook:xxx`) pattern. I do not know why but it is not properly documented so not everyone knows about it.  Example usage:

```js
created() {
  this.$on('hook:mounted', () => {
    // do something when component is mounted
  })
}
```

And you don't have to worry about cleaning up the events added this way in beforeDestroy hook, Vue will handle it for you


--
",pimlie,"
--
Very interesting, did not know this indeed. I had also asked this on Vue-land discord but unfortunately to no avail.
--

--
Unfortunately a vue core team member told me on discord that `hook:` is not a public API thus its not officially supported and shouldnt be relied on. Hence why its not documented.

So still looking for the official way to programmatically add lifecycle hooks.
--

--
It turns out (as found by @Remcoman with this jsfiddle https://jsfiddle.net/c61xL8ar/2/) that the memory leak occurs on any programmatically added lifecycle hook if the component you are adding them to already list those lifecycle hooks. Ie in the updated jsfiddle the AComponent already has a mounted hook, the BComponent already has a created hook. Both are being retained now.

@posva Does this mean its a bug or that we should use hook events anyway?
--

--
@sirlancelot Please read this comment https://github.com/vuejs/vue/issues/10458#issuecomment-528247551 and read this https://github.com/vuejs/vuejs.org/issues/2247

Although I appreciate your time responding to this issue, there is conflicting information here and therefore I am asking the Vue core-team what I should do.
As a library maintainer I am unable to use a feature when I was specifically told not to use it. Not unless a go-ahead has been given to do so anyway. You might not agree with this approach, but you should at least respect it as Im only trying to do my due diligence here.


--
",sirlancelot,"
--
You shouldn't write to `this.$options`. It is for reading only. If you want to attach hooks, you should do so using the public API [`this.$on()`](https://vuejs.org/v2/api/#vm-on) or [`this.$once()`](https://vuejs.org/v2/api/#vm-once). To listen to a lifecycle hook using the event system, you can prefix it with `hook:` like so: `this.$on(""hook:mounted"", () => {})`
--

--
It's worth pointing out that the `hook:` syntax is documented appropriately under [Handling Edge Cases: Programmatic Event Handlers](https://vuejs.org/v2/guide/components-edge-cases.html#Programmatic-Event-Listeners).
--

--
> It turns out (as found by @Remcoman with this jsfiddle https://jsfiddle.net/c61xL8ar/2/) that the memory leak occurs on any programmatically added lifecycle hook if the component you are adding them to already list those lifecycle hooks. Ie in the updated jsfiddle the AComponent already has a mounted hook, the BComponent already has a created hook. Both are being retained now.

Once again, that fiddle is paving over an object on `this.$options`. Don't do that. It is a Vue internal property.
--

--
Understandable. I was rather short in my previous post, and I apologize. I am going to guess that the ""has workaround"" was added in regards to using `$on()` & `$once()` with the `hook:` prefix.
--
",posva,"
--
To clarify, writing to `this.$options` in a `beforeCreate` hook is a very common way to manipulate options and it's used by many many plugins, it's not read-only, at least, in `beforeCreate` as it can still have an impact
--
",guastallaigor,"
--
Hello, is there any way to use this workahound (`$once()`) in Vue 3.x?
--
",,
10447,OPEN,Add Ethereum name or address to package.json,,2019-10-02 04:25:39 +0000 UTC,lastmjs,Opened,,"### What problem does this feature solve?
I would like to see an Ethereum name or address added to the ethereum field of the package.json file. This will allow consumers of the project to know a cannonical address to send funds to. For example, I'm building an application that will allow developers to automatically donate ETH to all of their npm dependencies that have Ethereum addresses in their package.json files: https://sustainus.io

### What does the proposed API look like?
Simply add an Ethereum name or address to the `ethereum` property of the package.json file. Done.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,vSanjo,"
--
Does Vue have such an address? A cursory search didn't reveal anything.

EDIT:
I didn't look nearly [hard](https://vuejs.org/support-vuejs/#eth) enough! 
I don't know if I agree with linking this information up to the project - surely that's the functionality of the website, not the package? 
--
",,,,,,,,,,
10443,OPEN,Feature request: provide option for removing all spaces arround tag,,2019-12-10 19:51:38 +0000 UTC,masquevil,In progress,,"### What problem does this feature solve?
For now, spaces around text tag will be kept at least one space:
https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#options

```html
<!-- source -->
<div>
  <span>
    foo
  </span>   <span>bar</span>
</div>

<!-- whitespace: 'preserve' -->
<div> <span>
  foo
  </span> <span>bar</span> </div>

<!-- whitespace: 'condense' -->
<div><span> foo </span> <span>bar</span></div>
```

Sometimes, it will keep some space we don't want:

```html
<!-- source -->
<span>
  一段很长的文字………………，
<span>

<!-- become -->
<span> xx </span>

<!-- if we write source like this -->
<span>a_long_long_chinese_characters…<span>

<!-- it will be formatted by prettier or etc like this, very bad -->
<span
  >a_long_long_chinese_characters…</span
>
```

Our code standard always: build tool (webpack) will kill all spaces around tag. If we need a real space, use `&nbsp;` like this:

```html
<!-- source if no need for spaces -->
<span>
    <i class=""icon""></i>
    文本
</span>
<!-- result -->
<span><i class=""icon""></i>文本</span>

<!-- source if need for spaces -->
<span>
    &nbsp;
    <i class=""icon""></i>
    &nbsp;文本&nbsp;
</span>
<!-- result -->
<span>&nbsp;<i class=""icon""></i>&nbsp;文本&nbsp;</span>
```

In this way, we get a great experience with react and vue@1.x (compress html myself).

now we are using SFC, vue-loader haven't provide this option. Spaces around tag will be kept at least one space.
So we hope vue-loader can provide an option to remove these spaces.

### What does the proposed API look like?
```js
compilerOptions: {
  whitespace: 'collapse'
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Justineo,"
--
As I understand the feature you are asking for is exactly the same with the original proposal here in #9208. Maybe we can add a new value for the `whitespace` option value like `'jsx'`? @yyx990803 
--
",posva,"
--
the thing is, doing this conversion

```html
<!-- source if need for spaces -->
<span>
    &nbsp;
    <i class=""icon""></i>
    &nbsp;文本&nbsp;
</span>
<!-- result -->
<span>&nbsp;<i class=""icon""></i>&nbsp;文本&nbsp;</span>
```

is not correct, it should condense the whitespace into one single space like we do now. If you want the non breakable space around, write them

```html
<span>&nbsp;<i class=""icon""></i>&nbsp;文本&nbsp;</span>
```

The reason we condense the whitespace instead of removing it is because it matters, I think having an option like this would cause trouble for people as the result would be different from the source in terms of rendering
--

--
but the formatting is not related to Vue, you can configure line length and eslint to not split up in lines, which is purely esthetic, while introducing the collapse is not, it does produce different renders.

So you are basically asking to add a feature that produces different results from what it's initially written, adds surface api and could be confusing to users only because the auto formatting setup in your project doesn't look good to you. And that's why I don't think this is a good idea
--
",masquevil,"
--
> write them
> 
> ```html
> <span>&nbsp;<i class=""icon""></i>&nbsp;文本&nbsp;</span>
> ```

Yes, I have tried this. But in this case:

```html
<!-- if we write source like this -->
<span>a_long_long_chinese_characters…<span>

<!-- the source code will be formatted by prettier or etc like this, very bad -->
<span
  >a_long_long_chinese_characters…</span
>
```

It is not what we want.

Some other tools have this feature (eg: html-loader has `collapseInlineTagWhitespace` and `conservativeCollapse` option), and we have use these feature as our company's standard. So I hope vue can offer one.

--

--
I can list more example, but it is not what I'm requesting.
JSX has this feature, And I think there should be an ability for developer to choose which code style they prefer, rather than no choice.

eg1: Which one do you think is the best? We choose 3.
```html
<!-- source code 1 -->
<p attr1=""1"" attr2=""1"" attr3=""1"" attr4=""1"" attr5=""1"" attr6=""1"" attr7=""1"" attr8=""1"">a_long_long_chinese_sentence………………………………</p>

<!-- source code 2 -->
<p
  attr1=""1""
  attr2=""1""
  attr3=""1""
  attr4=""1""
  attr5=""1""
  attr6=""1""
  attr7=""1""
  attr8=""1""
>a_long_long_chinese_sentence………………………………</p>

<!-- source code 3 -->
<p
  attr1=""1""
  attr2=""1""
  attr3=""1""
  attr4=""1""
  attr5=""1""
  attr6=""1""
  attr7=""1""
  attr8=""1""
>
  a_long_long_chinese_sentence………………………………
</p>
```

eg2: Which one do you think is better? We choose 1.

```html
<!-- source code 1 -->
<router-link
  v-if=""someCondition""
  class=""link-type-a""
  to=""an-long-long-url""
>
  <icon type=""some-icon"" />
  <span class=""highlight-link"">text</span>
</router-link>
<router-link
  v-else
  class=""link-type-b""
  to=""an-long-long-url""
>
  text
</router-link>

<!-- source code 2 -->
<router-link
  v-if=""someCondition""
  class=""link-type-a""
  to=""an-long-long-url""
>
  <icon type=""some-icon"" />
  <span class=""highlight-link"">text</span>
</router-link>
<router-link
  v-else
  class=""link-type-b""
  to=""an-long-long-url""
>text</router-link>
```
--
",westonlast,"
--
This is a good feature request.  @posva, if you're concerned about the template's XML ""implying"" a different render to conform to ESLint rules, you shouldn't be.

Developers shouldn't be using templates to affect layout in the first place.  That's HTML/CSS 101.  Developers just want templates to look ""readable.""  Adding extra spaces to a template/HTML in order to affect layout is semantically incorrect and always has been, regardless of how many people are blissfully unaware.  And using HTML for layout makes other aspects of development even more difficult.

Honestly, I thought this feature already existed, until I read the fine print on `whitespace`.  It's a shame, otherwise `whitespace` would be a useful option.
--
",,,,
10435,OPEN,O(n^2) performance when tearing down deps,,2019-09-24 15:11:03 +0000 UTC,ascott18,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/b9at5703/](https://jsfiddle.net/b9at5703/)







### Steps to reproduce
Click the button to toggle the render of the children on and off. Adjust the number of children rendered in the template.

Increasing the number of children by 10x (from 10,000 to 100,000) increases the render time by 10x, but increases the teardown time by 33x (from ~0.6s to 20s in my testing). I realize that 100,000 components is a pretty unrealistic use case, but please continue reading below.

### What is expected?
Teardown time for components should scale linearly with the number of components, not exponentially.

### What is actually happening?
In the repro link, every component has its own subscription against `$root.theme`. This is fine on its own, but subs are stored in an array, requiring an `O(n)` search to find the sub in order to remove it from the array.

This particular example is actually an extremely optimistic case - the subs are added to the array in order that the components are rendered, and then the components are destroyed in the order they are rendered. This means that the sub being removed is always found at the very beginning of the `subs` array, so the `indexOf` call in `remove()` (https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js#L28) can return almost immediately.

This is why I had to go to really high numbers of components (10k-100k) to make the problem very evident, but in my real-world application, I'm seeing this issue at 1,000 components or less (in a large data table component).

Now, imagine a scenario where a complex application has a large component tree with subs to some root `theme` prop all over the place. In fact, this is exactly what happens in a Vuetify app. As components are destroyed, their sub to this root value could be anywhere in the `subs` array.

---
Ran into this while using Vuetify, which has a subscription to `$vuetify.isDark` (saw 1700 subs), or to `$vuetify.theme.dark` (saw 1000 subs) in a large number of its components. I also saw 300 subs to `$route`, which could easily balloon much bigger if I added some router-links to some of the fields in my table cells.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,ascott18,"
--
There seems to be a PR for this (https://github.com/vuejs/vue/pull/8157, which appears to have languished), but I wasn't able to find a related issue.
--
",trickstival,"
--
It's probably going to be a part of Vue 3.x as stated in https://github.com/vuejs/vuex/issues/1383#issuecomment-429617484
--
",,,,,,,,
10416,OPEN,Scoped CSS attribute is reused or discarded when switching between components with scoped CSS,bug; contribution welcome,2020-01-06 21:22:15 +0000 UTC,sin1ght,In progress,,"### Version
2.6.10

### Reproduction link

- Functional components: [https://github.com/sin1ght/test](https://github.com/sin1ght/test)
- Regular components and slots: https://codesandbox.io/embed/vue-template-3pnsx







### Steps to reproduce
After npm run serve, click the toggle button and find that child has no style.

Child and child2 components are reused, child's data-v-* disappears, causing the style to disappear

### What is expected?

Child should have a black background scope style

### What is actually happening?

Child without style

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sin1ght,"
--
not only functional components,use functional components just to make sameVnode true,a functional component and a normal dom is ok as well
--

--
i add two lines code in patchVnode,and it work will at my demo,but i'm not sure

`oldVnode.fnScopeId = vnode.fnScopeId;
    setScope(oldVnode);`

![mt44X9.png](https://s2.ax1x.com/2019/08/21/mt44X9.png)
--

--
if samaVnode true then patchVnode

![mUrTBT.png](https://s2.ax1x.com/2019/08/21/mUrTBT.png)

regular component's tag will changed,but  functional component not

![mUrxjx.png](https://s2.ax1x.com/2019/08/21/mUrxjx.png)

so,a normal dom is ok as well

```javascript
//parent.vue

<template>
  <div class=""parent"">
    <Child class=""child"" v-if=""!test""/>
    <div class=""child2"" v-if=""test"">
  </div>
</template>
```


--

--
@CzBiX 
I think your problem is same with me.
two child reused but scopedId not be copied .
![mRH28I.png](https://s2.ax1x.com/2019/08/26/mRH28I.png)
--
",posva,"
--
I tested with the 4 possible combinations among regular and functional components and the problem only appears when both are functional

If you are up to give the fix a try, you can. If other things break, you should see tests failing
--

--
@sin1ght  It's weird I couldn't see the problem in your repro using regular components but others' repro do show so I adapted the title. Sorry about that!
--
",CzBiX,"
--
similar bug, affected pure normal components with slot, please see my simple demo.

https://codesandbox.io/s/vue-template-jimot
--
",,,,,,
10391,OPEN,Nested async components passed as slots are not rendered in SSR,bug,2021-03-16 12:36:27 +0000 UTC,jimmytsao,Opened,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-ssr-nested-async-components-repro-script-ozze7](https://codesandbox.io/s/vue-ssr-nested-async-components-repro-script-ozze7)







### Steps to reproduce
When the codesandbox starts up, it should run the ```npm start``` script. If it doesn't, open a bash terminal and run ```npm start``` to see the HTML generated from SSR. You can also take a look at the components in the ```src``` folder to see how they are configured.

### What is expected?
Expected the HTML for the nested async component (called ""SomeComponent"") to be rendered during SSR:

```html
<div data-server-rendered=""true"">
  <div class=""Grid"">
    <div class=""Grid__left"">Left
      <div class=""SomeComponent"">Somecomponent with value: first</div>
    </div>
    <div class=""Grid__right"">Right
      <div class=""SomeComponent"">Somecomponent with value: second</div>
    </div>
  </div>
</div>
```

### What is actually happening?
The HTML for the nested async component (called ""SomeComponent"") is not rendered during SSR. Only the HTML for the outer async component (called ""Grid"" ) is rendered:

```html
<div data-server-rendered=""true"">
  <div class=""Grid"">
    <div class=""Grid__left"">Left
    </div>
    <div class=""Grid__right"">Right
    </div>
  </div>
</div>
```

---
I have an App that is composed of many async components. Some of these components have named slots. I was trying to build a render function that will accept a config object to render these components in various setups (for example, an async component set to a named slot of another async component). I noticed that if I nest async components within another, the HTML for the async component does not render during SSR. The codesandbox is simplified scenario of this

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It seems to be related to the fact that the slot is a scoped slot so it is lazily used. The problem disappears if the components is directly used or passed as a regular slot.

As a side note though, components that are directly visible in a page should not be lazy loaded as that would be a waste of network requests and things are faster with fewer request. The only exception being the page itself or nested pages. This doesn't invalidate the usage of async components though, as it may depend on a v-if, thus making the lazy loading of two component valuable
--
",trip,"
--
I have a similar problem that appears to be some kind of a race condition. I'm not sure if it should be a new issue, so I'll start here and describe it.

My app is a multi-page app with a main app.js file that essentially configures the separate pages as async components, so that we don't have to pack hundreds of components into a single app.js file. The result is a pattern counter to what @posva suggested. For example, someone would visit `/shipment/12345/edit` and the main js file would load normally with the Shipment component loading asynchronously.

The problem I have is that the Shipment component only renders _sometimes_. It always mounts, as evidenced by 'Shipment component mounted' console logs. When it doesn't render, the DOM where it should be is simply blank. Rendering seems to be more reliable when 'Disable Cache' is checked in dev tools. This makes it seem like a race condition, but I can only imagine what that condition could be.

EDIT: I am not using SSR, so this would appear to be similar but unrelated. If this comment is off-topic as a result or not constructive, you won't hurt my feelings by removing/hiding it.
--
",endyquang,"
--
I'm seeing this race condition problem too, with Nuxt SSR

Sometime the page is rendered perfectly fine sometime not
The console error says `TypeError: Cannot read property 'toLowerCase' of undefined at emptyNodeAt`...

My workaround is having a fallback dummy div inside every slot tags
It solves the problem for me but I use a lot of slots in my project
--
",pi0,"
--
Here is a minimalistic reproduction: https://replit.com/@pi0/vuejsvue10391

Issue seems caused by https://github.com/vuejs/vue/commit/781c70514e01bc402828946805bfad7437c7175e. For some reason, for async components `isComment` is true. Reverting L65 fixes ~~but I guess have to investigate why `isComment` is `true` for proper fix.~~ we should check with `isAsyncPlaceholder`

Update: https://github.com/vuejs/vue/pull/11963
--
",,,,
10375,OPEN,Warn when v-for with a Range is not a valid integer,discussion,2019-08-09 12:12:00 +0000 UTC,Sand3r205,In progress,,"### What problem does this feature solve?
When using the v-for directive with a Range and the number passed is not a valid integer (valid integer = an integer between 0 and 2^32-1), Vue.JS still tries to create an Array and then throws the error `[Vue warn]: Error in render: ""RangeError: Invalid array length""`.

This happened to me while passing a computed property to the directive: `v-for=""n in lists""` where `lists` is the computed property.

When the developer has multiple v-for directives, it is unclear where the error occurs, making the debugging process though.

If the mistake is caught by Vue before creating the Array, rendering the component shouldn't have to stop. Instead we can throw a warning and render an empty v-for directive. This would would make debugging easier, since other v-for directives in the same component would still render.

### What does the proposed API look like?
Add a check in /src/core/instance/render-helpers/render-list.js at line 22, checking if a valid number is:
* higher or equal to 0
* lower or equal to 2^32 - 1
* modules to 1 is equal to 0

```javascript
else if (typeof val === 'number') {
  if (val >= 0 && val <= 4294967295 && val % 1 === 0) {
    ret = new Array(val)
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i)
    }
  } else {
    warn (
      `Number passed to v-for directive not valid (expected valid integer), got ${val}`,
      this
    )
    ret = []
  }
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Maybe a dev warning could be fired instead of adding https://github.com/vuejs/vue/pull/10341 but at the same time, I don't understand how you find yourself writing `v-for=""n in 10000000000` apart from testing purposes but it is a very unrealistic case. Let's wait for more feedback on this

FYI, the integer can also be writing in hex, making it more explicit that it is the upper bound of 4 bytes: `0xffffffff`
--

--
Yeah, but that's different, as you should ensure the number is an integer in the computed property
--
",Sand3r205,"
--
Directly passing a number to the v-for directive is indeed a very straight forward case, however when passing a computed variable to the v-for directive, the number can be anything. In my case it was a calculation possibly returning a number with decimal points, which will also break new Array().
--
",,,,,,,,
10366,OPEN,Click Event Triggers on Complex Buttons are ignored in some environments,browser quirks; contribution welcome; has PR,2020-03-23 14:51:15 +0000 UTC,ericdrobinson,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/s7hyqk13/2/](https://jsfiddle.net/s7hyqk13/2/)







### Steps to reproduce
1. Configure one of the Adobe CEP [Sample Panels](https://github.com/Adobe-CEP/Samples). The [PProPanel](https://github.com/Adobe-CEP/Samples/tree/master/PProPanel) is a good starting point as it has very clear documentation on how to [set up the environment](https://github.com/Adobe-CEP/Samples/tree/master/PProPanel#2-enable-loading-of-unsigned-panels) for testing.
1. Replace the HTML/JavaScript/CSS contents of the panel project with the contents of the [linked JSFiddle](https://jsfiddle.net/s7hyqk13/2/).
1. Open the panel.
1. Attach a debugger (with the default PProPanel setup this would mean browsing to `localhost:7777` in Chrome).
1. Set the ""_Mouse > `click`_"" **Event Listener Breakpoint** in the ""Sources"" tab of the Chrome Debugger.
1. Click the Vue icon in the center of the silver `div`.

### What is expected?
Method bound to the `@click` handler is triggered when the image embedded in the parent div is clicked. 

### What is actually happening?
The method bound to the `@click` handler is _only_ triggered when clicking outside of the parent div.

---
This is a non-trivial bug to reproduce as the only place I've experienced it is in [Adobe CEP](https://github.com/Adobe-CEP/CEP-Resources/blob/master/CEP_9.x/Documentation/CEP%209.0%20HTML%20Extension%20Cookbook.md) extensions (which run NW.js under the hood). That said, it does reproduce 100% of the time there.

The debugger (CEP context) seems to show several funny things at around [this line](https://github.com/vuejs/vue/blob/d40b7ddb8177944d1dd50f4f780e6fd92c9455c2/src/platforms/web/runtime/modules/events.js#L69) in the Vue events.js file. Specifically:

1. The `e.timeStamp` value **does not change** between callbacks for _different buttons/elements_.
1. The `attachedTimestamp` is **_significantly_ larger** than the `e.timeStamp` value.
1. The `attachedTimestamp` value _does_ change when the component is updated (the `e.timeStamp` remains identical).

I should note that this affects at least [CEP 8.0 and CEP 9.0](https://github.com/Adobe-CEP/CEP-Resources/blob/master/CEP_9.x/Documentation/CEP%209.0%20HTML%20Extension%20Cookbook.md#chromium-embedded-framework-cef) (tested in Premiere Pro).

**Vue Versions Note:** This broke somewhere between versions 2.5.17 and 2.6.x. If we run a version of 2.5 (2.5.17 and some earlier versions verified), then this issue does not occur. In testing 2.6.x, we've found that this same issue occurs from 2.6.5 to 2.6.10 (latest). Versions of 2.6 prior to 2.6.5 are actually _worse_ in that the buttons basically don't work at all.

**Important Note:** I should _further_ note that apparently right-clicking to open the basic CEF [not CEP] context menu will cause the `e.timeStamp` values to begin reporting as expected. Once this occurs, the buttons will _also_ work as expected. That said, we shouldn't have to instruct users to right-click prior to interfacing with the extension.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I don't own Photoshop so I won't be able to test nor debug this problem. Can it be on nw.js as well? Maybe that could be tested
--

--
I imagined it would be that, that's why I was asking about a nw.js version that we could target
It is weird that it doesn't appear on windows though, it would be worth seeing the differences in terms of user agent between them
--

--
Okay, thanks a lot for the research. In that case I think the best option we have here is to use the check you showed at https://github.com/vuejs/vue/issues/10366#issuecomment-525424657.
You could integrate the code modification (there is no need for a test in this scenario) and create a PR. I won't be able to check it since I don't have the adobe suite but hopefully other people could give feedback and it shouldn't break anything for others
--

--
> @posva Sounds good to me. Do you have any input on whether or not I should add the macOS platform check to restrict the fix to macOS?

Ideally, the program should behave the same on CEP osx vs CEP windows

Other than that the checks you wrote look good
--
",ericdrobinson,"
--
@posva As a quick note, this issue isn't restricted to Photoshop. Just about [every major Creative Cloud application](https://github.com/Adobe-CEP/CEP-Resources/blob/master/CEP_9.x/Documentation/CEP%209.0%20HTML%20Extension%20Cookbook.md#applications-integrated-with-cep) supports CEP extensions - and is affected by this problem. 😕
--

--
> right-clicking to open the basic CEF [not CEP] context menu will cause the `e.timeStamp` values to begin reporting as expected.

It appears that this isn't quite right. The `e.timeStamp` value is _updated_ when a right-click occurs. However, subsequent callbacks will then report the same updated value. This is, at least, what the following extremely simple test case shows:

```js
window.addEventListener('click', (evt)=>{console.log(evt.timeStamp);});
```

This means that a post right-click event will work as expected _as long as the `attachedTimestamp` isn't reset!_ It appears that once a ""flush"" occurs and the event listener is re-attached, the issue reappears (until the next right-click).
--

--
I should point out that it is possible to distinguish a CEP environment and version with standard JavaScript calls. This may be helpful for adding an environment flag.

Specifically, the following snippet is designed to be inserted into the [existing environment flag setup](https://github.com/vuejs/vue/blob/a9a303009a4267b7f12b956741b4e34dfdc6566f/src/core/util/env.js#L6):

```js
const  isAdobeCEP = inBrowser && typeof window.__adobe_cep__ !== undefined;
```

The `__adobe_cep__` object also has the `getCurrentApiVersion` native function, which returns the CEP version encoded as a JSON string. See:

```js
// In Premiere Pro 13.1.3, outputs: ""{""minor"":3,""micro"":1,""major"":9}""
window.__adobe_cep__.getCurrentApiVersion();
```

The version JSON returned by this function may be easily parsed and accessed:

```js
const cepVersion = JSON.parse(window.__adobe_cep_.getCurrentApiVersion());

cepVersion.major; // = 9
cepVersion.minor; // = 3
cepVersion.micro; // = 1
```

Hopefully this will prove helpful in some way.
--

--
_[**Update:** Please see [this comment](https://github.com/vuejs/vue/issues/10366#issuecomment-521703332) for more on the struck-through text below.]_

~Thanks to @Inventsable I was able to narrow down the test case a bit more. In order to experience the issue I described, a click event handler must be installed on the contained element (in this case, an `<img>` element) _as well as_ the container. I have updated the JSFiddle link in the issue description.~

~_[For the record, [this](https://jsfiddle.net/1d8nbv7h/2/) was the previous version and [this](https://jsfiddle.net/46bfrytw/) is the adjusted version.]_~

Also, @Inventsable was able to verify that the `timeStamp` value appears to update correctly when run in Windows applications. I've tested on macOS-based Premiere Pro and can verify that the `timeStamp` issue does occur there (even in the graciously provided [bug report panel](https://github.com/Inventsable/Vue-2.6-Issue-10366)).
--

--
**Update:** My [previous comment](https://github.com/vuejs/vue/issues/10366#issuecomment-521068621) about requiring a contained element to also have an event handler was 100% a **red herring**. This is entirely unnecessary to get the bug to reproduce.

It appears that small, fast-loading scripts result in the reported event `timeStamp` being **`0`**. This is unfortunate because it obscures the bug by passing as expected [here](https://github.com/vuejs/vue/blob/d40b7ddb8177944d1dd50f4f780e6fd92c9455c2/src/platforms/web/runtime/modules/events.js#L73).

On macOS, the event `timeStamp` value only increments when a right-click occurs to open a native context menu (provided it's not been disabled, of course). Great. The problem _now_ is that the ""`attachedTimestamp`"" is properly less than the currently-constant `timeStamp`. We need a way to ensure that the following occurs:

1. The `Event.timeStamp` value is **greater than `0`**.
2. The `attachedTimestamp` is greater than the `Event.timeStamp`.

That's easy: have the user right-click anywhere and then trigger some code that attaches a new listener!

I've adjusted the [JSFiddle example](https://jsfiddle.net/s7hyqk13/2/) to account for the above to ensure a 100% reproduction rate in Adobe CEP applications (e.g. Photoshop, Premiere Pro, Illustrator, InDesign, After Effects, etc.) running on macOS.
--

--
> I don't own Photoshop so I won't be able to test nor debug this problem. Can it be on nw.js as well? Maybe that could be tested

@posva We've narrowed the repro for this down to **Adobe CEP contexts running on macOS**. Adobe is aware of the problem but a fix from them will not address released applications.

From what I can gather by reading [this comment](https://github.com/vuejs/vue/issues/6566#issuecomment-329057367) from @yyx990803 on #6566, there is an issue here in event dispatch/processing with respect to the micro/macro task order.

Further, it appears that the code has subsequently been updated with [a few workarounds](https://github.com/vuejs/vue/blob/d40b7ddb8177944d1dd50f4f780e6fd92c9455c2/src/platforms/web/runtime/modules/events.js#L70) ""_for environments that have buggy `event.timeStamp` implementations_"".

It appears that the workaround for the event ordering issue that was implemented in ba0ebd4 to address #6566 ended up breaking things for CEP-on-macOS (as it did with a few other ""broken environments"").

I would then propose that a solution would be to follow the examples set in 0bad7e2 and 7591b9d and simply bail out of this special-case processing when we detect that we're in the ""broken environment"" that is CEP-on-macOS. This can be done like so:

1. Add the following to [env.js](https://github.com/vuejs/vue/blob/a9a303009a4267b7f12b956741b4e34dfdc6566f/src/core/util/env.js#L18)
    ```js
    export const isCEP = inBrowser && window.__adobe_cep__;
    ```
1. Add the following to [events.js](https://github.com/vuejs/vue/blob/d40b7ddb8177944d1dd50f4f780e6fd92c9455c2/src/platforms/web/runtime/modules/events.js#L74)
    ```js
    // #10366 Adobe CEP bug: event.timeStamp is not reliable
    isCEP ||
    ```

You will note that the above solution does not distinguish between macOS and Windows hosts (the latter of which does not have this issue). This would be for cross-platform consistency. It could easily be amended to check for macOS with something akin to the following:

```js
/mac/.test(window.navigator.platform.toLowerCase()); // True on macOS; false otherwise.
```

I have tested this locally and the above does appear to resolve the issue. Thoughts? Concerns?
--

--
I have no idea about whether `nw.js` would be similarly affected. Someone internal at Adobe would need to chime in there. @bbb999 perhaps?

The User Agent reported for Premiere Pro 13.1.4 on macOS 10.14.6 is as follows:
```
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.91 Safari/537.36
```
I've asked others if they can provide the Windows equivalent. Given that the _only_ difference between CEP's User Agent and the Chrome browsers' is the Chrome version, I'd be willing to bet it looks identical to a standard Windows Chrome User Agent for Chrome 61.0.3163.91...
--

--
@posva Here are the two User Agent versions:

From **After Effects 16.1.2 on Windows 10**:

```
Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.91 Safari/537.36
```

From **Premiere Pro 13.1.4 on macOS 10.14.6**:

```
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.91 Safari/537.36
```

The CEP version determines the User Agent. See [this table](https://github.com/Adobe-CEP/CEP-Resources/blob/master/CEP_9.x/Documentation/CEP%209.0%20HTML%20Extension%20Cookbook.md#chromium-embedded-framework-cef) for a rough outline.
--

--
@posva Sounds good to me. Do you have any input on whether or not I should add the macOS platform check to restrict the fix to macOS? If yes, do you have a suggestion on detection approach? Either of these should work:

1. ```js
   /mac/.test(window.navigator.platform.toLowerCase())
   ```
1. ```js
   UA && /mac os x/.test(UA)
   ```

Also, I just heard that the issue is fixed in the upcoming versions of the Adobe apps. I'm getting version information from them right now. This will allow me to further restrict the workaround to affected versions (the version check can be based on the version code I pointed to at the end of [this comment](https://github.com/vuejs/vue/issues/10366#issuecomment-519644448)).
--

--
Here is a proposal for a snippet of code to add to event.js (somewhere around [here](https://github.com/vuejs/vue/blob/d40b7ddb8177944d1dd50f4f780e6fd92c9455c2/src/platforms/web/runtime/modules/events.js#L46)):

```js
// #10366: CEP <= 9.3.x on macOS has a buggy Event.timeStamp implementation.
const isMacCEP93orEarlier = isCEPMac && ((maxBadMajor, maxBadMinor) => {
  const version = JSON.parse(window.__adobe_cep__.getCurrentApiVersion())
  return version.major <= maxBadMajor && version.minor <= maxBadMinor
})(9, 3)
```

This `isMacCEP93orEarlier` flag would restrict the standard flow elision to only affected CEP versions on macOS.

In the above example, `isCEPMac` would be defined as follows in env.js:

```js
export const isCEP = inBrowser && window.__adobe_cep__ !== 'undefined'
export const isCEPMac = isCEP && UA && /mac os x/.test(UA)
```

Does this look reasonable? Are the variable names okay?

(The above code works in my environment.)
--

--
Awesome! Thanks for giving it a shot @derrickb! For the record, I've tested the fix on Premiere Pro CC 2019 on macOS and everything looks good!
--

--
>EDIT: I decided to go with patch-package.

Probably wouldn't work. This PR only contains fixes for the source code - no `dist` modifications were committed. You'd have to grab this PR and run the correct build command to output the version of Vue that you need.


>I wanted to ask how I could get this bugfix into our system?

@atwhiteley Provided you only need the ESM build, you can use the branch I prepared on my own fork of the `vue` repository. Here's how you would install it with NPM:

```
npm uninstall --save vue
npm install --save ericdrobinson/vue#v2.6.10-with-cep-fix
```

If you need a different build, you can do the following:

1. Fork my `vue` repository on GitHub.
1. Create your own branch off of my [`fix-adobe-cep-mouse-events`](https://github.com/ericdrobinson/vue/tree/fix-adobe-cep-mouse-events) branch.
1. Build the version of Vue that your setup needs and commit it to your branch.
1. Run the following in your project:
    ```
    npm uninstall --save vue
    npm install --save atwhiteley/vue#[your-branch-name]
    ```

This approach works perfectly for us.
--

--
@joaomlemos #11031 does not mention CEP applications at all. Have you tested that PR in a CEP context? If so, which application and which version?

I'm also not sure if the new logic in #11031 isn't so broad that it would negate the purpose of the check to begin with... Someone on the Vue team would need to weigh in on that. @posva perhaps?
--

--
@joaomlemos Then, to be clear, you can **only** confirm that the proposed fix in #11031 handles the CE**F** case that @boardend mentioned, yes?

This is important because, if so, you cannot globally declare that #11031 fixes the issue for CE**P** as well, which your [initial comment](https://github.com/vuejs/vue/issues/10366#issuecomment-586047251) seemed to somewhat ambiguously imply.

Also, if this is the case, then it may be a good idea to comment on #11031 with a link to @boardend's comment above and mention on that PR that in your testing it seems to address the CE**F** problem.

---

I would still suggest that someone more familiar with the code in question take a good look at the proposed solution in #11031 as it seems that it _might_ be a little too ""lenient"".
--

--
@John0King That may very well be a separate core issue with a similar result. While Adobe CEP does indeed build on CEF, the issue described here explicitly occurred only on [macOS hosts](https://github.com/vuejs/vue/issues/10366#issuecomment-521068621). The CEF version in Adobe CEP is also relatively ancient, whereas the issue you posted describes _far_ more recent versions of CEF.

This issue [has an associated PR](https://github.com/vuejs/vue/pull/10459) that focuses the solution to as narrow a scope as possible. I would recommend opening a new issue and describe exactly the kind of values you're seeing for the event `timeStamp` that are causing the problem you're experiencing.
--
",Inventsable,"
--
I [made a standalone panel to demonstrate this](https://github.com/Inventsable/Vue-2.6-Issue-10366) but don't get the same behavior on Windows 10 and Vue 2.6.10, but I don't have a Mac to test:

![](https://thumbs.gfycat.com/RemarkableVeneratedAsiaticgreaterfreshwaterclam-size_restricted.gif)

Any Mac user should be able to run a single terminal command: `defaults write com.adobe.CSXS.9 PlayerDebugMode 1`, then clone the repo into the specified directory in the README and open it in Illustrator, After Effects, Photoshop or Premiere Pro via `Windows > Extensions > clicktest`, then access the CEF debugger easily via the right-click context menu on the panel.

---

EDIT: Eric corrected me on the version, this is 2.6.10 (not 2.6.1)
--
",derrickb,"
--
This is affecting me as well.

- Vue 2.6.10
- Photoshop CC 2019
- macOS 10.14.6

Thank you @ericdrobinson for filing this issue!
--

--
I can confirm that @ericdrobinson's PR fixes the issue for me on Photoshop CC 2019 macOS
--
",atwhiteley,"
--
Hi all, huge thank you for finding and fixing this bug. I spent the last couple days going crazy over debugging this, and I'm so happy to see this here. 

This bug is causing our panel to be practically unusable in production in mac environments, and I wanted to ask how I could get this bugfix into our system? I really rather not wait for this to be merged & published. Is there a way to patch a bugfix such as this?

Again, huge kudos to finding and fixing this bug.

EDIT: I decided to go with [patch-package](https://www.npmjs.com/package/patch-package).

EDIT 2 : I really can't seem to make it work. I am having a lot of trouble building vue from source code. I hope this gets accepted as a fix ASAP.
--

--
@ericdrobinson  Thanks a lot - I'm actually not a 100% sure which build we use but I'll check that now, though I think it's not the ESM one.

I did fork vue and already did create a separate branch - but I ran into trouble trying to build the source code.

Your response tells me I'm on the right path so I'll keep trying, thanks!

UPDATE: It was my own stupid mistake that I couldn't build it, resolved it, built the files - and now my project is in good shape again in adobe premiere! 



--
",boardend,"
--
I've just observed the same behavior in CEF 79.1.28 on Windows 10. The problem can be reproduced with the following conditions:

- Vue >2.5.17
  - Click Events work fine when downgrading to Vue <= 2.5.17
- CEF started with `--off-screen-rendering-enabled`
  - Click Events work fine when CEF is started without off screen rendering
  - I assume that CEP is using the off screen rendering inside the Adobe products
- Windows ""Fast startup"" is enabled and the computer was actually started after a real shutdown 
  - Click Events work fine when ""Fast startup"" is disabled
  - Click Events work fine after a restart
  - see https://www.windowscentral.com/how-disable-windows-10-fast-startup for more information

There is an issue reported on the CEF repo: https://bitbucket.org/chromiumembedded/cef/issues/2749/osr-results-in-weird-eventtimestamp-values

Maybe someone could check if the problem can be reproduced on their Windows 10 machine. CEF builds can be downloaded via http://opensource.spotify.com/cefbuilds/index.html (I've used cef_binary_79.1.28+gf272726+chromium-79.0.3945.117_**windows64_client.tar.bz2**)

If this is the case, then I would adapt the PR #10459 from @ericdrobinson to detect CEP and CEF.
--
"
10365,OPEN,Computed output doesn´t change but DOM gets re-rendered,,2019-08-07 19:19:12 +0000 UTC,janKroll,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/z1orgphL/1/](https://jsfiddle.net/z1orgphL/1/)







### Steps to reproduce
1. Start VueDevtools Performance Benchmark -> Component render
2. Wait for the interval

### What is expected?
If the output of the computed doesn´t change the DOM shouldn´t be re-rendered.

### What is actually happening?
DOM gets re-rendered

---
The DOM will not be updated if a primitive data type in applied in `changeData`.

This bug appeared in our Main Wrapper because we manipulate some styles based on the current route.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10338,OPEN,"Create an "".async"" modifier for event handlers",discussion; feature request,2019-11-28 22:10:53 +0000 UTC,twitwi,In progress,,"### What problem does this feature solve?
In an event handler, one can easily mix property modifications and method calls (which is great), as in:

    <span @click="" accumulator += fetchNextItem() "">do it</span>

However, if the called method is async, one need to actually wrap this code in an additional method like:

    <span @click="" fetchAndAccumulateNextItem() "">do it </span>
    ....
    methods: {
        async fetchAndAccumulateNextItem() {
            this.accumulator += await this.fetchNextItem()
        },
        async fetchNextItem() { .... } /* unmodified */
    }

This can be slightly inconvenient if there are many asynchronous methods of which we use the return value.
I think this might become more and more common as people start understanding and using async/await more and more.

Initial context: I have a very specific use case of a vuejs<->python bridge that makes (among other things) all the python-written method callable from vuejs, but as the call goes through websockets, all methods end up async. https://github.com/twitwi/vuejs-python


### What does the proposed API look like?
I'd suggest a "".async"" modifier that would allow for ""await"" in the event handler snippet.
For the example above, it would be written as:

    <span @click.async="" accumulator += await fetchNextItem() "">do it</span>

(this is probably useful for all types of events, not only click)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I don't think it's worth adding another modifier that only serves a very few uses cases: there are not many cases where the code is still readable when doing an `await` inside an event handler **in the html**. You don't need to create a method, you should be able to do:

```vue
<span @click="" async () => accumulator += await fetchNextItem() "">do it</span>
```

You could also create your own function helpers that are accessible globally like `asyncAdd`:

```vue
<span @click="" asyncAdd(accumulator, fetchNextItem())"">do it</span>
```

which ends up being shorter than the proposal.

Let's wait for more feedback on this

--

--
@sirlancelot you are right, I adapted the compiler to allow it: https://github.com/vuejs/vue/pull/10361
--
",twitwi,"
--
Thanks for the reply.
I like the first workaround, I'd give it a try
--

--
:+1:
For some reason, I needed to add some parentheses around it, but it works well.
For the record, I give the result here.

For the example above, this yields:
~~~vue
<span @click=""(async () => accumulator += await fetchNextItem())"">do it</span>
~~~

For my use case (with affecting an attribute), this gives:
~~~vue
<a @click=""(async()=> title = await fetchTitle())"">fetch</a>
~~~

Or, alternatively, inspired by the second suggestion:

~~~vue
    <a @click=""asyncSet('title', fetchTitle())"">fetch</a>
~~~
~~~javascript
    methods: {
        async asyncSet (attr, asyncVal) {
            this.$set(this, attr, await asyncVal)
        },
    }
~~~

Thanks again for the workarounds.

--
",sirlancelot,"
--
@posva it looks like the parser doesn't understand async function expressions. Here's the compiler output:

```js
function render() {
  with(this) {
    return _c('span', {
      on: {
        ""click"": function ($event) {
          async () => accumulator += await fetchNextItem()
        }
      }
    }, [_v(""do it"")])
  }
}
```

[async inline function epxression demo](https://template-explorer.vuejs.org/#%3Cspan%20%40click%3D%22%20async%20()%20%3D%3E%20accumulator%20%2B%3D%20await%20fetchNextItem()%20%22%3Edo%20it%3C%2Fspan%3E)

It appears to nest the entire string inside a normal function. Should this issue be re-purposed or create a new one?

I'm guessing the expected output should be:

```js
function render() {
  with(this) {
    return _c('span', {
      on: {
        ""click"": async () => accumulator += await fetchNextItem()
      }
    }, [_v(""do it"")])
  }
}
```
--
",adjenks,"
--
This works for me:
`@input=""(async function(){myVariable= await _queryVals($event)})()""`
but this failed:
`@input=""(async ()=>{myVariable= await _queryVals($event)})()""`

>Syntax Error: SyntaxError: await is a reserved word

It appears I can't use await inside an arrow function inside of an inline event handler.

--
",,,,
10331,OPEN,Component is re-renedered when DOM changes around it,has workaround,2019-12-10 15:03:28 +0000 UTC,r1chm8,In progress,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/Richm8/pen/VoWZQZ](https://codepen.io/Richm8/pen/VoWZQZ)







### Steps to reproduce
In the attached codepen, Open console and then click on the toggle button, you'll see that the created and destroyed hooks are called for the `logger` component even though the component is not having any manipulations performed on it.

### What is expected?
The created and destroy hooks on `logger` not to be called

### What is actually happening?
The created and destroy hooks on `logger` are being called

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Looks like a duplicate of https://github.com/vuejs/vue/issues/4362, here the divs are replaced, triggering the children destruction creation

I'm leaving this open for the moment because I'm not sure it's a duplicate, as a workaround, you must key the `div` container the logger
--

--
yeah, it's not an easy one to find
--
",r1chm8,"
--
Thank you for the workaround, I tired searching before making the issue but it’s hard to know what to search for
--

--
From my codepen example, it was as simple as adding a key on the div which wrapped the element being incorrectly rendered.

```vuejs
<div class=""my-4"">
    <logger />
</div>
```

became:
```vuejs
<div key=""logger"" class=""my-4"">
    <logger />
</div>
```
--
",staghouse,"
--
Could someone explain a bit more in depth how the workaround is applied? My issue relates to #9473 but some clarity would be greatly appreciated.
--

--
I see, thank you. Unfortunately that is not working on my end for components with iframes or an iframe nested but it could be for other reasons as I am working in Nuxt.
--
",,,,,,
10330,OPEN,nested v-slot is not reactive when using abbreviated syntax (v-slot on component itself) combined with an v-if/v-else,bug; has workaround,2020-07-31 06:40:09 +0000 UTC,dattn,Opened,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-template-j1w3r](https://codesandbox.io/s/vue-template-j1w3r)







### Steps to reproduce
In my example change the value by typing in the input field.
In the working example both values change.
In the not working example only the nested value changes.
The only difference is the wrapping `<template>` node

### What is expected?
scoped slot params (controllerSlotData) should be reactive in both cases

### What is actually happening?
scoped slot params (controllerSlotData) is not reative

---
The problem exists only when combining v-slot on component itself in combination with v-if/v-else

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Quentin01,"
--
I don't know why I didn't see this issue before opening #11553... Anyway, do you know when #10377 will be merged?
--
",,,,,,,,,,
10320,OPEN,Add JSDoc to types,improvement,2019-09-10 03:49:28 +0000 UTC,Shinigami92,Opened,,"### What problem does this feature solve?
This will improve the developer experience when using Vue in editors such as VSCode.

Currently, the developer must look up the default value in the [documentation](https://vuejs.org/v2/guide/components-props.html#Prop-Validation). And even there it is not clear, without trying it.

### What does the proposed API look like?
One example:

https://github.com/vuejs/vue/blob/b7c2d9366cf731a1551286b8ac712e6e0905070e/types/options.d.ts#L155

This line could get a JSDoc like:
```
Indicates whether the property must be set or is optional. Default is `false`.
```

### Example Result
![Bildschirmfoto 2019-07-29 um 11 03 36](https://user-images.githubusercontent.com/7195563/62035661-91545000-b1f0-11e9-928d-f4f82cd6fb2b.png)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,naisuuuu,"
--
Wanted to implement this, realized that while the guide section of the documentation does not provide clear information about default values, the [api section](https://vuejs.org/v2/api/#props) does.

Having a second source of truth to the official documentation is likely to cause more confusion than be convenient down the line. (outdated JSDoc comments are easily overlooked)

Opinions?
--

--
@kinow its definitely possible, but having to write the API documentation inside of type definition files introduces its own separation of concerns issues.

Also, JSDoc doesn't have one unified spec, which makes it hardly suitable for anything more than short comments like the one in the example.
--
",kinow,"
--
@ww7w could the JSDoc be used to generate the documentation?
--
",,,,,,,,
10318,OPEN,vue-server-renderer can't be compiled server-side with webpack 4,,2020-04-27 16:46:52 +0000 UTC,BDGrace,In progress,,"### What problem does this feature solve?
Webpack or likely any other bundler/compiler/sequencer is not going to be able to resolve dynamic require statements:

#### Example Added in comments (and at fiddle)
```
https://jsfiddle.net/te1b83jx/5/
```

#### Hence the webpack warning:
```
node_modules/vue-server-renderer/build.dev.js 9295:15-9298:9
Critical dependency: the request of a dependency is an expression
```

https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/build.dev.js#L9295



#### Using: 
```
const renderer = eval(""require"")('vue-server-renderer').createRenderer()
```
And including ""vue-server-renderer"" in the node_modules as I would imagine most people do, avoids this inconvenience, however IMO it's really nice to be able to compile system level javascript to a few javascript files (one for each process more or less... etc.)






### What does the proposed API look like?
Well if the module evaluation could be done in a way that doesn't necessitate a dynamic require statements, that would be really cool.  : )

<!-- generated by vue-issues. DO NOT REMOVE -->",,,BDGrace,"
--
[Example.tar.gz](https://github.com/vuejs/vue/files/3437351/Example.tar.gz)

--
",Tofandel,"
--
Adding to this that when importing it, if you have
```
        new webpack.DefinePlugin({
            'process.env': {
                'NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
                'VUE_ENV': '""server""'
            }
        })
    ]
```

In your webpack config, it will throw an error about left hand side assignment because vue server renderer is defining the process.env at runtime
In build.dev.js
```
process.env.VUE_ENV = 'server';
```

Which gets compiled to `""server"" = 'server';`
--
",,,,,,,,
10288,OPEN,Can template parser avoid loosing comments betwen conditionals?,,2019-08-05 22:40:22 +0000 UTC,elevatebart,Opened,,"### What problem does this feature solve?
Libraries like [vuese](https://github.com/vue-contrib/vuese) or [vue-docgen-api](https://github.com/vue-styleguidist/vue-styleguidist/tree/dev/packages/vue-docgen-api), use comments to determine how to document slots, props, methods, and events.
It uses babel to get comments from a JavaScript AST for script code. 
Using the `vue-template-compiler` parser, it does the same for HTML templates.

Here is the catch: If a comment is in-between conditions of `v-if`/`v-else`, see below, the comment will not be in the returned AST.

```vue
<template>
  <div v-if=""test"">foo</div>
  <!-- this comment will disapear -->
  <p v-else>bar</p>
</template>
```

Since I am using these comments to build the appropriate documentation objects, those comments will never bubble up.

### What does the proposed API look like?
What if `ASTifCondition` could contain their own comment field? 
The field would contain the `comment` as an ASTText object just before the condition allowing conditions to be commented and parsed.

Should it only contain the last one?
Should it contain an array of comments?
Should its name even be comments?
Is there performance concerns to look at?

Thank you in advance.

<!-- generated by vue-issues. DO NOT REMOVE -->

I already created a PR #10286 for the desired API. 
I can change it however you decide.",,,,,,,,,,,,,,
10284,OPEN,Consistency in `$refs`: all children of $refs array using same format.,discussion,2019-07-17 10:24:07 +0000 UTC,AeonFr,Opened,,"### What problem does this feature solve?
I know this is intended as a feature, but I encountered a lot of issues when trying to access $refs due to all the different formats:

- If `ref` is inside a `v-for`, the `$refs` element will be an array. This wouldn't be necessary since is trivial to add an unique name to the `ref` inside a loop, [as seen in this example](https://forum.vuejs.org/t/this-refs-theid-returns-an-array/31995/4)
- If `ref` is outside of a `v-for`, it will be a DOM Node.
- Except that when the referenced item is a custom component, then it will be an object and to access the DOM node you would have to read the `$el` property...

So basically, if we wanted to select a ref's node, and we wouldn't know if it's a node or a custom component, if it's in a for-loop or not, this would be the code:

```
const ref = (this.$refs.test && this.$refs.test[0] && this.$refs.test[0].$el) ? this.$refs.test[0].$el
    : (this.$refs.test && this.$refs.test.$el) ? this.$refs.test.$el
    : (this.$refs.test && this.$refs.test[0]) ? this.$refs.test[0]
    : this.$refs.test ? this.$refs.test
    : null;`
```

So far I've never encountered this case, but I did encounter:

- The case where the ref could be either a node or a custom component — I wanted to add a class and remove it with a timeout, for animation purposes. At the end, my workaround was to create a custom component to handle the ""empty state"" of a component, to consistently be able to reference the node using `.$el` (this was easier than refactoring all the parts where `.$el` was being referenced)-
- The case where the ref could either be a node or an array of nodes, in a case of a list that had a default value (the default value was outside of the ""for loop"").


My proposal is to have a consistent way of referencing a node/component inside templates.

An idea I found in [another issue of this repo](https://github.com/vuejs/vue/issues/2044) is to use a special syntax when the ref is expected to be an array:

```
<div ref:multiple=""example""></div>
```

Another part of the proposed change is to be able to access the DOM Node using `$el` (__always__ and exclusively that way). 

Since this is a breaking change, it would be interesting to hear workarounds for this. For example, using a different keyword altogether.

In general, I think this would add a lot of sanity and consistency to the usage of `$refs`, and I think it's a common issue for a lot of beginners.

Note: this feature request is not compatible with [this other feature request](https://github.com/vuejs/vue/issues/4035)

### What does the proposed API look like?
``` vue-html
<!-- Refs inside loops: -->
<div v-for=""..."">
    <div ref:multiple=""example""></div>
    (or ref:nested=""example"")
</div>
```

``` js
// Refs array
[
    0: { $el: <div></div> }, // simple node item
    1: { $el: <div></div>, methods, data, etc..... }, // ref in custom component
    ...
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Reworking refs as a breaking change should go through an RFC as it needs a deeper consideration of what is breaking.

To me the problem you are facing isn't clear and I'm not sure if it's a documentation problem instead. Some of the issues you are referencing are too old and now outdated in term of initial problem and comments, so let's keep this open as a discussion for the moment

Regarding many of your points, I wanted to clarify on some of those:

> f ref is inside a v-for, the $refs element will be an array. This wouldn't be necessary since is trivial to add an unique name to the ref inside a loop, as seen in this example

It's not the same, as having an array allows you to iterate through it, while having variable names with indexes attached to it doesn't if one of them is skipped with a v-if or other

> If ref is outside of a v-for, it will be a DOM Node.

Or a component

That example is quite misleading, such complexity would only exist in a case where all posibilities for ref exist in the same template. In which scenario the template itself would be a bigger problem probably

> The case where the ref could be either a node or a custom component 

That is a feature, limiting refs to just elements would not allow calling methods on the component and other patterns

> The case where the ref could either be a node or an array of nodes, in a case of a list that had a default value (the default value was outside of the ""for loop"").

In that case there must be some conditional switching between the `v-for` + `ref` version and the regular `ref`, that same conditional could be used to know if `ref` should be treated as an array or as a single element (from a business-logic perspective). Most of the cases the handling is similar and using an `Array.isArray` check is enough

--
",,,,,,,,,,
10271,OPEN,dynamic v-slot maybe overwite when used together with v-for on same element,bug; has workaround,2019-07-15 07:30:40 +0000 UTC,zrh122,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/zrh122/scg6eq1t/](https://jsfiddle.net/zrh122/scg6eq1t/)







### Steps to reproduce
1. open the reproduction link
2. look at the rendered result

### What is expected?
```js
a: a
b: b
```

### What is actually happening?
```js
a:
b: b
```

---
This is an english version of issue #10165.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10260,OPEN,v-bind not update dom in client side when data in client side is different from the server side,bug; has workaround,2019-07-12 08:36:41 +0000 UTC,maunier,Opened,,"### Version
2.6.10

### Reproduction link
[https://github.com/maunier/nuxt-learning](https://github.com/maunier/nuxt-learning)







### Steps to reproduce
npm install
npm run dev
http://127.0.0.1:8080/

### What is expected?
i expect the div is like this:
```
<div text=""isClient"">isClient</div>
```

### What is actually happening?
but now it is:
```
<div text=""isServer"">isClient</div>
```

---
it is not Nuxt's issue, I have tested in my own vue-ssr server without Nuxt, the problem is exsist still.  but the that project is not on the github, so i paste the nuxt project's link here

the core code is like this:
```
<div :text=""text"">{{ text }}</div>
```
```
data () {
      return {
        text: ''
      }
    },

    created () {
      this.text = Vue.prototype.$isServer ? 'isServer' : 'isClient'
    },
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Seems to be related to https://github.com/vuejs/vue/issues/7787, it looks like a bug to me but I might not considering something

so a workaround is to use a `ref` on the element
--

--
I didn't say it, but next time please provide a real repro not a project you are testing things on. I created o bare foot Nuxt project to repro it and a correct minimal repro would have been what was provided at https://github.com/vuejs/vue/issues/9231
--
",,,,,,,,,,
10255,OPEN,Cannot bind external web-component's 'value' property as an object,has workaround,2021-03-24 11:36:45 +0000 UTC,lmartorella,Opened,,"### Version
2.6.10

### Reproduction link
[https://embed.plnkr.co/2KKE9ixZJLrRB6FUNIou/](https://embed.plnkr.co/2KKE9ixZJLrRB6FUNIou/)

### Steps to reproduce
Steps to reproduce (see the attached plunkr):

1. Create a web-component (not using Vue).
2. Expose a 'value' property in this web component that accepts/returns non-string objects (e.g. a Date object).
3. Instantiate the web component in Vue and bind the property using :value.prop syntax

### What is expected?
The object is passed as is.

### What is actually happening?
The object is converted to string before being set to the web-component 's property.

---
It is more and more common to include third party components written in other frameworks and directly use it in Vue.
However, it seems that the Vue code always expect the 'value' property to be of type string. Let's suppose to import a date selector as ES5 web custom component, that defines the 'value' property to be a Date object.
Vue will always pass this value as string instead. Using a different property name works as expected.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
We do handle the `value` differently, we cast it as a string. I'm not sure if we should avoid this in all `ignoredElements` or only on registered components but I don't know if periodically checking has a perf impact.

Internally we also set the element's `_value` to the original value, so it's funny but the way to workaround the problem is by not calling `this._value = v` in your code because it's already done by Vue
--
",sidharthramesh,"
--
Any updates on this?
--
",,,,,,,,
10252,OPEN,Wrong definition of the type AsyncComponentFactory,good first issue; has PR; typescript,2019-10-02 17:54:10 +0000 UTC,Maorey,Opened,,"### Version
2.6.10

### Reproduction link
[https://github.com/vuejs/vue](https://github.com/vuejs/vue)







### Steps to reproduce
1. compare the [AsyncComponentFactory](https://github.com/vuejs/vue/blob/dev/types/options.d.ts) definition with the [document](https://vuejs.org/v2/guide/components-dynamic-async.html#Handling-Loading-State)

### What is expected?
attribute 'component'  should be a promise

### What is actually happening?
AsyncComponentPromise

---
I'm looking forward to your solution to this [issue](https://github.com/vuejs/vue/issues/9788)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It seems the type should be `Promise<Component | EsModuleComponent>`
--
",harshajayaweeraXHJ,"
--
Is this issue still available
--
",jvik,"
--
@harshajayaweeraXHJ  The issue already has a PR
--
",,,,,,
10248,OPEN,Vue does not work properly when setting the SVG style property in a lower version of the android browser,need repro,2019-07-10 01:40:58 +0000 UTC,tengmaoqing,In progress,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/anon/pen/XLyPJe](https://codepen.io/anon/pen/XLyPJe)







### Steps to reproduce
environment:
- qqBrowser 4.4
- android 4.2.2
- userAgent Mozilla/5.0 (Linux; U; Android 4.2.2; zh-cn; Coolpad 8297 Build/JDQ39) AppleWebKit/533.1 (KHTML, like Gecko)Version/4.0 MQQBrowser/4.4 Mobile Safari/533.1

### What is expected?
render normally

### What is actually happening?
alert
TypeError Cannot set property 'undefined' of null

---
if i remove `style=""stroke: #FFDA05;""` on SVG, it will be ok

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Everything seems to work fine on Android 4.2 and 4.1 with Chrome. I have no way to test on qqBrowser.
Could you try by using `:style.prop=""'stroke: #FFDA05;'""` instead?
--
",tengmaoqing,"
--
> Everything seems to work fine on Android 4.2 and 4.1 with Chrome. I have no way to test on qqBrowser.
> Could you try by using `:style.prop=""'stroke: #FFDA05;'""` instead?

If I using `:style.prop=""'stroke: #FFDA05;'""`  instead, it is working fine.
But, 
this is because it is assigned like this by using the `prop` modifier.
![image](https://user-images.githubusercontent.com/15967520/60886187-e0f3cb80-a283-11e9-921a-299b5ae84653.png)


In general, Vue is updating `style` through `setProp`.
![image](https://user-images.githubusercontent.com/15967520/60886091-af7b0000-a283-11e9-97b7-64746fde9f7c.png)

In some Android browsers that don't support SVG, The style attribute of the Element generated by createElementNS is null.
![image](https://user-images.githubusercontent.com/15967520/60886356-53fd4200-a284-11e9-8d0d-b978ba39d48c.png)
(`vnode.elm.style` is null.)

There is also a problem with using `v-show` in this case.

--
",,,,,,,,
10224,OPEN,Default slot content should not be evaluated when the parent is providing it,bug; has PR,2019-07-04 08:08:05 +0000 UTC,Rolanddoda,In progress,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/kk445knpx3](https://codesandbox.io/s/kk445knpx3)







### Steps to reproduce
In the `Child.vue` we have a slot with a default slot content. In the `Parent.vue` we override the default content of the child. 

### What is expected?
IMO the content of the slot in child component should not be evaluated since the content provided from the parent will be used.

### What is actually happening?
The content of the parent it renders which is what I expect.

The default content of the `Child.vue` it's evaluated even if it not renders. That's why you see in the console: `Cannot read property 'length' of null`

---
Maybe that's not a bug and instead it's the intentional behavior, but it doesn't make sense to me, to evaluate something that will not render.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I would say this is a bug as we should be able to pass a function to the slot function (`_t`) so the default slot content is only evaluated if no slot is provided.

I thought a workaround would be using a `v-for` to make it lazy, but it doesn't work
--
",Rolanddoda,"
--
Thanks for the quick response @posva . 
--
",,,,,,,,
10191,OPEN,Warn if colon shorthand is used on v-if/v-html/etc.,contribution welcome; feature request; good first issue; has PR; warnings,2020-12-18 02:37:38 +0000 UTC,simonhermann,In progress,,"### What problem does this feature solve?
I just spent way too long debugging something really weird until I realized I accidentally wrote `:v-if` instead of `v-if`. 

A warning when wrongly using shorthands like `:` on ""native"" vue attributes could prevent this bad experience easily. 

### What does the proposed API look like?
`:v-if=""foo""`

--> console.warn(""You specified v-bind:/ v-on: or a corresponding shorthand on a Vue attribute like v-if or similar. Usually this does not make sense.)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I've seen this happen so often when teaching Vue that even though having a prop named `vIf` is technically valid, I think this warning would help much more people than ever hurt
--

--
Thanks but as the tag suggest there is already a Pull request for this
--
",simonhermann,"
--
Yes. If you wanted a prop, why should have the same name as a `v-`attribute. That'd be incredibly confusing.

```
<ConfusingComponent 
  v-if=""true""
  :v-if=""false""
/>

```
--
",chrisdel101,"
--
I'll take this on.  It'll be my first issue here.
--
",zvf618,"
--
习惯就好
--
",WhiteDevill11,"
--
@simonhermann 
--
",oielbanna,"
--
I was going to give it a go but it seems there's a super old PR for this already  
--
"
10188,OPEN,Can't use the new v-slot syntax inside a template tag that is there only for conditional purposes,improvement,2019-06-24 16:08:16 +0000 UTC,wojtiku,In progress,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-template-9r28t](https://codesandbox.io/s/vue-template-9r28t)

### Steps to reproduce
Visit the repo and check out the template compilation error for `App.vue`. Remove the `<template v-else>` to get rid of the error.

### What is expected?
The template compiles properly

### What is actually happening?
The template doesn't comiple

---
Vue should allow to use slots inside a template tag that is inside component. Without this, the new slot syntax severely limits how one can put content into slots in more complex scenarios and forces repeating yourself on multiple template tags.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Duplicate of https://github.com/vuejs/vue/issues/7904
--

--
I'm confused because it doesn't work with the old syntax either, but it sounds like it did work for you with the old syntax
--

--
My bad, I was using both syntaxes at the same time. The other issue now works, so I'm not sure about so maybe it was reconsidered later and something is missing in the new implementation
--
",wojtiku,"
--
Now I am confused. It works with the old syntax. This is the same code as above just the slot syntax is different: https://codesandbox.io/s/vue-template-crbwt

Sorry for a duplicate, I haven't found it even though I was looking for it.
--
",,,,,,,,
10183,OPEN,[Feature] API for rendering VNodes to string,,2020-05-04 16:42:16 +0000 UTC,AlbertMarashi,In progress,,"## What problem does this feature solve?
I've created a `<head>` management system and an awesome feature would be a native way to render VNodes to strings, both in SSR and on client-side

Here's what I've been currently doing in user-land:
**hello-world.vue**
```html
<template>
    <master>
        <template slot=""title"">Hello World App</template>
        <template slot=""description"">Meta description here</template>
        <template slot=""content"">
            Hello World
        </template>
    </master>
</template>
<script>
import master from '@/layouts/master'

export default {
    components: {
        master
    }
}
</script>
```

**master.vue**
```html
<template>
    <servue>
        <template slot=""head"">
            <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
            <title>{{ this.$slots.title ? `${ this.$slots.title[0].text } - My App`: `My App` }}</title>
            <meta v-if=""this.$slots.description"" name=""description"" :content=""this.$slots.description[0].text"">
            <slot name=""head""/>
        </template>
        <template slot=""content"">
            <slot name=""content""/>
        </template>
    </servue>
</template>

<script>
import servue from './servue'

export default {
    components: {
        servue
    }
}
</script>
```

You can probably see some issues with how this is done, it only accounts for a single text node, and there may be more. Plus, it seems hacky to directly access slot data inside a template

The head is currently being stringified by a small component:
**servue.vue**
```html
<script>
const unaryTags = [
    ""area"",
    ""base"",
    ""br"",
    ""col"",
    ""embed"",
    ""hr"",
    ""img"",
    ""input"",
    ""keygen"",
    ""link"",
    ""meta"",
    ""param"",
    ""source"",
    ""track"",
    ""wbr""
]

function renderStartTag(VNode) {
    let html = `<${VNode.tag}`

    if (VNode.data) {
        if (VNode.data.attrs) {
            let attr = VNode.data.attrs
            for (let name in attr) {
                if (attr[name] === """") {
                    html += ` ${name}`
                } else {
                    html += ` ${name}=""${attr[name]}""`
                }
            }
        }
    }

    return html + "">"";
}

function isUnaryTag(VNode) {
    return unaryTags.indexOf(VNode.tag) > -1
}

function getFullTag(VNode) {
    if (!VNode.tag) return VNode.text

    let html = renderStartTag(VNode)

    if (VNode.children) {
        html += getChildren(VNode)
    }
    if (!isUnaryTag(VNode)) {
        html += `</${VNode.tag}>`
    }
    return html;
}

function getChildren(VNode) {
    let html = """"
    for (let i in VNode.children) {
        let child = VNode.children[i]
        html += getFullTag(child)
    }
    return html
}
export default {
    created() {
        let VNodes = this.$slots.head
        let renderedHead = """"

        for (let i in VNodes) {
            let VNode = VNodes[i];
            renderedHead += getFullTag(VNode)
        }

        if (this.$isServer) {
            this.$ssrContext.head = `<!--VUESERVEHEAD START-->${renderedHead}<!--VUESERVEHEAD END-->`
        }else{
            let head = document.head
            let node
            let foundStart = false
            let startNode

            let children = head.childNodes

            for(let node of children){
                if(node.nodeType === Node.COMMENT_NODE){
                    if(node.nodeValue === ""VUESERVEHEAD START""){
                        foundStart = true
                        startNode = node
                        continue
                    }
                }
                if(foundStart){
                    if(node.nodeType === Node.COMMENT_NODE){
                        if(node.nodeValue === ""VUESERVEHEAD END""){
                            break
                        }
                    }
                    head.removeChild(node)
                }
            }

            if(startNode){
                let fakeMeta = document.createElement('meta')
                startNode.after(fakeMeta)

                fakeMeta.outerHTML = renderedHead
            }

        }
    },
    render(h){
        return h('div', {
            class: ""servueWrapper""
        }, this.$slots.content)
    }
};
</script>
```

This whole process could be simplified by an API exposed by vue. The API already exists, it just needs to be exposed by Vue

## What does the proposed API look like?

```js
Vue.renderVNodesToString([VNode])
$vm.renderVNodesToString([VNode])

import { renderVNodesToString } from 'vue'
```

A few ideas",,,AlbertMarashi,"
--
@yyx990803 

The feature request text was too large to do through the issue helper
--

--
@posva it's slightly different, it's not for SSR

We need a universal API to render VNodes to a string on the server **and** the client

What @vedmant said
--

--
yeah, but the API is already there internally, it just needs to be exposed
--

--
@posva  will vue 3 have a feature like this, since they are opening up to a custom renderer API?
--
",LinusBorg,"
--
Sorry about that, the system isn't perfect. Thanks for understanding :)
--
",posva,"
--
This is pretty much a duplicate of your own issue: https://github.com/vuejs/vue/issues/9205#issuecomment-454261156
--

--
Sorry, I wasn't referring to the SSR part, that shouldn't change where the conversation went:

It still has to be optional on the client so it doesn't impact other users (rendering vnodes to a string is a niche case itself, even more on the client), like template compilation: it can be used on the client but can be stripped out as well.

--
",vedmant,"
--
I also trying to render Vnode but in the browser so SSR is not an option here.
--
",bmarkovic,"
--
A canonical example for this could be rendering HTML tooltip for [V-Tooltip](https://github.com/Akryum/v-tooltip) programatically.

So it's not that much of a niche use-case.
--
",6XGate,"
--
The Vue integration for ApexCharts would also benefit from this for custom tooltips since it handles this with a callback that must return raw HTML.
--
"
10171,OPEN,Only last element is accessible using ref in template-based functional components inside v-for loops,has workaround; improvement,2020-11-11 13:15:48 +0000 UTC,Sumolari,In progress,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-template-bqe44?fontsize=14](https://codesandbox.io/s/vue-template-bqe44?fontsize=14)







### Steps to reproduce
1. Create a functional component
2. Use that functional component inside a v-for
3. Add a ref binding to the functional component to be able to get the DOM element in parent component

### What is expected?
The ref in parent component is an array of DOM elements, like it is an array of vNodes when applying this steps to a non-functional component

### What is actually happening?
Only the last DOM element of the v-for is bound to the ref. It's also just an element and not an array

---
There's no warning about overriding previously existing ref

<!-- generated by vue-issues. DO NOT REMOVE -->",,,KaelWD,"
--
You need to pass down `data.refInFor` too, idk if that's possible without using render functions. 
--
",posva,"
--
Not sure what is the best way to handle this because the information about being in a v-for should be passed from the parent in the `context` and then passed down somehow to the `div`, maybe that last part should be picked up by vue-loader
--
",Sumolari,"
--
@KaelWD Doesn't look like `ref-in-for` can be passed down in a template-based component.

@posva Makes sense to me that vue-loader is the one responsible of passing that info. However, shouldn't Vue itself warn when some ref is being overwritten by a different one? Looks like an unexpected behaviour even though it's the intended one.

Just for the record, the solution I ended up implementing is just wrapping those template-based functional components in a div and having only one ref for that div. It's not the ideal solution but it's the easiest way I've found.
--
",all43,"
--
The same issue with regular elements, like `input` if it has `v-model` attached.
Replacing v-model `:value` and `@input` could be used as workaround in such case.
This behaviour should be changed, or at least mentioned in the documentation.
--
",,,,
10169,OPEN,Template Options,,2019-06-19 20:59:17 +0000 UTC,adligo,Opened,,"### What problem does this feature solve?
Beat React in Benchmarks & Improve Flexibility of Template System Integration

### What does the proposed API look like?
Hi,
  I have an idea for a new template system that I would like to integrate into Vue.  The basic idea is to create a template that can be compiled / aggressively inlined into multiple languages (i.e. Java, PHP, Python, Javascript), split up into files (with chunks of HTML) for maximum flexibility, or runtime compiled.  

**I am NOT looking to add this to the Vue project but simply integrate with the Vue project.**

 **In a nutshell the templates look like this (i.e. html chunks in xml files);**

```
<?xml version=""1.0"" encoding=""UTF-8""?>
<_templates>
<_page>
<![CDATA[<!DOCTYPE html>]]>
<html><head></head><body><div _attributeVariable="""">[[contentVariable]]</div></body>
</html>
</_page>
<_content p=""html.contentVariable"">Hello World!</_content> 
</_templates>
```


**The Plan for this is far from complete, but could it integrate to Vue?  If so how to go about doing it?**

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10153,OPEN,Add context to warn message when adding reactive properties to an instance at runtime,improvement; warnings,2019-06-30 09:47:56 +0000 UTC,miljan-aleksic,Opened,,"### What problem does this feature solve?
The  ` [Vue warn]: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.` message doesn't provide any insight about the component being affected or the property being set. Having those in place would make the deubbing way more easier.

### What does the proposed API look like?
` [Vue warn]: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option. Property being added: 'propertyName'.
<component trace>`

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
10151,OPEN,Computed properties can have widely different performance characteristics on client and server (because they are not cached during SSR),discussion; feat:ssr,2021-01-21 19:27:45 +0000 UTC,MoritzKn,In progress,,"### Version
[`v2.4.3`](https://github.com/vuejs/vue/releases/tag/v2.4.3) - current ([`v2.6.10`](https://github.com/vuejs/vue/releases/tag/v2.6.10))

### Reproduction link
[https://jsfiddle.net/anc6Lf23/2/](https://jsfiddle.net/anc6Lf23/2/)

### Steps to reproduce
1. Open the JSFiddle
2. You will see the time it takes to compute a value without caching of computed properties (~1 second) in the output
3. Set ""CACHE = true"" in the first line of the JS part to see the time it takes to compute the value with caching (~2 ms)

This issue concerns SSR but for simplicity I created the fiddle which emulates the behavior of the server render:
- `CACHE = true` – the behavior we usually have in the client
- `CACHE = false` – the behavior during SSR

### What is expected?
I would expect computed properties to have comparable performance characteristics on the server and client, so that I don't need to write custom code. 
I.e. I would expect computed properties to be cached during SSR.

### What is actually happening?
Computed properties are not cached and therefore have drastically different performance characteristics in some cases.

---
### Description if the issue

Since [computed properties are not cached during SSR](https://ssr.vuejs.org/guide/universal.html#component-lifecycle-hooks) some components unexpectedly take significantly longer to render. This is the case if it is heavy to compute the property or if it is accessed a lot. 

I would usually expect a computed property to have constant time complexity (`O(1)`) no matter how often we access it. But on the server it suddenly becomes linear time complexity (`O(n)`). This is especially critical when the computed is accessed in a loop. When we have multiple computed properties relaying on each other, each containing loops, this gets *really* bad. Then it has polynomial time with the exponent being the amount of nested computed properties (E.g. `O(n^3)` for three levels of computes, like in the JSFiddle)

### Real world example

I noticed this issue because our server renderer suddenly took multiple seconds (5-8 seconds) to respond after enabling a new component for SSR. Normally rendering the app on the server takes about 100ms.

The effected component is part of a proprietary code base but it is similar to the one in the JSFiddle. You can see the component in production here: 
- Open: https://www.ikea.com/de/de/bereiche/wohnzimmer/
- Click on the ""Serien"" button
- The flyout content is the effected component 

After finding out about this I also investigated other occurrences of this: 
In our Vuex store we did not have any nested getters with loops, like described above, however some of the getters are somewhat heavy to compute (~1ms) and accessed a lot in various templates. So I decided to introduce a very simple custom caching layer to our store. This sped up server rendering by about 20%.

**This could also be a low hanging fruit for optimizing SSR performance:**
Based on analyzing our own app, I would roughly estimate that caching all computed properties could speed up server rendering by about 30% in an average Vue.js app.

For me this issue was hard to understand because the affected code seemed harmless at first.

### Mitigation

To mitigate this issue you can move access to computes out of loops: access them once, store them in a local variable and then use this variable in the loop. This is generally a good idea since any look up of a property on a Vue.js VM has a small cost.  

However this is not possible if you have a loop inside your templates.

### References

- The code that controls this behavior:
https://github.com/vuejs/vue/blob/0948d999f2fddf9f90991956493f976273c5da1f/src/core/instance/state.js#L208-L219

- The issue that lead to this behavior being introduced: vuejs/vuex#877

- The commit that introduced this behavior 06741f32

- Earlier occasion of someone stumbling over this: 
  - nuxt/nuxt.js#2447
  - https://forum.vuejs.org/t/ssr-performance-problems-due-to-lack-of-caching/24653/5

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
I think you are aware of this (judging from how deep you digged into this), but I want to quickly re-iterate so people are on the same page:

* Reactivity is disabled on the server for a reason. 
* Yet disabling it leads to stale caches for computed properties.
* So disabling the cache for computed properties is technically necessary to ensure that the app shows the *correct* data.
* The performance issues that you describe here are an ugly side effect of this.

So technically it's not a bug as it ""works as designed"", but the end result is not satisfactory, of course. And there's no straightforward solution to this either, as far as I can tell at least. 

The best I can think of right now would be to 

1. Improve SSR docs to raise awareness and
2. maybe provide a helper function or something to use for memoizing computed props when on the server.
--
",MoritzKn,"
--
I think your proposed changes would be good improvements but I'm wondering if we can not go a bit further.

I would even question if the performance advantage of disabling reactivity on the server pays off, considering that that means computed properties aren't cached. It would be interesting to get some numbers on that.

But **maybe there is a way to cache computed properties without having stale caches**:
As far as I understand, caching for computed properties was only disabled because the Vuex state changes during SSR and getters then return outdated results. Though, in the Vuex case, we don't need the whole reactivity system to tell if the state changed because all state changes are encapsulated in mutations. So perhaps Vuex could just ""rest"" the computed cache for the getters after a mutation.

This would mean that the Vue.js Core had to provide a new API for ""resetting"" computes on the server. And Vuex would need to trigger that API after a mutation.
--
",brophdawg11,"
--
To @LinusBorg's second bullet, we ran into this recently and I wanted to drop in our optimization workaround.  We had a single getter that was massaging some data we get back from an API (in a particularly unuseful data structure) and the getter was converting the data into a much simpler data structure to be used in components.  However, computing the simpler structure took a triple-nested loop that could take close to 1ms - and that method could 50+ times during a single SSR page load because it was accessed in a bunch of places.

One option would have been to lift the getter access to a parent component and pass it via a prop all the way down - however, the component tree is fairly large and that would have been a pretty invasive change at the moment.  Another would be to move this computation out of the UI and offload to the api, but that would require a pretty significant refactor to the app as well.

So instead we decided to pre-compute the value during SSR and store it in the store `state`,  but since it's derivative data of other data in `state` we didn't want to increase the size of the stringified `state` sent to the client.  So we used a custom `JSON.stringify` replacer function to this key when stringifying the `state`.

The end code looked something like:

```js
// store.js
return new Vuex.Store({
    state: {
        apiData: null,
        _ssr_uiMap: null,
    },
    mutations: {
        setApiData(state, apiData) {
            state.apiData = apiData;
        },
        setUiMap(state, uoMap) {
            state._ssr_uiMap = uiMap;
        },
    },
    actions: {
        loadApiData({ commit }) {
            const apiData = await loadApiData();
            commit('setApiData', apiData);

            if (process.env.VUE_ENV === 'server') {
                commit('setUiMap', computeUiMap(apiData));
            }
        },
    },
    getters: {
        uiMap(state) {
            if (process.env.VUE_ENV === 'server' && state._ssr_uiMap) {
                return state._ssr_uiMap
            }
            return computeUiMap(state.apiData);
        },
    },
});


// And then when we stringify the store in entry-server.js, we use the following 
// to strip any _ssr_ prefixed keys from the state
JSON.stringify(store.state, (k, v) => k.startsWith('_ssr_') ? undefined : v)
```

So we can memoize the value on the server and only calculate it once, while still leveraging the built-in getter caching client side without impacting payload size of the stringified store.  

It's not a 100% ideal solution, but it works quite well in limited cases and we saw around a 20-25% increase in SSR render time.
--
",marcel,"
--
I have also experienced significant performance issues in SSR mode due to this behaviour. Even if I have later found and optimized the main bottleneck, I still don't like such greatly different behaviour of computed properties in SSR mode. That's why I tried to find en easy way to selectively enable caching of computed properties in components, where it is safe to do. Here is my solution, which seems to work fine for me, so maybe it could be also useful for others.

My idea was to add support for a new option, which will enable/control caching of computed properties on server.

```javascript
// Vue component
export default {
  computed: {
    compA () {},
    compB () {}
  },
  ssrComputedCache: true, // enable caching for all computed properties
  ssrComputedCache: ['compA'] // or enable cache for selected computed properties
}
```

And here is a global mixin implementing this feature, which can be used in nuxt app as plugin

```javascript
// nuxt plugin (mode: 'server')
import Vue from 'vue'

Vue.mixin({
  created () {
    if (process.server && this.$options.ssrComputedCache) {
      const { computed, ssrComputedCache } = this.$options
      const cachedProperties = ssrComputedCache === true ? Object.keys(computed) : ssrComputedCache
      cachedProperties.forEach(name => {
        let value
        let cached = false
        Object.defineProperty(this, name, {
          // for repeated re-definition in dev mode, depending on runInNewContext setting
          // (https://github.com/nuxt/nuxt.js/issues/7171)
          configurable: true, 
          get () {
            if (cached) {
              return value
            }
            value = computed[name].apply(this)
            cached = true
            return value
          }
        })
      })
    }
  }
})
```

--
",,,,
10149,OPEN,Regular slot and scoped slot with same name shouldn't be allowed,contribution welcome; feature request; warnings,2019-06-29 11:55:17 +0000 UTC,lee88688,In progress,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/lee88688/pen/jjPpBm?editors=1010](https://codepen.io/lee88688/pen/jjPpBm?editors=1010)







### Steps to reproduce
as seen in codepen,  ""hello"" component have only one slot. but rendered 2 div tag at last. I have a look at Vue's code [renderSlot ](https://github.com/vuejs/vue/blob/530ca1b2db315fbd0e360807b2031d26665c5d3d/src/core/instance/render-helpers/render-slot.js#L8) which seems renderSlot function would treat the normal slot as scoped slot. why it would be like this?

the following code is render function of hello component which is compiled by Vue.compile. _t is renderSlot function. when normal slot and scoped slot in same component the problem above will be present.
```javascript
(function anonymous() {
    with (this) {
        return _c('div', [_t(""default""), _v("" ""), _t(""default"", null, {
            ""x"": x
        })], 2)
    }
}
)
```

### What is expected?
render just one slot.

### What is actually happening?
render one slot twice.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
You cannot name a scoped slot and a regular slot the same way
Maybe we could issue a warning for this
--

--
Not really because we want to merge slots and scoped slots (v-slot is there for that too) so we want to disallow that behavior 

Eduardo San Martin Morote

> On 20 Jun 2019, at 00:52, likui <notifications@github.com> wrote:
> 
> I think it`s correct.In a way, a regular slot is a socped slot,only the context is underfined, the same name solt is can used by twice times. Maybe the user want to do like this.
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub, or mute the thread.

--
",lee88688,"
--
I really recommend adding this warning in docs. as I read the docs, I don't realize this may be a problem for me.
--
",underfin,"
--
I think it`s correct.In a way, a regular slot is a socped slot,only the context is underfined, the same name solt is can used by twice times. Maybe the user want to do like this.
--
",jamesgeorge007,"
--
@posva I would love to give it a try :+1: It would be great if you could point me to the right files to work upon as well as the required changes to be made :clap: 
--
",kerm1it,"
--
@posva I will work it.
--
",,
10115,OPEN,Unnecessary renders on parent update when $attrs is bound,improvement,2020-11-26 07:57:12 +0000 UTC,KaelWD,In progress,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/anon/pen/zQVRgG?editors=1010](https://codepen.io/anon/pen/zQVRgG?editors=1010)







### Steps to reproduce
Type something into the first field

Uncomment line 8 or 14 then try again

### What is expected?
In console:
```
Render a
```

### What is actually happening?
In console:
```
Render a
Render b
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is basically the same problem as with `$listeners` at https://github.com/vuejs/vue/issues/7257
It's because we read parent.attrs: https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js#L260
--
",KaelWD,"
--
Ah yep, missed that one. 

Looks like we have `c('field', { attrs: { ""title"": ""b"" } })`, then title is removed at [`extractProps`](https://github.com/vuejs/vue/blob/dev/src/core/vdom/helpers/extract-props.js#L63) leaving an empty object, so the `|| emptyObject` doesn't apply.  
I'll leave this open as the fix will probably be different. 
--

--
The workaround I'm using for now is to mutate a single object instead:
```js
data: () => ({
  $_attrs: {},
  $_listeners: {},
}),
watch: {
  // Work around unwanted re-renders: https://github.com/vuejs/vue/issues/10115
  // Make sure to use `v-bind=""$data.$_attrs""` instead of `v-bind=""$attrs""`
  $attrs: {
    handler (val) {
      for (const attr in val) {
        this.$set(this.$data.$_attrs, attr, val[attr])
      }
    },
    immediate: true
  },
  $listeners: {
    handler (val) {
      for (const listener in val) {
        this.$set(this.$data.$_listeners, listener, val[listener])
      }
    },
    immediate: true
  }
},
```
https://codepen.io/anon/pen/rXpGbj?editors=1010

I 100% guarantee there's bugs in this btw. 
--
",gaokun,"
--
> The workaround I'm using for now is to mutate a single object instead:
> 
> ```js
> data: () => ({
>   $_attrs: {},
>   $_listeners: {},
> }),
> watch: {
>   // Work around unwanted re-renders: https://github.com/vuejs/vue/issues/10115
>   // Make sure to use `v-bind=""$data.$_attrs""` instead of `v-bind=""$attrs""`
>   $attrs: {
>     handler (val) {
>       for (const attr in val) {
>         this.$set(this.$data.$_attrs, attr, val[attr])
>       }
>     },
>     immediate: true
>   },
>   $listeners: {
>     handler (val) {
>       for (const listener in val) {
>         this.$set(this.$data.$_listeners, listener, val[listener])
>       }
>     },
>     immediate: true
>   }
> },
> ```
> 
> https://codepen.io/anon/pen/rXpGbj?editors=1010
> 
> I 100% guarantee there's bugs in this btw.

Yes, need to delete attrs which wasn't in $attrs any more.
--

--
Consider this scenario:

```html
<my-button v-if=""visible"" />
<my-button v-else detail />
```
If we toggle `visible` once, `detail` will be in `$_attrs` even `visible` is true.
I think the root cause is **vue v-dom diff policy**.

**There are three ways to help this out:**

1. use `v-show` instead of `v-if`
```html
<my-button v-show=""visible"" />
<my-button v-show=""!visible"" detail />
```
2. add different `key` to these two components
```html
<my-button v-if=""visible"" key=""a"" />
<my-button v-else=""visible"" key=""b"" detail />
```
3. delete attributes which wasn't in $attrs any more. (like 'detail') [the same with $listeners]
```javascript
  $attrs: {
    handler (val) {
      const oldKeys = Object.keys(this.$data.$_attrs)
      for (const attr in val) {
        this.$set(this.$data.$_attrs, attr, val[attr])
        const index = oldKeys.indexOf(attr)
        if (index > -1) {
          oldKeys.splice(index, 1)
        }
      }

      for (const attr of oldKeys) {
        this.$delete(this.$data.$_attrs, attr);
      }
    },
    immediate: true
  },
```

--
",,,,,,
10112,OPEN,.DS_Store files shipped in npm package,,2021-03-19 14:47:41 +0000 UTC,graingert,In progress,,"### Version
2.6.10

### Reproduction link
[https://unpkg.com/vue@2.6.10/src/.DS_Store](https://unpkg.com/vue@2.6.10/src/.DS_Store)







### Steps to reproduce
```
wget https://unpkg.com/vue@2.6.10/src/.DS_Store
wget https://unpkg.com/vue@2.6.10/src/compiler/.DS_Store
wget https://unpkg.com/vue@2.6.10/src/platforms/weex/.DS_Store
wget https://unpkg.com/vue@2.6.10/src/platforms/weex/compiler/.DS_Store
wget https://unpkg.com/vue@2.6.10/src/platforms/.DS_Store
```
### What is expected?
```
--2019-06-06 18:17:31--  https://unpkg.com/vue@2.6.10/src/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 404 Not Found
2019-06-06 18:17:31 ERROR 404: Not Found.

--2019-06-06 18:17:31--  https://unpkg.com/vue@2.6.10/src/compiler/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 404 Not Found
2019-06-06 18:17:32 ERROR 404: Not Found.

--2019-06-06 18:17:32--  https://unpkg.com/vue@2.6.10/src/platforms/weex/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 404 Not Found
2019-06-06 18:17:33 ERROR 404: Not Found.

--2019-06-06 18:17:33--  https://unpkg.com/vue@2.6.10/src/platforms/weex/compiler/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 404 Not Found
2019-06-06 18:17:33 ERROR 404: Not Found.

--2019-06-06 18:17:33--  https://unpkg.com/vue@2.6.10/src/platforms/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 404 Not Found
2019-06-06 18:17:34 ERROR 404: Not Found.
```
### What is actually happening?
```
--2019-06-06 18:15:56--  https://unpkg.com/vue@2.6.10/src/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 6148 (6.0K) [null]
Saving to: ‘.DS_Store’

.DS_Store                                             100%[=======================================================================================================================>]   6.00K  --.-KB/s    in 0s      

2019-06-06 18:15:57 (69.3 MB/s) - ‘.DS_Store’ saved [6148/6148]

--2019-06-06 18:15:57--  https://unpkg.com/vue@2.6.10/src/compiler/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 6148 (6.0K) [null]
Saving to: ‘.DS_Store.1’

.DS_Store.1                                           100%[=======================================================================================================================>]   6.00K  --.-KB/s    in 0s      

2019-06-06 18:15:57 (65.4 MB/s) - ‘.DS_Store.1’ saved [6148/6148]

--2019-06-06 18:15:57--  https://unpkg.com/vue@2.6.10/src/platforms/weex/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 6148 (6.0K) [null]
Saving to: ‘.DS_Store.2’

.DS_Store.2                                           100%[=======================================================================================================================>]   6.00K  --.-KB/s    in 0s      

2019-06-06 18:15:57 (75.0 MB/s) - ‘.DS_Store.2’ saved [6148/6148]

--2019-06-06 18:15:57--  https://unpkg.com/vue@2.6.10/src/platforms/weex/compiler/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 6148 (6.0K) [null]
Saving to: ‘.DS_Store.3’

.DS_Store.3                                           100%[=======================================================================================================================>]   6.00K  --.-KB/s    in 0s      

2019-06-06 18:15:57 (33.9 MB/s) - ‘.DS_Store.3’ saved [6148/6148]

--2019-06-06 18:15:57--  https://unpkg.com/vue@2.6.10/src/platforms/.DS_Store
Resolving unpkg.com (unpkg.com)... 104.16.124.175, 104.16.123.175, 104.16.122.175, ...
Connecting to unpkg.com (unpkg.com)|104.16.124.175|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 6148 (6.0K) [null]
Saving to: ‘.DS_Store.4’

.DS_Store.4                                           100%[=======================================================================================================================>]   6.00K  --.-KB/s    in 0s      

2019-06-06 18:15:57 (38.7 MB/s) - ‘.DS_Store.4’ saved [6148/6148]
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Seems to be a problem with npm: https://npm.community/t/ds-store-files-show-up-after-npm-publish/831

It would be nice to `rm **/.DS_Store` before next time Vue is published
--
",graingert,"
--
Or publish from CI rather than some Dev's local machine
--
",reviewher,"
--
macOS `brew` reports errors with `apply2files` when node modules include `.DS_Store` files.  This also affects other modules like `term-size` and `extglob`.

PR #11739 should resolve this issue.  For users coming here from google, there's a way to clobber all of the `.DS_Store` files:

```
find /usr/local/lib/node_modules/ -name .DS_Store | while read x; do echo ""$x""; sudo rm ""$x""; done
```
--
",,,,,,
10102,OPEN,Stringify Vue instance,discussion,2019-06-23 06:25:03 +0000 UTC,miljan-aleksic,Opened,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/s/vue-stringify-instance-2h78n](https://codesandbox.io/s/vue-stringify-instance-2h78n)

### Steps to reproduce
Open the link, the error is reproduced right away as the code tries to serliaze the Vue instance.

### What is expected?
Being able to serlialize the Vue instance.

### What is actually happening?
Is not possible as the Vue prototype is missing the toJSON method.

---
The code is using `telejson` as the stringify library in order to remove circular references. Is the same utility used by Storybook 5 which will rise those errors in diferent scenarios, as for example when using the Action addon and passing as argument a Vue instance.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Yeah, there isn't a default toJSON method on classes, it's something that needs to be implemented. But I don't see what production use would `toJSON` have for Vue.

If the use case for this is being able to log messages during testing, error reporting or for a component style guide (like storybook), it should be implemented by those libraries so it fits their need. We cannot provide a silver bullet, dev-only `toJSON`
--

--
I'm labelling this as discussion because I'm not sure of the direction we should take and I don't want people to submit a PR and end up wasting their time if it gets rejected
--
",miljan,"
--
Maybe a simple `Vue.prototype.toJSON = () => 'Stringifying Vue instances is not supported'` in development mode would avoid confusion.
--

--
Fair enough. Meantime a stupidly simple solution is to just do...

```
Vue.prototype.toJSON = function () {
    return this;
};
```
--

--
@DominusVilicus, seriliazing an Object is quite common, a Vue instance is not more than that and all the edge cases are dealed by the serializing library. As stated in my last answer the solution is to just add the missing `_toJSON` function which could return the entire Vue instance or a new Object with just the important parts, as the `$data`.
--

--
That's fine with me.
--
",Justineo,"
--
The Vue instance can't be serialized reliably. How to “stringify” the state differs across different use cases. I prefer userland solutions like the one you posted as nobody knows what output you want better than yourself.
--
",AlbertMarashi,"
--
You can't really serialise functions (computed, methods etc), VUE relies on them to work.

If you need to serialise your vue app, you may be doing something wrong. Data can be serialised, and you can have a method for that, which can integrate with your API, but it's not easily possible to serialise a vue instance, there would be too many edge cases.
--

--
This can be implemented in userland, I'm sure there's uses for this, but most users won't need to use this.

This would be better implemented as a plugin or library
--
",,,,
10093,OPEN,Support DOM element to source mappings for VS Code's Browser preview,,2019-06-15 04:31:42 +0000 UTC,auchenberg,Opened,,"### What problem does this feature solve?
Hi 👋

I'm the author of https://github.com/auchenberg/vscode-browser-preview/, which is an extension for VS Code that allows users to preview web content inside the editor.

Browser Preview also supports ""inspect component"" which enables people to select a DOM element and go directly to the component source inside the editor.

![ezgif com-optimize](https://user-images.githubusercontent.com/173559/58752303-8041c980-8461-11e9-90e2-845957170534.gif)

Details: https://mobile.twitter.com/auchenberg/status/1133178573773164545

I'd love to be able to support Vuejs for this feature, and I'm wondering if Vue already exposes element to source mappings when running in development mode?

/k

### What does the proposed API look like?
Browser Preview is using https://github.com/auchenberg/element-to-source to do the mapping.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,psimyn,"
--
Dupe of https://github.com/vuejs/vue/issues/8034 ?

The `outputSourceRange` compiler option adds start/end tags to errors (added in https://github.com/vuejs/vue/pull/7127 mentioned on that issue)
--
",,,,,,,,,,
10083,OPEN,bug about keep-alive and @click.native caused repeated attach event handler?,bug; has PR; has workaround,2019-07-01 13:01:59 +0000 UTC,action-hong,Opened,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/action-hong/pen/eaKmOy](https://codepen.io/action-hong/pen/eaKmOy)







### Steps to reproduce
1. click ""show/hide button"" to hide button ""add 1""
2. click ""show/hide button"" to show button ""add 1""
3. click ""add 1""

### What is expected?
Repeat step 1 and step 2, Click the ""add 1"" to add 1 to the number

### What is actually happening?
Repeat step 1 and step 2 , Click the ""add 1"" to add n(repeat times) to the number

---
5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Seems like a bug indeed. As a workaround, you can pass a regular `@click` and handle it manually with `$listeners.click`

```vue
<button @click=""$listeners.click"">{{ text }}</button>
```
--
",,,,,,,,,,
10029,OPEN,Triggering a listener of a functional component breaks reactivity in Safari 12.1; if iframe is on the page,browser quirks; bug; has workaround,2020-09-10 09:02:33 +0000 UTC,mvy-siteimprove,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/ebgj6fra/2/](https://jsfiddle.net/ebgj6fra/2/)







### Steps to reproduce
- Access the fiddle
- click the ""change"" button

### What is expected?
*Hello world!* should change to *tada!*

### What is actually happening?
In latest Safari (12.1) on Mac OS, nothing happens, but it works as expected in other browsers.

---
Removing the `iframe` from the page makes the issue go away, as seen here: https://jsfiddle.net/ebgj6fra/3/

Seems like maybe there's a difference in how/when the latest Safari runs the `flushCallbacks`.

Conditionally rendering the iframe (`v-if=""myExpression !== null`), triggering the listener inside a `setTimeout` or calling `$forceUpdate` circumvents the issue.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Thanks for the boiled down repro 👌 
--
",vanputten,"
--
This issue still exists. Perhaps this should be mentioned somewhere in the Vue docs?

We used this as a fix in our main Vue instance:
`mounted: function() {
        this.$forceUpdate();
 }`
--
",,,,,,,,
10027,OPEN,get error detail when use async component factory,feature request,2019-10-11 18:38:07 +0000 UTC,jaylecn,Opened,,"### What problem does this feature solve?
https://vuejs.org/v2/guide/components-dynamic-async.html#Handling-Loading-State

```
const component = new Promise(function (resolve, reject) {
       reject('error detail');
});
```

```
const AsyncComponent = () => ({
  // The component to load (should be a Promise)
  component: component,
  // A component to use while the async component is loading
  loading: LoadingComponent,
  // A component to use if the load fails
  error: ErrorComponent,
  // Delay before showing the loading component. Default: 200ms.
  delay: 200,
  // The error component will be displayed if a timeout is
  // provided and exceeded. Default: Infinity.
  timeout: 3000
})
```


i want get error detail in  `AsyncComponent.error` component,  make page friendly




### What does the proposed API look like?
maybe inject error as props to  `AsyncComponent.error`  ?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I think it would make more sense to pass the error as a prop named `error` to the ErrorComponent
--
",Akryum,"
--
This would be very useful to debug an issue in production for example.
--
",,,,,,,,
10021,OPEN,<keep-alive> within <transition-group> blocks leave transitions,improvement; transition,2019-10-18 18:15:00 +0000 UTC,sathomas,Opened,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/sathomas/pen/Jqoyqo](https://codepen.io/sathomas/pen/Jqoyqo)







### Steps to reproduce
Component structure:

    <transition-group>
      <keep-alive>
        <component />
      </keep-alive>
    </transition-group>

Change dynamic component. Leave transition does not occur.

In repro example, click <kbd>Switch View</kbd>

- Note 1: In repro example if `<keep-alive>` is removed via checkbox, all transitions work as expected.
- Note 2: In repro example if `<transition-group>` is replaced with `<transition>`, all transitions work as expected.

### What is expected?
Initial component should transition out while new component transitions in.

### What is actually happening?
Initial component is removed immediately while new component transitions in.

---
In actual use case, `v-show` is not a good option as the dynamic components involved are quite complex (1000s of DOM elements) and leaving them in the actual DOM causes performance problems.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,underfin,"
--
it's not support use `keep-alive` in `transition-group`.I have a try which support it. it's maybe can become a new feature.Can I work it?
--
",posva,"
--
Sure, give it a try
--
",,,,,,,,
10009,OPEN,Vue.config.errorHandler and errorCaptured should capture rejected promised in watchers,good first issue; has PR; improvement,2021-01-14 22:06:21 +0000 UTC,xiangnanscu,In progress,,"### Version
2.6.6

### Reproduction link
Vue.config.errorHandler: [https://jsfiddle.net/0aeufxmr/5/](https://jsfiddle.net/0aeufxmr/5/)
`errorCaptured` option: https://jsfiddle.net/shenron/kbuymoz0/







### Steps to reproduce
Just click `click1` and `click2` you will see the difference

### What is expected?
when clicking `click1`, the message should be error response

### What is actually happening?
message not changed

<!-- generated by vue-issues. DO NOT REMOVE -->",,,xiangnanscu,"
--
this is code:
```
<template>
<div id=""app"">
<button @click=""changeTrigger1"">click1</button>
<button @click=""changeTrigger2"">click1</button>
  <p>{{ message }}</p>
</div>
</template>

<script>
Vue.use(VueResource)

Vue.config.errorHandler = function (err, vm, info) {
  console.log('error catched',err)
  vm.message = err
}

new Vue({
  el: '#app',
  data: {
    trigger1: '',
    trigger2: '',
    message: 'Hello Vue.js!'
  },
  watch: {
     async trigger1(v) {
    	await this.fetchData()
    },
    async trigger2(v) {
    	try{
      	await this.fetchData()
      } catch (err) {
      	this.message = err
      }
    },
  },
  methods: {
    async fetchData() {
      await this.$http.get('/foooooooo')
    },
    changeTrigger1() {
    	this.trigger1 = Math.random()
    },
    changeTrigger2() {
    	this.trigger2 = Math.random()
    }
}
})
</script>
```
--
",KancerEzeroglu,"
--
Hi @posva, is somebody working on this issue? If not, I would like to work on it.
--
",posva,"
--
This issue has already an open pull request as the label suggests
--
",berniegp,"
--
I put on my ""hacker"" hat and came up with a way to catch errors properly in watchers until #9484 is merged...

    // Fix ""Vue.config.errorHandler and errorCaptured should capture rejected promised in watchers""
    // https://github.com/vuejs/vue/issues/10009
    // Ugly monkey patching until https://github.com/vuejs/vue/pull/9484 is merged
    const realWatch = Vue.prototype.$watch;
    Vue.prototype.$watch = function $watchDetour(expOrFn, callback, options) {
      if (typeof callback === 'function') {
        if (this.$_watchCount === undefined) {
          this.$_watchCount = 0;
        }

        // Reroute $watch to $on which handles promise rejections properly
        const watchDetourEvent = `watchDetour_${this.$_watchCount}`;
        this.$_watchCount += 1;
        const realCallback = callback;
        this.$on(watchDetourEvent, (args) => { return realCallback.apply(this, args); });
        callback = (...args) => { this.$emit(watchDetourEvent, args); };
      }

      // realWatch will call back into $watchDetour with a function if callback wasn't one
      return realWatch.call(this, expOrFn, callback, options);
    };
--
",,,,
10004,OPEN,Memory leak with component with input with v-model,bug; has PR,2020-11-16 13:19:54 +0000 UTC,posva,In progress,,"### Version
2.6.10

### Reproduction

```html
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <meta http-equiv=""X-UA-Compatible"" content=""ie=edge"" />
    <title>Document</title>
  </head>
  <body>
    <script src=""https://unpkg.com/vue""></script>

    <div id=""app"">
      <div id=""nav"">
        <button @click=""goHome"">go to Home</button>
        <button @click=""goAbout"">go to About</button>
      </div>
      <component :is=""current""></component>
    </div>

    <script>
      const Home = {
        name: 'Home',
        template: `
      <div>
        <h2>Home</h2>
      </div>
      `,
      }

      const About = {
        template: `
        <div class=""about"">
    <h1>This is an about page</h1>
    <input type=""text"" v-model=""input"">
  </div>
      `,
        name: 'about',
        data: () => ({
          input: '',
        }),
      }

      const vm = new Vue({
        el: '#app',
        data() {
          return {
            current: 'Home',
          }
        },

        methods: {
          goHome() {
            this.current = 'Home'
          },
          goAbout() {
            this.current = 'About'
          },
        },
        components: { Home, About },
      })
    </script>
  </body>
</html>
```


![Screen Shot 2019-05-09 at 18 59 07](https://user-images.githubusercontent.com/664177/57471906-8a224380-728c-11e9-832d-f1ce989ee1e0.png)





### Steps to reproduce

- go to the about page
- type in the input
- leave the page
- collect garbage and take a snapshot with devtools

### What is expected?

VueComponent count should be stable

### What is actually happening?

VueComponent count keeps increasing.

---

seems to be related to typing in the input

<!-- generated by vue-issues. DO NOT REMOVE -->",,,ricardo,"
--
@posva After further testing. This might not be Vue's fault.

Testing the code above on Chrome Version 72.0.3626.121 (mac) seems to run without any issues and VueComponent count is stable.
--

--
> Does anybody know if this also happens in the PROD version? As I am not able to filter by ""vue"" components in Chrome DevTools. I see the same code as the dev version though...

@clopezcapo Yes it does.
--
",posva,"
--
it isn't in 74. It could be a bug on Chrome. I've found leaks in the past (https://bugs.chromium.org/p/chromium/issues/detail?id=949587). I didn't test with this one though as it looks like Vue is retaining the component and the browser cannot free it
--

--
Thanks for checking it out!
--
",kizivat,"
--
I can confirm this happens in Chrome 74. When trying to replicate this in Safari, I cannot even see any Vue related objects in their JS allocations inspector, but that is probably just my mistake somehow.

However, if this doesn't happen in the earlier versions of Chrome with the same Vue version, this could be probably forwarded to Chromium project and closed here?
--
",andysoa,"
--
This is especially critical when we talk about large SPA's with tones of data. As far as I can see Chrome 74 is not able to collect much...
--

--
https://bugs.chromium.org/p/chromium/issues/detail?id=961494

There is some development regarding this issue.
--
",KyLeoHC,"
--
Recently I have found that there is a problem while input element work with 'v-model'. If I type the content quickly, it cause the high CPU usage. 
![3E5A8D54478379E333140DDA975D8E0F](https://user-images.githubusercontent.com/11409080/58165130-ad4fe880-7cb9-11e9-89c4-16f4803307dd.jpg)

--
",diazemiliano,"
--
@posva or anyone knows how to test this with FF devtools and EDGE devtools?
Because we don't have the constructors names in those.
This is happening in other browsers like chrome and ff too.
Thanks.
--
"
10001,OPEN,When hydrate failed; the old component instance did not be destroyed,,2020-04-10 15:31:49 +0000 UTC,skyline0705,Opened,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/mt9xp1wo/](https://jsfiddle.net/mt9xp1wo/)







### Steps to reproduce
open the link and see the result

### What is expected?
the beforeDestroy hook should be called twice

### What is actually happening?
the beforeDestroy hook only be called once

<!-- generated by vue-issues. DO NOT REMOVE -->",,,AlbertMarashi,"
--
Why should the `beforeDestroy` hook be called twice? It seems expected https://jsfiddle.net/bec907ds/7/
--
",fedifazzy,"
--
The problem exists and it is really bad thing.

When hydrating it is expected that component will be destroyed before rendered again. But it's not, I've got two components linked with one node. I can see duplicates in this.$children. 

@skyline0705 Do you have any updates with your case, maybe some workarounds?

I'm going to manually fire $destroy on duplicated children, because having the same component hidden is big problem for my project.

@DominusVilicus you can see everything here:
https://jsfiddle.net/zf1h8x94/1/

--
",,,,,,,,
9992,OPEN,this.$nextTick don't work fine in (android 5.1.1)android webview 55.0.2883.91.,browser quirks; need repro,2019-09-17 01:49:56 +0000 UTC,Trendymen,In progress,,"### Version
2.6.10

### Reproduction link
[https://codesandbox.io/embed/k36zj3z5o7](https://codesandbox.io/embed/k36zj3z5o7)

### Browser info
android 5.1.1
android system webview 55.0.2883.91.

### Steps to reproduce
input phone number more than 3.

### What is expected?
when i input phone number more than 3 ,the position of cursor will be the last .

### What is actually happening?
when i input phone number more than 3 ,the position of cursor is not  on the last.I suppose the reason is the bug of microtask in this version of android webview.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I don't understand what you expect to happen. This is what happen on Android 5.1:

![ScreenFlow](https://user-images.githubusercontent.com/664177/57365988-62e14e80-7186-11e9-8592-83828ed4f9b8.gif)

the same happens on desktop Chrome 55
--

--
It still doesn't reproduce on Chrome 55 nor android 5.1
What is the bug of microtask you are talking about?
--
",Trendymen,"
--
> I don't understand what you expect to happen. This is what happen on Android 5.1:
> 
> ![ScreenFlow](https://user-images.githubusercontent.com/664177/57365988-62e14e80-7186-11e9-8592-83828ed4f9b8.gif)
> 
> the same happens on desktop Chrome 55

i'm sorry about that i can't reproduct too before, i have updated the codesandbox link, please check it one more.

This is the what happen on my test phone-Samsung Galaxy J3 Pro :

![20190508_210103](https://user-images.githubusercontent.com/35187547/57377586-62bc6f80-71d5-11e9-85e2-29d45064e175.gif)







--

--
> It still doesn't reproduce on Chrome 55 nor android 5.1
> What is the bug of microtask you are talking about?

Sorry, maybe i can't explain why i think it's a bug of microTask, but i supposed it is because if i use setTimeout, it will works fine. but there are no problem in other device when i use nextTick .
In the webview 55.0.2883.91. , i can get the right selectionEnd after this line when i debug
` target.setSelectionRange(selectionEnd, selectionEnd);`
but the cursor position on the (selectionEnd - 1).

And if i usethe keyup instead of input , the nextTick will not cause problem.
--

--
> It still doesn't reproduce on Chrome 55 nor android 5.1
> What is the bug of microtask you are talking about?

I reproduce it on chrome 55.0.2883.91 with android 6.0.1.
The key is the Android Chrome version should be 55.0.2883.91.Maybe it doesn't happen on desktop chrome.
![screenrecorder_Trimmed_20190509_103102 mp4_20190509_105023](https://user-images.githubusercontent.com/35187547/57423914-6806d200-7248-11e9-8e96-7eca2fb826b0.gif)

--

--
> Is this issue only reproducible with custom input methods (Sogou in your case)? I suspect it's related to IME.

Oh! yes, it happened with Sougou and sony's xperia input method, but Google Gboard works fine. 

--
",Justineo,"
--
Is this issue only reproducible with custom input methods (Sogou in your case)? I suspect it's related to IME.
--
",wLove,"
--
I've had this problem before. I solved that with setTimeout.
--
",,,,
9986,OPEN,ability to keep `enter-to` class after show transition completes,feature request; transition,2020-04-22 03:08:24 +0000 UTC,tmorehouse,In progress,,"### What problem does this feature solve?
In some CSS libraries, i.e. Bootstrap, many components have opacity set to `0` by default, and only have opacity set to `1` when a class is applied.  i.e. Bootstrap's `fade + show` classes:

```css
.fade:not(.show) { opacity: 0; }
```

The current `<transition>` behaviour does not support retaining the `enter-to-class` (as it is immediately removed once the transition completes).

Currently one has to use javascript hooks and VM data to add/remove the `show` class, which makes it impossible to make re-usable transition components, as simply adding a class via javascript to the `el` reference (via `el.classList.add/remove('show')`) doesn't guarantee persistence if the content in the default slot manipulates it's own classes, meaning the transition component _must_ be integrated into the custom component, not as a re-usable utility wrapper component).

### What does the proposed API look like?
It would be nice to either be able to retain the `enter-to-class` class after the transition completes, or create a new prop that provides this behaviour for a particular class name i.e. `enter-to-retain-class`. The class would be removed on leave.

The other option would be to create a new prop `active-class=""classname""` which is added one frame after insertion, and removed when the leave transition is to start (basically rolling the `enter-to-class` and `leave-class` into one prop, but retain the class until leave is initiated)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,tmorehouse,"
--
In our (BootstrapVue's) use case, we have to hard-code the transition component and code into each component that uses the `fade+show` Bootstrap V4 transition classes (modals, toasts, alerts, tabs, etc), causing unnecessary code duplication, and making it difficult for us to allow users to provide their own custom transitions (which has been a common ask for the past while), due to the need for us to mix CSS+Javascript to make Vue's transition system work with Bootstrap.
--

--
We tried something similar, but ran into issue if the root element of the default slot updates (i.e. classes dynamically added or attributes changed), that the class added by the `afterEnter` hook can get trashed/removed
--
",JoshMoreno,"
--
Ran into this issue today. +1 for adding it to core. Here's the workaround I came up with today:

Transparent wrapper around the default `transition` component with js hooks to add classes after the enter transitioning is done, and remove those classes before our leave transition starts.
`after-enter-class` is the prop I added which in my case just mirrors `enter-to-class`.

[https://codesandbox.io/s/serene-darwin-r7h4o?file=/src/components/BetterTransition.vue](https://codesandbox.io/s/serene-darwin-r7h4o?file=/src/components/BetterTransition.vue)
```vue
<template>
  <transition
    v-bind=""$attrs""
    v-on=""$listeners""
    v-on:after-enter=""afterEnter""
    v-on:before-leave=""beforeLeave""
  >
    <slot></slot>
  </transition>
</template>

<script>
export default {
  props: {
    afterEnterClass: {
      type: String,
      default: """"
    }
  },
  computed: {
    classes() {
      return this.afterEnterClass.split("" "").filter(i => i);
    }
  },
  methods: {
    afterEnter(el) {
      this.classes.forEach(cssClass => el.classList.add(cssClass));
    },
    beforeLeave(el) {
      this.classes.forEach(cssClass => el.classList.remove(cssClass));
    }
  }
};
</script>
```

**Usage**
```vue
<better-transition
  enter-active-class=""transition duration-1000""
  enter-class=""opacity-0""
  enter-to-class=""opacity-50""

  after-enter-class=""opacity-50""
        
  leave-active-class=""transition duration-1000""
  leave-class=""opacity-50""
  leave-to-class=""opacity-0""
>
  <div v-if=""open"" class=""mt-5"">Our transition</div>
</better-transition>
```
--

--
Ahhh. Yup I'm getting the same thing. Easiest workaround is to wrap the content for the slot in a tag using and ensure it doesn't ever update. Not ideal; works for me since I'm in complete control of everything, but I can see this not being something you'd want to support in a public package.

```vue
<better-transition
  enter-active-class=""transition duration-1000""
  enter-class=""opacity-0""
  enter-to-class=""opacity-50""

  after-enter-class=""opacity-50""
        
  leave-active-class=""transition duration-1000""
  leave-class=""opacity-50""
  leave-to-class=""opacity-0""
>
  <div v-if=""open"">
    <div class=""mt-5"" :class=""{'text-white': isActive}"">Our transition</div>
  </div>
</better-transition>
```

@tmorehouse On a side note, thanks for all your work on [bootstrap-vue](https://github.com/bootstrap-vue/bootstrap-vue). We've used it in a few projects and it's been great!
--
",,,,,,,,
9972,OPEN,<keep-alive> doesn't `destroy` cached components after when max is 1,bug; has PR; has workaround,2021-02-02 09:44:33 +0000 UTC,kchung,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/r2xjo5cf/7/](https://jsfiddle.net/r2xjo5cf/7/)







### Steps to reproduce
1. Open dev tools to see console
2. Cycle through the routes
3. View console and observe lifecycle hook logging

### What is expected?
I'd expect once the `max` cache is reached (in the example case of 1), the component that gets pruned also gets destroyed. In [the documentation](https://vuejs.org/v2/api/#keep-alive) it states (emphasis mine): 

> `max`
>
> The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed **will be destroyed** before creating a new instance.

### What is actually happening?
The pruned component is never destroyed, it's just removed from the cache. In the example, the `beforeDestroy` hook is never called.

---
Related code: https://github.com/vuejs/vue/blob/636c9b4ef17f2062720b677cbbe613f146f4d4db/src/core/components/keep-alive.js#L37-L49

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It seems not to destroy components when the max is one (in which case using keep-alive is pointless btw). I removed Vue Router from the repro to make it simpler: https://jsfiddle.net/p0te9vL3/ (max is set to 2 to show it works)

I marking this as a bug for consistency. The workaround would be not using a `keep-alive` if the value for max is `1`
--

--
it will cache 1 component, so as soon as you switch the cache is occupied by the new component and the previous component is removed. A cache of one entry here is the same as not having any cache
--

--
@zrh122  are you sure? I haven't tested but the pr https://github.com/vuejs/vue/pull/10015 introduced a very small change that does not appear in yours. In any case, it would be nice if we could merge both for different issues, so both contributions are taken into account 🙂 
--
",diem98,"
--
should we just validate max value just like this?
```js
       if (parseInt(this.max) > 1) {
          var ref$1 = this;
          var cache = ref$1.cache;
          var keys = ref$1.keys;
          var key = vnode.key == null
            // same constructor may get registered as different local components
            // so cid alone is not enough (#3269)
            ? componentOptions.Ctor.cid + (componentOptions.tag ? (""::"" + (componentOptions.tag)) : '')
            : vnode.key;
          if (cache[key]) {
            vnode.componentInstance = cache[key].componentInstance;
            // make current key freshest
            remove(keys, key);
            keys.push(key);
          } else {
            cache[key] = vnode;
            keys.push(key);
            // prune oldest entry
            if (this.max && keys.length > parseInt(this.max)) {
              pruneCacheEntry(cache, keys[0], keys, this._vnode);
            }
          }
  
          vnode.data.keepAlive = true;
        }
```
--
",kchung,"
--
@posva maybe I'm confused by the prop, but when I used `:max=""1""` I was expecting it to ""keep alive"" the previous component, so it'd always remember the trailing component but would destroy anything past 1
--

--
@posva ah that makes more sense, thanks!
--
",zrh122,"
--
@posva, #9962 already fixes it, i just found out.
--

--
> @zrh122 are you sure? I haven't tested but the pr #10015 introduced a very small change that does not appear in yours. In any case, it would be nice if we could merge both for different issues, so both contributions are taken into account 🙂

Yes, in my code i delay to call `pruneCacheEntry` until component mounted or updated, at that time `this._vnode` is equal to variable `vnode`.
--
",unitree,"
--
@posva I am using keep-alive to cache some expensive page, like the following.

`  <keep-alive max=""1"">
   <router-view v-if=""$route.meta.needCache""></router-view>
  </keep-alive>
  <router-view v-if=""!$route.meta.needCache""></router-view>`


However, I find out that there is no ""beforeDestroy"" hook for the cached file.
I used ""deactivated hook"", but it seems that there is some  minor memory leak. 


--

--
I wonder if <keep-alive max=""1""> can clean up nodes thoroughly.... 
--

--
> It seems not to destroy components when the max is one (in which case using keep-alive is pointless btw). I removed Vue Router from the repro to make it simpler: https://jsfiddle.net/p0te9vL3/ (max is set to 2 to show it works)
> 
> I marking this as a bug for consistency. The workaround would be not using a `keep-alive` if the value for max is `1`

`<keep-alive max=""1""> <router-view v-if=""$route.meta.needCache""></router-view> </keep-alive> <router-view v-if=""!$route.meta.needCache""></router-view>`
I use this to keep only one expensive page, so that user can switch from nonexpensive one to expensive one easily, but one can only cache one expensive page.

--

--
@posva I wonder if there are any other choices for my situation. 
--
",RichieChoo,"
--
> > @zrh122 are you sure? I haven't tested but the pr #10015 introduced a very small change that does not appear in yours. In any case, it would be nice if we could merge both for different issues, so both contributions are taken into account 🙂
> 
> Yes, in my code i delay to call `pruneCacheEntry` until component mounted or updated, at that time `this._vnode` is equal to variable `vnode`.

It may cause other problem, such as last router will fresh when activated
--
"
9895,OPEN,2.6-csp branch to support inline-templates with CSP enabled,,2020-09-27 01:44:14 +0000 UTC,ragoutje,In progress,,"### What problem does this feature solve?
Using inline-templates when CSP is enabled is currently impossible due to new Function() being used in the compiler in the full build.
In all posts that I could find regarding this issue the runtime only build is suggested. However when you are working on a project where you cannot move all templates to render functions, or precompile to render functions, this is not possible.

To us inline-templates are a very important part of the ""progressive framework"" idea. This allows us to utilize the full power of Vue while not forcing  a refactor upon our entire backend to use API's when we want to upgrade Vue to v2 (even though they ideally should).

For Vue 1.28 there is a specific csp branch which utilises notevil. I want to do the same for Vue 2.6.
I will try to provide a working fork, although I could use some help on this (it's my first time working with the vue source code)

### What does the proposed API look like?
1 branch, v2.6.x-csp, will be made where ```new Function()``` will be replaced by ```notevil.Function()``` to safely eval expressions.
Just like v1.28-csp, notevil will be included in the codebase.

Currently I have found ```new Function()``` in src/compiler/to-function.js:15 38 and src/compiler/no-error.js:86 95 which have to be refactored to ```notevil.Function()``` calls.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,ragoutje,"
--
I have tried to apply notevil by following this commit https://github.com/vuejs/vue/commit/94cf00d209c85e5ec7fe8c321fec9e094b18f1ca which was done in the vue 1.28-csp branch.

I have copied the notevil.js file from the commit above and added the commits from notevil@1.1.0 to it: https://github.com/mmckegg/notevil/commit/939b3f67b1d9c64760b0311af9828b305ca21deb

This results in an error (with or without the 1.1.0 code): ```Unexpected expression: WithStatement```
Turns out notevil has no support for with statements. I added the following to the walk function switch statement, but I know it should return some more in order to actually achieve something:
```
case 'WithStatement':
                    return;
```

With statements are still present in Vue code: I found this issue concerning them: https://github.com/vuejs/vue/issues/4115#issuecomment-260092742
But should not be a problem as commented in the issue by Evan You.

I have tried the following in my dev env which has CSP enabled, but also did not render anything (probably expected behaviour as nothing is returned when with statements are encountered):
```
function createFunction(code, errors) {
    try {
        // return new Function(code)

        const fn = notevil.Function(code);
        return function() {
            return fn.call(this);
        };
    } catch (err) {
        errors.push({ err, code });
        return noop;
    }
}
```

As I mentioned there are no visible errors and nothing renders. The DOM is removed but Vue did not replace it with it's own DOM.

When using breakpoints in Firefox I find the following error:
```TypeError: toFixed method called on incompatible Object```
And a quick google search hints that the ""this"" context is probably incorrectly set but I am unable to confirm this. Which is also probably related to the fact with statements are not properly handled by notevil.

It would be awesome if someone with a little more knowledge of inner workings of Vue and/or notevil could work out how to fix this.
--

--
Also opened an issue at the notevil repo: https://github.com/mmckegg/notevil/issues/33
--
",buddh4,"
--
Did not find any information regarding CSP in the [vue3 guide](https://v3.vuejs.org/guide/introduction.html), was this resolved or is [this part](https://vuejs.org/v2/guide/installation.html#CSP-environments) missing?
--
",,,,,,,,
9876,OPEN,Custom directive binds differs on components vs elements,bug; has workaround,2019-04-26 13:08:24 +0000 UTC,bponomarenko,In progress,,"### Version
2.6.10

### Reproduction link
[https://jsfiddle.net/bponomarenko/uom10qd2/](https://jsfiddle.net/bponomarenko/uom10qd2/)







### Steps to reproduce
1. Open browser console.
2. Click on Toggle button two times. 

### What is expected?
Directive will emit the same console messages when applied to DOM elements and to components (on init and after click on button).

I'm not sure what should be expected output. Either
```
bind: first comp
bind: first elem
unbind: first comp
unbind: first elem
bind: first comp
bind: first elem
```

or 

```
bind: first comp
bind: first elem
unbind: second comp
unbind: second elem
bind: first comp
bind: first elem
```

### What is actually happening?
Messages from the directive are the same on init, but different after button have been clicked.

Actual console output:
```
bind: first comp
bind: first elem
unbind: first comp
unbind: second elem
bind: second comp
bind: first elem
```

---
It seems that order in which directives are applied to DOM elements and components are different. In my setup I have custom directive which relies on some DOM attribute with configuration data. When this custom directive is bound/unbound in a ""regular flow"" – everything works as expected (directive binds after element attributes are updated). However when directive is bound/unbound in case of Vue ""in-place patch strategey"", behavior seems to be different.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Seems like the directive is called with the old component (because it's reused) but it still has old attrs

As a workaround, set a key on one of the components
--
",pistis,"
--
@bponomarenko 
What @posva said is already covered in the documentation.
You can refer to this.

https://vuejs.org/v2/guide/conditional.html#Controlling-Reusable-Elements-with-key
--
",bponomarenko,"
--
@posva @pistis Thanks for the answer. Yeah, that is what we used eventually as a workaround, I had to mention that in the ticket. However presence of `key` attribute will not allow to use Vue.js rendering optimisations. Would be great to have it fixed.
--

--
@Justineo I understand the concepts behind an optimization itself. In my situation, custom directive is responsible for adding the state attribute to element on `bind` and removing that attribute on `unbind`. And directive is perfectly added/removed when component is re-used by Vue.js. However order of component properties update and directive initialization is different in different moments of component lifetime, which makes it hard to develop custom directives.
Indeed additional documentation on these optimization techniques might be helpful, but inconsistent directives lifecycle events are rather a bug to fix in my opinion.
--
",Justineo,"
--
The optimization is based on that you have stateless elements so Vue won’t bother to take care of correctly managing event handlers or local states when trying to reuse an element. So I think this is not a bug but can be potentially improved in our docs so that our users can understand this more easily.
--
",alidavid0418,"
--
> As a workaround, set a key on one of the components
--
",,
9873,OPEN,Vuejs type inference does not work with TS 3.4.x,typescript,2019-08-27 19:00:21 +0000 UTC,p-kuen,Opened,,"### Version
2.6.10

### Reproduction link
[https://github.com/Patcher56/ts3.4.x-vuejs-issue](https://github.com/Patcher56/ts3.4.x-vuejs-issue)







### Steps to reproduce
1. create a new vue typescript project (without class syntax) `vue create test-ts`
2. open `src/components/HelloWorld.vue`
3. add a data variable and try to access it in a computed property

### What is expected?
No errors (as the data is defined)

### What is actually happening?
Typescript error 2339 telling me
```Property 'test' does not exist on type 'CombinedVueInstance<Vue, {}, {}, {}, Readonly<{ msg: string; }>>'.```

![image](https://user-images.githubusercontent.com/2443710/56112638-f5ae1500-5f5b-11e9-82c5-bc2cd4f52831.png)

---
I think this has something to do with the changed type inference in Typescript 3.4.x.

**Important**: Change vetur settings to use workspace dependencies to show errors directly in vscode, else you will only get the error when using `yarn serve`.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
Seems to belong into the vetur repository then, right?
--

--
Of course... 
--
",p,"
--
No, because the errors also appear in the terminal when using `yarn serve`.
Vetur is just responsible for showing me the errors directly in vscode.

```bash
patrick@patrick-Ubuntu:~/dev/test/test$ yarn serve
yarn run v1.15.2
$ vue-cli-service serve
 INFO  Starting development server...
Starting type checking service...
Using 1 worker with 2048MB memory limit
 98% after emitting CopyPlugin                                                 

 DONE  Compiled successfully in 2925ms                                                                                                                                        09:12:39

Type checking in progress...

  App running at:
  - Local:   http://localhost:8081/ 
  - Network: http://10.25.1.148:8081/

  Note that the development build is not optimized.
  To create a production build, run yarn build.

ERROR in /home/patrick/dev/test/test/src/components/HelloWorld.vue
104:19 Property 'test' does not exist on type 'CombinedVueInstance<Vue, {}, {}, {}, Readonly<{ msg: string; }>>'.
    102 |   computed: {
    103 |     testComp: function() {
  > 104 |       return this.test === false;
        |                   ^
    105 |     }
    106 |   }
    107 | });
Version: typescript 3.4.3
Time: 3161ms
```
--

--
Best workaround is to use the new [Vue Composition API](https://vue-composition-api-rfc.netlify.com/). It is a lot cleaner for typescript and works also with typescript versions > 3.3.4000.
--
",yyx990803,"
--
/cc @HerringtonDarkholme @ktsn 
--

--
/cc @DanielRosenwasser
--
",HerringtonDarkholme,"
--
Looks like TS3.4 has multiple inference issue... 

The minimal repro:

```ts
Vue.component('test', {
  data() {
    return {
      test: 123
    }
  },
  computed: {
    ttt() {
      return this.test + 1
    }
  },
})
```

Also spotted another failure:

The catch-all type signature of component
```ts
  component(id: string, definition?: ComponentOptions<V>): ExtendedVue<V, {}, {}, {}, {}>;
```
is causing union type to fail checking. 

I need more time for investigation...
--

--
Minimal repro:

```ts
type TypedDef<Data, Computed> =
  ComponentOptions<Data, Computed> &
  ThisType<Data & Computed>

type DataDef<Data> = () => Data

export interface ComponentOptions<Data, Computed> {
  data?: DataDef<Data>
  computed?: Accessors<Computed>
}
export type Accessors<T> = {
  [K in keyof T]: () => T[K]
}

declare function component<Data, Computed>(def: TypedDef<Data, Computed>): void;

component({
  data() {
    return {
      foo: 23
    }
  },
  computed: {
    bar() {
      // return this.foo + 1 // comment out the return solves the problem
    }
  }
})

```

The problem seems to be cyclic inference issue. If the computed property doesn't reference data, the compiler error goes away.

I think it should goes to TypeScript's repo.
--

--
The best way to avoid the issue now is to annotate return type of computed method... We cannot make much progress since it is an upstream issue in TS.
--

--
Please refer to the comment here:
https://github.com/Microsoft/TypeScript/issues/30854#issuecomment-485893681
--
",DaKoala,"
--
I wonder if properties in `data` are supposed to become properties of the instance when using TypeScript? 
--
",mrozekma,"
--
I filed the same bug against Typescript (Microsoft/TypeScript#30854)
--

--
> One workaround is assigning a return type to computed

Good call. Just discovered that workaround is documented [here](https://vuejs.org/v2/guide/typescript.html#Annotating-Return-Types).
--
"
9847,OPEN,[template-renderer] Make it possible to not automatically render used async scripts,feature request,2021-01-26 10:32:30 +0000 UTC,maoberlehner,Opened,,"### What problem does this feature solve?
In oder to make https://github.com/maoberlehner/vue-lazy-hydration more useful it would be great if we could prevent the template renderer from automatically injecting async scripts. The way vue-lazy-hydration works is, that it behaves differently on the server than it does on the client. On the server the script (of an async component) is loaded immediately so the template renderer correctly detects that it is used. But on the client the script might not be needed at all but because the template renderer has already injected it it is immediately loaded on page load.

There is currently kind of a backlash against loading huge amounts of JavaScript. vue-lazy-hydration can help with removing a lot of unnecessary JavaScript on server side rendered, mostly static sites like blogs and documentation. But currently it can't completely prevent loading all of the unnecessary JavaScript because of the way how template renderer works.

Here is the relevant line in the code: https://github.com/vuejs/vue/blob/dev/src/server/template-renderer/index.js#L226

### What does the proposed API look like?
I propose to make this configurable:

```js
const renderer = createBundleRenderer(serverBundle, {
  template,
  renderUsedAsyncScripts: false,
});
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,matthewp,"
--
I'm working on an app where this would be a huge improvement to lighthouse scores. Would a PR be accepted to include this option?
--
",simllll,"
--
this is the related PR https://github.com/vuejs/vue/pull/10794
anything we can do to get this into the core?
--

--
If you use nuxt, you can actually work around either by using modern mode (due to a bug) or by using a regex to remove the async deferred chunks from html ouput (render:route, see https://nuxtjs.org/api/internals-renderer#hooks)

example plugin:
```js
import consola from 'consola';

const logger = consola.withScope('js-optimization:module');

const bodyRegex = /<body[^>]*>(.*)<\/body>/s;
// list of all JS includes
const scriptRegex = /<script[\w""= ]*src=""(.*?)"".*?><\/script>/g;
// essenitials are all with ""pages"" or ending with ""app.js""
const validScriptRegex = /\/(legacy-)?.*?-(pages.*?|.*app).js/;

module.exports = async function JSOptimizer(moduleOptions) {
	if (!moduleOptions.setOutputFilenames) {
		logger.error(
			'JS optimization works only when you explicitly opt in for overwriting output filenames in nuxt!'
		);
		return;
	}

	if (!this.options.build) this.options.build = {};
	this.options.build.filenames = {
		...this.options.build.filenames,
		app: ({ isModern, isDev }) =>
			`${!isModern ? 'legacy-' : ''}${!isDev ? '[contenthash]' : '[name]'}-app.js`,
		chunk: ({ isModern, isDev }) =>
			`${!isModern ? 'legacy-' : ''}${!isDev ? '[contenthash]-' : ''}[name].js`
	};

	this.nuxt.hook('render:route', async (url, page, { req, res }) => {
		if (!page.html || (res.statusCode && res.statusCode !== 200) || page.redirected || page.error) {
			if (moduleOptions.debug) {
				logger.info(
					'skipping optimize JS render:route',
					JSON.stringify({
						url,
						isAmp: req.isAMP,
						matchedRoute: req.matchedRoute,
						page: page.html.length,
						statusCode: res.statusCode,
						error: page.error,
						redirected: page.redirected
					})
				);
			}
			return;
		}

		if (moduleOptions.debug) {
			logger.info(
				'optimize JS render:route',
				JSON.stringify({ url, isAmp: req.isAMP, matchedRoute: req.matchedRoute })
			);
		}

		if (!req.isAMP) {
			// remove all non-essential JS files

			let { html } = page;

			const bodyString = bodyRegex.exec(html);

			if (!bodyString || !bodyString[0]) {
				logger.warn('no body tag found', html);
				return;
			}
			const body = bodyString[0];

			const links = body.matchAll(scriptRegex);

			for (const match of links) {
				if (!validScriptRegex.test(match[1])) {
					// remove non essential JS
					html = html
						.replace(match[0], '') // script tag
						.replace(`<link rel=""modulepreload"" href=""${match[1]}"" as=""script"">`, '') // module preload
						.replace(`<link rel=""preload"" href=""${match[1]}"" as=""script"">`, ''); // preload

					if (moduleOptions.debug) {
						logger.info('removed js tags for', match[1]);
					}
				}
			}

			page.html = html; // set new response
		}
	});

	logger.success('JS optimization module initialised');
};
```

save it in modules/js-optimization.js and add `['modules/js-optimizer.js', { setOutputFilenames: true }]`  to the modules of nuxt.config.js
--

--
> @simllll
> Tried this it works, one thing I had to block loading the preload links. awesome thank you!

You are welcome, I just updated the example plugin to also get rid of preload tags. How did you remove them?
--

--
> @simllll I've got a question here.
> Will this manipulation work with a universal app? i.e remove all the unnecessary JS, but still have the SPA behavior after the SSR rendering?
> Thank you

Yes, that's exactly how we use it. It only makes sense to use with lazy hydration though, otherwise the JS will be needed for the inital page load and removing the preload tags would just slow down the page rendering.
--

--
Your example looks right, you can easily add some output in ""mounted"" hook to see if everything works as expected. Lazy hydration with ssr-only mode, shouldn't call the mounted hook at all. So e.g if you place a console log in there, the browser should not log it. 
For ""simple"" components with basically no logic in it and components that only occur once in your page, the performance benefit is small. But if you apply it to more components, you will see two things:
- initial js loading & parsing is faster (lighthouse ""first cpu idle"")
- page ""reacts"" faster (Estimated Input Latency)

It's very likely that you will only notice this on mobile phones though. Try reducing cpu and network performance in chrom dev tools to debug and analyze this on your desktop pc. Check out the performance tab, and watch the JS profiler.
--
",simplenotezy,"
--
That would be neat, Vue & Nuxt applications would see a huge performance boost, especially on LightHouse scores.
--

--
@simllll Hey Simon, I did exactly what you told, but I am getting:

   │   ✖ Nuxt Fatal Error                                   │
   │                                                        │
   │   Error: Module `modules/js-optimizer.js` not found.   │
   │                                                        │

Update:

Had to call it `['~/modules/js-optimization.js', { setOutputFilenames: true }],`
--

--
@simllll I am getting this error:

```
 FATAL  body.matchAll is not a function                                                    01:59:47

  at JSOptimizer.nuxt.hook (modules/js-optimization.js:68:23)
  at o (node_modules/hable/dist/hable.js:1:1052)
  at o.then.o (node_modules/hable/dist/hable.js:1:270)
  at process._tickCallback (internal/process/next_tick.js:68:7)
```
--

--
@simllll Had to install the matchall polyfill (https://www.npmjs.com/package/string.prototype.matchall) (aparently only es2020). My file ended up looking like so:

	import consola from 'consola';

	import shim from 'string.prototype.matchall/shim'
	shim()

	const logger = consola.withScope('js-optimization:module');

	const bodyRegex = /<body[^>]*>(.*)<\/body>/s;
	// list of all JS includes
	const scriptRegex = /<script[\w""= ]*src=""(.*?)"".*?><\/script>/g;
	// essenitials are all with ""pages"" or ending with ""app.js""
	const validScriptRegex = /\/(legacy-)?.*?-(pages.*?|.*app).js/;

	// eslint-disable-next-line require-await
	module.exports = async function JSOptimizer (moduleOptions) {
		if (!moduleOptions.setOutputFilenames) {
			logger.error(
				'JS optimization works only when you explicitly opt in for overwriting output filenames in nuxt!'
			);
			return;
		}

		if (!this.options.build) { this.options.build = {}; }
		this.options.build.filenames = {
			...this.options.build.filenames,
			app: ({ isModern, isDev }) =>
				`${!isModern ? 'legacy-' : ''}${!isDev ? '[contenthash]' : '[name]'}-app.js`,
			chunk: ({ isModern, isDev }) =>
				`${!isModern ? 'legacy-' : ''}${!isDev ? '[contenthash]-' : ''}[name].js`
		};

		this.nuxt.hook('render:route', async (url, page, { req, res }) => {
			if (!page.html || (res.statusCode && res.statusCode !== 200) || page.redirected || page.error) {
				if (moduleOptions.debug) {
					logger.info(
						'skipping optimize JS render:route',
						JSON.stringify({
							url,
							isAmp: req.isAMP,
							matchedRoute: req.matchedRoute,
							page: page.html.length,
							statusCode: res.statusCode,
							error: page.error,
							redirected: page.redirected
						})
					);
				}
				return;
			}

			if (moduleOptions.debug) {
				logger.info(
					'optimize JS render:route',
					JSON.stringify({ url, isAmp: req.isAMP, matchedRoute: req.matchedRoute })
				);
			}

			if (!req.isAMP) {
				// remove all non-essential JS files

				let { html } = page;

				const bodyString = bodyRegex.exec(html);

				if (!bodyString || !bodyString[0]) {
					logger.warn('no body tag found', html);
					return;
				}
				const body = bodyString[0].toString();

				const links = body.matchAll(scriptRegex);

				for (const match of links) {
					if (!validScriptRegex.test(match[1])) {
						// remove non essential JS
						html = html
							.replace(match[0], '') // script tag
							.replace(`<link rel=""modulepreload"" href=""${match[1]}"" as=""script"">`, '') // module preload
							.replace(`<link rel=""preload"" href=""${match[1]}"" as=""script"">`, ''); // preload

						if (moduleOptions.debug) {
							logger.info('removed js tags for', match[1]);
						}
					}
				}

				page.html = html; // set new response
			}
		});

		logger.success('JS optimization module initialised');
	}

However, it didn't work. No scripts would be loaded to page at all.

When visiting any page, having `yarn dev` running, this is the only log output I get:

```
ℹ optimize JS render:route {""url"":""/product/lace-ring-pave-2""}      js-optimization:module 02:31:51
ℹ removed js tags for /_nuxt/legacy-lang-da-DK.js                   js-optimization:module 02:31:51
```
--

--
@maoberlehner are you aware of a workaround to this solution posted by @simllll which unfortunately doesn't seem to work anymore?
--

--
Actually, I just tried again to use @simllll's solution on latest Nuxt version, and this time I didn't need the polyfill, and it worked out of the box. Will run a pagespeed test soon to see how/if things have changed.
--
",mnooblet,"
--
this would be super awesome to have, I'm currently struggling with lighthouse performance and this would make things a lot easier... ( want that nearly perfect score :) )
--
",Moncef12,"
--
@simllll 
Tried this it works, one thing I had to block loading the preload links. awesome thank you! 
--

--
I used another replace with the matched scripts: 

```head = head.replace(`<link rel=""preload"" href=""${match[1]}"" as=""script"">`, '');```

Will update to use fully your module :+1: 
--
",Sshuichi,"
--
@simllll I've got a question here. 
Will this manipulation work with a universal app? i.e remove all the unnecessary JS, but still have the SPA behavior after the SSR rendering?
Thank you
--

--
Gotcha! It makes perfect sense. 
I'll get back to you with the results tonight. 
--

--
Unfortunately, I couldn't see any change in the scripts loaded nor in the performance. 
So If I understand correctly your design, it's something like this: 
Use Lazy hydration on the page components: 
```
 <LazyHydrate ssr-only>
         <ArticleContent :content=""article.content""/>
    </LazyHydrate>
```
Then 

```
import LazyHydrate from 'vue-lazy-hydration';
 
export default {
  components: {
    LazyHydrate,
    ArticleContent: () => import('./ArticleContent.vue'),
  },
  // ...
};
```
Then build: `nuxt build --universal`
I could see a change in the scripts names (adding legacy-) But not much for the performance. 
Your help is appreciated
--

--
Yes, did that and the JS files for that specific page were indeed deleted. However, the performance didn't improve at all. I guess there is a core issue with vuetify performance. 
I mean, if you start a fresh vue project and add vuetify, and run the Lighthouse score, you will get a pretty high First CPU idle and TTI. 
There is an open issue with vuetify to fix this and honestly if it doesn't get any love soon, we are going to move out of Vuetify: 
https://github.com/vuetifyjs/vuetify/issues/7265
--
"
9842,OPEN,"Memory leak when using ""transition"" and ""keep-alive""",bug; has PR,2020-01-19 21:57:10 +0000 UTC,Aaron-Bird,Opened,,"### Version
2.6.10

### Reproduction link
[https://codepen.io/aaronbird/pen/JVRKwa](https://codepen.io/aaronbird/pen/JVRKwa)







### Steps to reproduce
I wrote a demo:  
```html
<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <meta http-equiv=""X-UA-Compatible"" content=""ie=edge"" />
    <title>demo</title>
    <style>
      .link {
        cursor: pointer;
        user-select: none;
      }
    </style>
  </head>
  <body>
    <script src=""https://unpkg.com/vue/dist/vue.js""></script>

    <div id=""app"">
      <transition>
        <keep-alive include=""foo"">
          <component :is=""target"" @change=""onChange""></component>
        </keep-alive>
      </transition>
    </div>
    <script>
      const Foo = {
        name: ""foo"",
        template: `<div class=""link"" @click=""$emit('change', 'bar')"">Go to Bar</div>`
      };
      const Bar = {
        name: ""bar"",
        template: `<div class=""link"" @click=""$emit('change', 'foo')"">Go to Foo</div>`
      };
      Vue.component(""foo"", Foo);
      Vue.component(""bar"", Bar);
      const app = new Vue({
        data: {
          target: ""foo""
        },
        methods: {
          onChange(target) {
            this.target = target;
          }
        }
      }).$mount(""#app"");
    </script>
  </body>
</html>
```

The debugging process is as follows:  
1 Click ""Collect garbage"" and ""Take heap snapshot""(snapshot 1)  
2 Click the routing button on the left 10 times, then click ""Collect garbage"" and ""Take heap snapshot""(snapshot 2)   
3 Click the routing button on the left 10 times, then click ""Collect garbage"" and ""Take heap snapshot""(snapshot 3)   
![](https://i.imgur.com/FCe40P6.gif)  

The generated ""snapshot"" is as follows:

snapshot 1:
![](https://i.imgur.com/S49oSJo.png)  
snapshot 2:
![](https://i.imgur.com/X1bbOgU.png)  
snapshot 3:
![](https://i.imgur.com/lLD8z7Y.png)
After clicking 100 times:  
![](https://i.imgur.com/E0bjppJ.png)  

VueComponent is not being recycled, is this a bug?  

### What is expected?
Why is this happening, is this a bug?

### What is actually happening?
Component will not be cleared when switching components.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,dejour,"
--
I will take a look this.
--

--
All component is retained by cached vnode’s parent，if we delete parent. then components are recycled.Will dig more
--
",sprocket99,"
--
I also have a memory leak issue, please see : https://github.com/bootstrap-vue/bootstrap-vue/issues/4214

I tried to make a jsfiddle but not sure how to replicate the caching behaviour.
--
",sky8ez,"
--
Hey, is there any news? is this updates already merged to master branch ? I have the same problem.
--
",kadet1090,"
--
I'd really love to see any update on this issue - there is PR but it seems dead?
--
",,,,
9822,OPEN,Transition Functional comp causes error in Jest tests: Cannot read property '_isDestroyed' of undefined,,2020-10-20 19:25:44 +0000 UTC,Akryum,In progress,,"### Version
2.6.10

### Reproduction link
[https://github.com/Akryum/vue-issue-test-transition-functional](https://github.com/Akryum/vue-issue-test-transition-functional)







### Steps to reproduce
Using a `<transition>` on a stubbed functional component is throwing an error during the unit tests with Jest (using `shallowMount`).

Examples: [Component](https://github.com/Akryum/vue-issue-test-transition-functional/blob/master/src/components/Test.vue) | [Test](https://github.com/Akryum/vue-issue-test-transition-functional/blob/master/tests/unit/Test.spec.js)

In the reprod, run:

```
yarn install
yarn run test:unit
```

### What is expected?
No error in the console

### What is actually happening?
The tests pass but an error is displayed in the console:

```
[Vue warn]: Error in nextTick: ""TypeError: Cannot read property '_isDestroyed' of undefined""
```

[Position of the error](https://github.com/vuejs/vue/blob/b9de23b1008b52deca7e7df40843e318a42f3f53/src/core/vdom/create-component.js#L89)

---
Not sure if this should be fixed in Vue core or Vue test utils.

In Vue core, a quick fix would be to check if `componentInstance` is defined on the vnode [here](https://github.com/vuejs/vue/blob/b9de23b1008b52deca7e7df40843e318a42f3f53/src/core/vdom/create-component.js#L89).

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Akryum,"
--
Note: workaround is manually stubbing the functional component in the test. This makes the error disappear.
--
",posva,"
--
@eddyerburgh maybe you know where this comes from 🙂 
--
",ShivamChaurasia,"
--
Getting this error in the production environment
Difficult to debug as in happens only on Static version of the site.

![image](https://user-images.githubusercontent.com/17452741/83901469-1e462f00-a75b-11ea-8303-c2ae7f90bb67.png)

--
",aj,"
--
We see this in static site generated by Nuxt.js. This only happens on page refresh.
--
",mayashavin,"
--
Happening on my side with Jest test when I use provide/inject and render function instead of template :(
--
",,
9788,OPEN,Provide a way to reload a failed async component,,2019-08-12 17:32:28 +0000 UTC,Maorey,In progress,,"### What problem does this feature solve?
Local register a async component by a factory function that return an object to handling loading state. But when the promise is rejected,  there will be always show error component  and no any way to reload it.

### What does the proposed API look like?
1. Recall the factory function on parent's next active/update hook when rejected
2. [Recommend]Accept more options to handle loading state such as provide an 'on' to 
listen replaced component's(loading/error) events and the event context allows to change loading state(rerend, of course)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I personally always felt the factory function was too high level for Vue. When using a user-side solution like vue-promised or a custom implementation, it's so much more flexible and you can deal with everything
--
",bogdanmatra,"
--
This can help to solve the problem, it's hacky but it works.
It wraps the async component in a functional component which recreates the async factory based on `shouldReload`. Calculating `shouldReload` might differ in your case.
```
const loadAsyncComponentWrapper = async () => {
    const createAsyncFactory = () => () => ({
        component: import('/your-component.vue'),
        loading: AppLoader,
        error: AppError,
        timeout: 15000
    });
    let componentHandler = createAsyncFactory();
    return {
        functional: true,
        render(h, { data, children }) {
            const shouldReload = navigator.onLine;  // Some criteria for reloading.
            if (shouldReload) {
                // The Vue component should be recreated completely if the component failed to load.
                // Issue: https://github.com/vuejs/vue/issues/9788
                componentHandler = createAsyncFactory();
            }
            return h(componentHandler, data, children);
        }
    };
};
```
--
",Maorey,"
--
@bogdanmatra I tried your solution, it's useless when async, and dead when sync (same code above). I modified your code to this:

``` JavaScript
// import...

/** get AsyncComponent with loading status
 * @param {Function: () => Promise<Component | { default: Component }>} promiseFactory eg: () => import('Component')
 *
 * @returns {Component} AsyncComponent
 */
function getAsync(promiseFactory, loading = LOADING, error = ERROR) {
  const asyncComponentFactory = () => () => ({
    error,
    loading,
    component: promiseFactory(),

    delay: 1,
    timeout: 15000,
  })

  const observe = Vue.observable({ c: asyncComponentFactory() })

  return {
    functional: true,
    render(createElement, { data, children }) {
      //  emit event $ to reloading
      if (data.on ? !data.on.$ : (data.on = {})) {
        data.on.$ = () => {
          observe.c = asyncComponentFactory()
          // parent.$forceUpdate()
        }
      }

      return createElement(observe.c, data, children)
    },
  }
}
```

And error.vue
``` html
<template>
  <div @click=""$emit('$')"">Loading failed, click me to reloading</div>
</template>
```
--
",,,,,,
9772,OPEN,TypeScript: Vue types $attrs should be type Record<string; any>,typescript,2019-03-26 09:58:17 +0000 UTC,baseprime,Opened,,"### Version
2.6.10

### What is expected?
`Vue.prototype.$attrs` should be type `Record<string, any>` and not `Record<string, string>`.

Since `2.4.0`, `vm.$attrs` has contained extracted bindings not recognized as props. The type of these values is unknown.

### Steps to reproduce
Take the following component:
```javascript
new Vue({
  data: function () {
    return {
      count: 0
    }
  },
  mounted() {
    let someFunc = this.$attrs.someBoundAttr as Function
    // Type 'string' cannot be converted to type 'Function'
  },
  template: `
    <button v-on:click=""count++"" :someBoundAttr=""() => count"">
      You clicked me {{ count }} times.
    </button>`
})
```

Notice the error in TypeScript checking:
```
Type 'string' cannot be converted to type 'Function'
```

### What is actually happening?
...


### Reproduction link
[http://www.typescriptlang.org/play/](http://www.typescriptlang.org/play/)


<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It's true that `$attrs` can be more than strings, but they come from the parent not the component itself
--
",,,,,,,,,,
9757,OPEN,Equivalent for this.$listeners for native events?,feature request,2019-03-22 17:14:08 +0000 UTC,DM2489,In progress,,"### What problem does this feature solve?
Imagine a wrapper component where you need to pass events to a child component. This is possible for non native events using `this.$listeners`, but it strips out native events. It would be good if we had something like `this.$nativeListeners` so that we can pass native events down to child components as well.

 In the meantime, Is there a workaround to pass events to child components?

### What does the proposed API look like?
`this.$nativeListeners` 

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Maybe something like `inheritNativeListeners: true` (that default to false) to go in pair with `inheritAttrs`

Native listeners are available in functional components but are passed to the root of the component in regular components
--

--
not that i'm aware of
--

--
Note they will still be bound to the root element though and that you should avoid reading `$vnode` in general and never modify it
--
",DM2489,"
--
Thanks for the reply! Is there a workaround to get the native events out of the root?
--
",sqal,"
--
@DM2489 
> Is there a workaround to get the native events out of the root

You can access them in `this.$vnode.data.nativeOn`
--
",,,,,,
9756,OPEN,Performance: compile default slots to functions,improvement,2019-05-06 19:16:30 +0000 UTC,KaelWD,In progress,,"### What problem does this feature solve?
The original v-slot implementation was not available in `this.$slots`, but that was added in 2.6.4. Scoped slots reduce unnecessary re-renders with nested slots, so this change would hopefully provide a performance improvement for component libraries. 

### What does the proposed API look like?
`<foo>default slot</foo>`

should output

```js
_c('foo',{scopedSlots:_u([{key:""default"",fn:function(){return [_v(""default slot"")]},proxy:true}])})
```

Equivalent to `<foo v-slot>default slot</foo>`

---

Note #9580 could be a problem if lots of people rely on that behaviour. 

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LukeeeeBennett,"
--
I've got a working version of this locally but I'd like to test it further over the weekend, it's my first look here so have probably naturally oversimplified. I also auto-prettified `codegen/index` which is a bit of a pain.

WIP: https://github.com/LukeeeeBennett/vue/commit/677ac91cbe6f5cb71b01b8336070454f48be0018
--

--
After running the tests and seeing many failures, my suspicions were confirmed 😛 I corrected for a lot of them and I seem to have the general compilation of the function together but am struggling to handle cases like the following...

```
  <foo>
    default-slot-content
    <span slot=""test"">
      test-slot-content
    </span>
  </foo>
```

With my current changes, `foo` is the same as `<foo v-slot>` and this breaks the `test` slot as no default slot placeholder is declared. Without `v-slot`, `default-slot-content` is ignored. I hope to put some more time into this as its beneficial to look around but let me know if you wanted to take it off me for a release.
--

--
> Hmm that could be a problem, maybe why it wasn't done originally. I'm not familiar with the vue compiler but my first thought is to just filter anything without `slotTarget`

@KaelWD I thought the same! It seems this isn't (always?) available but it has to be at some point so I'll keep digging, the behaviour might not even be in the same ground I've already covered 🔍 Maybe its impossible or leads to some tough patterns and we leave it :)

Thought: Anyone know if there is a significantly rewritten compiler for 3.0?

Update: No progress thus far. May end up in the wind.
--
",KaelWD,"
--
Hmm that could be a problem, maybe why it wasn't done originally. I'm not familiar with the vue compiler but my first thought is to just filter anything without `slotTarget`
--
",,,,,,,,
9745,OPEN,Some enter transition hooks doesn't work since 2.6.9 version,,2019-03-21 08:58:51 +0000 UTC,MrSammet,Opened,,"### Version
2.6.9

### Reproduction link
[https://jsfiddle.net/yyx990803/mwLbw11k/?utm_source=website&utm_medium=embed&utm_campaign=mwLbw11k](https://jsfiddle.net/yyx990803/mwLbw11k/?utm_source=website&utm_medium=embed&utm_campaign=mwLbw11k)







### Steps to reproduce
If I set css animation on transition enter, it doesn't work. Leave transitions works well. For example open modal on https://vuejs.org/v2/examples/modal.html ... after click on Show Modal the enter animation doesn't appear. It causes after update from 2.6.8 -> 2.6.9 version.

### What is expected?
CSS Transition on enter hook

### What is actually happening?
Modal appear without enter transition

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Justineo,"
--
Hi, please create a valid reproduction (probably a separate fiddle that shows the bug, without the need for further modification).
--
",shasharoman,"
--
Add the `appear` attribute on the transition tag will be ok, and I think the content of this [link](https://vuejs.org/v2/examples/modal.html) needs to be updated according to [this](https://github.com/vuejs/vue/blob/dev/examples/modal/index.html).
--
",posva,"
--
@yyx990803 could you update the jsfiddle?
--
",,,,,,
9742,OPEN,vue-template-compiler lacks a stringify API,feature request,2020-06-02 19:50:13 +0000 UTC,genffy,Opened,,"### What problem does this feature solve?
when i use vue-template-compiler parseComponent a vue file, and use  @babel/parser @babel/traverse @babel/generator modify some code at vueTemplateComplier AST.script content 
But can not find a api to auto generate file from  vueTemplateComplier AST it to origin file.


### What does the proposed API look like?
const fileContent = compiler.generateComponent(<vueTemplateComplier AST>, {
        pad: 'space'
});
// fileContent is same as *.vue file content

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Justineo,"
--
As I understand it's actually a feature request instead of a question so I modified your title.
--

--
Or we may consider adding it to [`@vue/component-compiler-utils`](https://github.com/vuejs/component-compiler-utils).
--
",getflourish,"
--
Any updates here? I also wonder wether the code for stringification exists somewhere in the Vue Universe already… 
--
",,,,,,,,
9718,OPEN,v-on listeners array,feature request; has workaround,2019-03-16 12:06:50 +0000 UTC,KaelWD,Opened,,"### What problem does this feature solve?
Two components with scoped slots that provide events to a child component. If they are used together some listeners may be overwritten if not normalised first. 

```html
<v-menu>
  <template #activator=""{ on: menu }"">
    <v-tooltip bottom>
      <template #activator=""{ on: tooltip }"">
        <v-btn v-on=""{ ...tooltip, ...menu }""> <!-- If both have a click event, only the menu will work -->
          Dropdown w/ Tooltip
        </v-btn>
      </template>
      <span>Im A ToolTip</span>
    </v-tooltip>
  </template>
  <v-list>[...]</v-list>
</v-menu>
```

### What does the proposed API look like?
```html
<component v-on=""[{ click: foo }, { click: bar }]"">
```
Equivalent to:
```html
<component v-on=""{ click: [foo, bar] }"">
```

In the first example:
```html
<v-menu>
  <template #activator=""{ on: menu }"">
    <v-tooltip bottom>
      <template #activator=""{ on: tooltip }"">
        <v-btn v-on=""[tooltip, menu]"">
          Dropdown w/ Tooltip
        </v-btn>
      </template>
      <span>Im A ToolTip</span>
    </v-tooltip>
  </template>
  <v-list>[...]</v-list>
</v-menu>
```

Currently this throws `[Vue warn]: v-on without argument expects an Object value`

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
at the moment, using a helper to merge looks like the way to go
--
",,,,,,,,,,
9687,OPEN,Performance: Include/Use uid in the name when using performance.measure,improvement,2019-03-13 09:05:18 +0000 UTC,mjntan35,Opened,,"### What problem does this feature solve?
This is in regards when Vue.config.performance is set to true. 
When there is multiple components of the same name, it is difficult to distinguish which component coincide to which performance information.

One simple use case is rendering components inside a v-for.

### What does the proposed API look like?
Instead of just using name (Vue._name), I suggest to include the _uid to better distinguish components with the same name

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
9669,OPEN,Vue should not cause execution of content within <noscript> tags,has workaround,2019-03-12 20:09:16 +0000 UTC,OwenMelbz,In progress,,"### Version
2.6.8

### Reproduction link
[https://jsfiddle.net/ncwuvekm/1/](https://jsfiddle.net/ncwuvekm/1/)

### Steps to reproduce
Check the ""network"" tab.

You can see that Vue causes a request to the content within the `<noscript>`

### What is expected?
Vue should not cause execution of `<noscript>`content

### What is actually happening?
Vue causes requests to elements within `<noscript>`

---
It's typical when websites are using Vue to supplement UI and a common pattern is to wrap the site with an `id=""app""`

However, this introduces a problem when people are using `<noscript>` in various areas of the site that are not within Vue components as Vue will execute it regardless.

A use case example would be using a lazy loading library with a `<noscript>` fallback.

```html
<img src=""thumbnail.jpg"" data-src=""hi-resolution.jpg"" />
<noscript><img src=""hi-resolution.jpg"" /></noscript>
```

Vue will cause the `hi-resolution.jpg` image to download even though it's within the `<noscript>`

<!-- generated by vue-issues. DO NOT REMOVE -->

> For anybody experiencing this issue, a hack is to add `v-if=""false""` to your `<noscript>` to prevent the element from rendering e.g.`<noscript v-if=""false"">`",,,posva,"
--
It's not that Vue processes the content, the browser seems to fire the requests with `noscript` tags added dynamically (which I wonder if should even be allowed)

```js
const noscript = document.createElement('noscript')
const img = document.createElement('img')
img.setAttribute('src', ""https://images.unsplash.com/photo-1552084007-76f5feb8d22a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=800&q=60"")

noscript.appendChild(img)

window.app.appendChild(noscript)
```

I think we could avoid rendering `noscript` elements in general, using a v-if=""false"" is a valid workaround, you can combine it with v-pre too so Vue skips rendering any of their children and probably boosting the performance a bit too
--

--
The code is showing the problem without Vue
--

--
What he's saying is that you are adding it through Vue by feeding it to Vue, which adds dynamically content. I get the usecase though, it's added in case there is no JS (Vue doesn't run) but if Vue runs you want it to be ignored the same way it is ignored upon first rendering
--

--
yeah, i said combine it to v-if to prevent vue from running inside, it's a performance improvement. Rendering wasn't the right word, interpreting maybe? Anyway, you can check it out in vue docs
--
",OwenMelbz,"
--
Sorry processing was probably the wrong word :) I could just see Vue was causing them to run.

I’ll try out the v-pre you’ve mentioned as well to see what that affects, thanks for the tip :)

I’m a little confused with your code snippet, what is that trying to demonstrate? - the noscript itself is just in a PHP template for something else, however because the page wrapper is what the “new Vue ( el = #app )” Vue starts to work it’s magic which causes this side effect 
--

--
Ah okay - do you think this is something Vue could handle? As if it works with v-if and v-pre then would suggest it can handle it without side effects?
--

--
@tony19 - that’s “sort” of my point. The noscript itself isn’t added through JS it just happens to be in the server side page source 
--

--
@Antoine-Demailly We've already established that there's several ""hacks"" to work around this issue, but that's not the point.

The solution should either be

- Vue internally makes sure it doesn't cause any side effects or execution for `noscript` content
- There's sufficient documentation, caveats or compatibility notices within the Vue documentation that highlight this side effect and explain an agreed ""best practice"" to follow to make sure it doesn't happen.

---

@posva - The `v-pre` trick did not work, I was hoping it would as it seems better than `v-if` or `inline-template` as it's more descriptive. You can see the example https://jsfiddle.net/nvfuyj8k/ - it still requests the content within the noscript
--
",tony19,"
--
It seems anti-intuitive (or an invalid use case) for `<noscript>` to be added through scripting -- the very thing that `<noscript>` indicates is disabled. 😜 
--
",Antoine,"
--
Just add the `inline-template` attribute to your `<noscript>` tag

``` html
<noscript inline-template>
 <img src=""//something.jpg"">
</noscript>
```
--
",,,,
9663,OPEN,Pass component instance as second argument in computed setters,feature request; has PR,2020-03-29 18:02:26 +0000 UTC,posva,Opened,,"### What problem does this feature solve?
Allow the usage of arrow functions  in copmuted setters
From #7688 

```js
computed: {
  value: {
    get: vm => vm.someValue,
    set: (val, vm) => vm.someValue = val
  }
}
```

### What does the proposed API look like?
```js
computed: {
  value: {
    get: vm => vm.someValue,
    set (val, vm) {
      this === vm // true
    }
  }
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
9661,OPEN,Option to treat function calls in value bindings as computed properties,,2019-04-12 05:44:39 +0000 UTC,seaskyways,In progress,,"### What problem does this feature solve?
This feature gives a performance boost for applications such as translation bindings as it reduces the number of redundant function calls. 

### What does the proposed API look like?
Adding an option with ""."" (like "".sync"") to property binding called "".computed"" as such.

```html
<template>
  <Modal :title.computed=""$t('MY_TITLE_KEY')""/> 
</template>
```

Which would then be kind of translated to:

```html
<template>
  <Modal :title=""randomComputed1""/> 
</template>

<script>
export default {
  computed: {
    randomComputed1() { return this.$t('MY_TITLE_KEY') }
  }
}
<script>
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I don't think this is possible in current version of Vue as it would require to add something to the component options. However, I wonder if it could be made possible with hooks in Vue 3
--
",DaKoala,"
--
Agree with @posva. I think in this case the Vue instance is modified by the template.
--
",seaskyways,"
--
The Vue instance is already being modified by the template. The template is being compiled to a render function which is being added to the Vue component object.
--
",,,,,,
9637,OPEN,Missing information regarding v1.x EOL/LTS plans,1.x; improvement; intend to implement,2019-03-06 12:48:17 +0000 UTC,vmlaguna,Opened,,"### Version
1.0.28

### Reproduction link
[https://jsfiddle.net/3ay9r8hz/](https://jsfiddle.net/3ay9r8hz/)







### Steps to reproduce
Open README.md and search for End Of Life / LTS support

### What is expected?
Find information about expected response from VueJs regarding 1.x EOL/LTS

### What is actually happening?
Nothing is mentioned regarding the stance from VueJs on supporting 1.x branches

---
Opening after discussion with @LinusBorg on the forum: https://forum.vuejs.org/t/vue-1-x-end-of-life-support/58143

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
We communicated EOL in a blogpost that announced v2, but never actually documented this propertly I think, so it's fair to add this to the README in the `v1` branch and maybe the docs as well (in the docs repo)
--
",,,,,,,,,,
9573,OPEN,transition before-leave js-hook does not manipulate the DOM which will be transitioned,has workaround,2019-04-21 18:21:41 +0000 UTC,plehnen,Opened,,"### Version
2.6.7

### Reproduction link
[https://jsfiddle.net/8zcdpkv0/](https://jsfiddle.net/8zcdpkv0/)







### Steps to reproduce
Please see jsfiddle.

Any changes in the `before-leave` hook won't affect the DOM which is transitioned.

My actual problem is that I try to transition an element which has `aria-live=""polite""` or `rule=""alert""`, which will be read out by a screenreader.
Apparently the change of classes from the transition are noticed by the screenreader and the message will be read out again.
I tried to fix this for accessibility purposes with the `before-leave` hook, but that doesn't seem to work correctly.



### What is expected?
It would either be great if the transitioned DOM will remove all attributes which will cause the screenreader to read it out again, or to allow the javascript hook `""before-leave""` to actually change the DOM **before** the transition happens.

### What is actually happening?
The old DOM will be transitioned (and the screenreader will read the content again).

<!-- generated by vue-issues. DO NOT REMOVE -->",,,DaKoala,"
--
I modified your code a little and the HTML now is:
```html
<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <title>Vue Dev</title>
  <link href=""style.css"" rel=""stylesheet"">
  <script src=""vue.js""></script>
  <script src=""script.js"" defer></script>
</head>
<body>
<div id=""app"">
  <button @click=""handleClick"">
    toggle
  </button>

  <transition mode=""out-in"" name=""fade"" appear @before-leave=""onBeforeLeave"" @after-enter=""role = 'alert'"">
    <p v-if=""isActive"" :role=""role"" id=""test"">{{ message }}</p>
  </transition>
</div>
</body>
</html>
```
The JS is:
```js
new Vue({
  el: '#app',
  data(){
    return {
      message: 'Hello Vue.js!',
      role: null,
      isActive: true,
    }
  },
  methods: {
    handleClick() {
      document.getElementById('test').textContent = 'new message';
      this.isActive = !this.isActive;
    },
    onBeforeLeave() {
      this.message = 'new message'; // this does not affect the DOM which will fade out
      this.role = 'document'; // this does not affect the DOM which will fade out ---> screenreaders will detect the class-changes and read out the content again :\
    }
  }
})
```
I added an `id` to the element to be modifed and in the click listener I used native JavaScript to change the `textContent` of the element. The code above works as you expect.

Actually I am not giving a solution to this situation but trying to figure out what is missed here. I also checked the devtool. I found that `message` property was changed immediately when I clicked the button, however it was not rerendered before the beginning of the animation.

I will continue paying attention to this problem. I am not sure if I can work it out later, but I will try.
--

--
**UPDATE:** If I use `vm.$nextTick` to set the `isActive` attribute it also works.
```js
new Vue({
  el: '#app',
  data(){
    return {
      message: 'Hello Vue.js!',
      role: null,
      isActive: true,
    }
  },
  methods: {
    handleClick() {
      this.message = 'new message';
      this.$nextTick(() => {
        this.isActive = !this.isActive;
      });
    },
    onBeforeLeave() {
      this.message = 'new message'; // this does not affect the DOM which will fade out
      this.role = 'document'; // this does not affect the DOM which will fade out ---> screenreaders will detect the class-changes and read out the content again :\
    }
  }
})
```
--
",posva,"
--
This is indeed one of the limitations of current transition, I'm not sure if it's something that can be changed.
The current way to deal with this is changing the data used in the template in one function and then, after one tick, change the variable that triggers the animation like @DaKoala showed with nextTick
--
",,,,,,,,
9539,OPEN,make serverPrefetch() rejection trappable,improvement,2019-03-06 12:51:13 +0000 UTC,FranckFreiburger,In progress,,"### What problem does this feature solve?
Currently, rejections in `serverPrefetch` cannot be handled
eg.
```
serverPrefetch() {

   return Promise.reject('myError')
}
```


### What does the proposed API look like?
Maybe send `serverPrefetch` rejections as `renderStream` error event ?

eg.

```
const renderStream = renderer.renderToStream(context)
renderStream.on('error', err => { ... })
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,skyline0705,"
--
Is there necessary to stop the renderer and throw an error for renderStream?
In Vue 2.6.x, I thinks this means ""only this component has error, not the hold app"",so it choose to stop render this component only, and the warning will be report when hydrating in browser.
--
",FranckFreiburger,"
--
I agree that stopping the rendering is too severe for a rejection, but we need at least a mean to accurately detect that something is going wrong during a `serverPrefetch`.

AFAIU, serverPrefetch rejection arrives here (`arguments[0]` of `end()`):
https://github.com/vuejs/vue/blob/6fe07ebf5ab3fea1860c59fe7cdd2ec1b760f9b0/src/server/render-stream.js#L44-L49
and could be simply pass as argument of `this.emit('beforeEnd')`
--
",,,,,,,,
9515,OPEN,Chrome overrides value if superior to max value of input[type=range] because Vue sets attributes in the same order as they are provided,browser quirks; has workaround,2019-02-24 11:03:51 +0000 UTC,stevelacey,In progress,,"### Version
2.6.6

### Reproduction link
https://codepen.io/posva/pen/LqMMNV







### Steps to reproduce

- set value attribute before max with a value > 100 on Chrome

### What is expected?
Vue should respect the value attr regardless of whether it is outside of the bounds of the default min/max threshold

### What is actually happening?
Vue sets the value to 100 if it is >100

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
There are many things going on here, first it seems to be browser related, as it doesn't happen on Safari. On chrome it seems the value is coerced to 100 by the browser. When providing the min/max attributes, the order matters because if the value is set before max, it will have a default max of 100 on Chrome (apparently), so doing

```html
<input type=""range"" min=""0"" max=""1000""  value=""200"">
```

will fix the problem

I'm not sure we should workaround this. It's already very weird for Chrome to setup a default of 100 but I haven't checked the spec on this
--
",stevelacey,"
--
Wow, can confirm that  reordering the attributes does workaround the problem, and you're right, it doesn't happen in Safari.
--
",marcus,"
--
yep, reordering works for me. Thanks @posva
--
",,,,,,
9488,OPEN,[vue ssr]normalizeFile get undefined file,,2020-07-01 08:28:26 +0000 UTC,leekafai,In progress,,"### Version
2.6.6

### Reproduction link
[https://codepen.io/lkafai/pen/Erpgze](https://codepen.io/lkafai/pen/Erpgze)







### Steps to reproduce
package.json:
    
""vue"": ""^2.5.22"",
 ""vue-server-renderer"": ""^2.6.6""

run command
`vue-cli-service build`


### What is expected?
success render 

### What is actually happening?
TypeError: Cannot read property 'replace' of undefined
 at normalizeFile (/node_modules/_vue-server-renderer@2.6.6@vue-server-renderer/build.dev.js:8998:27)


---
i open the file vue-ssr-client-manifest.json , and found that some id in modules got -1 index
```
  ""modules"": {
    ""13323344"": [
      13,
      14
    ],
    ""0b0ba5ab"": [
      3,
      15,
      -1,
      16
    ],
```
and the -1 index not found any file.
so in vue-server-renderer/build.dev.js file,the normalizeFile get undefined , and throw out ""Cannot read property 'replace' of undefined""
i have no idea why there is -1 in modules , and file mapping fail, is this a configure problem?
my vue.config.js is writed in codepen , sorry for my poor english

<!-- generated by vue-issues. DO NOT REMOVE -->",,,leekafai,"
--
```
  css: {
    extract: true,
    sourceMap: false
  }
```
when i set sourceMap to true ,render success
```
  css: {
    extract: true,
    sourceMap: true
  }
```
looks like that no matter where you set in sourceMap,when you create manifest.json, it alway mapping xxx.css.map
--
",ediaos,"
--
i got same error when enable sourceMap .
in vue-server-render/build.prod.js , `getUsedAsyncFiles` will throw undefind error. 

## enable js sourceMap , disable css sourceMap
server render error

## enable js and css sourceMap 
server render success

## disable js and css sourceMap
server render success
--

--
@sneko 
if target is `ssr node`, you can try delete extract 
code :
```
if (TARGET_NODE) {
      const isExtracting = config.plugins.has(""extract-css"");
      if (isExtracting) {
        // Remove extract
        const langs = [""css"", ""postcss"", ""scss"", ""sass"", ""less"", ""stylus""];
        const types = [""vue-modules"", ""vue"", ""normal-modules"", ""normal""];
        for (const lang of langs) {
          for (const type of types) {
            const rule = config.module.rule(lang).oneOf(type);
            rule.uses.delete(""extract-css-loader"");
            // Critical CSS
            rule
              .use(""vue-style"")
              .loader(""vue-style-loader"")
              .before(""css-loader"");
          }
        }
        config.plugins.delete(""extract-css"");
      }
```

AND I WRIETE A PROJECT FOR SSR TEMPLATE [vue-cli3-ssr-project](https://github.com/ediaos/vue-cli3-ssr-project)

--
",sneko,"
--
Hi @ediaos,

I tried in my `vue.config.js` : 
```
  productionSourceMap: true,
  css: {
    extract: true,
    sourceMap: true,
  },
```

and 

```
  productionSourceMap: false,
  css: {
    extract: true,
    sourceMap: false,
  },
```

but none of them works 😢 do am I doing something wrong?

Thank you,

EDIT: Oups! Sorry! I was just retrying the `ssr:start` without `ssr:build` before. My bad! Great news!
--

--
Hi,

No longer sure but I just saw my source code generated by the SSR is always containing all the style into a `<style> ... </style>` instead of having a separate CSS style file that can be cached.

Any idea if it comes from the workarounds mentioned before?

Thanks,
--

--
@lovetingyuan I upgraded to `v0.6.0` and thanks to that I was able to remove a lot of workarounds including the one in this thread.

But I still have all CSS in the source code, do you know why this plugin does not embed it by default? Even with `css.extract = true` it does not work.

Do you have an example of your `vue.config.js` integrating `mini-css-extract-plugin` please? Otherwise will give a try in the week, but dealing with webpack chaining has always been a pain for me haha 🤣 

Thank you,

EDIT: @GreenMashimaro I have no `eval` in my code

EDIT2: @lovetingyuan it seems related to some new activity on https://github.com/Akryum/vue-cli-plugin-ssr/issues/186 and https://github.com/Akryum/vue-cli-plugin-ssr/pull/191
--
",Zousdie,"
--
> @sneko
> if target is `ssr node`, you can try delete extract
> code :
> 
> ```
> if (TARGET_NODE) {
>       const isExtracting = config.plugins.has(""extract-css"");
>       if (isExtracting) {
>         // Remove extract
>         const langs = [""css"", ""postcss"", ""scss"", ""sass"", ""less"", ""stylus""];
>         const types = [""vue-modules"", ""vue"", ""normal-modules"", ""normal""];
>         for (const lang of langs) {
>           for (const type of types) {
>             const rule = config.module.rule(lang).oneOf(type);
>             rule.uses.delete(""extract-css-loader"");
>             // Critical CSS
>             rule
>               .use(""vue-style"")
>               .loader(""vue-style-loader"")
>               .before(""css-loader"");
>           }
>         }
>         config.plugins.delete(""extract-css"");
>       }
> ```
> 
> AND I WRIETE A PROJECT FOR SSR TEMPLATE [vue-cli3-ssr-project](https://github.com/ediaos/vue-cli3-ssr-project)

I found that the inline style of the SSR injection is duplicated with the extracted css style. So use css-loader/locals instead of css-loader, css-loader/locals will not inject the css file at server.
```
const langs = ['css', 'postcss', 'scss', 'sass', 'less', 'stylus'];
      const types = ['vue-modules', 'vue', 'normal-modules', 'normal'];

      // disable inline style
      langs.forEach((lang) => {
        types.forEach((type) => {
          const rule = config.module.rule(lang).oneOf(type);
          rule
            .use('vue-style')
            .loader('css-loader/locals')
            .before('css-loader');
          rule.uses.delete('css-loader');
          rule.uses.delete('extract-css-loader');
        });
      });

      // delete MiniCssExtractPlugin
      config.plugins.delete('extract-css');
```
--
",GreenMashimaro,"
--
Check if *.vue file is use `eval` keyword
--
",lovetingyuan,"
--
@sneko I create a complete example for vue ssr at https://github.com/lovetingyuan/vue-ssr-example. You could check it out.
--
"
9485,OPEN,升级2.6以上版本后在部分安卓机上input使用v-model的同时有对数据格式化时光标异常,browser quirks; need repro,2019-03-15 16:56:17 +0000 UTC,matf5,In progress,,"### Version
2.6.6

### Reproduction link
https://codepen.io/matf5/project/editor/ARGnKV


```
computed: {
    cardNoFormat: {
      get() {
        return this.cardNo.replace(/(\d{4})(?=\d)/g, '$1 ');
      },
      set(value) {
        this.cardNo = value;
      }
    }
}
```




### Steps to reproduce
例如输入输入62148时，数据会变为6214 8

### What is expected?
光标位于8后面

### What is actually happening?
有问题的安卓机如vivo，华为荣耀在部分浏览器内核下（如uc）光标会卡在8前面

<!-- generated by vue-issues. DO NOT REMOVE -->",,,daanhaitsma,"
--
> # After upgrading to 2.6 or higher, the input v-model behaves differently than expected on some Android devices.
> 
> ### Version
> 2.6.6
> 
> ### Reproduction link
> [https://codepen.io/matf5/project/editor/ARGnKV](https://codepen.io/matf5/project/editor/ARGnKV)
> 
> ```
> computed: { cardNoFormat: { get() { return this.cardNo.replace(/(\d{4})(?=\d)/g, '$1 '); }, set(value) { this.cardNo = value; } } }
> ``` 
> ### Steps to reproduce
> For example, when you enter 62148, the data will change to 6214 8.
> 
> ### What is expected?
> The cursor is after the 8.
> 
> ### What is actually happening?
> On some Android devices (such as Vivo and Huawei Glory) in some browser kernels (such as uc) the cursor will be stuck before of 8.


As a sidenote: I cannot reproduce on my OnePlus 6(t) using Chrome or Firefox, but can using the mentioned UC Browser. Pretty sure it's not an issue with Vue.
--
",matf5,"
--
> > # After upgrading to 2.6 or higher, the input v-model behaves differently than expected on some Android devices.
> > ### Version
> > 2.6.6
> > ### Reproduction link
> > https://codepen.io/matf5/project/editor/ARGnKV
> > ```
> > computed: { cardNoFormat: { get() { return this.cardNo.replace(/(\d{4})(?=\d)/g, '$1 '); }, set(value) { this.cardNo = value; } } }
> > ```
> > ### Steps to reproduce
> > For example, when you enter 62148, the data will change to 6214 8.
> > ### What is expected?
> > The cursor is after the 8.
> > ### What is actually happening?
> > On some Android devices (such as Vivo and Huawei Glory) in some browser kernels (such as uc) the cursor will be stuck before of 8.
> 
> As a sidenote: I cannot reproduce on my OnePlus 6(t) using Chrome or Firefox, but can using the mentioned UC Browser. Pretty sure it's not an issue with Vue.

Thanks for helping reproduce. I think it is a browser quirks too. However, I do not know why the version '2.5.22' has not this problem but the version above '2.6.0-beta.1' can reproduce. Maybe due to the dependencies updating?
--
",TonyPythoneer,"
--
https://imgur.com/a/vi2EaVk
ipad air2
5.0 (iPad; CPU OS 12_1_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1

I can reproduce.


I think it’s implement issue. You should modify your implement method to avoid display result to affect input.
After It sets from computed is 12345, it will dispaly 1234 5. It’s right.
But it re-uses the display value 1234 5 and append 6, it will set 1234 56 in vue instance.

--
",,,,,,
9467,OPEN,Custom error message from prop validator,feature request,2021-03-28 17:00:52 +0000 UTC,znck,In progress,,"### What problem does this feature solve?
Currently, if a custom validator fails, we get a console error log saying `Invalid prop: custom validator check failed for prop 'email'` which is not helpful if you're using a third-party component. The only way to find out what failed is to jump into the source code of the component and try to understand what does this custom validator do. If the custom validator can provide a custom message that immensely changes developer experience e.g. Instead of `Invalid prop: custom validator check failed for prop 'email'`, it can say, `Invalid prop: the prop 'email' should be a valid GMail address.`

### What does the proposed API look like?
No change in API signature only behavior of `validator` function. If a validator function throws an error, use it as a custom message for prop validation. Also, allow `{{name}}` interpolation in error message. So the `email` can be defined as:

``` js
...
  props: {
    email: {
      validator(value) {
        if (!value.endsWith('@gmail.com')) throw new Error('the prop '{{name}}' should be a valid GMail address.')
        return true
     }
   }
...
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Duplicate of #8726 tho 😆
I think we should talk about the api a bit first
--

--
But right now validation takes place in order so not all props are available to validate. I don't think validators should have access to `this` though
--

--
It would allow people to test against anything related to the component and I don't think we should allow that because a validator should be a pure function. Apart from props and maybe slots presence, what would you use from `this` 
--

--
I want to avoid access to other properties, for example the `$router`, `$store` or other things.
--
",znck,"
--
It was one-liner but I agree on finalizing the API first. With custom validation messages, we can have user-land packages shipping complex validation helpers. I, myself, can use it in [znck/prop-types](https://github.com/znck/prop-types).
--
",dietergeerts,"
--
FYI: At the moment, there is a way to have a better warning though, one where you can add the value passed to the prop in the warning message:
```javascript
/**
 * @type {RegExp}
 */
const validatorWarningRegExp = /Invalid prop: custom validator check failed for prop ""(.*?)""\./;

/**
 * Better warn messages than the built-ins (adds value for invalid prop, ...).
 *
 * @see {@link https://vuejs.org/v2/api/#warnHandler}
 *
 * @function
 * @param {VueConstructor} vue
 * @param {function(...*)} handler
 */
export const initGlobalWarnHandlerForVue = (vue, handler) => {
  vue.config.warnHandler = (message, vm, trace) => {
    const validatorWarning = validatorWarningRegExp.exec(message);
    if (validatorWarning) {
      handler('[APP] Vue:', message, '\nValue:', vm[validatorWarning[1]], trace);
    } else {
      handler('[APP] Vue:', message, trace);
    }
  };
};
```
--
",chrisvfritz,"
--
When the returned value from a validator is truthy, I wonder if it would be simpler to check if what's returned is a string, then if it is, make that the warning message. Thoughts?
--

--
@diachedelic That's true. I like the thrown error better then. 🙂 

@posva As for the API, I think it can be discussed separately if throwing an error could be an acceptable solution. Though my personal thought is that unless we're using `this` for something else in validators, I think it might be most intuitive to just bind props (and `$props`) directly to the function, so they can be accessed the same way as anywhere else in the component.
--

--
@posva Yes, the change would require postponing prop validation until after the first pass of processing props. Regarding validators having access to `this`, what are your concerns?
--

--
@posva That's it - probably just props and maybe slots. I wouldn't expect the entire instance to be initialized at that point, similar to how not everything is available on `this` in `beforeCreate`. When you say ""a validator should be a pure function"", what are the disadvantages or edge cases you're trying to avoid?
--
",diachedelic,"
--
@chrisvfritz that would break validators that look like `val => val.name`, i personally expect only the truthiness of a validation result to be checked.
--
",Itee,"
--
This is exactly what is asked on the forum: [Props validation error message override](https://forum.vuejs.org/t/props-validation-error-message-override/46765)

So to resume my point of view:

We could/should be able to do things like this:

```javascript
props: {
    foobar: {
        type: String,
        validator: ( value ) => { return [ 'foo', 'bar' ].includes( value ) },
        errorMessage: 'Invalid prop ""foobar"", available values are ""foo"", ""bar"".'
    }
}
```

and the incriminated code with one implementation to that purpose could be:

```javascript
/**
 * Assert whether a prop is valid.
 */
function assertProp (
    prop,
    name,
    value,
    vm,
    absent
) {
    if (prop.required && absent) {
        if (prop.errorMessage) {
            warn(
                prop.errorMessage,
                vm
            );
        } else {
            warn(
                'Missing required prop: ""' + name + '""',
                vm
            );
        }
        return
    }
    if (value == null && !prop.required) {
        return
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
        if (!Array.isArray(type)) {
            type = [type];
        }
        for (var i = 0; i < type.length && !valid; i++) {
            var assertedType = assertType(value, type[i]);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
        }
    }
    if (!valid) {
        if (prop.errorMessage) {
            warn(
                prop.errorMessage,
                vm
            );
        } else {
            warn(
                ""Invalid prop: type check failed for prop \"""" + name + ""\""."" +
                "" Expected "" + (expectedTypes.map(capitalize).join(', ')) +
                "", got "" + (toRawType(value)) + ""."",
                vm
            );
        }
        return
    }
    var validator = prop.validator;
    if (validator) {
        if (!validator(value)) {
            if (prop.errorMessage) {
                warn(
                    prop.errorMessage,
                    vm
                );
            } else {
                warn(
                    'Invalid prop: custom validator check failed for prop ""' + name + '"".',
                    vm
                );
            }
        }
    }
}
```

So what about a such implementation ?

--
"
9463,OPEN,Provide way to destroy app in SSR,feature request,2019-03-26 17:37:45 +0000 UTC,ronald-d-rogers,Opened,,"### What problem does this feature solve?

This issue is related to: https://github.com/vuejs/vue-router/issues/2606
Providing a way to destroy the app or mark the SSR request as complete (maybe on `$ssrContext`) is a potential fix to this problem, though maybe not the best one.

To recap:
A memory leak happens when the `router-view` is programmed to appear conditionally, and the component matching the view has a `beforeRouteEnter` guard and a callback is passed to it's `next(...)` method (e.g. `next(vm => {})`).

This will cause `vue-router` to poll every 16ms until the `router-view` materializes.

In a typical SSR application an instance of the app is created per request, which means the `router-view` will never appear, causing infinitely recursing poll methods.

### What does the proposed API look like?
A potential fix to this would be to detect when the app is destroyed in `vue-router`'s `poll` method, and allow the user to destroy the app that they created in `entry-server.js`.

A simplified example:
```javascript
export default context => {
  return new Promise((resolve, reject) => {
    const { app, router } = createApp(context)

    const { url } = context

    router.push(url)

    router.onReady(() => {
      resolve(app)
    }, reject)
  }).then(destroyApp)
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
9454,OPEN,Add beforeDeactivated hook,feature request,2019-04-05 11:31:43 +0000 UTC,danyadev,In progress,,"### What problem does this feature solve?
I use :key and keep-alive tag to display chats. And in order to maintain the position of the scroll when switching between chat rooms, I need to save the scrollTop when the hook is deactivated and put it on the element when the hook is activated. But the deactivated hook is already called when the element has been removed from the DOM, so I needed a new hook - beforeDeactivated.

Seriously, this hook is needed just like the others before* hooks.

### What does the proposed API look like?
Here, I think, everything is clear. Simple hook.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sh7dm,"
--
I want to do this
--
",danyadev,"
--
oops
--
",,,,,,,,
9447,OPEN,Ability to access context from serverPrefetch,feat:ssr; feature request; intend to implement,2019-02-06 19:27:53 +0000 UTC,yekver,Opened,,"### What problem does this feature solve?
After vue 2.6 was released and serverPrefetch hook was introduces I lost a possibility to update `httpCode` during SSR if there was a data fetching failure.

### What does the proposed API look like?
Provide access to `context` from the `serverPrefetch` hook.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yyx990803,"
--
We should probably provide `context` as the first argument. In the meanwhile you can use `this.$ssrContext`.
--
",,,,,,,,,,
9440,OPEN,Ability to cancel rendering,feat:ssr; feature request,2019-02-11 21:28:54 +0000 UTC,KindWizzard,Opened,,"### What problem does this feature solve?
Under high-load, some pages are rendered to slow. The connection is aborted by the remote side. It would be nice to be able to cancel pages rendering in this case.

### What does the proposed API look like?
const rendererId = renderer.renderToString(...);

rendererId.cancel();

<!-- generated by vue-issues. DO NOT REMOVE -->",,,vankop,"
--
@yyx990803 Do you have any suggestion how to solve this problem in current SSR implementation?
--
",,,,,,,,,,
9427,OPEN,Integration: using HTMLTemplateElement inside CustomElements,,2019-02-05 12:43:57 +0000 UTC,riovir,Opened,,"### What problem does this feature solve?
Conveniently using `Custom Elements` that require both prop bindings and `HTMLTemplateElement`s together with Vue templates.

Related fixed bug: https://github.com/vuejs/vue/issues/8041

The fix unfortunately doesn't allow the parent of the `HTMLTemplateElement` to retain its prop bindings with Vue.

The use case is similar to the `scoped slot` feature of Vue, but with `Custom Element`s. It's clear that without a special directive Vue will not assume the `<template>` is expected to be a `HTMLTemplateElement`.

# Assumptions:
* Using `v-pre` on the parent breaks prop bindings
* Using `v-pre` on the child template still makes Vue skip rendering the `<template>` element
* This behavior of `v-pre` is intended

# JsFiddle:
Attempts at the problem and desired solution. https://jsfiddle.net/qhkb6sof/2/

### What does the proposed API look like?
The `v-native` directive, marking a tag to be rendered as the native DOM element of the same name.

Since there is a [proposal](https://scotch.io/bar-talk/an-overview-of-the-most-exciting-proposals-for-the-web-platform-related-to-web-components#toc-template-instantiation-with-substituted-values) on the way to allow mustache-style expressions inside `HTMLTemplateElement`s `v-pre` might still be needed to avoid Vue interpreting the internals.

Only using the already present `v-pre` would be nice, but I'm unsure how much of the already established behavior it would break.

```html
<x-filtered-list :items.prop=""['one', 'two', 'three']"" search=""t"">
  <!-- The template is intended to represent the ""native"" HTMLTemplateElement, which needs to be rendered -->
  <template v-native v-pre>
    <!-- The expression below expected to be ignored by Vue and rendered as is  -->
    <li>{{text}}</li>
  </template>
</x-filtered-list>
```

The resulting DOM should look like this in inspection:
```HTML
<x-filtered-list search=""t"">
  <template>
    #document-fragment
      <li>{{text}}</li>
  </template>
</x-filtered-list>
```

Ideally `<li>{{text}}</li>` ends up in the `#document-fragment`.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
9406,OPEN,On SSR; script tag escaped,,2019-02-04 08:38:02 +0000 UTC,,Opened,,"### Version
2.5.22

### Reproduction link
[https://codesandbox.io/s/kx35l39lkv](https://codesandbox.io/s/kx35l39lkv)







### Steps to reproduce
Open tab Console

### What is expected?
```html
<script data-server-rendered=""true"">
            var a = 'a';
            var x = ""x"";
            if (a && x) {}
            if (a > x) {}
            if (a < x) {}
          </script> 
```

### What is actually happening?
```html
<script data-server-rendered=""true"">
            var a = 'a';
            var x = &quot;x&quot;;
            if (a &amp;&amp; x) {}
            if (a &gt; x) {}
            if (a &lt; x) {}
          </script> 
```

---
There are no restrictions on rendering `script` tags on the server

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
9372,OPEN,Types of FunctionalComponentOptions breaks,has workaround; typescript,2019-01-29 14:31:27 +0000 UTC,meteorlxy,In progress,,"### Version

vue: 2.5.22

typescript: 3.2.4

### Reproduction link
[https://jsfiddle.net/meteorlxy/9x2ts16a/1/](https://jsfiddle.net/meteorlxy/9x2ts16a/1/)


### Steps to reproduce

```ts
// works with vue 2.5.17
// fails with vue 2.5.18+
import Vue, { FunctionalComponentOptions } from 'vue'

const testFunctionalOptions: FunctionalComponentOptions = {
  functional: true,
}

Vue.component('Test', testFunctionalOptions)
```

### What is expected?
No types error as in v2.5.17

### What is actually happening?
```sh
error TS2345: Argument of type 'FunctionalComponentOptions<Record<string, any>, PropsDefinition<Record<string, any>>>' is not assignable to parameter of type 'ComponentOptions<Vue, DefaultData<Vue>, DefaultMethods<Vue>, DefaultComputed, PropsDefinition<Record<string, any>>, Record<string, any>>'.
  Types of property 'render' are incompatible.
    Type '(this: undefined, createElement: CreateElement, context: RenderContext<Record<string, any>>) => VNode | VNode[]' is not assignable to type '(createElement: CreateElement, hack: RenderContext<Record<string,
any>>) => VNode'.
      Type 'VNode | VNode[]' is not assignable to type 'VNode'.
        Type 'VNode[]' is missing the following properties from type 'VNode': isRootInsert, isComment
```

### PS

It seems to be introduced here:

https://github.com/vuejs/vue/commit/bf2e2ed159f680cd4e230427ce94739c657c1b61#diff-23d7799dcc9e9be419d28a15348b0d99R116

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
As a workaround, you can give the props an explicit type:

```ts
const testFunctionalOptions: FunctionalComponentOptions<{}> = {
  functional: true,
}
```
--
",meteorlxy,"
--
@posva Yeah thanks
--
",kjleitz,"
--
Related to https://github.com/vuejs/vue/issues/9357
--
",,,,,,
9363,OPEN,transition-group replacing group flicker,has workaround,2019-10-31 14:19:21 +0000 UTC,phouri,In progress,,"### Version
2.5.22

### Reproduction link
[https://codesandbox.io/s/y3910wr9j9](https://codesandbox.io/s/y3910wr9j9)







### Steps to reproduce
Click the change button in the link, no matter if animation is on or off (changing the animation name) - there is a brief flicker where both groups are present. 

This is barely visible in this scenario, but on a full page and more rows it's a lot more visible.
(Might need to click multiple times to notice) 

### What is expected?
Groups would transition ""atomically"" without having a moment where both groups are present

### What is actually happening?
Both groups are present for a moment 

---
The only way to solve this is to remove the the transition-group component completely, not even changing the name of the transition to null or something that doesn't match works.

Happened when I was working on a data table and was using the move transition for sorting, and then when replacing rows completely I saw this flicker and couldn't get around it easily.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
You have two workarounds, either use a `key` on transition-group to change it while changing lists which would make the most sense since you are replacing the whole list anyway. Or add some CSS to make the animation immediate and hide the elements while leaving

```css
.test-enter, .test-leave-to {
  display: none;
}
```

I think this is expected because you are using a transition but you don't want one. As described in the docs, transitions add `leave` + `leave-active`, then removes `leave` and adds `leave-to` (after a tick) when removing elements, then removes `leave-active` and `leave-to`.
To make transitions work when we don't want one, we would need to check for a transition-duration of 0. But it's making the transition work in a scenario it is not needed.
--
",phouri,"
--
Perhaps the best solution to this would be to explicitly say what transitions I am interested in for a transition-group with a default for all - (also maybe for normal transition? not sure if that's already implemented).
--

--
https://codesandbox.io/s/y3910wr9j9 nope - unless I did something wrong here - I can still see both groups at the same time.
--

--
@posva it seems the display: none does indeed works around the issue - it seems I needed to refresh after saving the code sandbox, sorry about that! 

@LinusBorg I was using Date + index just to mimic a random id, it works now because of the display: none I added, I will remove it from the example though as to not confuse.
--

--
To summarise: Workaround is working - I added to the example with and without workaround, wether to close this or leave open - up to you guys, thanks! :)
--

--
https://codesandbox.io/s/y3910wr9j9 the example before has the workaround (click on the right button). I must say I think that it worked ok in this example but when I tried in a heavy application scenario it wasn't perfect.
--
",shadow7412,"
--
@phouri can you please provide a codesandbox.io link with the working example?
--
",grumpygary,"
--
I have a related question, about transition keys.

I checked the Vue source code (2.6.10).  It appears that it does not respect key names for transitions -- it mangles it to includes its own prefix (`__transition-${this._uid}-` + myKey) , which is subject to change if a prop changes.  This appears to have been on-purpose (it literally checks to make sure it's using the internal prefix).  I consider this a bug, as it causes a full re-render of the transitioned vnode if all I want to do is change the exit transition class.  

For example, I might have a ""stack"" of pages that slide to the left to exit when going forward, or to the right to enter if going backwards; otherwise no animation.  So the transition depends on what the user is doing.  The enter transition is not the issue, but if I change the leave active class, Vue will change the transition key, which will re-render the page (though nothing has changed), causing a brief flicker.

And I can't find a work around...

My question(s): what is the rationale for not respecting a supplied transition key?  And is there a work-around?
--
",,,,
9357,OPEN,Function-type props broken in TypeScript,typescript,2020-11-02 08:22:40 +0000 UTC,kjleitz,In progress,,"### Version
2.5.22

### Reproduction link
[https://jsfiddle.net/keegan_openbay/gehkx7pf/10/](https://jsfiddle.net/keegan_openbay/gehkx7pf/10/)  
[https://jsfiddle.net/keegan_openbay/018rs3ae/11/](https://jsfiddle.net/keegan_openbay/018rs3ae/11/)

(More explanation in the fiddle, but keep in mind that JSFiddle doesn't show TS errors)

### Steps to reproduce
1. Declare a prop of type `Function`, and with a default function that returns some value; e.g.,

```ts
// ...
  props: {
    fooFn: {
      type: Function,
      default: () => true,
    },
  },
// ...
```

2. Try to use that function elsewhere in your component options; e.g.,

```ts
// ...
  methods: {
    useFooFn(): void {
      const bar = this.fooFn();
      // ...
    },
  },
// ...
```

### What is expected?
```ts
type FooFn = typeof this.fooFn; // Function
this.fooFn(); // no errors
```

### What is actually happening?
```ts
type FooFn = typeof this.fooFn; // boolean | Function
this.fooFn();
// Cannot invoke an expression whose type lacks a call signature.
// Type 'boolean | Function' has no compatible call signatures.
```

---
Vue version: 2.5.22
TypeScript version: 3.0.3

tsconfig.json:

```json
{
  ""compilerOptions"": {
    ""declaration"": false,
    ""emitDecoratorMetadata"": true,
    ""experimentalDecorators"": true,
    ""lib"": [""es7"", ""dom""],
    ""module"": ""es2015"",
    ""moduleResolution"": ""node"",
    ""sourceMap"": true,
    ""target"": ""es5"",
    ""allowSyntheticDefaultImports"": true,
    ""esModuleInterop"": true,
    ""baseUrl"": ""./app/javascript"",
    ""noImplicitThis"": true
  },
  ""include"": [
    ""app/javascript/**/*.ts"",
    ""app/javascript/**/*.tsx"",
    ""app/javascript/**/*.vue""
  ],
  ""exclude"": [
    ""**/*.spec.ts"",
    ""node_modules""
  ],
  ""compileOnSave"": false
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I tried adding the test case to the project and couldn't reproduce:

```ts
Vue.extend({
  props: {
    isValid: {
      type: Function,
      default: () => true,
    }
  },
  methods: {
    useFooFn(): void {
      const bar = this.isValid()
      alert(bar)
    }
  }
});
```
--

--
no, I'm using the one we have in the repo
--
",kjleitz,"
--
@posva Are you using the same TypeScript setup and seeing no compile errors?
--

--
Can you try with the setup I posted?
--

--
@posva 

![screen shot 2019-01-23 at 3 45 55 pm](https://user-images.githubusercontent.com/18669659/51635963-06835780-1f26-11e9-8a1c-1a6173d04406.png)

![screen shot 2019-01-23 at 3 45 12 pm](https://user-images.githubusercontent.com/18669659/51635914-eeabd380-1f25-11e9-94e8-95158e23b8bd.png)
--

--
Found a clue:

I just downgraded `vue` (and `vue-template-compiler`) to **2.5.17** and it works fine, as it used to. Then I upgraded both to **2.5.18**, and now I see a bunch of compiler errors (including this one) which had never occurred before:

```ts
// for Function-type props with a default like `() => false`, `(arg: number) => false`, etc.:
// => TS2349: Cannot invoke an expression whose type lacks a call signature. Type 'boolean | Function' has no compatible call signatures.
// (same error occurs with any return value)

function foo(barEl: HTMLElement) { /* ... */ }
foo(this.$el);
// => TS2345: Argument of type 'Element' is not assignable to parameter of type 'HTMLElement'.

const bar = this.$el.innerText;
// => TS2339: Property 'innerText' does not exist on type 'Element'.
```

Seems that:

1. Function props' types are being recognized as either `Function` _or_ the return type of their `default` function
1. The type of `this.$el` has become `Element` instead of `HTMLElement`
1. This occurs in `vue`/`vue-template-compiler` 2.5.18+, but not 2.5.17

~It may have something to do with `""noImplicitThis"": true` in `tsconfig.json`; setting it to `false` removes all those errors (there is one new error in our project after setting it to `false` but it's to do with a lack of type inference on `this.$store`, all in one component rather than scattered across the project)~
--

--
Reverting https://github.com/vuejs/vue/pull/8537, specifically this change:

```diff
diff --git a/types/options.d.ts b/types/options.d.ts
index cc58affe6a..25eb8a0fdf 100644
--- a/types/options.d.ts
+++ b/types/options.d.ts
@@ -133,7 +133,7 @@ export type PropValidator<T> = PropOptions<T> | Prop<T> | Prop<T>[];
 export interface PropOptions<T=any> {
   type?: Prop<T> | Prop<T>[];
   required?: boolean;
-  default?: T | null | undefined | (() => object);
+  default?: T | null | undefined | (() => T | null | undefined);
   validator?(value: T): boolean;
 }
```

...fixes the `Function`-type prop issue.
--

--
And reverting https://github.com/vuejs/vue/pull/8809, specifically this change:

```diff
diff --git a/types/vue.d.ts b/types/vue.d.ts
index 44a892ead3..3832f2c9e4 100644
--- a/types/vue.d.ts
+++ b/types/vue.d.ts
@@ -21,7 +21,7 @@ export interface CreateElement {
 }
 
 export interface Vue {
-  readonly $el: HTMLElement;
+  readonly $el: Element;
   readonly $options: ComponentOptions<Vue>;
   readonly $parent: Vue;
   readonly $root: Vue;
```

...fixes the `this.$el` defaulting to `Element` issue.
--

--
I'll see if I can write up a PR for a fix without resurfacing the original issues those PRs were trying to solve.
--

--
Aaaaand I've realized over the past few days that I am not good enough with TypeScript to figure out how to do this.

Where...

1. `""noImplicitThis"": true` in `tsconfig.json`, and
2. Vue version is 2.5.18 and above,

...in order to get a prop definition such as this:

```ts
// ...
  props: {
    isValid: {
      type: Function,
      default: () => true,
    }
  },
// ...
```

...to yield a type of:

```ts
this.isValid //=> Type: () => boolean
```

...instead of:

```ts
this.isValid //=> Type: boolean | () => boolean
```

You'd have to edit the `PropOptions` interface such that:

```ts
export interface PropOptions<T=any> {
  type?: Prop<T> | Prop<T>[];
  required?: boolean;
  // default?: T | null | undefined | (() => T | null | undefined);
  // I guess...?
  default?: Function extends T ? (T | null | undefined) : (T | null | undefined | (() => T | null | undefined));
  validator?(value: T): boolean;
}
```

Unfortunately, that example doesn't work, and the types of other properties on `Vue` are lost. I've tried a _lot_ of different things over the past few days, but clearly I don't have the expertise to understand exactly how to fix the issue.

I believe, currently, a **Function-type** prop is a **unique** case. It is (correct me if I'm wrong), the _only_ prop type that does not have the option of a default ""factory"" function:

```ts
props: {
  fnProp1: {
    type: Function,
    default: () => false, // type of this.fnProp1 should be `() => boolean`
  },
  fnProp2: {
    type: Function,
    default: () => (() => false), // type of this.fnProp2 should be `() => (() => boolean)`
  },
  boolProp1: {
    type: Boolean,
    default: false, // type of this.boolProp1 should be `boolean`
  },
  boolProp2: {
    type: Boolean,
    default: () => false, // type of this.boolProp2 should STILL be `boolean`
  },
  strProp1: {
    type: String,
    default: 'hi', // type of this.strProp1 should be `string`
  },
  strProp2: {
    type: String,
    default: () => 'hi', // type of this.strProp2 should STILL be `string`
  },
  // etc.
},
```
--

--
Furthermore, if you want to return an _object_ from the default, it _completely_ skips the function type altogether:

```ts
// ...

  props: {
    returnsAnObject: {
      type: Function,
      default: () => ({}),
    }
  },

// ...

  // Type SHOULD be `Function`, or `() => {}`, but...
  this.returnsAnObject; //=> Type: {}
  // ...which is not even the [broken] union `{} | () => {}` type like the other cases

  this.returnsAnObject();
  // Cannot invoke an expression whose type lacks a call signature.
  // Type '{}' has no compatible call signatures.

// ...
```
--

--
I'd rather not keep bumping this unnecessarily, since it's mostly an echo chamber at the moment, but this `2.5.17` to `2.5.18+` patch update breaks our build, necessitates a lot of boilerplate around what used to be correctly-inferred properties on our components, and the causal changes seem to be fairly clear. Any attention or help would be greatly appreciated!
--

--
@romansp I'm fairly confident that hasn't worked without annotation since Vue 2.5.17. Annotating with `PropType<...>` (**note:** _not_ `PropOptions<...>`) works just fine on Vue 2.6.10 and TypeScript 3.6.3, though.
--

--
@romansp Ah, I see, you're not using the same `tsconfig.json` as in my original example. The fact that you're using `""strict"": true` instead of `""noImplicitThis"": true` fixes it in your `ts-3.5.3` branch (we've also switched to using `""strict"": true` since the time this ticket was written; much better!). Even with `""strict"": true` though, if you set Vue back to v2.6.8 it's actually still broken in your `ts-3.5.3` branch. It's always been wonky.

Vue v2.6.10 & TS v3.5.3 must be one of those special combinations that don't error for function props 🤷‍♂ But even in that branch, the ""working"" case loses type info from `this.cb`—better to use `type: Function as PropType<() => void>,` instead of a bare `type: Function,`.
--

--
This is still broken, even with `""strict"": true`; can't use a `default` for a function-type prop. A more complete example:

```ts
const ComponentWithFunctionProps = Vue.extend({
  props: {
    functionProp: {
      type: Function,
      default: () => true,
    },
    functionPropWithBooleanReturnType: {
      type: Function as PropType<() => boolean>,
      default: () => true,
    },
    booleanProp: {
      type: Boolean,
      default: true,
    },
    booleanPropWithFunctionDefault: {
      type: Boolean,
      default: () => true,
    },
  },
  methods: {
    test(): void {
      // ERROR!
      // (property) functionProp: boolean | Function
      // -------------------------------------------
      // This expression is not callable.
      //   No constituent of type 'boolean | Function' is callable.ts(2349)
      this.functionProp();

      // ERROR!
      // (property) functionPropWithBooleanReturnType: boolean | (() => boolean)
      // -----------------------------------------------------------------------
      // This expression is not callable.
      //   Not all constituents of type 'boolean | (() => boolean)' are callable.
      //     Type 'false' has no call signatures.ts(2349)
      this.functionPropWithBooleanReturnType();

      // const foo: boolean
      const foo = this.booleanProp;

      // const bar: boolean
      const bar = this.booleanPropWithFunctionDefault;
    },
  },
});
```

I submitted a fix for this in https://github.com/vuejs/vue/pull/11223.
--
",pikax,"
--
if you annotate with the `PropType<>` it should work, this was a fix on https://github.com/vuejs/vue/pull/9733

```ts
const Example = Vue.extend({
	template: `
  	<button @click=""doSomethingWithFoo()"">
    	<slot></slot>
    </button>
  `,

  props: {
    // original issue
    fooFn: {
      type: Function as PropType<()=>string>,
      default: () => { return 'hey this is the default return value'; },
    },


     returnsAnObject: {
      type: Function as PropType<()=>object>,
      default: () => ({}),
    }
  },

  methods: {
    doSomethingWithFoo(): void {
      const obj = this.returnsAnObject(); //obj is object
    	const bar = this.fooFn(); // bar is string
  
      alert(bar);
    },
  },
});
```


there's an PR https://github.com/vuejs/vuejs.org/pull/2068 to update docs





--
",romansp,"
--
Is this issue back on TypeScript 3.6? The following compiles fine on TS 3.5.3 and fails on the latest TS 3.6.3.

Vue: 2.6.10
TypeScript: 3.6.3
```
import Vue from 'vue';

export default Vue.extend({
  props: {
    cb: {
      type: Function,
      default: () => {},
    },
  },

  created() {
    this.cb();
  }
});
```

```
13:10 This expression is not callable.
  No constituent of type 'void | Function' is callable.
    11 | 
    12 |   created() {
  > 13 |     this.cb();
       |          ^
    14 |   }
    15 | });
```

Removing `default: () => {}` from `cb` as well as annotating it with `PropOptions<() => void>` helps, but this wasn't needed before.

Put a repro here: https://github.com/romansp/vue-typescript-prop-function-default. 

May be related to #10455.
--

--
@kjleitz I'm sure that it does work on TS 3.5.3 and Vue 2.6.10. You can try cloning my repro https://github.com/romansp/vue-typescript-prop-function-default. I just pushed `ts-3.5.3` branch where `vue serve` runs fine.
--
",,,,
9355,OPEN,Inconsistent Vue.set() and Vue.delete() TypeScript types,,2019-01-22 10:05:27 +0000 UTC,zlumer,In progress,,"### Version
2.5.22

### Reproduction link
[https://bit.ly/2W6bvIu](https://bit.ly/2W6bvIu)







### Steps to reproduce
1. Make sure you have `strict: true` in your `tsconfig.json` to handle all type mismatch cases.
2. Run TypeScript compiler against provided code.

### What is expected?
Vue mimics TypeScript behaviour, triggers compiler errors on not allowed operations.

### What is actually happening?
Vue doesn't trigger any compilation errors.

---
As discussed in #9347 and #9353, TypeScript typings for `Vue.set()` and `Vue.delete()` are not consistent with TypeScript behavior.
While TypeScript helps catch bugs at compile time with its type system, Vue breaks certain TypeScript rules due to incomplete type definitions in `vue.d.ts`

I propose changing `Vue.set()`/`Vue.delete()` typings to the following:
```typescript
set<T, K extends keyof T>(object: T, key: K, value: T[K]): T[K];
delete<T>(object: T, key: keyof T): void;
```
This will match TypeScript behaviour on provided examples.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This would be a breaking change
`set` allows to dynamically define properties that do not exist as well as properties coming from arbitrary sources like user input:

```js
const obj = {}
// dynamicName could come from end user
set(obj, dynamicName, value)
```

If we add those typings we would be breaking this usage. Same goes for `delete`, it can delete dynamic properties.
We would need to force users to type those objects as `Record<string, any>`. I think this makes sense though, so maybe we should ensure this for Vue 3 instead. cc @ktsn, @HerringtonDarkholme 
--

--
breaking changes are only possible in major versions (Vue 3)
--
",zlumer,"
--
I agree that this is a breaking change not suitable for patch version (not sure about minor/major though).
--
",,,,,,,,
9329,OPEN,Vue-Mobx integration broken with PR #7828,need repro,2019-02-11 17:14:39 +0000 UTC,bitencode,In progress,,"### Version
2.5.18

### Reproduction link
[https://codesandbox.io/s/k90k8kwn2r](https://codesandbox.io/s/k90k8kwn2r)







### Steps to reproduce
* Use the `mobxjs/mobx-vue` package (or a custom integration with Mobx)
* Everything worked fine on Vue 2.5.17 and is broken on 2.5.18 and above
* See that TypeErrors are thrown

### What is expected?
Vue would not attempt to to set the `__proto__` property of a Proxy.

### What is actually happening?
Reactivity with Mobx is broken:

[Vue warn]: Error in event handler for ""input"": ""TypeError: 'set' on proxy: trap returned falsish for property '__proto__'""
---
We attempted to upgrade Vue from 2.5.17 to latest version for our applications - thought it would be smooth because upgrade target was still 2.5.x, but ever version after 2.5.18 is broken with Mobx integration.

We have a custom integration with Mobx-state-tree, but some of the code is very similar to `mobxjs/mobx-vue` integration code.  We are not using that library, and I'm not a Vue internals expert,  but I _think_ I  tracked the problem down to this PR: https://github.com/vuejs/vue/pull/7828.  

Since then I have searched around and found this issue reported to that package also: https://github.com/mobxjs/mobx-vue/issues/15#issuecomment-453570397.  @Nemikolh wrote the codesandbox example I referenced above and it appears to be the same conclusion.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Nemikolh,"
--
Thanks for mentioning me, the other option that I think would be doable is to change mobx itself so that it would allow setting `__proto__` for an array. The problematic code is in `arrayTraps.set` function:

https://github.com/mobxjs/mobx/blob/daf6ac0ac8dd369fb6179ec6a7fbbb231f383f9f/src/types/observablearray.ts#L96-L109

I'm not sure of the impact of such a change though.

Either way, it would be nice to have test(s) that are run as part of the test suite to verify the mobx integration. I think they should go into the [`mobx-vue`](https://github.com/mobx/mobx-vue) repo but they would need to be triggered whenever a new minor version of vue and/or mobx is released. That might not be trivial to do.
--
",bitencode,"
--
Good point @Nemikolh - I have no context for which might be the better place to fix this.  I followed the Vue path because that's the package that appeared to break. Maybe core Vue and/or Mobx contributors will have an opinion (that is compatible😜).   It does seem that tests would  be well placed in `mobx-vue`.
--

--
Hi @posva, to be honest, probably nothing; but neither is anything broken in Mobx unless you try to use Vue - so I'm a bit at a loss as to how to proceed 😞 With my personal apps (using Vue and Vuex) nothing is wrong.  When I'm working with my employers app (Vue, Mobx, MST) this function:
```
function protoAugment (target, src: Object) {
  /* eslint-disable no-proto */
  target.__proto__ = src
  /* eslint-enable no-proto */
```
in `vue/src/core/observer/index.js` invokes the Mobx `set` on observable arrays and returns `false` (causing the vue warning). https://github.com/mobxjs/mobx/blob/daf6ac0ac8dd369fb6179ec6a7fbbb231f383f9f/src/types/observablearray.ts#L96-L109

I forked the Mobx repo and added a check to the end of the `set` function:
```
        if (name === ""__proto__"") {
            return true
        }
        return false
``` 
But I have a really bad feeling about that as I have no idea what I might be breaking in Vue.  It looks like Vue is trying to hook into the prototype chain to observe changes, but Mobx is already doing that.  So, I don't know what the answer is.
--
",posva,"
--
what is the actual thing breaking Vue, without any mobx/mobx-vue import?
--
",,,,,,
9328,OPEN,Allow nested transition to trigger upon removal,feature request; transition,2019-07-23 14:58:05 +0000 UTC,mw76,In progress,,"### Version
2.5.22

### Reproduction link
[https://jsfiddle.net/wx91uLft/](https://jsfiddle.net/wx91uLft/)
other: https://jsfiddle.net/ae82rfnv/






### Steps to reproduce
- Show/hide elements with the  ""Toggle"" button.
- Show/hide elements with the  ""Toggle Ticked"" button. Shows a workaround.

### What is expected?
All transitions should be triggered on leave, even for nested child elements.

### What is actually happening?
Transition classes don't get applied to nested child elements, when conditions for leaving transitions occur on the same tick.

Workaround: Delaying the parent transitions by one tick fixes the problem.

---
This has been reported, but got closed due to the sample code did not use `appear` on the `<transition>` elements. (See issues [#7643](https://github.com/vuejs/vue/issues/7643) and [#9243](https://github.com/vuejs/vue/issues/9243))

My example is more detailed and also provides a workaround.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is working as expected because when both conditions are set to false on the same tick, only the parent is removed by the `v-if`, nothing inside is evaluated. That's why the inner transition doesn't trigger, it wasn't removed directly
--

--
it could be via a new prop on transition I think 🤔 . I haven't checked the feasibility though although it should be possible
--
",mw76,"
--
Wow, that's disappointing. 😢
So if we want to have working nested transitions in Vue, this should be considered a feature request?
--

--
Nice! 😊👍
--
",damtsnkff,"
--
For future reader, @posva is right, we can achieve that via props.

I made a quick [example here](https://jsfiddle.net/tsnkff/yuh9j3qp/6/) for the matter.
I used `@before-leave=""""` to trigger the parent transition (change of state), and `@before-enter=""""` on the parent, to trigger the animation on the child element.
--
",,,,,,
9325,OPEN,Modifier to propagate/forward events to parent,feature request,2020-11-24 10:24:55 +0000 UTC,Vontus,In progress,,"### What problem does this feature solve?
Currently, and as far as I know, if we want to propagate an event fired by a child component to the parent (the child's grandparent) we need to $emit the event again, and we need to pass all the arguments one more time. This can become a problem, for example, if the event has a variable number of arguments because we need to specify them manually or pass the whole array as a new argument.

The current way would be something like
```
@blur=""$emit('blur')""
@create=""$emit('create', arguments[0])""
@input=""$emit('input', arguments[0], arguments[1])""
```

### What does the proposed API look like?
```
@blur.propagate
@create.propagate
@input.propagate
```
And if we want to both handle the event and propagate it to the parent, we would use
```
@input.propagate=""someFunction""
```
----
EDIT: Maybe since .propagate may be confused with the function .stopPropagation(), a better term could be simply .emit

<!-- generated by vue-issues. DO NOT REMOVE -->",,,lopugit,"
--
why not just `@input=""$emit('input', arguments)""` ?

I do like having a dedicated keyword though
--

--
Isn't propagating arguments upwards what you want??

On Wed., 16 Jan. 2019, 6:50 pm Vontus <notifications@github.com wrote:

> @lopugit <https://github.com/lopugit> because passing the whole array in
> one argument would make users handle the same event differently in
> different components, plus it is a little redundant.
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/vuejs/vue/issues/9325#issuecomment-454683246>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AM_3BshACHBnU8nluMZLTLrOAGxiD6NEks5vDtmzgaJpZM4aAyIG>
> .
>

--

--
nice!!! OPEN SOURCE FTW
--
",Vontus,"
--
@lopugit because passing the whole array in one argument would make users handle the same event differently in different components, plus it is a little redundant.
--

--
@laander That solves the issue with the arguments, but I think a modifier to let Vue do it would be a nice addition.

I think this modifier can be specially useful for wrapper components that need to emit most events they receive from their child component.
--

--
> I believe you can achieve this by adding `v-on=""$listeners""` on a root element of the nested component?

I didn't know that, thank you for the tip! The only problem I find is that you aren't able to select which events are being propagated to the parent, it just forwards every event from the nested component.
--
",laander,"
--
You should be able to use the spread operator, ala:
```
@input=""$emit('input', ...arguments)""
```
--
",AlbertMarashi,"
--
I think this would be a cool addition
--

--
`@input=""$emit('input', ...arguments)""` works great, however `@input.propagate` would be an awesome addition

--
",raisou,"
--
+1
--
",alecoscia,"
--
That's also great for keeping the whole app more maintainable
--
"
9320,OPEN,Transition's @appear hook invoked even when appear not specified / falsy,bug; transition,2019-03-11 07:22:26 +0000 UTC,pkaminski,Opened,,"### Version
2.5.22

### Reproduction link
[https://codepen.io/anon/pen/jXdLGV](https://codepen.io/anon/pen/jXdLGV)







### Steps to reproduce
Open the repro and note that the rendered page says ""initial appear"".

### What is expected?
The `@appear` hook should not be invoked and the page should just say ""initial"".

### What is actually happening?
The `@appear` hook is invoked even though the `transition` doesn't have an `appear` attribute, and hence shouldn't be triggering on appear.  The same thing happens if you add `:appear =""false""` to the `transition`.

---
Ran into this when building some custom transition components where `appear` should be user-controlled, but was being invoked all the time instead.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It's also worth noting that we could improve the docs in this matter: https://vuejs.org/v2/guide/transitions.html#Transitions-on-Initial-Render

I'm not sure what is exactly expected here, but I would also say no `appear` events if `appear=false`. It seems there is a `done` callback to it
--
",Itisfilipe,"
--
Hey guys! I am learning this code base so I have implemented a fix for that without knowing if that would be ever needed, feel free to review it if you find it useful or disregard if not. Thanks!
--
",shasharoman,"
--
I think this is not a code bug, but the document needs to be described more clearly.

Both `appear attribute` and `@appear hook` will cause an appear transition, and `@appear hook` will have a higher priority. If you don't want an appear transition, don't specify `@appear hook`. Because `@appear hook` has a higher priority, using `:appear=false` does not cancel the transition.
--
",,,,,,
9313,OPEN,[SSR] Add option to output the server entry through webpack,feature request,2020-02-05 16:42:37 +0000 UTC,Kjir,In progress,,"### What problem does this feature solve?
The guide for Server-Side rendering creates 2 webpack builds, one for the client and one for the server. Then you create a file that imports the outputs from those 2 builds and returns the responses to whatever framework you use (e.g. express). Let's call this file the server handler.
The issue with this approach is that you would need a third webpack build to process the server handler through webpack as well. You might want to do that for a few different reasons:
 1. To have the same flow for all your files
 2. Because you use typescript/babel/minification or other transformations
 3. To use the same style of imports (i.e. ES modules)

### What does the proposed API look like?
I can think of a few possible solutions:

#### 1. Define the name of the server handler to emit

There could be a configuration option for `VueSSRServerPlugin` that defines one additional entry to emit in the Webpack configuration. This would mean that there could be at most 2 entries, one is used for creating the JSON bundle, the other one to emit the server handler

```javascript
// webpack.config.js
const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')

module.exports = {
  // Point entry to your app's server entry file
  entry: {
     main: '/path/to/server-entry.js',
     handler: '/path/to/server-handler.js'
  },
  resolve: {
    alias: {
      'client-manifest': '/path/to/dist/client/vue-ssr-client-manifest.json'
    }
  },
  plugins: [
    new VueSSRServerPlugin({ serverHandler: 'handler' })
  ]
}
```

The handler would look something like this:
```javascript
// server-handler.js
import clientManifest from 'client-manifest';
// This alias could be created by the VueSSRServerPlugin itself
import serverBundle from 'server-bundle';
import { createBundleRenderer } from 'vue-server-renderer';

const template = `[...]`;

const renderer = createBundleRenderer(serverBundle, {
  template,
  clientManifest,
  runInNewContext: false
});

export function handler(event, context) {
  // use the renderer in here
}
```

The upside of this approach is that it should be relatively easy to accomplish this.
Another upside is that this would be backwards compatible.
The downside is that there would be quite a bit of configuration necessary to make it look nice — to avoid importing build outputs directly in code, which would add a dependency on our webpack configuration in the code.

#### 2. Provide an alias that resolves to the renderer instead of emitting a JSON bundle

Another possible approach would be to change completely the way the VueSSRServerPlugin works to reduce the additional webpack configuration necessary. Here's how the webpack configuration would look like:

```javascript
// webpack.config.js
const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')

module.exports = {
  // Point entry to your app's server entry file
  entry: '/path/to/server-handler.js',
  plugins: [
    new VueSSRServerPlugin({
      clientManifest: '/path/to/dist/client/vue-ssr-client-manifest.json',
      serverEntry: '/path/to/server-entry.js',
      template: '/path/to/template.html'
    })
  ]
}
```

And here is how the server handler would look like:

```javascript
// alias defined by the plugin, returns the renderer
import renderer from 'vue-ssr-server-renderer'

export function handler(event, context) {
  // use renderer here
}
```

The clear upside is the reduction of the boilerplate.
The first big downside is that this would not be backwards compatible. It could be implemented as a new, different plugin.
The second downside is that there might be other use cases I haven't considered. `createBundleRenderer` takes other arguments as well, and you might not want to instantiate it at the top level.
A smaller downside is that some pieces are connected in webpack rather than in the code, making it unclear where the template is referenced from.

#### 3. Use a loader to transform the server entry

This would be similar to the first proposal, but it would change the way `createBundleRenderer` works.

Starting from the server handler this time, here is how the usage would look like:

```javascript
import App from '/path/to/server-entry.js'
import clientManifest from 'client-manifest';
// This function has the client manifest already pulled in by the plugin
import { createAppRenderer } from 'vue-server-renderer';

const template = `[...]`;

const renderer = createAppRenderer(app, {
  clientManifest,
  template,
  runInNewContext: false
});

export function handler(event, context) {
  // use renderer here
}
```

And the webpack configuration would be something like this:

```javascript
// webpack.config.js

module.exports = {
  // Point entry to your app's server entry file
  entry: '/path/to/server-handler.js',
  module: {
    rules: [
      {
        test: /entry-server\.js$/,
        loader: 'vue-ssr-loader'
      }
    ]
  },
  resolve: {
    alias: {
      'client-manifest': '/path/to/dist/client/vue-ssr-client-manifest.json'
    }
  }
}
```

This approach would have the upside of not requiring magic to happen on the webpack entries, making it possible to have multiple entrypoints.
The second upside would be to just configure a loader where appropriate, instead of adding a plugin.
The first downside is that we still have to include the client manifest from the build.
The second downside is that is could not be feasible with a webpack loader.

#### So which one?
I believe this problem needs a deeper reflection on the implications for all possible use cases, so someone with a better understanding of the usages of this plugin should trace the path to follow. Other ideas could be possible that would in the future also lead to simpler usages that hide the complexity from the users.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Kjir,"
--
I had to create this issue ""manually"" since using the tool I get `414 Request-URI Too Large` 😭 
There should be a `feature request` label, which I can't add myself apparently....
--
",zwmmm,"
--
More than how to configure SSR entrance
--
",CaptainYouz,"
--
any news on this one ? In my use case, I'm trying to set the `runInNewContext` from the vue.config.js, without having to create 2 webpack build files.
--
",,,,,,
9284,OPEN,Vue父子组件间数据传递在IE浏览器中内存泄漏,,2019-01-16 01:48:50 +0000 UTC,MR-fisher,Opened,,"### Version
2.5.21

### Reproduction link
[https://github.com/MR-fisher/vue-memory-leak-case](https://github.com/MR-fisher/vue-memory-leak-case)







### Steps to reproduce
通过连接下载案例demo，并运行 npm install 安装，完成后运行 npm start 启动工程，通过浏览器输入 http://localhost:8080/ 访问问题页面，交叉重复点击 xx 和 yy 按钮，组件x和y因为条件渲染控制会重复创建和销毁，看到任务管理器中ie浏览器占用内存不断飙升。

### What is expected?
ie浏览器内存回收正常

### What is actually happening?
ie浏览器内存占用不断飙升

---
该问题在ie edge浏览器下可以重现，chrome下是正常的
怀疑是条件渲染切换不同子组件展示时，每次切换会导致当前子组件被销毁，但是对应传入的prop并未销毁，组件的DOM与prop对象存在引用联系，尽管组件已销毁，但是引用关系仍然存在内存中，导致内存泄漏。

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
9266,OPEN,[SSR] Scoped-Mixed SSR Hydration for specific components,,2019-09-18 01:52:57 +0000 UTC,VenusAdept,In progress,,"### What problem does this feature solve?
Take a look at these snippets:

```
//Blade
<div id=""app"">
    <div>Some contents</div>
    <component1></component1>
    <component2></component2>
    @bladedirective
    <div>something else</div>
    <div is=component3>{{ $myComponentHtmlFromSSR }}</div>
</div>
```

```
//Client
const app = new Vue({
    el: '#app',
    components: { Component1, Component2, Component3}
});
```

```
//Server
const app = new Vue({
    render: h => h(Component3),
});
//Process app with vue-server-renderer
```

This works, we've used the common Blade  +  Vue dom templating approach and for some components, we will use SSR with its benefits.

The issue here is that the HTML snippet got from server can't be hydrated because the entire #app was not hydrated and Vue through client always regenerate the component from scratch.

### What does the proposed API look like?
Vue should have a ""scoped"" or ""mixed"" hydration for components in a way that we can use SSR with a mixed approach of Vue and other templating techniques and then hydrate a specific component and not an entire app.

Maybe something similar to:
`<div is=""component3"" hydrate=""true"">{{ $myComponentHtmlFromSSR }}</div>`


<!-- generated by vue-issues. DO NOT REMOVE -->",,,AlbertMarashi,"
--
I think Vue should have a feature that allows certain components to be server-side hydrated, like `<myComponent hydrate></myComponent>` that allows developers to selectively hydrate specific components instead of hydrating an entire app.
--
",justrhysism,"
--
Also, it would be nice if the pre-hydrated SSR markup was removed from the app (JS) bundle entirely reducing payload.
--
",Nettsentrisk,"
--
There definitely needs to be a way to selectively tell the Vue app which components need to be hydrated.

Let's say you build your web site using Vue components and SSR. Many/most of your components will be ""static"", that is, they will not be reacting to user input or anything happening on the client, their only purpose is to produce HTML.

There doesn't seem to be a way of preventing hydrating every single component in the Vue app with the existing options, you either hydrate the whole thing, or nothing.

If there's a way to do this with the current API, I would love to see an example!

Otherwise, maybe a ""static"" property on a component can let Vue know that this component will only be rendered server-side, or when hydration is turned off at the app-level, that you have to have a hydrate option per component/instance to tell the app to hydrate that componeny on the client.
--
",VenusAdept,"
--
News about that?
--
",,,,
9259,OPEN,Support Array subclassing,feature request,2019-02-22 16:25:10 +0000 UTC,AmrIKhudair,In progress,,"### Version
2.5.21

### Reproduction link
[https://codepen.io/AmrIKhudair/pen/NevxML](https://codepen.io/AmrIKhudair/pen/NevxML)







### Steps to reproduce
1- create a class extending Array and add a custom method
2- instantiate a new instance of the class and add it to data
3- try to call the method on the instance in the template

### What is expected?
The method is successfully executed

### What is actually happening?
Error not a function

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yyx990803,"
--
Vue 2 currently does not support Array subclassing (Vue 3 development branch already does). I will convert this into a feature request.
--
",edcoreweb,"
--
@AmrIKhudair 
I needed this as well and made it work in user-land. When Vue 3 arrives you can remove it.

```js
export function makeReactive (obj) {
  // eslint-disable-next-line no-proto
  const proto = obj.__proto__

  Object.defineProperty(obj, '__proto__', {
    get () { return proto },
    // eslint-disable-next-line no-proto
    set (newValue) { proto.__proto__ = newValue }
  })
}
```

```js
import { makeReactive } from 'util'

export default class UserCollection extends Array {
  constructor (...args) {
    super(...args)

    makeReactive(this)
  }
}
```
--
",AmrIKhudair,"
--
@edcoreweb
Thanks a lot
--
",,,,,,
9255,OPEN,class binding not updating on client after using `$isServer` with boolean values,bug; has workaround,2019-07-12 08:10:26 +0000 UTC,AlbertMarashi,In progress,,"### Version
2.5.21

### Reproduction link
[https://codesandbox.io/s/y05q554q71](https://codesandbox.io/s/y05q554q71)







### Steps to reproduce
code sandbox will illustrate the issue. (may take a few seconds to load)

Notice how `{{ isActive() }}` prints true, yet the class isn't binded

### What is expected?
`:class` to bind class attribute `class=""nav-link active` and cause nav-link to turn red

### What is actually happening?
Not binding class and making nav-link red

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I would say this is intended, you don't want your component to completely re renders when hydrating, that would defeat the purpose of hydration. You can call `$forceUpdate` in `mounted` to make it happen. But the whole point of using `$isServer` is that you know when you rendered on server. And that's pretty much what you have right now
--

--
it's indeed weird, it only happens with `class`
--
",AlbertMarashi,"
--
Thanks @posva, @nickmessing provided the same solution over DMs, I was about to post it and close.

```html
<template>
    <a class=""nav-link"" :href=""href"" :class=""{ active: isActive() }""><slot></slot></a> 
</template>
<script>
export default {
    props: ['href'],
    methods: {
        isActive(){
            if(this.$isServer) return false
            return window.location.pathname === this.href
        }
    },
    mounted(){
        this.$forceUpdate()
    }
}
</script>
<style scoped>
.nav-link {
  color: white;
  padding: 10px 14px;
  margin: 4px;
  background: blue;
}
.active {
  background: red;
}
</style>
```

OR:
```html
<template>
  <a class=""nav-link"" v-bind:class=""{ active: active }"" :href=""href"">
    <slot></slot> {{ active }}</a
  >
</template>
<script>
export default {
  props: [""href""],
  data() {
    return { active: false };
  },
  mounted() {
    this.active = window.location.pathname === this.href;
  }
};
</script>
<style scoped>
.nav-link {
  color: white;
  padding: 10px 14px;
  margin: 4px;
  background: blue;
}
.active {
  background: red;
}
</style>
```

Just for anyone's future reference
--

--
Well, if I have a say, I would like to see class/element attributes hydrated (when `app.$mount(""#el"", true)` is passed, as that seems expected behaviour.

I spent a few hours unable to solve the issue, as there was no info in the docs about whether element attributes are hydrated or not.

To add, `isActive` was being called, whether it was a `computed` method or a `method`. If the class binding method is being ignored, then why call it at all?
--
author:	
association:	none
edited:	false
status:	none
--
I have a similar issue. Here is what i found in the source code https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6068
```
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
```
and then in `hydrate` function there is a check
```
if (!isRenderedModule(key)) {
    fullInvoke = true;
    invokeCreateHooks(vnode, insertedVnodeQueue);
    break
 }
```
So it turns out that Vue does not call invokeCreateHooks (which internally calls updateAttrs) during hydration if there are no other directives attached to the element. That is why your class attribute has not been updated. If you add any event or ref to that element, it will call the hooks.
--
author:	
association:	none
edited:	true
status:	none
--
Removing `class` from `isRenderedModule` map or adding `updateClass(emptyNode, vnode);` here 
```
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
          updateClass(emptyNode, vnode);
        }
```
 fixes the issue, but i am not sure about performance implications and maybe there is a better way to fix it.
--

--
I have a similar issue. Here is what i found in the source code https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6068
```
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
```
and then in `hydrate` function there is a check
```
if (!isRenderedModule(key)) {
    fullInvoke = true;
    invokeCreateHooks(vnode, insertedVnodeQueue);
    break
 }
```
So it turns out that Vue does not call invokeCreateHooks (which internally calls updateAttrs) during hydration if there are no other directives attached to the element. That is why your class attribute has not been updated. If you add any event or ref to that element, it will call the hooks.
--
author:	
association:	none
edited:	true
status:	none
--
Removing `class` from `isRenderedModule` map or adding `updateClass(emptyNode, vnode);` here 
```
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
          updateClass(emptyNode, vnode);
        }
```
 fixes the issue, but i am not sure about performance implications and maybe there is a better way to fix it.
--
author:	AlbertMarashi
association:	contributor
edited:	true
status:	none
--
> So what exactly is the rule for things to be re-hydrated or not?

> it's indeed weird, it only happens with class

So why not just re-render everything, including class. It seems like intended behaviour. @yyx990803 
--

--
Removing `class` from `isRenderedModule` map or adding `updateClass(emptyNode, vnode);` here 
```
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
          updateClass(emptyNode, vnode);
        }
```
 fixes the issue, but i am not sure about performance implications and maybe there is a better way to fix it.
--
author:	AlbertMarashi
association:	contributor
edited:	true
status:	none
--
> So what exactly is the rule for things to be re-hydrated or not?

> it's indeed weird, it only happens with class

So why not just re-render everything, including class. It seems like intended behaviour. @yyx990803 
--
author:	AlbertMarashi
association:	contributor
edited:	true
status:	none
--
@bny6613 can you provide a pull request for that?

edit: AGH, I need to stop accidentally closing issues 🤣 
--

--
> So what exactly is the rule for things to be re-hydrated or not?

> it's indeed weird, it only happens with class

So why not just re-render everything, including class. It seems like intended behaviour. @yyx990803 
--
author:	AlbertMarashi
association:	contributor
edited:	true
status:	none
--
@bny6613 can you provide a pull request for that?

edit: AGH, I need to stop accidentally closing issues 🤣 
--
author:	AlbertMarashi
association:	contributor
edited:	false
status:	none
--
@yyx990803 can we fix this maybe in 2.6 or 3.0 if you're worried about it being a breaking change.
--
",lbogdan,"
--
@posva I don't think that's entirely true, as the ""Home"" `<nav-link>` is actually re-rendered from showing ""false"", like it comes hydrated in the html, to showing ""true"" (because `isActive()` now returns `true` on the client). So what exactly is the rule for things to be re-hydrated or not?
--
",,,,,,
9234,OPEN,Transition is erroneously run when placed with bizarre sequence of sibling elements.,bug; has workaround; transition,2019-03-27 13:01:42 +0000 UTC,AnalyzePlatypus,In progress,,"
### Version
2.5.21

### Reproduction link
[https://jsfiddle.net/analyzeplatypus/eywraw8t/513878/](https://jsfiddle.net/analyzeplatypus/eywraw8t/513878/)

![screen recording 2018-12-20 at 8 21 07 pm mov](https://user-images.githubusercontent.com/18376110/50303197-00b4d500-0495-11e9-9f02-145099a68d15.gif)

### Steps to reproduce
The fiddle contains a seemingly random sequence of elements that illustrates the issue (described below). 

1. Open the JSFiddle
2. Click the ""Change"" button
3. The transition plays (it should not).

Try removing any of the DOM elements and the errant transition no longer plays!

### What is expected?
The transition should not run.
(CSS transition classes should not be applied, hooks should not be called, etc.)

### What is actually happening?
The transition is run (CSS transition classes are applied).

---
I came across this while building a complex form with multiple buttons that appear/disappear based on form state.
I noticed duplicated buttons in one of my unit tests, and found that a transition was being run even though its child's `v-if` binding was not being changed. I duplicated the component and whittled it down until I arrived at the attached JSFiddle.


This issue appears when the following sequence of elements are aligned:
1. A boolean entry in the Vue component's `data` dictionary (`hasChanges: false`, in the JSFiddle)

The DOM contains
2. A `<div>` whose `v-if` is bound to the boolean entry (1).
2. A `<transition>` containing a button which modifies the boolean entry (1).
3. An empty `<transition>` element.
4. A `<div>` whose `v-if` is bound to the boolean entry (1) modified by logical NOT (!). (In the fiddle, `v-if=""!hasChanges""`).

With this exact structure, modifying the boolean entry (1) will run the transition - even though the transition is not bound to the boolean at all!

If you remove any of the above elements, **or even reorder them** (!) the errant transition will not run (which is the correct behavior).


Why does the transition run when placed with this particular set of siblings in this particular order?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,AnalyzePlatypus,"
--
It also seems like the `<button>` in the fiddle is **duplicated by the transition system** (watch the DOM in your web inspector!) and simultaneously transitioned in and out: one `<button>` with `-enter-active` and one with `-leave-active`. 
--

--
@beica1 , try wrapping your `<transition>` in a `div`.
--
",posva,"
--
Looks like a bug, as a workaround, wrapping one of the transitions with a simple container should do it
--
",beica1,"
--
think i have the same issue:
```vue
<page>
  <component-a />
  <transition name=""page-slide"">
    <component :is=""comp"" />
  </transition>
  <component-b />
</page>
```
after the `comp` change and the transition done(after leave), the siblings compoents(`component-a` and `component-b`) will have a flash like rerender
--

--
@AnalyzePlatypus Yes, Thank you!, it's worked for me.
--
",,,,,,
9222,OPEN,Add an option to throw global errors; making it possible for debuggers to automatically break on error.,feature request,2019-07-16 12:13:18 +0000 UTC,nialna,In progress,,"### What problem does this feature solve?
Currently, the [globalHandleError](https://github.com/nialna/vue/blob/dev/src/core/util/error.js#L27) function will intercept all errors thrown in components and log them. It can also pass them to an external error handler, but that external error handler won't be able to throw it because the call to `config.errorHandler` is wrapped in a try catch.

In vanilla JS, when an unhandled error happens in your code, the debugger can break immediately, giving you access to the stack and context. When using VueJS, we have no way of doing this because the errors are always handled by Vue.

### What does the proposed API look like?
The simplest way I can think of is to add a new `config` option, for example:

```js
Vue.config.throwUnhandledErrors = true;
```

Then in `globalHandleError`, we could check for that flag and throw errors:

```js
function globalHandleError (err, vm, info) {
  if (config.throwUnhandledErrors) {
    throw(err);
  } else if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler')
    }
  }
  logError(err, vm, info)
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,nialna,"
--
More specifically, to keep the original stack when the debugger breaks, the best thing would be to _not_ catch errors thrown by hook handlers, since this is where user code gets called. In this function:

```js

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + "" hook""));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}
```

(I can't find which part of the repo it came from. Copied that from my chrome console). If the `throwUnhandledErrors` option could allow this function to not wrap the handler in a try catch, then we would actually be able to have the browser debugger break properly on user code.
--
",,,,,,,,,,
9216,OPEN,Impossible to preserve directive dom changes when the dom element is shared by multiple vnodes.,improvement,2018-12-17 19:00:50 +0000 UTC,Aaron-Pool,Opened,,"### Version
2.5.17

### Reproduction link
[https://codesandbox.io/s/8y0yqono38](https://codesandbox.io/s/8y0yqono38)







### Steps to reproduce
Create a wrapper component that has another custom component as its root node. Put a directive on the wrapper component that adds a class to the element. Do anything that updates the child's class. The classes assigned in the directive of the parent vnode will be wiped out, and the directive has no way of knowing it. I _think_ this is because the vnodes were merged into the same element. So, the child vnode gets patched, causing the class update and the dom change to the same element that the parent vnode is using, but, because no actual patch happened to the parent vnode, the parent directive never has a chance to readd it's class.

I think this probably _technically_ correct behavior, but it still presents (in my opinion) an issue with directive functionality. Which is that my host dom element can be mutated by a different vnode and I'm not aware of it.

### What is expected?
The `update` trigger runs when my host element is mutated.

### What is actually happening?
The class the directive adds is overwritten and my directive has no chance to readd the class.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yyx990803,"
--
Yeah, your understanding is correct. Just so you know in 3.0 this will not be an issue as all data on the component node is merged onto the component's root node instead of patched separately as it is now in 2.x.

I'm not sure if we will be able to address this in 2.x since it's a pretty risky change that may lead to unexpected breakage.
--
",Aaron,"
--
@yyx990803 Thanks for the quick response! I guess that was what I expected. I don't suppose there's anyway to make DOM changes like this in a directive that the current vDom merge strategy _wouldn't_ overwrite?
--
",,,,,,,,
9194,OPEN,[vue-server-renderer] Bug failing when using a reference of process - related to SSRClientWebpackPlugin,,2019-07-25 10:17:51 +0000 UTC,AlexandreBonaventure,In progress,,"### Version
2.5.21

### Reproduction link
[https://github.com/AlexandreBonaventure/repro-vue-ssr-bug](https://github.com/AlexandreBonaventure/repro-vue-ssr-bug)







### Steps to reproduce
1. `yarn install`
2. `yarn run ssr:build && yarn ssr:start`
3. go to localhost:8000


### What is expected?
to serve / correctly

### What is actually happening?
error 500:
```
TypeError: Cannot read property 'replace' of undefined
    at normalizeFile (.../node_modules/vue-server-renderer/build.js:8183:27)
```

---
Hi, I came across this weird bug when I was trying to retrieve a global variable (eg. global.localenv.PUBLIC_URL) in App.vue to populate a meta tag (using vue-meta).
I stumble upon the bug, and narrowed it down to referencing `process` being the cause here.
Another weird thing is that if you remove the component Icons import in the minimal repro, it works fine!

The error stack is initiated by `TemplateRenderer.renderPreloadLinks` which makes me think that maybe it is a bug in the webpack SSRClientPlugin which inject preload links for every assets.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,tkjaergaard,"
--
+1 

I'm experiencing the same issue `TypeError: Cannot read property 'replace' of undefined`.

Downgrading to `vue@2.5.17`, `vue-server-renderer@2.5.17` and `vue-template-compiler@2.5.17` made my application run again.

`2.5.18`-`2.5.21` make my application break with the TypeError:
```
TypeError: Cannot read property 'replace' of undefined
    at normalizeFile (.../node_modules/vue-server-renderer/build.js:8176:27)
```
--
",sebkolind,"
--
I had this error too when building my client webpack config. It turns out that I forgot to delete `VueSSRServerPlugin()` and had both the server and client plugin. As soon as I removed the server plugin from the client config it works.

I am not sure if it's related but someone else might have the same issue.
--
",laure,"
--
For me, the error was caused by a malformed `vue-ssr-client-manifest.json` : in the modules section, some modules were mapped to indexes `-1`. As a result, at runtime, the `vue-server-renderer` was unable to load the file. 

To fix it, I just enabled the source maps for css files. In `vue.config.js`, add to your client config : 

```js
css: {
     sourceMap: true,
},
```
Tested with version 2.6.9.

I hope this will help.
--

--
The vue client plugin receives from webpack compilation stats a list of files that includes css maps, even when css maps are not emitted. The list is provided by webpack though [stats.chunks.files](https://webpack.js.org/api/stats/#chunk-objects). The [stats.assets](https://webpack.js.org/api/stats/#asset-objects) doesn't contain the css map files.

However, I am not sure why webpack is doing this. 

Anyway, the client plugin is not robust to webpack inconsistent data.
--
",AlexandreBonaventure,"
--
@laure-at-irun  yep! that was my issue as well
--
",OliverJEvans,"
--
@laure-at-irun This fixed the issue for me too. But why!?
--
",lovetingyuan,"
--
https://github.com/vuejs/vue/issues/9488#issuecomment-514985110
--

--
> The vue client plugin receives from webpack compilation stats a list of files that includes css maps, even when css maps are not emitted. The list is provided by webpack though [stats.chunks.files](https://webpack.js.org/api/stats/#chunk-objects). The [stats.assets](https://webpack.js.org/api/stats/#asset-objects) doesn't contain the css map files.
> 
> However, I am not sure why webpack is doing this.
> 
> Anyway, the client plugin is not robust to webpack inconsistent data.

Maybe souceMap in chunks is set by option: `devtool`.
--
"
9070,OPEN,match (getTypeIndex) is called lot of time when props changed and consume lot of memory,improvement,2018-12-02 20:52:34 +0000 UTC,Farkal,Opened,,"### Version
2.5.17

### Reproduction link
[https://codepen.io/anon/pen/MzpZoz?editors=1011](https://codepen.io/anon/pen/MzpZoz?editors=1011)





### Steps to reproduce
Open google chrome dev console  
Go in 'Memory' tab  
Select 'Allocation instrumentation timeline' and check 'Record allocation stacks'  
Launch for 30 seconds  
On your snapshot select 'Allocation' on the top left drop-down  
Order by 'Count'  
You will see high number of match called (a lot more than the actual var change)

### What is expected?
Expected to have match number closer to the number of var change.

### What is actually happening?
Match is executed lot of time and consume lot of memory.

---
I think it's the way i deal with the object that it's not the right way but i search in the doc and couldn't find something related to that behavior and how to manage it (perhaps use store ?).

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
9054,OPEN,Unexpected component destroyed trigger by sibling component,has workaround; improvement,2018-11-12 08:30:32 +0000 UTC,scmp-teddy-lok,Opened,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/teddy_scmp/2m6kv3rn/](https://jsfiddle.net/teddy_scmp/2m6kv3rn/)





### Steps to reproduce
1. Open console
2. click the TOGGLE bottom

### What is expected?
It is weird that the component between the two v-if will destroy and mount again

### What is actually happening?
1. AComponent is destroyed which is unexpected
2. BComponent will keep, which I only added a class there.

---
In addition, I find that DIV will cause this issue, if I added a class / change it to a tag / button, it won't destroy.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
it's because the div is being reused by Vue to create the TOP div.
You can get around it by adding a `key` to the div wrapping the component a or the TOP div.

--
",scmp,"
--
@posva 🙏 thanks a lot. The workaround works, it helps to prevent the bug in my project.
--
",,,,,,,,
9040,OPEN,Conditional template not rendering when it has the same slot name,has workaround,2018-11-15 05:33:30 +0000 UTC,jameslkingsley,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/ad17bgtq](https://jsfiddle.net/ad17bgtq)





### Steps to reproduce
1. Create a component that has a named slot exposing a boolean flag in its scope
2. Consume the component with two templates inside it, each with a v-if using the exposed boolean flag
3. Only the last template written in the order of code is rendered

### What is expected?
All templates using the same slot name should render when their v-if evaluates true.

### What is actually happening?
Only the last template written in the code order is rendered. Any other template with the same slot name will not render even if its v-if permits it.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,jameslkingsley,"
--
The work-around I'm currently using is to change the slot name based on the flag:

```html
<template :slot=""visible ? 'content' : 'content-x'"">
    ...
</template>
```
--
",handmadedigital,"
--
From a quick look I see you are binding the value prop to the `visible` attribute on the child component. But `visible` is a data attribute on the parent. 

`Vue.component('example', {
	props: ['value'],
	template: '<div><slot name=""content"" :visible=""value""></slot></div>'
})`

From my understanding slot-scope is needed when you are trying to use a data attribute that is in the child component from the parent, when passing in the scope. In this case you already have the `visible` data attribute accessible on the parent so you could do something like this. 
https://jsfiddle.net/0ockh2td/
--
",,,,,,,,
9038,OPEN,Throw error when using interpolation instead of JS expression for slot names,feature request; good first issue; has PR,2018-11-10 08:53:31 +0000 UTC,revolter,In progress,,"### What problem does this feature solve?
For this demo:

[https://jsfiddle.net/2os9jken/](https://jsfiddle.net/2os9jken/)

opening the console and running it throws the `Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead.` error for the `span`, but it should also throw it for the `slot`, as it has the exact same issue for its `name` attribute.

### What does the proposed API look like?
N/A

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Thanks for the proposal, the warning was meant for people coming from v1 where this was allowed. Personally, I don't think it is worth adding any more warnings regarding this as it will rarely help any user
--
",revolter,"
--
Well, old references still exist, and it's not that obvious for new users. It surely confused me in #9037.
--
",,,,,,,,
9034,OPEN,vnode reference to original component (reopened),feature request,2018-11-07 15:33:34 +0000 UTC,LukasBombach,In progress,,"### What problem does this feature solve?
Because we have to have lots of ads on our site we cannot hydrate our SSR'd page with VUE completely as the ads would break VUE. Also most of our site ist static and it would be stupid to ship our entire app for only some parts of our page being interactive.

Instead we **partially hydrate** the page (with our own plugin https://github.com/spring-media/vue-plugin-moisturizer). For this we need to map SSR'd HTML to the corresponding VUE components, so we need to put some `data-attribute` in the HTML match them. 

We use the `name` setting of a component for this,  so if I have component like this:

```js
{
  name: 'my-component'
}
```

the html would read

```html
<div data-hydration-name=""my-component"">...</div>
```


but this does not work for 3rd party components. Anything we get without that ID we cannot hydrate. It would be great if we could find the component from a component's instance / vnode.

There is a `cid` property, but this is not the same on the server and on the client,  because we have a different number and oder of components on the client and server so we cannot use this.

There is a similiar issue for this here: https://github.com/vuejs/vue/issues/7213 but one of your members suggested to create a new issue because the old one would just not show up under your pile of issues.

### What does the proposed API look like?
```js
this.$vnode.cuuid // hash based on the filename and path
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
Hi Lukas,

Nice idea you have going on with your moisturizer plugin!

Unfortunately, I think your proposal isn't really feasable:

```javascript
this.$vnode.cuuid // hash based on the filename and path
```

The reasoning is simple:

1. That id would have to be generated at build time (where we can actually know file paths through nodejs), not runtime (so even if possible it would be a job for  vue-loader, or an additional loader, not vue-core).
2. 3rd party components  can and regularly do come bundled in one file (e.g. `/dist/3rdPartyComponentCollection.umd.js`).
3. So if you have a 3rd party lib that exports a bunch of components, you possibly would end up with duplicate `cuuid` values.

That means that even if we can make it work, you will still end up not being able to identify 3rd party components reliably as soon as more than one comes bundled in a single file.

### Alternative Approaches

Have you thought about defining a name for the 3rd party components that you use yourself? 

Since [this code](https://github.com/spring-media/vue-plugin-moisturizer/blob/master/lib/hydrateComponents.js#L6-L9) seems to indicate that you know and control the collection of components you intend to ""moisturize"" this way, that seems like a viable path to take.

There's nothing wrong with doing this:
```javascript
import ThirdPartyComp1 from 'thirdparty-collection'

export default {
   ...ThirdPartyComp1,
   name: 'YourDesiredName'
})

// or even just:

ThirdPartyComp1.name = 'YourDesiredName'
export default ThirdPartyComp1
```

The above example expects `ThirdPartyComp1` to be defined as an options object, but a similar thing could be done to a component that's distributed as a constructor already.

And extending this thought you could even use something other than the `name` property (you can set any custom options on the options object, so you could add a `moisturizeId` to every component that you want to), which means you can leave the name untouched.
--
",LukasBombach,"
--
Ah ok, I understand that this cannot be done by filename / path. We _could_ attach names to each component manually, that would probably work, thank you! But that also means overhead for the developer. Particularly we are loading SVGs with the `vue-svg-loader` and it'd be quite annoying to give a name to each SVG. Still, this can be a fallback-scenario for us.

I am currently seeing into ways to fingerprint components, like this:

```js
function fingerprint(component) {
  if (component.name) return md5(component.name); // Components with a name
  if (component.render) return md5(component.render.toString()); // Functional components
};
```

What do you think about that and do you see other attributes that can be used to fingerprint a component?
--

--
Bonus question: Functional components have a render function. Compiled components have a render function. How do I get the render function for a component that has not been compiled yet. And how can I compile it to get the render function?
--

--
Bonus question 2: I found this in the debugger on the `$vnode`:

```js
{
  ""ssrContext"": {
    ""_registeredComponents"": [
      ""592f84f2"", ""cb0b8b00"", ""5ece1878"", /* ... */
    ]
  }
}
```

Seems to me like a mal op components that the SSR module knows about. Can this be made use of?
--
",,,,,,,,
9010,OPEN,SSR error during $style injection on cached components,,2021-01-23 09:18:31 +0000 UTC,henriqemalheiros,Opened,,"### Version
2.5.17

### Reproduction link
[https://github.com/henriqemalheiros/vue-ssr-cached-component-css-modules](https://github.com/henriqemalheiros/vue-ssr-cached-component-css-modules)





### Steps to reproduce
- `yarn install`
- `yarn run ssr:build`
- `yarn run ssr:start`
- Open `http://localhost:8000/`
- Refresh the page

The error is also reproducible in development mode with `yarn run ssr:serve`.

### What is expected?
The app should render properly, as it rendered before refreshing the page.

### What is actually happening?
```
error during render : /
TypeError: Cannot set property '$style' of undefined
    at CachedComponent_injectStyles (src/components/CachedComponent.vue:8:0)
    at hook (node_modules/vue-loader/lib/runtime/componentNormalizer.js:53:0)
    at c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:7467:15
    at c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:2487:40
    at c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:7465:11
    at c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:2487:40
    at renderComponent (c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:7463:7)
    at RenderContext.renderNode (c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:7418:5)
    at RenderContext.next (c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:2436:14)
    at cachedWrite (c:\[...]\vue-ssr-cached-component-css-modules\node_modules\vue-server-renderer\build.js:2295:9)
```

---
If you remove the `serverCacheKey` from the cached component and try again, the app renders properly.

Originally I thought this was a Nuxt related issue (nuxt/nuxt.js#3868). I then forgot about the issue, since I ditched component caching, but now I was able to find the time to reproduce it with plain Vue.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
Thanks for reporting this, we will have a look as soon as we can.
--
",iztsv,"
--
@LinusBorg do you have any news about the issue?
--
",anzolo,"
--
I have same issue :(
--
",andreynazarov3,"
--
any news?
--
",AntonMoskalchenko,"
--
It is very sad news that using ""nuxt"": ""2.11.0""  I still have the same bug
--
",v,"
--
any news?
--
"
8996,OPEN,Allow <noscript> in Vue templates for SSR usage,discussion; improvement,2020-12-08 15:23:24 +0000 UTC,brophdawg11,In progress,,"### Version
2.5.17

### Reproduction link
[https://codepen.io/brophdawg11/pen/OBdZyX](https://codepen.io/brophdawg11/pen/OBdZyX)


### Steps to reproduce
I'm opening this issue as a follow up to https://github.com/vuejs/vue/issues/8247, as I don't think the solution provided there is suitable for all use-cases.  In a fairly simple UI, where everything is relatively positioned and flows downward, it would likely be fine to include `<noscript>` outside the context of the Vue application, and it would render correctly above the entire app.

However, there are plenty of other UI's that it may not be desirable or feasible to include `<noscript>` _outside_ of the Vue application context and display it properly.  The linked codepen shows a simple fixed-header layout, where including the `<noscript>` tag outside the Vue application context results in the `<noscript>` tag being hidden _behind_ the fixed header, where in reality it is intended to be rendered inside the main body content, and thus below the fixed header.  

The `<noscript>` outside the Vue context also has the unintended effect of pushing down the main content, which has a proper margin-top to account for the static-height fixed header.

Per MDN, `<noscript>` is Flow Content (https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Flow_content), it is perfectly viable to exist outside the `<head>` (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript), and is perfectly valid to nest inside the DOM in a `<div>`, as div's allow Flow Content as their children (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div).

Please reconsider the decision to not permit `noscript` tags in Vue templates.

### What is expected?
`<noscript>` elements should render properly in Vue templates

### What is actually happening?
`<noscript>` elements do not render properly in Vue templates and cause hydration issues when in SSR

<!-- generated by vue-issues. DO NOT REMOVE -->",,,brophdawg11,"
--
As a workaround, we are currently doing the following, but it feels quite hackish:

```
<template> 
    <main>
        <div v-once v-html=""noscriptHtml"" />
        ...
    </main
</template>

<script>
export default {
   ...
    created() {
        this.noscriptHtml = '<noscript>...</noscript>';
    }
};
</script>
```

--

--
Sorry, it's not super clear in the description here - but the linked/closed issue is specific to using SSR with Vue, as is my case.  With JavaScript disabled - we still SSR a perfectly valid page.

The problem is that we include `noscript` tags for when the browser _doesn't_ have JavaScript enabled.  But Vue's inability to render them client side breaks browsers that _do have_ JavaScript enabled (insofar as hydration fails and a full re-render is performed).
--

--
I disagree.  What the code pen is showing is that with a fixed header UX, it is not feasible to put the noscript tag in the index.html template, completely outside of the Vue app.  It must be part of the app in order to be displayed to the user in a meaningful location.

And redirecting to a separate page defeats the purpose of allowing users with JS disabled to browse and use the site.  If the site is already 100% user friendly with JS disabled, why would we redirect instead of showing a message that some advanced UI functionality might not work, but core browsing and usage will be fine.

What is the reasoning behind Vue templates supporting only a subset of valid HTML markup?  One of the major advantages of SSR is that is opens up the possibility of using Vue and not giving up support for JS disabled users.


--
",alexbruno,"
--
I don't know, but I think it doesn't make sense.

`<noscript>` is for disabled Javascript on the browser. And, Vue apps are just Javascript. So, if Javascript is disabled, Vue templates don't works.

So, `<noscript>` needs to stay out of Vue and should be in vanilla HTML.
--

--
Ok, even with SSR, Vue components are not place for `<noscript>`. If you want to prevent errors when browser Javascript is disabled, write a global `<noscript>` in the `index.html`.

If you want to show an user friendly content, put a `<meta>` redirect into `<noscript>` and head to a static vanilla HTML page.

It makes more sense.
--

--
None of these are necessary.

```html
<form @submit.prevent='ajaxSubmit'>
  ...
  <button type='submit'>Submit</submit>
</form>
```

If JS is enabled, Vue capture the event. Else, native HTML action will happen.
--

--
In fact, `noscript` is like an HTML native hack in modern web!
For today web apps, disabled JS is **very** uncommon.
--

--
Ok @bpossolo and @AndrewBogdanovTSS  , I think it is surprising that someone needs this markup in modern frontend applications.
But there is a lot of mentions about SSR and SEO here...
Maybe, for SSR someone would find a use for `noscript`, but SEO is not the case since years ago.
Google Developer docs says that Google Search Engine is able to load, render and crawling from websites built with JS frameworks with dynamic content since 2015.
That said, I can't understand where is the SEO needs for `noscript`.
So, @bpossolo and @AndrewBogdanovTSS , I'm sorry if my web dev competence is very limited to contribute, despite my 10 years of experience.
--

--
@AndrewBogdanovTSS I can't forbid anyone to use anything (maybe my children 🤣 ) !
I'm just trying to say that maybe it is not critical to have it.
Maybe there are better ways to develop Vue apps to doesn't need `noscript`.
Like this:

https://developers.google.com/search/blog/2015/10/deprecating-our-ajax-crawling-scheme.html
https://developers.google.com/search/blog/2014/05/understanding-web-pages-better

But, I want to apologize again if I can't be able to see your needs.
--
",tmorehouse,"
--
Using the redirect described above would also not be very good for SEO
--

--
@Sevensidedmarble @brophdawg11 

Here is a simple workaround using Vue's `<component>` component (which doesn't feel too ""hacky""):

```html
<component is=""noscript"">
  <p>No Script Content Here</p>
</component>
```

This will let you get around Vue's constraints on the `<noscript>` tag (also works for rendering `<style>` tags as well)

You could even make it conditional for rendering on the server generated pages only (and clients/cralwers with javascript disabled will still see it):

```html
<component v-if=""$isServer"" is=""noscript"">
  <p>No Script Content Here</p>
</component>
```

--

--
Here is a quick component for creating a `<noscript>` (as an alternative to using `<component is=""noscript"">`).

Note that render functions allow you to use tags that vue-loader normally filters out:

```js
export default {
  name: 'NoScript',
  functional: true,
  render(h, { data, children }) {
    return h('noscript', data, children)
  }
}
```

And then use it like so:

```html
<no-script>
  <p>JavaScript you have not. Hmmm.</p>
</no-script>
```
--

--
@dozyio you could have a `<div>` rendered SSR, and then when mounted set it's display to none:

```html
<template>
  <infinite-loading @infinite=""infiniteHandler"" spinner=""spiral"">
    ...
  </infinite-loading>
  <div v-show=""showPager"">
    <Pager :info=""$page.posts.pageInfo"" />
  </div>
</template>

<script>
export default {
  data() {
    return {
      showPager: true
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.showPager = false
    })
  }
}
</script>
```

If Javascript is not enabled on the client, then the pager link will remain visible.
--
",AlbertMarashi,"
--
I don't see why `<noscript>` shouldn't be allowed in vue. 

Obviously, it makes no sense in the client-side **but if you are using SSR** to provide html & css to the client, it's an incredibly **useful feature**
--
",Antoine,"
--
@alexbruno It makes sense to have noscript in component in some case : like SEO (one of the main purpose of SSR provided by Vue).

If you lazy-loading image you can have a component like that :

``` html
<div class=""lazy-image-component"">
  <img :src=""inView && src""  />

  <noscript inline-template>
    <img :src=""src"" />
  </noscript>
</div>
```

In this case it's important for the `img` tag contain in noscript to be at this place for better UI integration.

--
",mwidmann,"
--
One small caveat, should anybody come here in search for a solution for `noscript`. The children of the `<noscript/>` are not rendered if it is inside a conditional.

```html
<div>
    <noscript inline-template>
        <span>OMG</span>
    </noscript>
</div>
```

sends `<noscript><span>OMG</span></noscript>` to the client

```html
<div v-if=""someTrueCondition"">
    <noscript inline-template>
        <span>OMG</span>
    </noscript>
</div>
```

sends an empty `<noscript>` tag.
--
"
8976,OPEN,v-enter class is removed immediately when using animation transition,,2020-07-30 05:22:31 +0000 UTC,Tae69,Opened,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/u9wryh32/2/embedded/result/#Result](https://jsfiddle.net/u9wryh32/2/embedded/result/#Result)





### Steps to reproduce
1. Click 'toggle' button
2. When the text component is still animating, inspect its class
3. Got ``bounce-enter-active`` instead of ``bounce-enter bounce-enter-active``

### What is expected?
It will have ``bounce-enter bounce-enter-active`` class

### What is actually happening?
It only has ``bounce-enter-active`` class

---
The docs stated
>CSS animations are applied in the same way as CSS transitions, the difference being that v-enter is not removed immediately after the element is inserted, but on an animationend event.

https://vuejs.org/v2/guide/transitions.html#CSS-Animations

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
@chrisvfritz @yyx990803 aren't the docs inaccurate here? To me it would make sense the v-enter class to also be removed on animations (or even to not get applied at all)
--
",chrisvfritz,"
--
@sdras What are your thoughts on this (having probably built more animations than the rest of us combined)? 😄 What behavior would you expect?
--
",yuzhihang,"
--
got the same problem, is there any one explain it?
see also
https://forum.vuejs.org/t/v-enter-class-is-removed-immediately-when-using-animation-transition/46368
--
",bangbangde,"
--
我也遇到了这个问题，很疑惑为什么这个问题到现在还没有被处理
--
",,,,
8969,OPEN,'inject' Properties are not added to the CombinedVueInstance type definition,typescript,2021-01-23 13:31:08 +0000 UTC,StormBurpee,Opened,,"### Version
2.5.17

### Reproduction link
[https://codesandbox.io/s/rr18r3vm9p](https://codesandbox.io/s/rr18r3vm9p)





### Steps to reproduce
1. Copy Minimal reproduction link into a local environment, and run the webpack compilation process.

**OR**

1. Initialize a vue vm
```typescript
let vm = new Vue({
    el: ""#app"",
    render: (h: any) => h(someComponent, {}),
    provide: { service: { something: ""Hello, World"" } }
});
```
2. Try and access service in a SFC

```typescript
export default Vue.extend({
    name: ""someComponent"",
    inject: [""service""],
    data() {
        return {
            accessService: this.service.something // Property 'service' does not exist on type CombinedVueInstance...
        }
    }
});
```

### What is expected?
When declaring injections in a component in typescript, you should be able to access the injection with `this.injection`

### What is actually happening?
When accessing an injection in a vue single file component, it is currently throwing an error during the webpack compilation process, stating that the injection `Property 'injection' does not exist on type 'CombinedVueInstance<Vue...`

---
**Please note:** that the link to minimal reproduction won't show the error logs from the webpack compiling, as it will compile successfully, but with errors. This will need to be tested in a local environment to see what is happening. 

As this is in typescript, we're currently using Webpack to compile it to a single file, and then use this on our application.

The compilation will complete successfully, however will print multiple errors to the console after compiling, about not being able to access properties, etc. When running in the browser it works successfully.

We've dug around in the `vue/types` folder, and to the best of our knowledge think that Inject should be a part of the `type DataDef` or something of this sort.

Is there possibly a temporary workaround that we can use to avoid having these errors, until a fixed release is proposed?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,XLearner,"
--
Yep, I come across a similar question. I have written the property ""provide"" in father vue-component and have used ""inject"" in son vue-component, but the chrome console show:  [Vue warn]: Injection ""color"" not found.   Here is my sectional code.

/********** parent **********/
...
export default {
    name: ""father"",
    provide: {
      color: 'blue'
    },
    components: {
      son
    },
...
/********** son **********/
...
export default {
    name: 'pagesTable',
    inject: ['color'],
    mounted(){
        console.log(this.color);
    }
}
...
------------------------------------------------------------------------
And then 
![image](https://user-images.githubusercontent.com/26158725/66902065-94621e00-f032-11e9-80ad-51d46f9e0bf9.png)



--
",filimon,"
--
Any news on this?
--
",klinkby,"
--
Issue open >1 year. Does that mean DI is not supported with TypeScript?
--
",wllmsash,"
--
I'm working around this by modifying Vue in my component. Example:

```typescript
// main.ts

import Vue from 'vue';
import App from './App.vue';

export interface Collection {
  dog: string;
  cat: number;
  cow: boolean;
}

const myCollection: Collection = {
  dog: 'dog',
  cat: 0,
  cow: false,
};

export const myServices = {
  api: 'api',
  auth: {
    do: 'something',
  },
};

new Vue({
  render: h => h(App),
  provide: {
    ...myCollection,
    ...myServices,
  },
}).$mount('#app');
```

```typescript
// src/helpers/vue.ts

import { VueConstructor } from 'vue';

export function makeInjector<TProvider>() {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return function<V extends Vue, K extends keyof TProvider>(v: VueConstructor<V>, properties: K[]) {
    return v as VueConstructor<V & Pick<TProvider, K>>;
  };
}

export function makePropertySelector<TProvider>() {
  return function<K extends keyof TProvider>(properties: K[]) {
    return properties;
  };
}
```

```typescript
// src/components/my-component.vue

import Vue from 'vue';
import { makeInjector, makePropertySelector } from '../helpers/vue';
import { Collection, myServices } from '../main';

// use a type ...
const collectionPropInjector = makeInjector<Collection>();

// ... or typeof
const serviceInjector = makeInjector<typeof myServices>();

// use propertySelector to reuse across injector and inject
const injectServices = makePropertySelector<typeof myServices>();
const services = injectServices(['auth']);

// add properties from one or many types to this Vue instance ...
export default serviceInjector(collectionPropInjector(Vue, ['dog', 'cat']), services).extend({
  // ... and inject properties as normal here
  inject: ['dog', 'cat', ...services],
  created() {
    console.log(this.dog); // 'dog'
    console.log(this.cat); // 0
    console.log(this.cow); // undefined

    console.log(this.api); // undefined
    console.log(this.auth.do); // 'something'
  },
});
```

Works with VSCode Intellisense as well.
--
",shivam,"
--
Been facing the same issue with my TypeScript project. I resorted to use `$parent` and methods in subcomponents to be accessed in descendent component. Would really appreciate if I could use DI with TypeScript.
--
",,
8926,OPEN,Child transitions are triggered when the parent element is hidden,,2018-10-11 01:33:13 +0000 UTC,BryceBarbara,Opened,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/BryceBarbara/kv7espnq/](https://jsfiddle.net/BryceBarbara/kv7espnq/)

### Steps to reproduce
1. Click the ""Toggle Screen"" button.
2. See that the first screen's content is faded out while the second screen's content is already visible.

### What is expected?
I would expect the transition to not trigger due to the fact that the parent has been hidden and does not have a transition on it.

### What is actually happening?
The child element on the first screen is faded out after the second screen's content is already visible.

---
I assume this is some sort of element re-use situation because adding a key to either the first or second screen elements fixes it. I'm reporting this mainly to call attention to something that doesn't _seem_ intentional and that has very little information on it.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is indeed a caveat related to element reuse. It's necessary to provide a key to the outer div. I'm not even sure if we could document this properly tbh :/
--
",resolritter,"
--
Could this be attempted to be solved with some conditional disposing code through updateChildren https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L405 or patchVnode https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L502? Perhaps a way to mark that the node should not have its own transition hooks triggered if the parent context has been replaced and/or is not part of the same transition group.
--
",,,,,,,,
8912,OPEN,A deliberately empty slot-scope attribute will not be rendered as a scoped slot,improvement,2019-11-20 12:36:54 +0000 UTC,decademoon,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/decademoon/50wL7mdz/759740/](https://jsfiddle.net/decademoon/50wL7mdz/759740/)





### Steps to reproduce
```
<foo>
  <bar slot-scope/>
</foo>
```

### What is expected?
`<bar slot-scope>` should be a scoped slot.

### What is actually happening?
`<bar slot-scope>` is rendered as a child as if `slot-scope` were not present.

---
As a workaround, I've been using a dummy variable to force it to be a scoped slot:

```<bar slot-scope=""scope""/>```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I'm pretty sure we talked about this in another issue but couldn't find it 🤔 
--
",basselAhmed,"
--
Hi @decademoon I'd like to pick this up, can you check this sandbox and tell me if it's the correct behavior for your use case?
https://codesandbox.io/s/4q15jlq12w
--

--
Thanks, I'll create a PR for this shortly.
--
",smolinari,"
--
For my curiosity, what is the use case for doing this?

Scott
--

--
Um, can you expand that with a real world example, maybe even with code? I'm still not understanding. Sorry. And thanks for being patient with me.

Scott
--

--
Thanks. With the breadcrumb separator use case, this issue now makes sense. 

Scott
--
",decademoon,"
--
@basselAhmed Yes that appears to be correct.

@smolinari One example is the `Foo` component may want to render the slot multiple times, in which case the slot needs to be scoped in order for it to be a function which will return a different vnode instance each time it is called.
--
",Justineo,"
--
@smolinari See #8496. Currently Vue doesn't allow a slot to be rendered more than once, the workaround for now is using a scoped slot without meaningful scope arguments.
--
",WORMSS,"
--
> @smolinari See #8496. Currently Vue doesn't allow a slot to be rendered more than once, the workaround for now is using a scoped slot without meaningful scope arguments.

Is that true? Because if you add two default slots, it's rendered twice. (Which I am trying to actually not happen)
--
"
8895,OPEN,"Non-breaking space acts different than other characters - outputs ""&nbsp;"" in template when passed via props",bug,2020-12-24 14:35:17 +0000 UTC,Eibx,In progress,,"### Version
2.5.17


### Reproduction link
https://codepen.io/avertes/pen/LYYpNRe
[https://jsfiddle.net/50wL7mdz/756973/](https://jsfiddle.net/50wL7mdz/756973/)





### Steps to reproduce
1. Create a new component that accepts a string prop.
1. Display the prop within the component's template.
1. Use the component in a Vue application and pass a string containing a non-breaking space character for the prop.

### What is expected?
The output should contain a non breaking space

### What is actually happening?
The output shows `&nbsp;`

---
In the example provided I've made 3 cases

- First case is that `&#160;` get turned into `&nbsp;`
- Second case is that in a long list of UTF-8 characters only `NON-BREAKING SPACE` is escaped.
- And third when getting the same list of characters, but retrieving it from a regular `HTMLElement` with `document.querySelector('#test').title` the character aren't escape.


**Note**: When copying the non-breaking space character it might turn into a regular space in the clipboard. Therefor use https://en.wikipedia.org/wiki/Non-breaking_space#Keyboard_entry_methods to make sure how to insert the character.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Eibx,"
--
I've added a new example - where in a list of html entities (including other whitespace and zero width characters) - only `&nbsp;` not decoded.

- https://jsfiddle.net/50wL7mdz/765399/

Also I've noticed that in [mathiasbynens/he](https://github.com/mathiasbynens/he/) there are two entries for `&nbsp;` one without simicolon and one with simicolon. 

- https://github.com/mathiasbynens/he/blob/master/data/entities.json#L1470

Might be a shot in the dark, but could this have any influence on the result above?
--

--
I've tried using [mathiasbynens/he](https://github.com/mathiasbynens/he/) v1.1.1 to find any inconsistencies with `&nbsp;`, but haven't been able to find any.

I've tried duplicating my previous jsfiddles, to see if `&nbsp;` would react any different.
- https://jsfiddle.net/ebpcx1do/3/

If anyone can give me some pointers for where to look for this error, I'm more than happy to give it a shot.

I would also very much appreciate any response on issue.


--

--
Yeah - it does seem to be related the way Vue parses html attributes in general.

I've made a similar example based of @approached example
https://jsfiddle.net/onbzk0m6/3/





--
",rosrosros,"
--
Looks like a bug to me - a fix would be nice 
--
",tmorehouse,"
--
Ive noticed issues with `&times;` on occasion.  say a component prop has a default of `&times;`, which is rendered in the component (v-html). When rendering it shows the actual `x` character and causes an SSR hydration bail.
--
",approached,"
--
Other example: https://jsfiddle.net/onbzk0m6/ (character &nbsp;)
--
",grreeenn,"
--
as a workaround, try to put the JS escape code for `&nbsp;` - `\xa0`

found [here](https://github.com/kazupon/vue-i18n/issues/318#issuecomment-380103519), worked for me in nonbreakinspacification function
```
    public static noBreakingSpaces(str: string): string {
        return str.replace(' ', '\xa0');
    }
```
strings returned by this function are being rendered with `&nbsp`s instead of spaces.
--
",styxxx,"
--
I stumbled upon the same issue: The html entity &shy; results in""&shy;"" as text when used in templates instead of the soft hyphen. The same for ""&#173;"" and others.
Vue 2.6.10
--
"
8884,OPEN,An API to allow replacing observer implementation with alternative implementation,,2018-10-03 22:29:40 +0000 UTC,mitar,In progress,,"### What problem does this feature solve?
This is a followup to https://github.com/vuejs/vue/pull/4652. For integration of Vue with existing Tracker-based Meteor apps, one approach how to assure fur compatibility is to implement Tracker on top of observer implementation. This has been proven to work great with 2.x version and it just needed a bit more access to Vue observer internals than what was already available.

I would suggest that in 3.x there is a simple way to register an alternative Vue observer implementation. In this way 3rd party libraries could extend new Vue observer implementation with additional things and then register it back for Vue to use it.

### What does the proposed API look like?
It could be something as simple as `Vue.useReactivity(module)`. It would be on `module`'s author to assure that the alternative implementation is compatible and works well with Vue.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
> I would suggest that in 3.x there is a simple way to register an alternative Vue observer implementation. 

In Vue 3.0, we will indeed implement the new, proxy-based Observer implementation as an independent package, and also implement an alternative version which uses the getters/setters based Reactivity system from 2.0 (for IE compatibility)

So something like this will likely be possible, though the details are still under consideration.
--
",mitar,"
--
In fact I am more interesting in hooking into underlying observe logic. Not so much how it is exposed (through proxy or other means). But probably it can be the same thing. Generally it is more or less something like ""every time X gets invalidated, also call this extra code, and when Y gets rerun, call this as well"".
--
",,,,,,,,
8878,OPEN,Functional component not rendering named slot (following #8871),has workaround,2019-07-02 07:12:58 +0000 UTC,nicolas-t,Opened,,"### Version
2.5.17

### Reproduction link
[https://codesandbox.io/s/p9mx85qpz0](https://codesandbox.io/s/p9mx85qpz0)





### Steps to reproduce
nothing in particular.

### What is expected?
It should display `Hello World`  

### What is actually happening?
It displays `Hello`

---
Following https://github.com/vuejs/vue/issues/8871 I made App.vue non-functional: 

If you make Child.vue non-functional it works: https://codesandbox.io/s/pw5lzx2w90

If you use default (not named) slots it works: https://codesandbox.io/s/04jrp3y4ln

<!-- generated by vue-issues. DO NOT REMOVE -->",,,murr4y,"
--
Responded on the Vue Forum as well, is this maybe the same issue as in #7587?

It works by using a scoped slot:
https://codesandbox.io/s/0p96w8o1pw
--
",joedski,"
--
I've been running into this for a little while now, trying to make a simple functional component to use with values created by daggy.js.

I've created [a codesandbox thingy with a number of cases showing the effects of this](https://codesandbox.io/s/7yx4zl839q).

Peeking at the VNodes being created during the render call, the issue seems to be caused by the root element of a named unscoped slot passed to a functional component still having `data.slot` on its VNode when that VNode is returned by the functional component.

Example results of using a named, unscoped slot with a plain DOM node:

```
Render Template:
  transition[name=overlay-fade]
    my-functional-component
      div.busy-overlay[slot=waiting]
        spinner

VNode: transition[name=overlay-fade]
  tag: 'vue-component-19-transition'
  children: undefined
  componentOptions:
    tag: 'transition'
    children: [
      VNode: div.busy-overlay[slot=waiting]
        tag: 'div'
        data:
          slot: 'waiting'
        children: [
          VNode: spinner
            tag: 'vue-component-25-spinner'
            children: undefined
            componentOptions:
              tag: 'spinner'
        ]
    ]
```

Compare this to the use of a template tag as the slot root:

```
Render Template:
  transition[name=overlay-fade]
    my-functional-component
      template[slot=waiting]
        div.busy-overlay
          spinner

VNode: transition[name=overlay-fade]
  tag: 'vue-component-19-transition'
  children: undefined
  componentOptions:
    tag: 'transition'
    children: [
      VNode: div.busy-overlay
        tag: 'div'
        data:
          slot: (not present)
        children: [
          VNode: spinner
            tag: 'vue-component-25-spinner'
            children: undefined
            componentOptions:
              tag: 'spinner'
        ]
    ]
```

The exact component used to wrap the functional component doesn't matter, as demonstrated in the codesandbox example at the top of this post, I just ran into this using the Transition component most recently, hence the appearance of `transition` in the outlines above.

For now, I'm going to stick to wrapping the contents of slots in `<template>`s.  I may also add a wrapper function for getting normalized slot contents in functional components.
--
",why06,"
--
I've ran into this issue too. Seems to only occur when a functional component wraps another functional component.
--
",MrJmpl3,"
--
I have same problem, When a functional component wraps another functional component.
--

--
> there should be an anwser you want here
> #7587

Ok, can be a solution , but I use SFC functional with default slot: 
```js
<template functional>
</template>
```
--
",moonRider,"
--
there should be an anwser you want here
#7587
--
",posva,"
--
In this specific scenario, the `Parent` component should be written like this:

```js
  render(h, context) {
    context.data.scopedSlots = {
      username: () => h('span', {}, 'World')
    }
    return h(Child, context.data, [])
  },
```

I think we may need to adapt the functional component to allow passing a child with a `slot` attribute:

```js
  render(h, context) {
    context.data.scopedSlots = {
      username: () => h('span', {}, 'World')
    }
    return h(Child, context.data, [
      h('span', { slot: 'username' }, 'World')
    ])
  },
```

@nickmessing I imagine the jsx plugin transforms into this because it has no way of knowing if `Child` is functional or not
--
"
8876,OPEN,Binding the bind directive and change events to the <input/> tag doesn‘t work,has workaround,2018-12-12 00:03:17 +0000 UTC,rhliu228,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/MoriGirl/50wL7mdz/755097/](https://jsfiddle.net/MoriGirl/50wL7mdz/755097/)





### Steps to reproduce
Enter two numbers less than 10(etc, 7 , 8) in succession twice, observe page display and console output.

### What is expected?
I originally expected the page and console to display 10 after each input.

### What is actually happening?
When I input numbers less than 10 for two consecutive times, such as ( 7, 8 ), it was observed that after the first input, the page and console display 10 at the same time, but after the second input, the page displays 8 and the console displays 10.

---
## reluctant solution
1. Get the native input element and modify its value

   *  use ref   
```
<input  :value='num' @change='handleChange' ref='inputnumber' />
...
handleChange(event){
   this.num=this.check(event.target.value);
   this.$refs.inputnumber.value=this.num;
}
``` 
   *  use event  

```
handleChange(event){
    this.num=this.check(event.target.value);
    event.target.value=this.num;
}
```
but if I replace the input element with a custom component, this may not work.
2.  use both v-model and watch
```
<input  v-model.lazy='num' />  //.lazy: Data synchronization using the change event
...
watch:{
    num:function(v){
      	this.num=this.check(v);
    }
},
```

I want to know why such  outputs appear and if there is a better solution.
Thank you！

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Probably a race condition here.
You can get around it by doing `this.$forceUpdate()` after setting `this.num`
--
",rhliu228,"
--
> Probably a race condition here.
> You can get around it by doing `this.$forceUpdate()` after setting `this.num`

Good idea.Thank you!
--
",rjmill,"
--
You're using `v-bind:value` on your input element. The input element can't mutate the Vue instance's reactive data on its own. As far as the Vue instance is concerned, the second time the user sets the input to a number less than 10, the value of `this.num` doesn't change. It was already set to 10, and it is being set to 10 again.

To illustrate, try adding the line ```this.num = event.target.value``` to the beginning of `handleChange` in your fiddle. That will make it work as expected, because `this.num` is set to a number less than 10, and then it's set to 10, triggering the update.

This is effectively the same as your second relucatant solution: The change event is emitted, the value of `this.num` is set to a number below 10, then `this.num` is immediately set to 10.

Depending on what you're going for, there are a few different options: Your second reluctant solution with `v-model.lazy` most closely resembles the behavior you're looking for. If you don't feel comfortable with `this.num` getting set to a string before the watcher casts it to a number with `this.check`, you can use the [`.number`  modifier for `v-model`](https://vuejs.org/v2/guide/forms.html#number).

You can also use two separate data properties: one to use as a `v-model` on your input, and another that you set the value of whenever you change/submit that input field. Since `v-model` will keep the `value` of your input in sync with the data property you've bound it to (by listening to the `input` event instead of `change`), you won't have to guess the value being held in Vue's reactivity system.

The Vue cookbook has a [section on form validation](https://vuejs.org/v2/cookbook/form-validation.html) that you might find interesting as well.
--
",,,,,,
8855,OPEN,Check if tag is already in the window.customElements registry on top of checking config ignoredElements,feature request; improvement,2019-04-24 20:48:25 +0000 UTC,halybee,Opened,,"### What problem does this feature solve?
When Vue is mounting, the function `isUnknownElement` is called and checks, among others, whether the element tag is in the list of `ignoredElements`. In the context of an app that uses multiple web components, we don't want to manually add every new component's tag to the `ignoredElements` list. Maintaining that list could quickly become a headache. If the  `isUnknownElement` also checks the custom elements registry, it could figure out that the element in question is not necessarily unknown.

### What does the proposed API look like?
The API would stay the same, but on top of checking for `config.ignoredElements` in the function `isUnknownElement`, we would also check if `window.customElements.get(vnode.tag)` is defined or not. If it is defined, then we return false.

I am happy to submit a pull request, I just wanted to discuss this first to make sure there aren't design constraints to adding something like this.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,DaKoala,"
--
I want to work on this issue.
--
",,,,,,,,,,
8831,OPEN,Using multiple selects with v-model and bound and unbound values causes value overriding,bug; has workaround,2018-09-24 06:50:12 +0000 UTC,KelsamGames,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/du578xc0/32/](https://jsfiddle.net/du578xc0/32/)





### Steps to reproduce
change first select to ""Some"", then change newly displayed select. You will see that val2 is being set to the bound vals from the val1 select instead of it's own values.

You can change the first select to use the .number modifier on the v-model and exchange the bound number values for strings to fix this issue. (at least for this very specific desired effect).

You can ""fix"" the problem by either using v-bind:value on all values, or by using non-bound values on all values - but as far as I can tell, if you mix them, then it will cause this override bug

### What is expected?
different values for each variable

### What is actually happening?
second variable is being overwritten with the first's value

---
This was posted/discussed in the discord chat

<!-- generated by vue-issues. DO NOT REMOVE -->",,,lbogdan,"
--
As I said on Discord, this is not really a bug, but related to how Vue is reusing DOM elements when re-rendering on state changes. In this particular case, the select and the first two of its options are reused, and for some reason (ok, this might be a small bug 🙂 ) the `<option>`s remain bound to their initial values. There's two ways you can fix this:
- bind the values in the second select, too: https://jsfiddle.net/du578xc0/49/ , or
- use a distinct key on the `<select>`s, to explicitly tell Vue not to reuse them: https://jsfiddle.net/du578xc0/51/ .
--
",KelsamGames,"
--
Use of the key attr is the perfect solution to this, thank you!
--
",,,,,,,,
8829,OPEN,On SSR; do not escape RAW nodes,improvement,2018-12-13 20:52:43 +0000 UTC,,Opened,,"### What problem does this feature solve?
When rendering a script tag on server the content is escaped, breaking the js code.

```html
<script>
  var x = ""y"";
</script>
```

is rendered as 

```html
<script>
  var x = &quot;y&quot;;
</script>
```


### What does the proposed API look like?
A solution would be to allow users to define what to be escaped, to override this map

https://github.com/vuejs/vue/blob/833175e9d6e8f47367e49e1752cd149a677cdae8/src/platforms/web/server/util.js#L43

Or a option to disable escaping et all here 

https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/server/optimizing-compiler/codegen.js#L228

Thanks.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Your components should not include script tags. There is even a Vue error/warning for that
If you are talking about something else, could you please provide a small repro?
--
author:	
association:	none
edited:	false
status:	none
--
When using Vue for SSR only(without intention to hidrate) i surely can use scripts and styles in templates.

See the condition for that error to appear:
https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/compiler/parser/index.js#L133

Here is the repro
https://runkit.com/sleewoo/5ba897abdcb0ef0012e77a49

<img width=""600"" alt=""screen shot 2018-09-24 at 10 59 23 am"" src=""https://user-images.githubusercontent.com/9264860/45941901-efb90c80-bfe8-11e8-9e8d-6a5a3bff7734.png"">

--

--
When using Vue for SSR only(without intention to hidrate) i surely can use scripts and styles in templates.

See the condition for that error to appear:
https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/compiler/parser/index.js#L133

Here is the repro
https://runkit.com/sleewoo/5ba897abdcb0ef0012e77a49

<img width=""600"" alt=""screen shot 2018-09-24 at 10 59 23 am"" src=""https://user-images.githubusercontent.com/9264860/45941901-efb90c80-bfe8-11e8-9e8d-6a5a3bff7734.png"">

--
author:	posva
association:	member
edited:	false
status:	none
--
mmh, true, was added at https://github.com/vuejs/vue/pull/3425
--
author:	
association:	none
edited:	false
status:	none
--
thanks

--
author:	
association:	none
edited:	false
status:	none
--
turns out that even when i disable the escaping entirely here, 
it still escapes the quotes if there are `{{ something }}` in the script

https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/server/optimizing-compiler/codegen.js#L228

--
author:	
association:	none
edited:	false
status:	none
--

```html
<div>
  <script>
    var x = ""y"";
    var a = ""{{ something }}"";
  </script>
</div>
```

is rendered like

```html
<div data-server-rendered=""true""><script>
    var x = &quot;y&quot;;
    var a = &quot;something&quot;;
  </script></div>
```

--
",nbaulesglobalsolutions,"
--
mmh, true, was added at https://github.com/vuejs/vue/pull/3425
--
author:	
association:	none
edited:	false
status:	none
--
thanks

--
author:	
association:	none
edited:	false
status:	none
--
turns out that even when i disable the escaping entirely here, 
it still escapes the quotes if there are `{{ something }}` in the script

https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/server/optimizing-compiler/codegen.js#L228

--
author:	
association:	none
edited:	false
status:	none
--

```html
<div>
  <script>
    var x = ""y"";
    var a = ""{{ something }}"";
  </script>
</div>
```

is rendered like

```html
<div data-server-rendered=""true""><script>
    var x = &quot;y&quot;;
    var a = &quot;something&quot;;
  </script></div>
```

--
author:	nbaulesglobalsolutions
association:	none
edited:	false
status:	none
--
Guys thank you for the help I really appreciate it. But pls note that I have little or next to no knowledge on programming or coding..

Anyways SW, is the code something I can just cut and paste or share?

Thanks



NBaules

Get Outlook for iOS<https://aka.ms/o0ukef>

________________________________
From: Slee Woo <notifications@github.com>
Sent: Tuesday, September 25, 2018 9:28 PM
To: vuejs/vue
Cc: Ngerikl Baules; Manual
Subject: Re: [vuejs/vue] On SSR, do not escape RAW nodes (#8829)


<div>
  <script>
    var x = ""y"";
    var a = ""{{ something }}"";
  </script>
</div>

is rendered like

<div data-server-rendered=""true""><script>
    var x = &quot;y&quot;;
    var a = &quot;something&quot;;
  </script></div>

—
You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub<https://nam02.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Fissues%2F8829%23issuecomment-424340963&data=02%7C01%7C%7C4b441f57a06a432f355308d622ead0ed%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636734789245204018&sdata=nRrAVbBJF3mGEoejWNuPIFF%2F1O2MBfv0OTVqg3PFFPA%3D&reserved=0>, or mute the thread<https://nam02.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAQTcduA6bPu9d8_qLFh4djy6aPlw2ZyLks5uei-LgaJpZM4W100r&data=02%7C01%7C%7C4b441f57a06a432f355308d622ead0ed%7C84df9e7fe9f640afb435aaaaaaaaaaaa%7C1%7C0%7C636734789245204018&sdata=kYSai4X53Ikx4HFO3zLRQM6qACsJPDrrX80k%2F5pr%2FYM%3D&reserved=0>.

--
author:	
association:	none
edited:	false
status:	none
--
so this time is `vue-server-renderer`

replacing this
https://github.com/vuejs/vue/blob/3d36a443c755bf16f2656a8595dda9076f021a4a/src/server/optimizing-compiler/runtime-helpers.js#L21

with

```js
_ssrEscape: (s) => s,
```

will disable escaping and render valid script

--
author:	
association:	none
edited:	false
status:	none
--
@yyx990803 can you please take a look,
for sure you have a better idea how to address this issue,
thanks

--
author:	
association:	none
edited:	false
status:	none
--
here is a new repro - https://runkit.com/sleewoo/5c12c6621c8e9f0014a02e7a

--
",,,,,,,,
8825,OPEN,Non-Deterministic CSS ordering for extracted CSS in an SSR App,,2019-03-16 17:29:45 +0000 UTC,brophdawg11,In progress,,"### Version
2.5.17

### Reproduction link
[https://github.com/brophdawg11/vue-ssr-css-ordering](https://github.com/brophdawg11/vue-ssr-css-ordering)

### Steps to reproduce
Reproduction steps are outlined in the README in the github repo.

### What is expected?
In both development and production builds, the extracted CSS stylesheets should be loaded in a deterministic order.  

I believe from reading various semi-related github issues that the order corresponds with the import order via webpack.  If that is the case for SSR as well, I would expect the order to be `app.css -> home.css -> about.css` since the `App.vue` file is loaded statically, and `Home.vue` and `About.vue` are loaded dynamically via routes in that order.

Either way, I would expect global styles from `App.vue` to always be loaded first, followed by dynamic-route styles, allowing for a proper cascade. 

### What is actually happening?
I think there are two issues at play:

**Primary Issue**: In development mode, the `app.css` file is incorrectly loaded _after_ the `about.css` file, breaking the cascade for contents of `About.vue`.

**Secondary Issue**: In production mode, the `app.css` file is properly loaded first, but then `about.css` is loaded prior to `home.css` even though they are imported in the reverse order and even when SSR-ing the home page.

---

### Additional Notes

I'm trying to determine what feels like the optimal solution, and I think there are a few options, in a loose descending order of ""optimal"", and likely increasing order of feasibility:

1. Global styles from the root `App.vue` component would always be loaded first, followed by the only the styles for the component matched for the current route.  Additional route-specific styles would be loaded on demand when routing.  I understand this is likely beyond the scope of the bundle renderer and potentially something to be implemented by the application itself.
2. Global styles from the root `App.vue` component would always be loaded first, followed by styles for the current route-component, followed by styles for additional route-components.
3. Global styles from the root `App.vue` component would always be loaded first, followed by styles for route-level components, in import-order (i.e., in route-declaration order)



It is also worth noting that my specific scenario in my larger app is slightly different, but I wasn't able to quite reproduce it exactly in this minimal repo, and I'm not quite sure why.  In my specific app case, I have an `App.vue` and 3 dynamic routes defined in the order:

* Home
* Page 1
* Page 2

In development mode, my stylesheets are included in the order:   page1, app, home, page2.

In production mode, my stylesheets are included in the order:   home, page1, page2, app

So in the demo repo, the production build is correct insofar as it doesn't break the cascade for either route, and the development build is incorrect for only one of the routes.  

In my actual app, the development mode only breaks the cascade for the page1 route, while the production build breaks it for all routes.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,brophdawg11,"
--
I think the only workaround available at the moment is to set `inject:false` on the bundle renderer and manually insert these into the template in the proper order by reading them from the client manifest?  I assume that even using `renderStyles` from https://ssr.vuejs.org/guide/build-config.html#manual-asset-injection would result in the same ordering issues?
--

--
This seems to have been resolved for me in 2.5.22 but another issue has surfaced.  I have updated the reproduction repo to show the new issue.

* The prior commit (https://github.com/brophdawg11/vue-ssr-css-ordering/commit/94fbd4dcc02d3666ee9434babc407c8b1f3911d4) had the issue of dev builds breaking the cascade by loading app.css _after_ the route-specific CSS chunk.
* That specific issue seems to be fixed by upgrading to 2.5.22, so running the newer commit (https://github.com/brophdawg11/vue-ssr-css-ordering/commit/11d32d0531c8156f685bb125d3a3a0fb40498591) doesn't suffer that problem.

However, on 2.5.22, the bundle renderer includes 2 `<link rel=""stylesheet"">` tags for `app.css` in dev builds.  We're seeing this in our app locally, however we're getting 2 `app.css` files in both dev and production builds on 2.5.22.

I am going to upgrade the reproduction repo to the latest 2.6 release now and see if that changes anything.
--

--
Still seeing the same issue in 2.6.6 - the dev builds include two `<link rel=""stylesheet"">` tags for `app.css`.  See https://github.com/brophdawg11/vue-ssr-css-ordering/commit/2b2acf3a0ee17d298d2fbd12d6d15e4376d99183.

I will need to dig in further as to what's different in my app such that the bundler renderer gives us two `app.css` tags in both dev and prod builds.
--
",lyswhut,"
--
I also encountered this problem. I extracted CSS with mini-css-extract-plugin. After compiling via webpack, there will be a CSS file for every chunk, but VUE-SSR does not seem to support CSS asynchronous chunk loading. I don't have The way to make a mini-css-extract-plugin create a single CSS file: 

> https://github.com/webpack-contrib/mini-css-extract-plugin/issues/52

In VUE-SSR, the CSS module is loaded synchronously, the JS module is loaded asynchronously, and the CSS module loading order is reversed:
![ssr](https://user-images.githubusercontent.com/20365169/49919196-b9e93d00-fee0-11e8-9fe3-cb87a250719b.png)

In SPA, CSS modules and JS modules are loaded asynchronously:
![spa](https://user-images.githubusercontent.com/20365169/49919759-ae971100-fee2-11e8-81c4-9a4e0772912e.png)


--

--
@brophdawg11 
I also encountered the same problem, this bug has been fixed in `vue-server-renderer@2.6.9`
see https://github.com/vuejs/vue/pull/9677
--
",iztsv,"
--
@lyswhut

> VUE-SSR does not seem to support CSS asynchronous chunk loading

that problem was fixed in [v2.5.18-beta.0](https://github.com/vuejs/vue/releases/tag/v2.5.18-beta.0) - [#7902](https://github.com/vuejs/vue/pull/7902)

> Non-Deterministic CSS ordering for extracted CSS in an SSR App

I have the same issue in 2.5.22

--
",,,,,,
8822,OPEN,Different functional componens has the same key,has workaround,2020-09-21 12:56:18 +0000 UTC,vedmaque,Opened,,"### Version
2.5.17

### Reproduction link
[https://github.com/vedmaque/vue-functional-bug](https://github.com/vedmaque/vue-functional-bug)





### Steps to reproduce
1) create `Component1`
```
<template functional>
  <div class=""a"">
    <div class=""b"">first (template)</div>
    <div class=""b"">component</div>
  </div>
</template>
```
2) create `Component2`
```
<template functional>
  <div class=""x"">
    <div class=""y"">second (template)</div>
    <div class=""y"">component</div>
  </div>
</template>
```
3) render them in App.
```
<template>
  <div id=""app"">
    <component1 />
    <component2 />
  </div>
</template>
```

### What is expected?
Everything works fine

### What is actually happening?
Vue warns about same key
```
[Vue warn]: Duplicate keys detected: '__static__0'. This may cause an update error.
```

---
If you create the same components from render function directly, it works fine, without duplicated keys (keys are `undefined` in this situation)
```
<script>
export default {
  functional: true,
  render(createElement) {
    return createElement(""div"", {
        staticClass: ""a""
    }, [createElement(""div"", {
        staticClass: ""b""
    }, [""first""]), createElement(""div"", {
        staticClass: ""b""
    }, [""component""])])
  }
}
</script>
```

This image shows the difference in VNode objects.
![screenshot](https://github.com/vedmaque/vue-functional-bug/raw/master/functional-bug.png)

Moreover, if `Component1` looks likes this, it works fine too.
```
<template functional>
  <div class=""a"">first (template) component</div>
</template>
```

Vue Template Exporer will go crazy too if you try to compile `Component1`
https://template-explorer.vuejs.org/#%3Cdiv%20class%3D%22a%22%3E%0A%20%20%3Cdiv%20class%3D%22b%22%3Efirst%20(template)%3C%2Fdiv%3E%0A%20%20%3Cdiv%20class%3D%22b%22%3Ecomponent%3C%2Fdiv%3E%0A%3C%2Fdiv%3E%0A

<!-- generated by vue-issues. DO NOT REMOVE -->",,,kimlisa,"
--
I had the same warning using version `2.6.10`. I had a component using three child functional components and it would give me this warning, so what I did was assign the root element for each functional component with a unique key from each other and the warning went away. Not sure if that was right though but it got rid of the error.


--
",posva,"
--
there is indeed a problem with template-based static functional components.
You have two workarounds: moving it to a render function, or making it non statical by having anything on the template using a v-bind or mustache expression

I think this belongs to vue-loader though 🤔 cc @sodatea 
--
",inamandev,"
--
I had the same issue and by defining a key in the template root element can resolve this issue. Example below:
### First Component
```
<template functional>
  <div class=""a"" :key=""'component1'"">
    <div class=""b"">first (template)</div>
    <div class=""b"">component</div>
  </div>
</template>
```
### Second Component

```
<template functional>
  <div class=""x"" :key=""'component2'"">
    <div class=""y"">second (template)</div>
    <div class=""y"">component</div>
  </div>
</template>
```

After defining the key to the very root element of the template you can solve this issue. You can see the static generated keys in Vue-Dev Tools(Browser) as well, so defining your own key attribute resolve the issue. Once you add your key attribute in template's root element, you can see your defined keys in Vue-Dev Tools.

Please let me know your outcome on this.

--
",a,"
--
@inamandev That works, but since the keys are static strings, it can just be written without the binding: `<div class=""a"" key=""component1"">`
--
",quannt,"
--
@posva Is this something that will be addressed in Vue 3?
--
",,
8819,OPEN,Inactive keep-alive component keeps updating if bound to nested properties,,2018-09-25 15:30:54 +0000 UTC,Razenpok,In progress,,"### Version
2.5.17

### Reproduction link
[https://refactoring.ninja/vue-v-if-keep-alive/](https://refactoring.ninja/vue-v-if-keep-alive/)
https://github.com/Razenpok/vue-v-if-keep-alive





### Steps to reproduce
1. Press ""Hide labels""
2. Open dev tools
3. Select DoesUpdate component
4. Press ""Add stuff""

### What is expected?
`player.money` remains the same

### What is actually happening?
`player.money` goes up
[![Image from Gyazo](https://i.gyazo.com/893b9067b540323d582bbd328ebd6ff4.gif)](https://gyazo.com/893b9067b540323d582bbd328ebd6ff4)


---
Component ""DoesntUpdate"" doesn't update on ""Add stuff"" as expected - it is bound to `lives` property which is on top level of `data`.

This isn't a dev tools issue, as I observe the same behavior with devtools disabled

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Razenpok,"
--
Anything?
--
",,,,,,,,,,
8805,OPEN,HTML entities in attributes are not always decoded for string templates,,2018-10-01 15:48:58 +0000 UTC,johnnymijnhout,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/sf9cg0db/](https://jsfiddle.net/sf9cg0db/)





### Steps to reproduce
Try to dynamically load an input field with a value that contains an encoded single quote (&amp;#39;) as plain HTML. Normally the input field will display the single quote in the input box. However, Vue shows the &amp;#39; in the input box. 

~~I tested this with multiple encoded chars, and everything works correctly, except for the single quote.~~ As stated by @HcySunYang, all entities except the 6 he listed have this issue.

### What is expected?
A single quote is shown in the input field when loaded async with Vue

### What is actually happening?
&amp;#39; is show in the input field when loaded async with Vue

<!-- generated by vue-issues. DO NOT REMOVE -->",,,HcySunYang,"
--
This is not related to whether the component is asynchronous or not. Non-asynchronous components also have this problem. Vue's html-parser will only process the following entity content:
```js
const decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '""',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t'
}
```
it's here: https://github.com/vuejs/vue/blob/dev/src/compiler/parser/html-parser.js#L38-L45.


--
",johnnymijnhout,"
--
So '&amp;#39;' should be added to the map?

Update: https://jsfiddle.net/sf9cg0db/12/
You are right, also &amp;eacute; for example doesn't work... So if manually 6 out of all entities are correctly converted, how should this be fixed then?
--
",rafaelcorradini,"
--
It would not be better to use something like this package?
https://github.com/mdevils/node-html-entities
--
",Justineo,"
--
Actually Vue is already using [`he`](https://www.npmjs.com/package/he) on Node.js (compile-time and SSR) and [leveraging DOM API](https://github.com/vuejs/vue/blob/dev/src/compiler/parser/entity-decoder.js) on the browser side to perform entity decoding. It seems that only attribute values are decoded using the `decodingMap` mentioned above and I'm not sure it's intentional or just a miss.
--
",,,,
8785,OPEN,Race condition in transition-group,transition,2018-09-12 09:34:33 +0000 UTC,nkovacs,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/nkovacs/Lskfredn/](https://jsfiddle.net/nkovacs/Lskfredn/)





### Steps to reproduce
1. Click the add button


### What is expected?
the animation should work properly, and animation classes should be cleaned up

### What is actually happening?
the enter animation doesn't work and the new item's element keeps the `list-enter-to` class forever

---
The style tag binding triggers a second rerender of the transition-group component between the transition-group setting `_enterCb` on the entering new child and `nextFrame` triggering its callback. `prevChildren` is updated to include the new item, and `update` calls the pending `_enterCb` callback. Then after that, `nextFrame` triggers, but because `_enterCb`  can only be called once, it won't be called, so the `enter-to` class will remain on the element.

This only happens if the transition-group has a move transition.

The bug also occurs if the elements are changed between `update` and `nextFrame`: https://jsfiddle.net/nkovacs/cnjso1h5/

<!-- generated by vue-issues. DO NOT REMOVE -->",,,janschoenherr,"
--
This is happening for me too. However it is only happening when trying to transition the `transform` property. The `left` property works as expected. 
--
",nkovacs,"
--
That's strange, it shouldn't matter what you are transitioning, the only important thing is that you have a move class with a transition.
--
",,,,,,,,
8784,OPEN,Oddity with JS transition hooks used in combination with CSS,transition,2018-09-12 09:46:47 +0000 UTC,alexdilley,In progress,,"### Version
2.5.17

### Reproduction link
[https://codesandbox.io/s/6x4k5vrrkn](https://codesandbox.io/s/6x4k5vrrkn)

### Steps to reproduce
Remove the [unused] `done` parameter from the `leave` callback signature in `SideSheet.vue`.

### What is expected?
The component to transition both on enter and leave.

![want](https://user-images.githubusercontent.com/22343/45375530-28221900-b5ed-11e8-90ca-f7eff6d20bc8.gif)

### What is actually happening?
The component enters immediately (without transitioning).

![get](https://user-images.githubusercontent.com/22343/45375595-5bfd3e80-b5ed-11e8-8894-7c839df72cb3.gif)

---
The `done` callback shouldn't be needed if the transition duration is implicit in CSS (as noted in the docs). However, by retaining the `done` parameter in the function signature it is unclear why it should ""work"" (since it's unused within the function definition itself).

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
This is the same as #8279 but it is unclear to me why the CSS transition isn't triggering.
However, your transition seems to be using the leave while it should be using the enter (try changing durations
--
",alexdilley,"
--
Thanks for pointing me at the other issue, @posva; apologies for not finding that.

You're right, it should be the `enter` transition/cb that should be the concern. It was by fluke that I discovered that an unused `done` arg  (which as @yyx990803 points out is the cue that the `userWantsControl`) provided a ""solution"", so suspected it had relevance.

After stepping through the code, I noticed the `nextFrame` trick (defined in the transition util file and utilised in the transition module) which nests a `requestAnimationFrame` call to remove the `beforeEnter` transition class, so wondered if it was a timing issue (since that happens asynchronously to any user defined `enter` callback). And that leads to an alternative, more appropriate solution:

```js
beforeEnter(el) {
  el.style.marginLeft = `-${this.width}px`;
},

enter(el) {
  window.requestAnimationFrame(() =>
    window.requestAnimationFrame(() => {
      el.style.marginLeft = null;
    })
  );
},

leave(el) {
  el.style.marginLeft = `-${this.width}px`;
},
```

But the code is brittle since it's arguably reliant on what's happening internally.

Does it suggest that the user defined hooks should actually run within that `nextFrame` cb? 🤷‍♂️ Else the DOM change in the `beforeEnter` hook appears not to actually [re]paint, hence why a transition never occurs.

(Area in code of relevance, [here](https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/modules/transition.js#L146-L169).)
--
",,,,,,,,
8767,OPEN,Allow array/object binding for all (or specific a11y related) attributes,,2018-09-11 05:38:25 +0000 UTC,thedamon,In progress,,"### What problem does this feature solve?
The docs state that we have special functionality `when v-bind is used with class and style`. These are really useful because class and style are often references to other things. That exact use-case applies to a lot of attributes that are involved in semantic and accessible markup.

For instance, the `aria-describedby` attribute which accepts a list of IDs and must have correct spacing to be compatible with all screenreaders; this list is often dynamic and often controlled externally so we would potentially need to combined local describedby with some coming in externally.

Doing
```
:aria-describedby=""trim(`${describedBy} ${componentId}-affix`)""
```
works, but if describedBy is a Boolean it would have to be evaluated separately to avoid printing 'false'. Essentially we have to rebuild whatever beautiful easiness the Vue engine already does for class and style in order to make sure our code is semantic.

Attributes that would greatly benefit from this would be most [aria relationship attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#Relationship_attributes) as well as non-aria relationship type attributes like the `headers` attribute on a table cell.

```
return ['error', 'hint']
        .filter(prop => this[prop])
        .map(prop => `${this.componentId}-${prop}`)
        .join(' ').trim();
```
I have been doing a lot of weird code to get proper strings based on the values of nested data and realized this exact logic is already hidden somewhere in Vue.js. I think writing accessible code is extremely important and Vue should make it as simple as possible to do so. This (and perhaps a community standard way to set predictible IDs automatically) would make establishing semantic relationships between elements/components (the main accessibility challenge with dynamic js driven interfaces that are so popular these days) much simpler.

Being able to update the docs to call out these important attributes would be a great opportunity to push people toward writing more accessible code as well.

### What does the proposed API look like?
```
:aria-describedby=""[describedBy, `${componentId}-affix`]""
```

Not sure if there are specific issues with just allowing any attribute to behave this way, but that would be my preferred solution. If that is too difficult or causes particular performance concerns then adding that behaviour to specific attributes (those called out above, but I would have to review all valid html attributes to see which would make sense) would be a good alternative solution.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
What would `:aria-describedby=""[describedBy, `${componentId}-affix`]""` yield?

allowing every attribute to behave as class and style would indeed be more expensive
--
",Justineo,"
--
I think users would implement the same logic in their application layer anyway (repeating those Vue has done for `class`). We may need this feature for those attributes which accept [space-separated tokens](https://www.w3.org/TR/wai-aria-1.1/#b-mapping-wai-aria-value-types-to-languages). It requires Vue to maintain a list for this, but for `aria-*` attributes I think the tradeoff is worth considering.

There's still one problem that when users asks why `inheritAttrs` doesn't work for `class` and `style`, we did claim that we have special treatment for them so they are not passed into `$attrs` when `inheritAttrs: false`. If we do the same for `aria-*` attributes that logic might be not accurate anymore.
--
",thedamon,"
--
@Justineo definitely worth considering.. I was a little bit frustrated / confused about `inheritAttrs` not applying to class and style. The difference between props and attributes is a little bit fuzzy to me as well

@posva in my situation it would yield something like `:aria-describedby=""field-7-error field-7-hint field-7-affix""` where `describedBy` is a passed in String prop. But ideally `describedBy` would be an array, so you might instead write `:aria-describedby=""[...describedBy, `${componentId}-affix]`""` or similar. I really think the best way of describing the ideal API is ""like class and style work""

I wonder about calling out or providing utility functions or something, but that doesn't really seem to fall within the ""Vuey"" realm of things
--

--
@KaelWD I was going to ask where the code for that is! I am considering writing a filter to do this since I understand it's not hugely likely this request would get priority or buy-in.

Another approach might be to, on a component level, allow the option to set `stringifyAttrs: ['aria-describedby','headers','aria-labelledby']` or something like that to avoid unnecessary overhead
--
",KaelWD,"
--
Or expose [stringifyClass](https://github.com/vuejs/vue/blob/3b43c81216c2e29bd519c447e930d6512b5782e8/src/platforms/web/util/class.js#L50) somehow. 

```html
:aria-describedby=""$stringifyAttr([describedBy, `${componentId}-affix`])""
```
--
",jacekkarczmarczyk,"
--
What about directive?  Should be simple enough to write and syntax could be very similar to what you've suggested, for example

`:aria-describedby=""[...describedBy,${componentId}-affix]""`

vs

`v-aria.describedby=""[describedBy, componentId+'-affix']""` (or similar so it could handle non-aria attrs as well, but this will probably make it longer)
--
",,
8766,OPEN,Lag during render when using cross sub-array,,2018-09-06 22:53:06 +0000 UTC,lalmat,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/Lalmat/eywraw8t/336389/](https://jsfiddle.net/Lalmat/eywraw8t/336389/)

### Steps to reproduce
I've isolated the bug here : https://jsfiddle.net/Lalmat/eywraw8t/336389/

To reproduce :
1) Try to hide/show the hello world message, the redraw is instant
2) Use the load data button
3) Try to hide/show the hello world message, there's a lag that is fully dependant of you CPU velocity. 

It seems that there's a setTimeout inside vue that cause this lag

### What is expected?
Instant redraw

### What is actually happening?
Lag during redraw depending of computer CPU

---
I use cross arrays to avoid using a toggle function. I'm completely aware that this code is kind of tricky but I can't understand why there's a lag...

This is why I follow this to experts :)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,fnlctrl,"
--
It's not a setTimeout. Performance timeline shows massive `dependArray` calls, which is caused by array access in v-model 
```html
<input type=""checkbox"" v-model=""bat.lines[line.id].checked"">
```
![image](https://user-images.githubusercontent.com/5557143/45105040-f7159480-b165-11e8-8c4f-27ee896280bb.png)

I'm not familiar with the code but perhaps [this PR](https://github.com/vuejs/vue/pull/8734) would fix this.

A quick workaround (or maybe the correct way in your case) is to use an object for `bat.lines` since you're using it as a hash map(direct access by key) rather than an array. See https://jsfiddle.net/eywraw8t/336702/

--
",lalmat,"
--
Working, thank you !
--
",jamesalanfinnigan,"
--
Another solution that worked for me with one-way binding and a click event handler.

<input type=""checkbox"" :value=""bat.lines[line.id].checked"" @click=""bat.lines[line.id].checked = !bat.lines[line.id].checked"">
--
",,,,,,
8762,OPEN,Key Event wrongly triggered for unknown Modifier/Alias/Keycode on every Key in Safari 9,improvement,2018-09-07 06:02:08 +0000 UTC,cb109,In progress,,"### Version
2.5.17

### Reproduction link
[https://codepen.io/cb109/pen/xarvBZ](https://codepen.io/cb109/pen/xarvBZ)





### Steps to reproduce
Please open the codepen link in Safari 9 on iOS, which is where I observed the bug (works fine in Chrome 68 on Ubuntu 18).





### What is expected?
There are two inputs, the first working as expected, the second showing some weird behaviour:

The first textfield has a handler to fire only when pressing escape. Typing should work as expected, pressing escape while focused should clear the input.

The second textfield has a handler for an unknown key code by using an unknown key modifier alias. Typing should work the same as for the first input.

### What is actually happening?
Typing into the second input in Safari 9 on iOS it will always trigger the `@keyup` handler, thus clearing the input while typing. This feels wrong.

IMHO this should not happen. If a key modifier-alias/code is not recognized, it should not be triggered by any key.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Maybe we can provide a warning if a modifier doesn't exist (except numbers)
--
",cb109,"
--
That would help :+1: But it would be more useful to have consistent behaviour across browsers (aka do nothing for unknown/non-existing modifiers), although it's not clear for me if this is entirely within Vue's control.
--
",,,,,,,,
8759,OPEN,Style binding: implicitly assign 'px' as the default unit for numeric values for certain css properties,discussion; feature request,2020-04-26 19:50:48 +0000 UTC,julian-ca,Opened,,"### What problem does this feature solve?
When assigning values to a CSS property via style binding like

````html
    <div class=""d-inline-block"" :style=""{width : width}""></div>
````

or using the shorthand syntax...

````html
    <div class=""d-inline-block"" :style=""{width}""></div>
````

this will actually not gonna work because we need to explicitly set the `unit`:

````html
    <div class=""d-inline-block"" :style=""{width : width + 'px'}""></div>
````

or via interpolation...

````html
    <div class=""d-inline-block"" :style=""{width : `${width}px`}""></div>
````

Now our code becomes more verbose. Combining all the number of occurrences of such binding, it's becoming ridiculous.

I'm not sure if currently there is an elegant solution for this, but if there is. It would be also good if it is referenced in in the [docs](https://vuejs.org/v2/guide/class-and-style.html).

In React, this is the default behavior. It will add 'px' if the `unit` is not specified.

### What does the proposed API look like?
For common css properties like `width` and `height`, having vue implicitly assign 'px' to the value it would definitely make our code much more cleaner.

This code...

````html
    <div class=""d-inline-block"" :style=""{width}""></div>
````

will be interpreted as:

````html
    <div class=""d-inline-block"" :style=""{width : width + 'px'}""></div>
````

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Justineo,"
--
TBH I'm not a fan of this feature. A CSS property can accept multiple value types and even it's “unitless” today doesn't mean it will stay “unitless” forever, and vice versa. As the language evolves,  maybe someday a “unitless” property can take length units, or those accept length units can take “unitless” values. If a property use to not accept “unitless” values and later changed to accept them, we would never know the true semantics behind a number if we had supported appending `px` to it by default.
--

--
As you can see, feature is already included in Vue 3:

https://github.com/vuejs/vue-next/blob/eaf414f06366b413e36a688749a6524687b952d7/packages/shared/src/domAttrConfig.ts#L44-L55

Although I mentioned this is theoretically not a safe move, the reality is that this feature already exists in React and we would have to take this into account when trying to evolve CSS, to prevent conflicts with the most popular JavaScript frameworks.

Maybe we can back port this into 2.7 after 3.0 and the companion libs are fully ready. But we still have to maintain a list because feature detection doesn’t work on the server side.
--
",julian,"
--
Hi @Justineo,

I see your point, but I think you're a little bit exaggerating such concern. We know CSS' implementation in relation to the units of values of css properties hasn't changed that much between versions. Take the width or height for example, ever since the birth of CSS, it hasn't changed much. It didn't go unitless.  

And also, I am certain that some properties wouldn't go unitless, particularly those properties where `length` are involved like the `height`, `width` and `border` for example. As far as CSS' maturity is concerned, I'm pretty much sure that we won't be seeing something like `height: 1` or `opacity: 1em` in the future. 

Anyway, this is implemented in ReactJS, so there shouldn’t be that much problem having it in Vue since it will definitely improve our productivity.
--

--
Hi @posva,

I think we we don’t necessarily need to list all unitless or non-unitless properties. We could just list the commonly used properties in real world scenarios. Like the `height` and `width`, there are cases where we assign these properties via javascript.
--

--
Hi @posva ,

Yes, you are right.
--
",posva,"
--
I'm not a fan of this either, it means we have to keep another list of [unitless properties](https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59) and keep it up to date, and it has to be added at runtime too because a property name could be dynamic
--

--
Unfortunately, that wouldn't be consistent and confusing to users
--
",sirlancelot,"
--
I think this would be doable with a sort of feature-detection solution. For example, if a value of type ""number"" were passed, then during normalization a one-time check is done to see whether the property in question supports unitless values.

At least in Chrome, if a value isn't allowed to be unitless, it won't get set:

```js
tmpDiv = document.createElement(""div"")
tmpDiv.style.width = 20
console.log(tmpDiv.style.width) // output: """"
```

The output will *always* be a string so for the comparison check, the input value should be converted to a string. This should allow Vue to maintain high performance in this area due to the solution's opt-in nature. If a developer never passes a number type, then they'll never encounter that branch.
--
",WisdomSky,"
--
Yes, that's what I'm saying ever since I started this discussion. React has been implementing it, so why shouldn't we?

Anyway, it's really cool seeing this getting pushed despite the tons of dislikes. 😅
I'm looking forward to Vue 3.0. ❤️

PS: @julian-ca is my older account. 
--
",,
8757,OPEN,Add a way to check if a component responds to an event; or make vm._events public,feature request,2018-11-18 15:20:02 +0000 UTC,lehni,In progress,,"### What problem does this feature solve?

It would be nice to be able to check if a component responds to a given event or not. We can already do so for listeners declared in the template through the `vm.$listeners` object, but the ones registered with `vm.$on()` / `vm.$off()` don't show up in this object, they are stored in the private `vm._events` object.

I would like to suggest to either add a function that checks if a component responds to a given event, or to make `vm._events` public, and call it `vm.$events`


### What does the proposed API look like?

A method called `vm.$responds(event)` could be considered, returning `true` if a component responds to a given event, `false` otherwise. If an array of strings is passed to this method instead of a string, it could return `true` if the component responds to some of these events.

Alternatively, the interface could simply be `vm.$events`

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
What is the use-case behind?
--

--
Oh, the use case was clear to me: you don't want to `emit` if the component isn't listening to the event because building the payload for the event is expensive
--
",lehni,"
--
It's to permit an optimisation that only builds a larger parameter object for a given event if the event is actually to be received by the component on which it is emitted.
--

--
@LinusBorg I am not listening to the event from the same component. I am simply listening to this event programmatically through a call to `$on()`, instead of directly from the template. And when doing so, the event doesn't show up in `$listeners`, only events that are provided in the template do so.

This is something I am using in @ditojs/admin: https://github.com/ditojs/dito/tree/master/packages/admin, a Vue.js based framework to build admin UI from simple Pojo schemas. And since much of the connecting is happening through code and processing of these schema, i cannot listen the vents in a template.

Since one is exposed, I was wondering why isn't the other.

--

--
It's mostly used from the outside through the schema. Here the events get installed:
https://github.com/ditojs/dito/blob/d5ed796e9705d47a4395e0d788850d9dda91edc1/packages/admin/src/mixins/DitoMixin.js#L294-L298

And here the framework itself uses it internally:
https://github.com/ditojs/dito/blob/d5ed796e9705d47a4395e0d788850d9dda91edc1/packages/admin/src/components/DitoSchema.vue#L189

Here's my current workaround:
https://github.com/ditojs/dito/blob/91d1de30df3795f775c5c73a8db68b9164176e75/packages/admin/src/DitoComponent.js#L43-L97
--

--
@ChristianKienle a good idea, but this is for a public-facing API, and I'd like to use a similar approach as Nuxt does for its hooks, where you use destructuring to pluck the parameters that you need out of one single object argument provided to the callback...
--

--
In the meantime I've transitioned fully away from Vue's own event mechanism, since I needed the callbacks to be async and also queued. I guess we can close this issue, but maybe `$responds()` would still be useful to others? Here's my `EmitterMixin`: https://github.com/ditojs/dito/blob/master/packages/admin/src/mixins/EmitterMixin.js
--

--
@ChristianKienle ha that's nice to hear, thank you! Actually, @puckey is the author of that example, he'll be happy to hear that I'm sure.
--
",LinusBorg,"
--
As you explained yourself, for parent/child events, you can already`$listener`, so I think @posva is interested in understanding what use case requires to emit and listen to an event *within the same component*, instead of, for example, calling a method if `someCondition: true` is set in the component's local data.

It's not something I've ever come across so far.

The reason for asking for the use case is this: Adding a new API for the purpose of a ""fringe use case"" isn't really anything we would consider right now, so we have to understand the prevalence and severity of the use case(s) for any new API/feature we add.
--

--
> Since one is exposed, I was wondering why isn't the other.

`$listeners` didn't exist until Vue 2.3 or something, it was added after a lot of people asked for it, it's useful, for example to pass down listeners like you pass down props - which happens a lot in functional components and HOCs.

OTOH, no one asked for what you asked for so far, so we didn't think of adding it. No need for an API that nobody wanted so far.

> . And since much of the connecting is happening through code and processing of these schema, i cannot listen the vents in a template.

A quick search didn't bring up any use of $on in the codebase (github code search ignoring special chars is no helping), care to link to one?
--
",ChristianKienle,"
--
Just an idea: instead of emitting the costly object you could emit a function that, when called, returns the costly object. Then the costly object is only ever created when someone actually calls the function you emit which in turn should only happen when someone is listening to your event. Just my two cents. Not sure if this any good though. 😁
--

--
@lehni just saw that you are behind Paper.js. 😍 

I regularly play with the Voronoi example because I noticed that it calms me down and helps me relax. If you are in the area ping me for a beer/coffee/whatever :)
--
",,,,
8738,OPEN,set the templateRenderer.publicPath on the fly? [vue-server-render],,2019-02-09 07:54:38 +0000 UTC,loviselu,Opened,,"### What problem does this feature solve?
In some case, I need to set the publicPath base on the runtime. For example, I need to set the publicPath base on request.url and the environment。


But now I can only edit the source code to support that. So, how i wonder if it can be implemented officially. :)


btw, webpack support set the publicPath on the fly. [ref](https://webpack.js.org/guides/public-path/#on-the-fly)


### What does the proposed API look like?
```js
const bundleRenderer = createBundleRenderer(serverBundle, {
    template,
    clientManifest,
    runInNewContext: false
})

//request handler
module.exports = async (request, response) => {

    const hostname = request.REQUEST.hostname;
    if(devMode) {
        domain = `${hostname}/proxy/`   cdnDomain;
    } else {
        domain = cdnDomain;
    }

    bundleRenderer.renderer.templateRenderer.publicPath = domain;

    const html = await bundleRenderer.renderToString(context)
    response.end(html)
    
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,FranckFreiburger,"
--
any status about this issue ?
--
",thomasboyt,"
--
Also would like to register my interest in this feature!

For some context:

I use `publicPath` to set the URL of the CDN I rely on (Cloudfront). I'm moving my app from Heroku to Docker on a VPS.

On Heroku, I did my Webpack builds as a `postinstall` script, as is pretty common for Heroku deploys of built applications. This meant that I could set an environment variable on my server, `STATIC_PATH=http://path/to/cloudfront`, that would get used at _build time_ for the Webpack bundle. It was easy to just set Webpack's `publicPath` to be that variable in the config.

However, on my new setup, I'd like to _pre-build_ my Webpack bundles before deploying, and have them copied into the Docker image as part of my `Dockerfile`. I've found this is a fairly standard pattern (either building as part of `docker build`, or pre-building and copying the build artifacts into the image).

An annoying thing about this is that I have to  set `STATIC_URL` when doing these Webpack  builds locally (or, eventually, on CI) to be the CDN URL, instead of being able to leave that configuration on my server. If Vue's server renderer could adjust the publicPath on the fly, it'd mean I could avoid this.

Thanks for the docs link about `__webpack_public__path` @loviselu, btw - my first assumption was that this wouldn't be possible on a Webpack level, but it seems like it should be doable.
--
",,,,,,,,
8737,OPEN,2 transition-groups with different tags v-if / v-else = Cannot read property '$vnode' of null,has workaround; improvement; transition,2018-08-31 16:18:12 +0000 UTC,Mboulianne,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/anon/pen/BOpJZb](https://codepen.io/anon/pen/BOpJZb)





### Steps to reproduce
1- Open the console
2- Click the button

### What is expected?
In fact I don't know.  I would expect not to see the error but I'm thinking maybe I'm doing something wrong. 

### What is actually happening?
Cannot read property '$vnode' of null appears in the console

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Mboulianne,"
--
Note: I've dug into the issue.
If I use v-shows instead of v-if / else it works.
If all my transition-group have the same tag it works, even with v-if-else.  However, this is not practical in my case.
If there are no components in transition-group children, it works.
--

--
I've also thought of nesting my transition-groups in 2 divs that I'd apply the v-if/else on and I get the same error
I've added the code in my codePen

--

--
@posva thank you for the workaround =D
--
",posva,"
--
You can add a `key` attribute to the `transition-group` as well to remove the error but the error shouldn't appear indeed
--
",,,,,,,,
8733,OPEN,Vue treat every element attribute named like 'v-[something]' as directive,improvement,2018-08-31 16:16:55 +0000 UTC,mcekiera,Opened,,"### Version
2.5.17

### Reproduction link
[http://jsfiddle.net/wf48v9de/3/](http://jsfiddle.net/wf48v9de/3/)





### Steps to reproduce
Run the fiddle and look at console.

### What is expected?
If there is not registered directive named 'v-fake', Vue should ignore this attribute of an element.

### What is actually happening?
Vue treat every 'v-[something]' attribute as directive, regardless if it is registered globally or locally, or not at all. It is trying to compute the value of 'v-' beginning attribute, and in effect throws TypeError, as it doesn't find property named like string passed to attribute. 

---
if it is intentional, there should be information about such behavior in Vue docs. However in my opinion it should ignore such attributes.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,kayandra,"
--
IMHO, I think the docs are clear enough. The `v-*` lookup has a good behavior. It makes debugging easier, if you want to add a property `v-something` and not want Vue to treat it as a directive, you should be using data attributes

So instead of `<div v-fake/>` it should be `<div data-v-fake/>`
--

--
@posva I guess that could work.
--
",posva,"
--
Maybe it would make more sense to resolve the directive and show an error (like when there is no value)
--
",,,,,,,,
8728,OPEN,An anti-pattern in computed property may cause performance issue,has PR,2018-08-31 13:41:59 +0000 UTC,Yuyz0112,Opened,,"### Version
2.5.17

### Reproduction link
[https://codesandbox.io/s/140202wlq](https://codesandbox.io/s/140202wlq)





### Steps to reproduce
Open the code sandbox link and click the button to use the computed property 'filteredEntities', and you will find it cost a lot of time.

After check the call tree, I found this is because the code calls the getter of 'entities'  many times which will then call the `dependArray` function.

The code leading to this is:
```js
const len = this.entities.length;
for (let i = 0; i < len; i++) {
  const e = this.entities[i];
  // do something with e
}
```
If this.entities has a length of n, its getter will be called n + 1 times. And every time when the getter was called, it will call dependArray on the value of this.entities, which is the array with length n.
Since dependArray will iterate the value, the depend function will be called **(n + 1)^2** times totally.

I found this code when I'm reviewing someone's PR, and the original code use `for (let i = 0; i < this.entities.length; i++) ` and make another n times call to the getter.

It was easy to avoid this problem, such as using some array methods like `filter` to only call getter once.
Even cache the value of entities by `const cache = this.entities` can solve it.

Although it was easy to avoid of this pattern, I still think it is dangerous because the original code was not an obvious anti-pattern.
And this will not show any performance issue when the array is small, but may cause serious performance issue when the array is large in some production environment.

### What is expected?
I've read the related source code and I think this is the expected result of the observer system.

Then I read some chapter of the guide again to ensure there is no mention about this, so I'm not sure whether we need to add this as a NOT TODO in the computed property chapter.

### What is actually happening?
Described.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
8721,OPEN,Property 'xxx' does not exist on type CombinedVueInstance ?,typescript,2021-04-03 04:58:29 +0000 UTC,SunshowerC,In progress,,"### Version
2.5.17

### Reproduction link 



### Steps to reproduce
1. use vue-cli init a ts hello-world project .
2. code like that
```js
<script lang=""ts"">
import Vue from ""vue"";
export default Vue.extend({
  name: ""HelloWorld"",
  props: {
    msg: String
  },
  data():any {
    return {
      wtf: this.initData(), // throw ts error : Property 'initData' does not exist on type 'CombinedVueInstance<Vue, {}, {}, {}, Readonly<{ msg: string; }>>'.
    }
  },
 
  methods: {
    initData():any {
        return {
          a: ''
        }
    },
  },
 
});
</script>
```


### What is expected?
How can i fix it ?

### What is actually happening?
**Property 'initData' does not exist on type 'CombinedVueInstance<Vue, {}, {}, {}, Readonly<{ msg: string; }>>'.**


<!-- generated by vue-issues. DO NOT REMOVE -->",,,KaelWD,"
--
It seems to be intentional, I guess so you can't accidentally access computed properties via a method? https://github.com/vuejs/vue/blob/3b43c81216c2e29bd519c447e930d6512b5782e8/types/options.d.ts#L34

edit: https://github.com/vuejs/vue/pull/6391/commits/540a38fb21adb7a7bc394c65e23e6cffb36cd867, https://github.com/vuejs/vue/pull/5887#discussion_r122128852
--

--
They don't exist yet: https://codepen.io/kaelwd/pen/pOErZw?editors=0011
--

--
Yeah I know, it is a bit silly. Just a guess as to why they might've done that. 
--

--
Typescript 3.9 has made this even worse, I have to specify return types for methods too now. 
--

--
`InstanceType<typeof mixin>` or use this mixins utility I made for Vuetify: https://github.com/vuetifyjs/vuetify/blob/master/packages/vuetify/src/util/mixins.ts

Vue 3 has proper typings for mixins. 
--
",SunshowerC,"
--
I don't understand. What bad would happen if i access computed properties via a method ?  
--

--
Uh... I didn't use `computed` property, just use a `method` function, and the `methods` does exist in `data`.     
   

![image](https://user-images.githubusercontent.com/13402013/44784873-96181a80-abc1-11e8-98dc-b53011ce97c5.png)
    

  
And I may turn to `vue-class-component` instead of `Vue.extend`,  the native vue is still not so friendly to typescript (Maybe just because i am not so proficient in vue). Anyway, thanks for helping me.
--
",zhuscat,"
--
Same here.

```
""vue"": ""^2.5.17""

""typescript"": ""^3.0.0""
```

Is there any way to access methods in `data` function?
--
",brandoncash,"
--
Since this appears to be only a typing issue and not a runtime issue, there is an (ugly?) workaround available: cast `this` as type `any`:
```
return {
  wtf: (this as any).initData(),
};
```

Additionally omit the `()` to store a reference to the method that is executable outside of the current scope, e.g. if you pass it to a child via a prop.
--
",mms,"
--
Same here. Vue 2.5 has [better type declaration support for TypeScript](https://medium.com/the-vue-point/upcoming-typescript-changes-in-vue-2-5-e9bd7e2ecf08) but this seems broken.
--
",gcollombet,"
--
Same problem for me
--
"
8719,OPEN,Vue.component doesnt except argument of type `Component`,typescript,2019-07-14 15:07:40 +0000 UTC,backbone87,In progress,,"### Version
2.5.17

### Reproduction link
[https://codesandbox.io/s/8z04jxj3y8](https://codesandbox.io/s/8z04jxj3y8)





### Steps to reproduce
- Click repro link
- Open test.ts
- See type errors
- Uncomment vue type augmentation to see errors disappear


### What is expected?
I can pass any component to `Vue.component`

### What is actually happening?
Type error:
```
Argument of type 'Component<DefaultData<never>, DefaultMethods<never>, DefaultComputed, Record<string, any>>' is not assignable to parameter of type 'ComponentOptions<Vue, DefaultData<Vue>, DefaultMethods<Vue>, DefaultComputed, PropsDefinition<Rec...'.
  Type 'VueConstructor<Vue>' is not assignable to type 'ComponentOptions<Vue, DefaultData<Vue>, DefaultMethods<Vue>, DefaultComputed, PropsDefinition<Rec...'.
    Value of type 'VueConstructor<Vue>' has no properties in common with type 'ComponentOptions<Vue, DefaultData<Vue>, DefaultMethods<Vue>, DefaultComputed, PropsDefinition<Rec...'. Did you mean to call it?
```

---
Adding the following overload to `Vue.component` will fix it:
```ts
    component<Data, Methods, Computed, Props>(
      id: string,
      definition: Component<Data, Methods, Computed, Props>,
    ): ExtendedVue<V, Data, Methods, Computed, Props>;
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,ktsn,"
--
This is because `Component` type is a union type with `VueConstructor` and `ComponentOptions`.

Why do you use `Component` type? It means your `getComponent` function can return both Vue constructor and component options object.
I think you should use more concrete type such as `VueConstructor` or `ComponentOptions` as the return type.
--

--
I see your use case. I'm not sure that union type sometimes passes overload but we can replace fallback overload of `component` method with `Component` type.
--
",backbone87,"
--
Because the function loads components via webpacks require.context. Also there is a EsModule type for async comps that hints against Component. There is also a Vue.component overload foreach member type of the Component union. I think that is just a problem of typescript not being able to check that correctly.
--

--
Another indicator for this being a ts problem is that the following works:
```ts
const comp: Component = {};
Vue.component('test', comp);
```
--

--
ofc it is. that is not the point. but then TS somehow finds the correct `Vue.component` overload:

```ts
// type Component = typeof Vue | ComponentOptions | FunctionalComponentOptions;

const first = {};
const firstComponent: Component = first;
Vue.component('first', first); // ok
Vue.component('firstComponent', firstComponent); // ok

const second = { functional: true };
const secondComponent: Component = second;
Vue.component('second', second); // ok
Vue.component('secondComponent', secondComponent); // ok

const third = Vue.extend({});
const thirdComponent: Component = third;
Vue.component('thrid', third); // ok
Vue.component('thirdComponent', thirdComponent); // ok

declare function getComponent(): Component;
const final: Component = getComponent();
Vue.component('final', final); // type error
```

It is a typescript problem. TS seems like it doesnt allow multiple overloads to match (what the final case is requiring).
--

--
here is a plain typescript example demonstrating the problem:
```ts
interface A {
  a: string;
}
interface B {
  b: string;
}
interface C {
  c: string;
}
type union = A | B | C;
declare function acceptsUnion(x: A): void;
declare function acceptsUnion(x: B): void;
declare function acceptsUnion(x: C): void;
declare function returnsUnion(): union;
acceptsUnion(returnsUnion()); // type error
```
--

--
any update on this?

i am using the following `vue.d.ts` in my projects, which solves the type problem according to @ktsn proposed solution:
```ts
import Vue, { Component } from 'vue';
import { ExtendedVue } from 'vue/types/vue';

declare module 'vue/types/vue' {
  interface VueConstructor<V extends Vue = Vue> {
    component<Data, Methods, Computed, Props>(
      id: string,
      definition: Component<Data, Methods, Computed, Props>,
    ): ExtendedVue<V, Data, Methods, Computed, Props>;
  }
}

```
--
",posva,"
--
well, `{}` is a valid component
--
",,,,,,
8698,OPEN,transitionend event isn't fired on element inside <transition> when leaving,transition,2018-08-29 04:37:09 +0000 UTC,guanzo,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/guanzo/xcLk083u/1/](https://jsfiddle.net/guanzo/xcLk083u/1/)





### Steps to reproduce
1. Open reproduction demo in a non-Chrome browser.
2. Attach `transitionend` listener to the component root $el. (It can be on any element, doesn't matter)
3. Transition out a child element with `<transition>` and `v-if`.
4. Listener callback isn't fired.

### What is expected?
The transitionend event is fired in all browsers.

### What is actually happening?
The transitionend event is only fired in Chrome.

---
My use case does NOT allow me to use the template, therefore I cannot use the <transition> javascript hooks, such as `leave` and `afterLeave`.  Regardless, this is inconsistent behavior and should be figured out. Is vue stopping the propagation of the event somehow?

For a complete context of the use case, read this issue: https://github.com/guanzo/vue-smooth-reflow/issues/3

<!-- generated by vue-issues. DO NOT REMOVE -->",,,KaelWD,"
--
Doesn't show for me in chrome either, v68.0.3440.106 on windows 10. Adding `mode=""out-in""` fixes it for chrome, but not firefox or edge. 
--
",guanzo,"
--
Weird. Works for me, v68.0.3440.106 (Official Build) (64-bit) on windows 10. 
--
",posva,"
--
Seems to be related to the element being removed from the dom
--
",,,,,,
8680,OPEN,Cache access to process.env,feature request,2018-08-21 01:52:32 +0000 UTC,jnields,Opened,,"### What problem does this feature solve?
Access to `process.env` is a slow, system-bound call.

After react restructured their project to cache access to `process.env`, they had a 2.4x - 3.8x performance improvement for server-side rendering,

https://github.com/facebook/react/issues/812

This should also be done for vue, vue-server-renderer, vuex ... anything that accesses `process.env`.

### What does the proposed API look like?
An easy strategy might be to replace references to `process.env.NODE_ENV` with a reference to a singleton that checks process.env.NODE_ENV.

```
// foo.js
if (process.env.NODE_ENV !== 'production') {
  // do stuff
}
```

becomes

```
// isDevEnv.js
export default process.env.NODE_ENV !== 'production';

// foo.js
import isDevEnv from './isDevEnv';

if (isDevEnv) {
  // do stuff
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
8679,OPEN,Property 'X' does not exist on type CombinedVueInstance using TypeScript Prop Validator,typescript,2020-01-17 15:22:52 +0000 UTC,RehanSaeed,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/muhammadrehansaeed/pen/XPWKyJ](https://codepen.io/muhammadrehansaeed/pen/XPWKyJ)





### Steps to reproduce
Use Typescript to build this component:

```
export default Vue.extend({
  props: {
    delay: {
      default: 600,
      type: Number,
      validator: function(value: number) {
        return value >= 0;
      }
    },
    minValue: {
      default: 0,
      type: Number
    }
  },
  data() {
    return {
      valueInternal: 0
    };
  },
  methods: {
    reset(): void {
      this.valueInternal = this.minValue; <----THIS LINE ERRORS
    }
  }
});
```

### What is expected?
The component builds.

### What is actually happening?
The following error is thrown:

```
Property 'minValue' does not exist on type 'CombinedVueInstance<Vue, { isVisibleInternal: boolean; valueInternal: number; }, { reset(): void; }, {}, Readonly<{}>>'.
methods: {
  reset(): void {
    this.valueInternal = this.minValue;
                                               ^
  }
}
````

If I remove the validator from the prop, the error goes away. If I remove the data section, the error also goes away.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,KaelWD,"
--
Typescript bug? `validator: (value: number) =>  value >= 0` also removes the error. 
--

--
¯\\\_(ツ)\_/¯

They both have the same type signature, so no idea. I'd try to reproduce it without vue and open an issue on https://github.com/Microsoft/TypeScript
--
",RehanSaeed,"
--
@KaelWD That works! But why?
--
",pikax,"
--
if you do
```typescript
    delay: {
      default: 600,
      type: Number ,
      validator(value:number){
        return value >= 0;
      }
    } as PropOptions<number>
```

seems to be working, typescript seems not picking up the type
--
",alexsasharegan,"
--
Ran into this issue yesterday and @pikax suggestion fixed this for me. I didn't know about `PropOptions<Type>`.
--
",danjohnso,"
--
I had this happen with a Date prop.  If I had just the type, it was ok:
```
 date: {
    type: Date
}
```
But when I added a default value, everything broke in the component:
```
 date: {
    type: Date,
    default: () => new Date()
}
```
Unless you cast the object like mentioned above:
```
 date: {
    type: Date,
    default: () => new Date()
} as PropOptions<Date>
```
 For anyone googling the seemingly unrelated error, you will get this for every property in your component:
> Property 'Name' does not exist on type 'CombinedVueInstance<Vue, object, object, object, Record<never, any>>' Vetur(2339)
--
",seyfer,"
--
```
import {PropOptions} from 'vue';

 date: {
    type: Date,
    default: () => new Date()
} as PropOptions<Date>
```

leads to eslint error
```
  11:13  error  'PropOptions' is defined but never used  no-unused-vars
```

but I do not want to switch off `no-unused-vars` rule. what should I do?
```
parserOptions:
    parser: ""@typescript-eslint/parser""
    ecmaVersion: 8
    sourceType: module

plugins:
    - ""@typescript-eslint""

extends:
    - 'eslint:recommended'
    - 'plugin:vue/strongly-recommended'
    - 'plugin:@typescript-eslint/recommended'
```
--
"
8659,OPEN,<transition> 在 UIWebView和WKWebView 中没有起作用,need repro,2020-02-05 14:39:03 +0000 UTC,ZiQiangWang,In progress,,"### Version
2.5.17

### Reproduction link
[https://jsfiddle.net/50wL7mdz/608590/](https://jsfiddle.net/50wL7mdz/608590/)

### Steps to reproduce
这段代码在浏览器和安卓中都可以正常运行，但是在UIWebView和WKWebView中不可以

### What is expected?
toast 能够从底部动态滑出

### What is actually happening?
0.3s后，直接显示

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sodatea,"
--
Can't reproduce with iOS 11 & the [WebView](https://itunes.apple.com/cn/app/webview-wkwebview-and-uiwebview-rendering/id928647773?mt=8) app
--

--
上述代码仍然无法复现你说的效果，请提供正确的复现代码。
--
",ZiQiangWang,"
--
在UIWebView可能是因为300ms延时导致
--

--
进一步使用中发现，当webview打开一段时间以后，多次操作，transition动画表现越来越差，经常动画不连贯，最后动画效果完全没有。
不知道是否和性能有关。
有一个特点是，如果我把动画时间延长，比如10s，transition仍有效果，只是在动画快结束时，突然跳过中间动画过程，直接结束
--

--
![10 -30-2018 15-14-38](https://user-images.githubusercontent.com/11312811/47702471-f5dd8100-dc57-11e8-8998-a3386fba8c7a.gif)
这个是transition-duration为3s
![10 -30-2018 15-26-25](https://user-images.githubusercontent.com/11312811/47702537-34733b80-dc58-11e8-9a66-9a01719f7428.gif)
这个是transition-duration为0.3s
请问你是怎么重现的，能否用类似teamview的工具给你看下
--

--
![10 -30-2018 15-48-18](https://user-images.githubusercontent.com/11312811/47703485-676afe80-dc5b-11e8-9802-78b53a2c26f6.gif)
![10 -30-2018 15-48-53](https://user-images.githubusercontent.com/11312811/47703491-69cd5880-dc5b-11e8-8631-feeb2b5e5fad.gif)
我用codepen重新做了下，地址：https://codepen.io/ziqiangwang/pen/jeoVWG
--

--
ios那边使用NSURLProtocol导致了当前问题，但是具体什么原因还不了解 @sodatea @Justineo 
--
",Justineo,"
--
@ZiQiangWang 

你发的动图和你 issue 里的 JSFiddle 对应不了啊。
--
",Cuikeyi,"
--
我们也出现这个问题，我们出现问题的原因是因为客户端做了截屏操作，截屏操作之后，这个动画就会到结尾的时候，一下子就结束了，
// 存在问题的截屏方式
[DMAPPDELEGATE.window drawViewHierarchyInRect:DMAPPDELEGATE.window.frame afterScreenUpdates:YES];
// 修改后的截屏方式
[DMAPPDELEGATE.window.layer renderInContext:UIGraphicsGetCurrentContext()];
--
",,,,
8579,OPEN,Typescript - Component's property types are not correct,typescript,2019-07-05 06:59:49 +0000 UTC,AntoineEsteve,Opened,,"### Version
Vuejs: 2.5.16
Typescript: 2.8.1

### Reproduction link
[https://stackblitz.com/edit/typescript-rrnw8z?file=index.ts](https://stackblitz.com/edit/typescript-rrnw8z?file=index.ts)

### Steps to reproduce
- Use typescript
- Create a component with at least one property

### What is expected?
If your property of type `X` is not required, its type should be `X | undefined`

### What is actually happening?
If your property of type `X` is not required, its type is still `X`

---
More dangerous: The properties are not required by default and you can easily write code that will fail at runtime.

Note: The stackblitz above won't show the error because the types are not correctly assumed and `this` is assumed as `any`

<!-- generated by vue-issues. DO NOT REMOVE -->",,,KaelWD,"
--
https://github.com/vuejs/vue/issues/6901#issuecomment-339054776
--
",ChuChencheng,"
--
Will this issue be fixed in Vue 3.x ? 
Or how to correct it with TS 3.4+ ? 😕 
--
",,,,,,,,
8560,OPEN,Slots with only comments use fallback instead,improvement,2018-08-03 20:29:09 +0000 UTC,raihle,In progress,,"### Version
2.5.16

### Reproduction link
[https://jsfiddle.net/sg0bkLhv/7/](https://jsfiddle.net/sg0bkLhv/7/)

### Steps to reproduce
* Register a component with a slot
* Use the component in a Vue instance with comments=true, filling the slot with only HTML comment(s)

### What is expected?
The HTML comment is rendered into the slot.

This could be a breaking ""fix"" for someone who is running with comments=true and still relying on this behavior. If the current behavior is kept, I think it should at least be documented.

### What is actually happening?
The HTML comment is discarded and the slot uses its fallback content instead.

If any other content is provided together with the HTML comment, all content is kept.

---
I am developing for a CMS which uses HTML comments to provide its editing capabilities. It has the concept of ""areas"", which are similar to Vue's slots, so it would be handy to render areas into slots. An empty area (e.g. in a newly created page) consists solely of an HTML comment. Since the comment is stripped by Vue, the editing tools are not available.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,webther,"
--
Try to use a variable instead of a string inside the `<my-component></my-component>`.
See this example: https://jsfiddle.net/sg0bkLhv/90/
--

--
If you want to use the inline html string, I think you should encode the html tags like this:
`
<my-component>
  &lt;!-- kept --&gt;
</my-component>
`
See the example: https://jsfiddle.net/wz5y3svp/3/
--
",raihle,"
--
Thanks, @webther! It does seem to cover some cases: https://jsfiddle.net/wz5y3svp/.

However, it has some problems as well:

* v-html does not accept direct string input, but instead goes looking for data or props in the parent component. I think parents should not have to be aware of the contents of their children.
* v-html will also not work when the content includes other Vue components, since it is inserted as raw HTML instead of being compiled. Using a slot instead work since the comment is no longer on its own in this case, but it is again not nice to have to inspect content from outside the component.
--

--
It should still be treated as an HTML comment, not rendered as text. The second example renders correctly but relies on a data property in the parent instead of allowing text to be rendered directly into the template (server side, pre-Vue).

Our workaround for now is to append `<div style=""display: none;"">` when we detect an empty area. This is not amazing as it requires code in every affected template (and may affect styling), but since it at least *works*, I am more interested in seeing whether this behavior is a bug or intended.
--
",,,,,,,,
8551,OPEN,Directive does not behave the same on component as it does on element.,,2018-08-21 15:05:28 +0000 UTC,autumnwoodberry,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/autumnwoodberry/pen/XBamPN](https://codepen.io/autumnwoodberry/pen/XBamPN)

### Steps to reproduce
There are 4 input elements on the page. Each element has had the custom `v-active-input` directive applied. This directive attempts to read the value of the element and if that value is present it will add the `.active` class to the element.

There are 4 cases tested here: 

- A native input element with a `v-model` value that is defined in the component's `data` option.
- A custom input component with a `v-model` value that is defined in the component's `data` option.
- A native input element with a `v-model` value that is initially empty and then defined in the component's `mounted` hook.
- A custom input component with a `v-model` value that is initially empty and then defined in the component's `mounted` hook.

Observe that the 4th input element does not have the `.active` class applied. Modify the text in the 4th input element (for example, just add a few more characters). Observe that after changing the value of the input the `.active` class is applied to the 4th element.

### What is expected?
All input elements have the `.active` class from the start, regardless of if that input element is inside of a custom component, and regardless of when that `value` prop is defined or updated.

### What is actually happening?
The directive does not behave the same on a component as it does on a native element - the 4th input element on the page does not have the `.active` class applied.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,autumnwoodberry,"
--
I’ve updated the codepen.

On Thu, Jul 26, 2018 at 5:30 AM Haoqun Jiang <notifications@github.com>
wrote:

> Hi, thanks for your report.
> Would you please reduce your issue to a minimal reproducible example
> <https://stackoverflow.com/help/mcve>?
>
> The current reproduction link is undebuggable for us as it depends on vue,
> vuex and vue-router, with the main logic lying in a *remote*, *721KB*,
> *bundled* js file.
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/vuejs/vue/issues/8551#issuecomment-408080465>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AE9UvdxAryyGC09tC1iclP0qRTGoGMX5ks5uKbZIgaJpZM4Vg2uQ>
> .
>

--
",sodatea,"
--
@autumnwoodberry 😂I'm so sorry. Your reproduction is perfectly fine and I will look into it later. The previous reply was meant for another issue so I deleted it…… Seems you still received it by email.
--
",olsonpm,"
--
I've been seeing this as well.  For others getting here my workaround has been to provide a prop which passes the necessary data to the directive.  This sometimes results in a chain of props which isn't ideal, but it's not terrible either.

e.g.

```vue
// parent.vue
...
<child :active-input=""trueOrFalse"" />
...


// child.vue
<template>
  <div v-active-input=""activeInput"">
  ...
</template>

<script>
export default {
  name: 'child',
  props: ['active-input'],
  ...
}
</script>
```
--
",arturs,"
--
I guess it is happening because you are expecting input to update its value on current tick. Since you are using directive shortcut, it is triggered on `bind `and `update`. Neither is ensuring that component is updated.
Played with your codepen a little bit and got the same result with componentUpdated (personally expected that using this one will fix your issue). 

Best workaround I found is to wait for nextTick in your directive
https://codepen.io/anon/pen/MqYKLe

--
",,,,
8535,OPEN,The logic of Vue.set is unreasonable when handling array,,2018-10-23 20:00:43 +0000 UTC,xyzingh,In progress,,"### Version
2.5.17-beta.0

### Reproduction link
[https://jsfiddle.net/L6pey1ts/22/](https://jsfiddle.net/L6pey1ts/22/)

### Steps to reproduce
Run JSFiddle snippet

### What is expected?
I expect, that the program only outputs `2,3,5,7,11,13` (when executing `arr.push(13)`).

### What is actually happening?
```
    (empty line)
2,3,5,7,11
arr.abc changed
arr.def
    (empty line)
2,3,5,7,11,13
    (empty line)
arr.def changed
```

---
**abc** is already existed on **arr** when **app** is initializing, and it is neglected for it was defined on an array.

**def** is set by **Vue.set()**, but it executes **defineReactive(arr, 'def', 'arr.def')** (src/core/observer/index.js  line:225), and notifies the watchers.

Vue.set() should be consistent when dealing with them. In my mind, both of them should be neglected.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,xyzingh,"
--
Corrects #5216
--

--
You are right, but I am still considering about if we should give the same treatment to **arr.abc**, and there may be some other work to do if we truly want to enable reactive non-numerical prop on array.

As we know that **arr** was handled by **Observer.prototype.observeArray**, its non-numerical prop was ignored and not made reactive, which distincted from object.
![image](https://user-images.githubusercontent.com/32507398/43032933-b86a1ecc-8cf3-11e8-9dee-f9ee2990910b.png)

Also, in my modified snippet,
https://jsfiddle.net/L6pey1ts/40/
we can see that
    1. `arr.abc = ...`, `Vue.set(arr, ""abc"", ...)`  is not reactive
    2. `arr.def = ...` will notify the Dep of arr.def
    3. `Vue.set(arr, ""def"", ...)`  will notify the Dep of `arr` at first call for `def` is not on `arr`, therefore the watchers `arr`, `arr.abc`, `arr.def` was activated. `arr` shouldn't be activated because the sequence of the array has not changed. `arr.abc` was activated, because when using `app.$watch(""arr.abc"", func)` the `arr.abc` watcher record the value **""arr.abc""**, and `app.$set(app.arr, ""abc"", ""arr.abc changed"")` didn't change the value of this watcher, so it executes callback when the Dep of `arr` was notified.
    4. `Vue.set(obj, ""ghi"", ...)`  will notify the Dep of `obj` at first call for `ghi` is not on `obj`.

I have to point out there are many conflicts in handling object and array, and suggest we'd better disable the reactive prop of array.

Please forgive for some syntax errors, for I am not an English speaker. I am happy to accept corrections if someone is willing to help.
--
",Justineo,"
--
As #5216 was merged so we may assume this is an expected behavior. Using `Vue.set` to create reactive custom string keys for arrays are intentionally allowed by this PR. Removing this feature (or maybe you think it's a bug) would introduce a breaking change which we are not gonna accept ATM.
--
",yyx990803,"
--
I think it probably makes more sense for `Vue.set` to convert existing properties to a reactive one, if it is not already. Removing the existing behavior as in #8536 would be a breaking change so it's a no-go.
--
",,,,,,
8516,OPEN,Error thrown when using transition-group with conditionally rendered children,transition,2020-04-16 08:10:06 +0000 UTC,riophae,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/riophae/pen/EpgWdZ](https://codepen.io/riophae/pen/EpgWdZ)

### Steps to reproduce
1. Open the pen and it shows 1, 3, 5
2. Click the button

### What is expected?
It should show 3, 5

### What is actually happening?
Got this error in console:

```
[Vue warn]: Error in render: ""TypeError: c$1.elm.getBoundingClientRect is not a function""

found in

---> <TransitionGroup>
       <Root>

TypeError: c$1.elm.getBoundingClientRect is not a function
   at Proxy.render (VM643 vue.js:8383)
   at VueComponent.Vue._render (VM643 vue.js:4535)
   at VueComponent.updateComponent (VM643 vue.js:2788)
   at Watcher.get (VM643 vue.js:3140)
   at Watcher.run (VM643 vue.js:3217)
   at flushSchedulerQueue (VM643 vue.js:2981)
   at Array.<anonymous> (VM643 vue.js:1839)
   at MessagePort.flushCallbacks (VM643 vue.js:1760)
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,maxirozay,"
--
The transition try to modify an element from the v-for that is not rendered because of the v-if. You can use v-show instead of v-if to render the element. The best solution for me would be to filter the list in a computed property and give the filtered list in your v-for.
--

--
You're welcome Fangzhou.

`display: none` should work. But if you still have a `v-for` with a list the best solution is still to filter the list then give the filtered list to your `v-for`. Then in your JSX component you only care about rendering the component and never return null.

Yes that is weird that transition-group is trying to transition something that doesn't exist but it can be easily avoided. Maybe somebody who knows more about that can look at it.
--
",riophae,"
--
@maxirozay Hi Maxime, thanks for your reply.

My actual use case is that, I was not rendering a list inside `<transition-group />`, but some different components . And I was not using template but JSX. So there is no `v-if` or `v-show`. I was conditionally rendering the children using `if` statement in the child component's render function. When I didn't want to show the compent, I returned `null` in its return function. So I should try change that to set `display: none`.

But I still think it would be better for Vue to be able to handle cases like mine, since my code is very normal and not doing anything wrong :) Anyway, with `display: none` it should work.
--

--
@shinriyo See: https://github.com/vuejs/vue/blob/504d5da7eff1c77117c2f57b0c4238e56de80fc5/src/platforms/web/runtime/components/transition-group.js#L80
--
",shinriyo,"
--
what is `c$1.elm.getBoundingClientRect is not a function`?
Did you fix?
--
",Daiver13,"
--
Any update?
--
",kostia7alania,"
--
i have the same issue
--
",selfagency,"
--
I am having the same issue but with `v-show` on 2.6.10
--

--
@LinusBorg I figured out my issue—

In my component, I was trying to alternate between two global components using `v-show`. My guess was that the subcomponent needed to render before trying to attach an event to it, and there was a race condition preventing it from doing so.  So, I wrapped the global components in `div` tags and put the `v-show` on those, and then my problem was solved. Could this possibly also be resolved by using an async component?

**Before (throws error)**
```html
<transition-group name=""zoom"" mode=""out-in""> 
  <inline-svg v-show=""modal"" key=""close"" :src=""close"" width=""25"" height=""25""></inline-svg>
  <inline-svg v-show=""!modal"" key=""open"" :src=""open"" width=""25"" height=""25""></inline-svg>
</transition-group> 
```

**After (no error)**
```html
<transition-group name=""zoom"" mode=""out-in"">
  <div v-show=""modal"" key=""close"">
    <inline-svg :src=""close"" width=""25"" height=""25""></inline-svg>
  </div>
  <div v-show=""!modal"" key=""open"">
    <inline-svg :src=""open"" width=""25"" height=""25""></inline-svg>
  </div>
</transition-group>
```

I hope this helps others.
--
"
8507,OPEN,Possible memory leak when v-for in development mode,improvement,2020-02-24 14:33:10 +0000 UTC,peluprvi,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/anon/pen/KBMaOY](https://codepen.io/anon/pen/KBMaOY)

### Steps to reproduce
- Open the codepen https://codepen.io/anon/pen/gjMgzG
- Click a couple of times to list 0 item, then 1000
- See the memory increasing
- Try force GC (trash icon) before measure it
- Take heap snapshots in Chrome ""Memory"" tab
- Watch the memory usage in the Chome task manager (shift   esc)
- Watch the memory usage in OS task manager

### What is expected?
Same memory usage after garbage collector

### What is actually happening?
Despite the ""Performance"" tab displays the same memory usage, the ""Memory"" heap snapshot displays a memory increase.
Also, the both Chrome and OS task managers show the memory only increasing.

---
It get worse when:
- Using Vuei18n (even without translating)
- Having big children components

Tested on:
- Windows 7 64 Bits
- Chrome 67.0.3396.99 64 bits

Please, consider that:
- I may be doing something wrong
- It can be a Chrome issue
- It can be an OS issue

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It seems there is a leak in non-production mode only. You should be fine in production
--
",peluprvi,"
--
Thanks for the return @posva .

I also created an issue on vue-i18n, since the memory usage gets way too heavy when using it.
I'm using vue-virtual-scroller too, which do destroy and create a lot for components when paginate or scroll the page.

I don't know how much these can be related, but these two packages together with some complex or deeper components structure are taking a lot of memory usage even on production mode.

Looking into Google task manager, my app tab increases by ~2.400K each item I scroll down/up (each one is destroyed/created in the processes).
In less than a minute scrolling up and down I get get almost 1GB memory usage, production mode or developer tools closed or after GC. And it doesn't go much down after route.

I'm not used to the core code of vue or vue-i18n, but It looks like the installed components structure are getting copied for each nested component in the app, and the GC can't clean that up after destroy that nested components. It can be the way vue-i18n installs itself, I really don't know. The data below is what makes me think about that:

![image](https://user-images.githubusercontent.com/1561360/42843561-d694731c-89e6-11e8-9ff5-49fcdaa94805.png)

--
",Rikhart,"
--
I have the same issue, any advance about this?
--
",,,,,,
8494,OPEN,When a getter is defined that does not define a setter; no recursive reactive is made.,has workaround,2019-07-11 09:04:02 +0000 UTC,ts0307,In progress,,"### Version
2.5.17-beta.0

### Reproduction link
[https://jsfiddle.net/ts0307/pd8zr3sk/](https://jsfiddle.net/ts0307/pd8zr3sk/)

### Steps to reproduce
Run JSFiddle snippet

### What is expected?
I expect, the result is shown as {""bar"": ""b""} instead of {""bar"": ""a""}

### What is actually happening?
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)

My example is that the data object defines that the getter does not define a setter, causing the above judgment to fail, val is not evaluated, and no recursive reactive is made.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,pkaminski,"
--
FYI:  Ignoring getters was done on purpose due to #7280.  I added an exception for getter/setter pairs in #7828 to fix my own use case.  I don't know whether ignoring pure getters is right or not, but either way it's clear that somebody will be unhappy.
--
",ts0307,"
--
It seems that it is difficult to be compatible with all use cases.
--
",malaxiannv,"
--
@ts0307 if a getter is defined, proving that the property is an accessor property. If an accessor property does not have a setter, that means the property cannot be set new Value, thus there is no need to make it be recursive reactive.
--
",shengrongchun,"
--
why not?
let childOb = !shallow && observe(val) -->
get: function reactiveGetter () { const value = getter ? getter.call(obj) : val; childOb = !shallow && observe(value);
--
",,,,
8485,OPEN,Component scope attribute is lost when conditionally rendering root node,has workaround,2018-07-12 11:37:35 +0000 UTC,Frizi,In progress,,"### Version
2.5.16

### Reproduction link
[https://codesandbox.io/s/5vj19q8yk](https://codesandbox.io/s/5vj19q8yk)

### Steps to reproduce
1. observe that text is green
2. click two times on checkbox to trigger slot's hide and show cycle


### What is expected?
3. text should still be green

In other words, the toggled `div` should have `GreenSlot`'s `data-v` attribute applied

### What is actually happening?
3. observe that text is red

In other words, the toggled `div` doesn't have correct `data-v` applied.

---
Also tested on beta, issue persists.

In my use-case, I cannot trivially replace it with external `v-if`, as the component that does the toggling contains important internal logic that decides if it should be shown or not. It's not just a simple prop.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
As a workaround make sure to always have a node for the ConditionalSlot component (`<div v-else/>`)
But I'm not sure it should be green actually, why would the style of the wrapper component leak into the slot that was written in the parent?
--
",Frizi,"
--
That's because the `<slot>` is also a part of component, so it receives it's scope. In the case from the example, it ends up being the `div` with ""I should be green"" text directly. In fact, this `div` is a node present in all `App`, `GreenSlot` and `ConditionalSlot` components at the same time.
--
",,,,,,,,
8467,OPEN,Vue.compile should return the errors which happens during compilation even in prod env,feature request; improvement,2020-10-13 03:11:23 +0000 UTC,jbouzekri,In progress,,"### What problem does this feature solve?
I am building a VueJS frontend where templates are coming from a backend where end users contributed them in a CMS or something else. VueJS is bundled with esm in order to have the Vue.compile method.

When I run Vue.compile with the template string coming from the backend, I have no way to know if a compilation error occured in order to display a message to the user. In development I just have the warn messages in the console.

### What does the proposed API look like?
Vue.compile could return an error boolean in an attribute or an array of all errors that occured during compilation.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Vue already does that. If it's failing at some specific scenario it shouldn't be failing at, please provide a repro
--

--
oh, indeed the errors are not returned as I thought
--
",jbouzekri,"
--
@posva  : I don't think it does. `Vue.compile` just returns an object like this : 

```
{
    render: function() { .... },
    staticRenderFns: []
}
```

There is no indication that compilation had error. Just the warn message in dev environment.
--
",DelfsEngineering,"
--
Was this every addressed?, or is there a way to detect compilation errors, namely more than oen parent node?
--
",,,,,,
8461,OPEN,Error thrown when using transition-group with component v-bind:is directive,transition,2018-08-29 04:38:07 +0000 UTC,chipit24,Opened,,"### Version
2.5.16

### Reproduction link
[https://jsfiddle.net/50wL7mdz/451168/](https://jsfiddle.net/50wL7mdz/451168/)

### Steps to reproduce
Render a `component` (not just any component, but the build-in one: https://vuejs.org/v2/api/#component), with the `v-bind:is` directive set to `""transition-group""` (or simply `is=""transition-group""`):

```
<component is=""transition-group""></component>
```

### What is expected?
I expect no errors to be thrown.

### What is actually happening?
This component appears to work as expected but throws the following error in the console:

```
vue.js:597 [Vue warn]: Unknown custom element: <component> - did you register the component correctly? For recursive components, make sure to provide the ""name"" option.

found in

---> <TransitionGroup>
       <TransitionWrapper>
         <Root>
```

No error is thrown if `transition` is used instead of `transition-group`.

---
I came across this bug because I was building a re-usable animation component that looks like this:

```
<template>
  <component
    :is=""group ? 'transition-group' : 'transition'""
    @enter=""velocityEnter""
    @leave=""velocityLeave""
  >
    <slot/>
  </component>
</template>
```

The component actually seems to work as expected, but the error described above is thrown.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
`transition-group` has to render a root-node, which by default, is a `<span>`,and which ca be customized with the `tag` attribute.

However - and this is not clearly documented I think - if you are using `transition-group` through the special `is=""""` attribute, `transition-group` will actually try and use the tag that you used the `is` on as the element for the root node:

https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/components/transition-group.js#L52

While that may seem confusing, it's actually pretty useful. `is=""""` can be used on any element - it's most often used in that way to turn a `<tr>` in a DOM-template into a component, since other elements would be hoisted out of the `<table>` befoe Vue can touch the template:

```html
<tr is=""mycomponent"">
```

In terms of `transition-group`, the usecase would be:
```html
<transition-group tag=""li""> 

<!-- has the same result as: -->

<li is=""transition-group""> 

<!-- if transitiongroup didn't do what I explained above, 
        you would have to do the following, which feels a bit redundant:
-->
<li is=""transition-group"" tag=""li""> 
```

Now the consequence of your code is that `transition-group` actually renders a literal `<component>` element as it's root node, which is neither a native HTML Element nor a Vue component - it's just a placeholder not meant to be rendered to the DOM, really.

### Solution
```html
<span
    :is=""group ? 'transition-group' : 'transition'""
```

--- 

/ping @chrisvfritz should we document this?
--

--
Would be totally feasable as what I described wasn't a default behaviour of Vue, but rather an intentional decision in the code of that component. 
--
",chrisvfritz,"
--
Hm, I'm wondering how feasible it would be to have `transition-group` make an exception and still fall back to a `span` when the tag is `component`. Then it would behave as expected and there'd be no need to document the gotcha.

@LinusBorg What do you think?
--
",,,,,,,,
8433,OPEN,Allow to call original `errorHandler` when custom one defined,improvement,2019-07-01 13:06:27 +0000 UTC,ArmorDarks,In progress,,"### What problem does this feature solve?
When custom `Vue.config.errorHandler` defined by the user, it will stop firing original [`logError `](https://github.com/vuejs/vue/blob/c2b1cfe9ccd08835f2d99f6ce60f67b4de55187f/src/core/util/error.js#L38).

The problem is that there is no straight way to recreate `logError ` behavior in custom `Vue.config.errorHandler` without requiring some Vue's internals.

This issue is partially related to [raven-js#1416](https://github.com/getsentry/raven-js/issues/1416), which defines custom `errorHandler`... which prevents Vue from login errors to the console.

### What does the proposed API look like?
I think Vue should by default expose original `errorHandler` under `Vue.config.errorHandler`. In other words, `Vue.config.errorHandler` shouldn't be `undefined` by default.

If the user would like to override `errorHandler`, he will reassign it. Otherwise, it would be possible to save original `Vue.config.errorHandler` into some variable and call it within custom `errorHandler`.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
You should be able to recreate it easily:

```js
function logError (err, vm, info) {
  if (process.env.NODE_ENV !== 'production') {
    warn(`Error in ${info}: ""${err.toString()}""`, vm)
  }
  console.error(err)
}
```

Apart from that, this looks reasonable to me
--
",ArmorDarks,"
--
`warn` content isn't easily re-creatable (that's what I meant when said ""there is no straight way to recreate `logError` behavior"", I had to be more specific), and it's importable only from Vue sources, that's not an option in most cases.
--
",b,"
--
I just ran into this error too. It looks like the warn function is actually available via `Vue.util.warn`. So the custom error handler can be:

```javascript
  Vue.config.errorHandler = (err, vm, info) => {
    if (process.env.NODE_ENV !== 'production') {
      Vue.util.warn(`Error in ${info}: ""${err.toString()}""`, vm)
    }
    console.error(err)
  }
```

I am using Vue 2.6.2
--
",loomchild,"
--
Since the request looks reasonable and it simplifies configuration of external loggers, I am wondering if anyone is working on a PR for this? If not I'd be happy to try to propose something (basically exposing original `errorHandler` under `Vue.config.errorHandler`).
--
",,,,
8424,OPEN,<transition-group> not working as expected on page scroll,has PR; transition,2019-08-01 15:31:09 +0000 UTC,Justineo,Opened,,"### Version
2.5.16

### Reproduction link
[https://codesandbox.io/s/kxkmp9mov3](https://codesandbox.io/s/kxkmp9mov3)

### Steps to reproduce
1. Create a list using `<transition-group>`.
2. Put the list at the end of a long page.
3. Scroll to the bottom of the page.
4. Trigger some change so that the page height is reduced and force the viewport to scroll upwards a little bit.

### What is expected?
The existing items should stick to the container, instantly appear in the final position, without transitions.

### What is actually happening?
The existing items jump out of the container because of the sudden change on vertical position and slowly move back to the expected position.

---
Internally, `<transition-group>` is using `getBoundingClinetRect()` to track the positions of transition items. This works fine when no page scroll is introduced. But when browsers force page scroll on certain situations, the container (and the rest of the page) flashed into the final position while transition items are stuck in the old position based on the viewport, which makes it look like they suddenly jump out of the document and start performing unexpected transitions.

Maybe we can provide some new prop on `<transition-group>`, say, `origin: 'viewport' | 'document'`, to optionally calculate positions based on the canvas origin instead of the viewport.

F.Y.I.

When forced page scroll is triggered:

![jun-28-2018 14-55-05](https://user-images.githubusercontent.com/1726061/42018058-80ecc336-7ae3-11e8-91da-f8774d873946.gif)

When not triggered:

![jun-28-2018 14-55-12](https://user-images.githubusercontent.com/1726061/42018090-97fb94c6-7ae3-11e8-879c-6212e952ecda.gif)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,misterobot404,"
--
Same problem. How to fix?
--
",saschwarz,"
--
FWIW I worked around this by forcing scrolling to the top on route transitions:
https://router.vuejs.org/guide/advanced/scroll-behavior.html
```
const router = new Router({
  mode: 'history',
  scrollBehavior(to, from, savedPosition) {
      return { x: 0, y: 0 }
  },
...
```
--
",,,,,,,,
8415,OPEN,Style bindings with !important don't work properly in IE 11.540,browser quirks,2018-06-27 06:37:03 +0000 UTC,superMDguy,Opened,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/anon/pen/QxVRyW?editors=1010](https://codepen.io/anon/pen/QxVRyW?editors=1010)

### Steps to reproduce
I've only seen this occur in IE 11.540 (through BrowserStack). The issue is not present in IE 11.0.

1. Click ""toggle"" button
2. ""Surprise!!"" should show up
3. Click ""toggle"" button again
4. ""Surprise!!"" is still visible

### What is expected?
Clicking ""toggle"" should hide the message. This works properly in chrome, and probably other browsers as well.

### What is actually happening?
The message is still visible, and has the `display: block !important` styling applied.

---
This causes problems with modals in semantic ui vue. See Semantic-UI-Vue/Semantic-UI-Vue#191

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sodatea,"
--
As a workaround, you can change `'none'` to `'none !important'` and the new style will apply.
--
",,,,,,,,,,
8413,OPEN,Transitions classes are added after `before-enter` or `before-leave`,transition,2020-04-21 17:40:16 +0000 UTC,nicooprat,Opened,,"### Version
2.5.16

### Reproduction link
[https://codesandbox.io/s/zq5mw2zk9x](https://codesandbox.io/s/zq5mw2zk9x)

### Steps to reproduce
1. Open browser console (to trigger the debugger)
2. Click on ""Page 2""
3. Inspect elements inside `<main`>`

### What is expected?
The two children `<sections>` are supposed to have the transitions classes.

### What is actually happening?
The two children`<sections>` are already added but without any transition class, which are added on next tick. So the new `<section>` is visible on top on the old one for 1 frame, causing a flickering effect.

---
Remove this fix in `App.vue`:

```css
main > :first-child {
  z-index: 1; /* Prevent flickering on first frame when transition classes not added yet */
}
```

And navigate through the app to see the flicker effect.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,josvos,"
--
This is not what I see (Vue 2.6.11): When the `@before-leave` function is called, the element does already have the transition classes. In fact, I had hoped the `@before-*` functions would be called at a moment I can still prevent a transition: I want to be able to conditionally set a boolean used in `:css=""bool""`. For me this now does work fine with `@before-enter`, but not with `@before-leave`.
--
",,,,,,,,,,
8409,OPEN,Computed Watchers Not Firing,browser quirks; help wanted,2020-08-16 12:09:11 +0000 UTC,grayfella,In progress,,"### Version
2.5.16

### Reproduction link
[https://vuejs.org/v2/guide/computed.html#Watchers](https://vuejs.org/v2/guide/computed.html#Watchers)

### Steps to reproduce
Use the demo for entering a question on the Docs page using a Amazon Kindle 7'' or Android Tablet (I used a Lenovo Tab 3 7'' version)
https://vuejs.org/v2/guide/computed.html#Watchers

### What is expected?
When typing in the field the value is evaluated after each letter is tapped when using a browser on a tablet, as per the demo instructions. 

### What is actually happening?
Nothing is evaluated until the space bar is tapped or a question mark / exclamation mark is selected from the keyboard. 

---
I use this to create a drop down list of options when a user starts typing into a text field using Android tablet specifically Amazon Fire.
The user starts typing and after letters are entered the list is shown..
After updating then the list is only shown if the user taps the space bar or the enter key on the on screen keyboard.
This works as expected when using a browser on a computer.
I have tested my code on Mac using Safari, Chrome and Firefox and no errors are in the console. 
On Amazon Fire and it works as expected when on version 2.5.13
Updating my VueJS to version 2.5.16 and this stops working on the tablet and requires the space key, exclamation mark, question mark or enter key to be tapped for the evaluation to fire/run when using the tablet device.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,zaggy,"
--
hi, may I try to fix this as my first bug?
--
",sodatea,"
--
@zaggy Sure! 😀
--
",grayfella,"
--
Just a guess but would it be this issue that was fixed that causes it? https://github.com/vuejs/vue/pull/7121 
I'm not sure how I would exclude that from a version for testing.
The reason being that the form field is not being processed until a 'button' such as enter is tapped whereas before it was processing the content as soon as it changed.
--

--
Issue still remains.
--

--
Yes it is. I'm using the standard help page / demo page on a Kindle Fire and you have to tap the enter key when typing letters before the check is made. A question mark or an exclaimation mark after a word does fire the check the same as tapping the enter key. 
--

--
I could replicate also on a Lenovo Tab 3. On both I have spell check / suggestions disabled in off chance that would help but it doesn't. 
--

--
It okay on an old Android 5 device I tested with but the Kindle Fires have the issue. Even with all the spelling options disabled there is an underline on the text you type in the field. Once you press space bar or enter that line goes and then the event is fired and in my case the dropdown shown.
--
",THEozmic,"
--
What's the status of this?
--
",karanisverma,"
--
@zaggy are you working on it? if not I would like to pick this up! 🙂
--
",chriswburke,"
--
is this still an issue?
--
"
8379,OPEN,Dynamic input field type renders invalid code in IE11,improvement,2019-12-27 13:48:42 +0000 UTC,nirazul,In progress,,"### Version
2.5.17-beta.0

### Reproduction link
[https://github.com/nirazul/vue-loader-bug-repro](https://github.com/nirazul/vue-loader-bug-repro)

### Steps to reproduce
1. `npm install`
2. `npm run build`
3. `npm run watch`
4. Open `./public/index.html`
5. Inspect `main.bundle.js` in dev tools
6. On line 9044 you will find a duplicated key `value`

### What is expected?
A valid output from vue-template-compiler without duplicated value props, or at least a warning that the usage of dynamic input field types is prohibited in certain cases.

### What is actually happening?
In IE11 a blank page is rendered

---
I'm using a centralized component for both radio and checkbox input fields as the markup is 90% the same.
As we switched from webpack 3 to webpack 4, we had to also upgrade the vue-loader version from 12 to 13 or 14, which introduced this bug. 
Prior to version 13, vue-template-renderer was not enforcing strict mode on all of its rendered templates. This is now the case, introducing this critical bug.


References:
https://vuejs.org/v2/guide/forms.html#Radio-1
https://github.com/vuejs/vue/issues/7048
https://github.com/vuejs/vue/issues/6917

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sodatea,"
--
See discussions here: https://github.com/vuejs/vue/pull/7406

In this case, we are more likely to patch code generation to suppress :value emission when both type is dynamic and v-model is set. Thanks for pointing out!
--
",nirazul,"
--
@sodatea 
Thanks for the clarification. I agree that `:value` suppression would be the right way to go with that.
--
",ollietreend,"
--
I've just experienced this exact same 'white screen' issue with IE11, whereas no warnings or problems were experienced in modern browsers (Chrome, Firefox, Safari, Edge).

The IE11 JS console showed the following error:

```
Multiple definitions of a property not allowed in strict mode
```

I jumped down the rabbit hole and followed a few threads between different issues and PRs here, but struggled to find a clearly documented solution. After some trial and error, I've come up with something that works for my needs.

For the benefit of others in the same situation, this is the solution I've come up with:

## Solution

Originally I'd bound the `input` `type` attribute to a variable, which would either be `checkbox` or `radio`:

```vue
<input :type=""type"" :value=""value"" v-model=""model"" />
```

Since the issue seems to stem from dynamically binding the `type` attribute, I changed my template to conditionally render the input using `v-if`:

```vue
<input v-if=""type === 'checkbox'"" type=""checkbox"" :value=""value"" v-model=""model"" />
<input v-if=""type === 'radio'"" type=""radio"" :value=""value"" v-model=""model"" />
```

By hardcoding the `type` attribute for each of the possible types, and showing them conditionally depending on the value of `type`, I was able to workaround this particular bug. IE11 seems to be fine with this.
--
",4refael,"
--
Just spent a few hours trying to debug the same issue.
This is still an issue in v2.6.10..

--
",rs3d,"
--
I've also spend now some time debugging this on a async module, which complicated the bug search a lot. It would be great to have this fixed <3
--
",,
8350,OPEN,VNode.componentInstance is undefined when rendered by a functional component,regression,2020-06-19 08:06:59 +0000 UTC,KaelWD,In progress,,"### Version
2.5.17-beta.0
2.5.16

### Reproduction link
[https://codepen.io/anon/pen/rKwWXq?editors=1010](https://codepen.io/anon/pen/rKwWXq?editors=1010)

### Steps to reproduce
Open the console

### What is expected?
An instance of `MyComponent` should be logged

### What is actually happening?
`undefined` is logged

---
This worked in 2.5.15
It also works if you change `RootComponent` to be non-functional:
```js
const content = h(MyComponent, {}, this.slots.default)
```
I'm guessing this was caused by 62a922e8, `cloneVNode` doesn't include that property. 

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sodatea,"
--
IMHO, private APIs may not be the best idea to rely on as they are always subject to change.
--
",KaelWD,"
--
Yeah probably. It would be nice if it was usable though, because functional components don't have a reliable way to access `$refs` as far as I know. 
--

--
Ok I've figured out a bit of a workaround using `context.data.ref` and `context.parent.$refs[context.data.ref]`, but it fills `$refs` with `undefined` when the parent re-renders: 
![image](https://user-images.githubusercontent.com/16421948/41928926-17dae7f8-79ba-11e8-987f-9b9d67bd9fab.png)

Is there anything like `_uid` to tell functional components apart? (again, more private interfaces)

--

--
Also is `componentInstance` even really private API? It doesn't have a `_` prefix, and is pretty common to see when working directly with VNodes. 
--
",sc0Vu,"
--
@KaelWD Did you solve this issue? The componentInstance is also undefined when I use named slot like:

A component  template
```JS
<template v-slot:body>
  <test>Hello world</test>
</template>
```

B component template
```JS
<div>
  <slot name=""body""></slot>
</div>
```

B component script
```JS
export default {
  mounted () {
    console.log(this.$slots.body)
  }
}
```
--
",edlefebvre,"
--
> @KaelWD Did you solve this issue? The componentInstance is also undefined when I use named slot like:
> 
> A component template
> 
> ```js
> <template v-slot:body>
>   <test>Hello world</test>
> </template>
> ```
> 
> B component template
> 
> ```js
> <div>
>   <slot name=""body""></slot>
> </div>
> ```
> 
> B component script
> 
> ```js
> export default {
>   mounted () {
>     console.log(this.$slots.body)
>   }
> }
> ```

Quite an old issue I know... but did you find a solution @sc0Vu ?
--
",,,,
8308,OPEN,vdom: warn innerHTML not watch when the string have some escaped chars,improvement,2018-06-06 08:55:35 +0000 UTC,cxtom,Opened,,"### Version
2.5.17-beta.0

### Reproduction link
[https://codepen.io/cxtom/pen/XYKgde](https://codepen.io/cxtom/pen/XYKgde)

### Steps to reproduce
1. using v-html and the string has \&quot; \&#39;
2. ssr
3. warn not match during hybrating in browser

### What is expected?
not warn The client-side rendered virtual DOM tree is not matching server-rendered content

### What is actually happening?
warn The client-side rendered virtual DOM tree is not matching server-rendered content.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
8302,OPEN,Inconsistent behavior when using deep objects in vuex with SSR,,2018-06-05 16:53:32 +0000 UTC,Sopamo,In progress,,"### Version
2.5.16

### Reproduction link
[https://github.com/Sopamo/vue-ssr-deep-state-bug-reproduction](https://github.com/Sopamo/vue-ssr-deep-state-bug-reproduction)

### Steps to reproduce
 - Install all node modules
 - Run `npm run dev`
 - Open localhost:8080
 - Reload the page while being on page A

### What is expected?
The class of both divs should reflect the value of their variables

### What is actually happening?
The classes of both elements are wrong (they have the class ""true"" despite them having changed to ""false""). The issue is gone when you navigate between page B and page A. The issue only occurs when you are reloading the browser on page A.

---
The inital state is that both variables are true. They are both being set to false in the entry-client.js file with the `store.replaceState` method.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Sopamo,"
--
I had a bug in the code (which I fixed) which made it appear like the ""deepness"" is an issue. It isn't.
I updated the reproduction link and the issue description accordingly.
I also forgot to mention that when outputting the value of the variables they are correct, only when using them as a class they do not work. You see this in the reproduction.
--
",,,,,,,,,,
8296,OPEN,CSS injection does not work with funcational component and/or undefined context,,2019-05-24 20:06:05 +0000 UTC,znck,Opened,,"### Version
2.5.16

### Reproduction link
[https://github.com/znck/ssr-functional-component-css-inject-bug](https://github.com/znck/ssr-functional-component-css-inject-bug)

### Steps to reproduce
- `yarn`
- `yarn test`

### What is expected?
Server render HTML should have `<style>` block.

All tests should pass.

### What is actually happening?
In tests, 3 of 4 cases does not have injected styles.

https://github.com/znck/ssr-functional-component-css-inject-bug/blob/17e6ca6e5bc6b6135b84ea6083e79168fadf7753/tests/SSR.spec.js#L20-L36

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Robula,"
--
I'm glad I'm not the only one. I have been searching for hours for a solution to this.

```
css-loader: 2.1.1
vue: 2.6.10
vue-loader: 15.7.0
vue-server-renderer: 2.6.10
vue-style-loader: 4.1.2
vue-template-compiler: 2.6.10
webpack 4.32.2
```

I can remove `functional` for now, but it would be nice to get rid of the unneeded data attributes since I won't be hydrating.
--
",,,,,,,,,,
8278,OPEN,Make vue available to other libraries without having to import it,discussion,2020-01-11 22:32:32 +0000 UTC,KaelWD,In progress,,"Title needs work, idk what to call this. 

### What problem does this feature solve?
Writing a component library with typescript requires importing Vue so you can use `Vue.extend(...)` to get typings. This causes problems when webpack decides to load a different instance of vue. 
See https://github.com/vuetifyjs/vuetify/issues/4068

### What does the proposed API look like?
[Local registration](https://vuejs.org/v2/guide/components-registration.html#Local-Registration) to accept a function that **synchronously** returns a component, calling it with the parent vue instance. 

The library can then do:
```ts
export default function MyComponent (Vue: VueConstructor) {
  return Vue.extend({ ... })
}
```

And be used like:
```js
import MyComponent from 'some-library'

export default {
  components: { MyComponent }
}
```

Of course that would then cause other problems, particularly where we use methods directly from other components. Maybe something that adds types like `Vue.extend()` but doesn't have any runtime behaviour would be better instead?

```ts
// When used, this will behave the same as a bare options object, instead of being an entire vue instance
export default Vue.component({
  ...
})
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,ktsn,"
--
You may want to use https://github.com/ktsn/babel-plugin-remove-vue-extend
--
",KaelWD,"
--
👌 

How does that handle stuff like [mixins](https://github.com/vuetifyjs/vuetify/blob/dev/src/util/mixins.ts) ([usage](https://github.com/vuetifyjs/vuetify/blob/dev/src/components/VBtn/VBtn.ts#L19)) or [directly calling methods](https://github.com/vuetifyjs/vuetify/blob/dev/src/components/VAvatar/VAvatar.js#L33)? 

EDIT: Didn't rtfm, this looks perfect. I'll have to try it out to see how well it actually works though. I might have to massage the types a bit to get &#35;2 working. 
--

--
The plugin doesn't work on everything, it seems to assume that all exports are `Vue.extend()`
![image](https://user-images.githubusercontent.com/16421948/40799873-16b13a02-6552-11e8-9111-9cef69bc996d.png)

EDIT: Or not, I still get the same error if I wrap that component. 
--

--
I'm fine with having to use `Vue.extend`, it's just not ideal that it creates a standalone instance. It would be nice if vue still resolved component references and everything else the same way as with bare options objects. It isn't really a problem anyway unless one of our users messes up and somehow ends up with two different vue imports. 
--

--
Yeah that would be helpful, the current errors don't really indicate what's actually going on very well. Is our current setup likely to be a problem with vue-test-utils and `createLocalVue` though? vuejs/vue-test-utils#532 seems similar to this one. 
--

--
![image](https://user-images.githubusercontent.com/16421948/41507789-3fa7f6a2-727d-11e8-8acc-05261e89242d.png)

https://github.com/vuetifyjs/vuetify/blob/c722f79b92550405e94ec6bb0129ad56ac869aed/src/mixins/routable.ts#L69
https://github.com/vuetifyjs/vuetify/blob/c722f79b92550405e94ec6bb0129ad56ac869aed/src/components/VBtn/VBtn.ts#L150
--

--
I use this to make sure the same file is always loaded, you can omit the `path.resolve` if there's no symlinks or other weird directory setup being used. 
```js
resolve: {
  alias: {
    'vue$': path.resolve(__dirname, '../node_modules/vue/dist/vue.runtime.esm.js')
    // 'vue$': 'vue/dist/vue.runtime.esm.js'
  }
}
```
--
",posva,"
--
@ktsn can we close this or is there anything we could do in Vue core to improve the situation? 
--
",yyx990803,"
--
Alternatively we may try to detect duplicate Vue imports.
--
",uris,"
--
A few months ago I have asked for help with [an issue related](https://stackoverflow.com/questions/48570028/webpack-vue-typescript-vue-in-main-package-and-in-library-is-imported-twi) to this one on stackoverflow.
I've been living with my temporary solution since then (passing the Vue instance to the library initializer, and not importing Vue in the library), but I'm not very happy about it and now I'm stuck because Vuetify also started to use typescript and creates a separate Vue instance and it's not clear how to tell to webpack (or to Vue) that it's always the same instance that has to be used.
The solution provided at the top of this thread does not help me much, since I'm not using babel.
Are you aware of an existing solution to have a package and dependencies, all written in typescript and compiled with webpack, to share the same Vue instance?
--

--
The solution should also allow to use .vue files in packages, which, with the original proposal at the top of this thread would probably not be possible.
--

--
After giving a hard look at the problem, the only solution that I found at the moment (with webpack) is to add vue as an external import wherever you import it.
In webpack.config.js
````
externals: {
    vue: 'Vue'
},
````
and then import vue.js with a script tag (or an equivalent solution) in your html file.
This avoids that vue is instantiated more than once. Depending on your package and subpackage structure, you probably need to import your subpackages and or vuetify also as external modules.

That means that you have to pack them as standalone libraries, with, in webpack.config.js
````
    output: {
        path: 'path/to/your/output',
        filename: 'build.js',
        library: 'LibraryName',
    },

````
and in tsconfig.json
````
""compilerOptions"": {
    ...
    ""module"": ""es2015""
    ...
}
````
As a side effect with this solution you can also work with vue files in your libraries. The proposed solution at the top of this issue would in any case not allow that, because you cannot inject the vue constructor in a vue file (as far as I understand).
If you are working with tests suites like karma and phantomjs you need to inject vue and the other external libraries there as well.
This is now a workaround and a better solution would be if vue would have at initialization an option to detect if there is another VueConstructor outside the actual bundle and use it (as an option, because that may or may not be desired). 


--
",wfischer42,"
--
I had the ""duplicate import"" problem in a monorepo project using [Lerna](https://github.com/lerna/lerna), and it seems to be related to the same problem when using `npm link` or `yarn link`. My project has a shared component package that multiple apps import, including an Electron app and a browser extension. It seems that `lerna bootstrap` uses symlinks, ultimately leading to some bundle confusion, in which Vue is separately imported for the main repo and the dependency, thereby causing the '`$listeners` and `$attrs` are readonly' errors. 

From what I've found, the common generalized solution seems to be to mark your dependency as an 'external' in whatever build configuration you're using.

I'm using Electron with `electron-builder` and `@vue/cli`. I solved this problem by adding this to my `vue.config.js`:

```js
module.exports = {
  pluginOptions: {
    electronBuilder: {
      // List native deps here if they don't work
      externals: ['my-shared-components'],
    }
  }
}
```

--
"
8266,OPEN,Transition using js hooks always run the initial render,transition,2019-04-24 21:42:35 +0000 UTC,jackysee,In progress,,"### Version
2.5.16

### Reproduction link
[https://jsfiddle.net/p1dthw6z/](https://jsfiddle.net/p1dthw6z/)

### Steps to reproduce
In the demo link, toggle checkbox 'odd'.

### What is expected?
When rows appeared, both inner element transition using CSS (fade) and transition using hooks (slide) should not do initial render.

### What is actually happening?
Transition using CSS do not run the initial render, as expected.
But the transition using hooks run the initial render, as if I have used `<transition appear>`, which I didn't.

---
I don't know if it is the intended behavior. If it is, I would like to know how to avoid the initial render in the hooked transition.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,jwanggggg,"
--
Hi, I looked at your JSFiddle, and toggling the checkbox 'odd' collapses the a2 and a4 rows. Are you referring to the initial slide transition that occurs when odd is unchecked?
--
",jackysee,"
--
@jwanggggg yes
--
",,,,,,,,
8241,OPEN,VueSSRServerPlugin produces a slow-to-parse JSON for large projects,improvement,2020-10-01 04:01:00 +0000 UTC,nemtsov,In progress,,"### What problem does this feature solve?
Makes for a better development experience with vue SSR.

I was looking into why it takes 500ms to render an single-component page from the server in our fairly large application and found an interesting issue. Webpack creates ~40 bundles for us. Altogether, these weigh ~20MB. The way  `VueSSRServerPlugin` plugin works, as you know, is it combines all of these files into a single `vue-ssr-server-bundle.json` file. Reading that file in node is fast (5ms on average) for us, but after reading it we need to `JSON.parse` it before providing to `createBundleRenderer` and _that_ takes ~400ms.

Initially I was thinking of using webpack's `splitChunks`, to reduce the file-size (our router dynamically imports top-level pages, so each chunk could benefit from not having to bring in common component) but `VueSSRServerPlugin` does not support that (and throws the ""Server-side bundle should have one single entry file"" error).

### What does the proposed API look like?
I'm not exactly sure what to do here at this point as I just noticed this issue. I'm concerned that as the app grows, the json parse time will increase adding seconds to the load-time in development.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yyx990803,"
--
400ms reload during dev seems acceptable for ""a fairly large application""... unless you expect your app to be 3~4 times larger than it already is in the future?
--
",nemtsov,"
--
Thanks for responding, @yyx990803. We're anticipating the app to grow by more pages. That is what's making me concerned that a single JSON file containing all of the code (without at least the ability to split out common chunks) will not scale for us. Also (and this is subjective, of course) 400ms is a noticeable penalty for every refresh of the app.
--

--
Thanks for your analysis and care for the ecosystem, @zeltice!

You're correct in that by externalizing our vendor libraries the size of the `vue-ssr-server-bundle.json` goes down. The amount of reduction we see with the use of `webpack-node-externals` isn't quite 95% unfortunately, but is a decent ~20%. This brings us down to ~16MB.

The next big chunk of that file is made up of source-maps, disabling which unsurprisingly gives us a ~50% reduction (to ~8MB of first party code). Of course, this also means that we can't debug, so disabling these isn't an option, but it's important to know that it isn't just code in there.

As I wrote, we're running a large website with ~30-and-growing top-level page components and many features across those pages. Although tolerable for now, I don't believe the single-json-file approach of the` VueSSRServerPlugin` scales well. That being said, 90% of the time is spent parsing the JSON file, and not reading it, so perhaps a low-hanging fruit is to optimize that, maybe by using an alternative serialization format, or maybe by allowing source-maps to be their own file.
--

--
Thanks again for your comment, @zeltice. Webpack combines our source files into a single bundle and uses the loaders to compile the source `.vue` templates and styles into JS. Thus, disabling source maps in development would mean that we would get post-combine-and-compile bundle-specific line & column numbers in stack traces instead of source-file-specific line numbers, making it very difficult to identify the source of errors.
--

--
It has now been two years since I opened this issue. Whereas the `vue-ssr-server-bundle.json` was 20MB then and took 400ms to reload it is now **51MB** in size and **takes seconds to reload**. The application is 3-4 times larger now (or rather we've converted the rest of it to use vue) @yyx990803 . If you have any suggestions we'd happily try them out, as we're finding it more and more difficult to tolerate the reload time. Thank you for your amazing work!
--
",fogil,"
--
I would be willing to bet 95% of your ~20MB file is redundant code from external libraries.  You should never be recompiling external libraries and bunching them into your bundle file.

Analyze the bundle file and make sure only your app's proprietary code is inside.  This should only be page template, business logic, routing logic, state management logic.  If you see the Vue library in there that should set off alarm bells.

Always externalize vendor libraries.  On the server, on the client, everywhere.

Another rule of thumb is if npm run build takes longer than 10 seconds, something is wrong.

Once you axe out the redundant code you'll notice your real app is actually something along the lines of 500KBs tops, and JSON.parse will be back to bearable speed.
--

--
In regards to source maps, you're likely working with two environments:  dev & production

In dev:  you should never have source maps enabled since your JS should not be minified anyway.  Therefore, source map size should be 0 bytes.

In production:  During the build stage, webpack creates a separate file for the source maps -- those are never part of your js bundle, unless there was a misconfiguration.  Remember that the source maps are retrieved as separate files in separate HTTP requests in production.  These source map URLs are hinted by specialized commented hints in your minified, packaged js and css files.

Regardless, the original problem is slow development experience -- so dev environment.  Source map should not exist in dev.

--

--
I see.  If you *must* have source maps in dev, try the cheaper but still effective source map solutions going for a balance of filesize and speed:

https://webpack.js.org/configuration/devtool/

My company does not use source maps in dev so my advice is only based on experience from 4 years ago where I used ""cheap-eval-source-map""; which was good enough to identify the file and line number of the problem, yet fast enough to be ~1 second delay in updates on every code change.
--
",mojodev,"
--
> In production: During the build stage, webpack creates a separate file for the source maps -- those are never part of your js bundle, unless there was a misconfiguration. Remember that the source maps are retrieved as separate files in separate HTTP requests in production. These source map URLs are hinted by specialized commented hints in your minified, packaged js and css files.
> 
> Regardless, the original problem is slow development experience -- so dev environment. Source map should not exist in dev.


In my projet server bundle vue-ssr-server-bundle.json file size is 21.4 mb because of source map. i don't know why server bundle including source map. i am using [this scaffolding](https://github.com/JZ-FE/vue-ssr-demo ). can you guys tell me where i am doing wrong ?

--
",,,,
8238,OPEN,👋 Vue reactivity engine and MobX 🖖,discussion,2018-07-15 12:22:07 +0000 UTC,benjamingr,In progress,,"Hey,

Vue is cool, over at React land MobX ( https://github.com/mobxjs/mobx/ ) takes a similar approach by defining getters/setters. 

The architectural nature of Vue apps is much closer to React+MobX than the typical React architecture and MobX is used and trusted by some [big companies](https://github.com/mobxjs/mobx/issues/681)

I am not aware of any knowledge sharing or idea sharing between the projects. I think it would be really cool if we explore possibilities to collaborate.

Some areas of collaboration which could be cool:
 - Standardized benchmarks.
 - Optimization tips and what things that worked out and didn't.
 - Good user experience for things like circular references.
 - What code can be shared between libraries or extracted.
 - Discuss the transition to from getters/setters to proxies.
 - Discuss what's hard from the language PoV to provide feedback to TC39.

I am explicitly not suggesting anything concrete. Just to get the discussion started. I got the idea after I started participating in SinonJS and someone from Jest reached out to us in order to use a shared code component.

What do you think?

(And I want to point out that ""no"" is also a perfectly acceptable response here)

----

Full disclosure - I am a part of the MobX team - MobX is written and is the brainchild of @mweststrate - I am also probably quite terrible at Vue itself :D

It's possible Michel reached out in the past (or vice versa) and the discussion simply isn't public.",,,vue,"
--
Hello, your issue has been closed because it does not conform to our issue requirements. In order to ensure every issue provides the necessary information for us to investigate, we require the use of the [Issue Helper](https://new-issue.vuejs.org/?repo=vuejs/vue) when creating new issues. Thank you!

--
",benjamingr,"
--
Don't mind if this is closed or open in order to keep the tracker just bugs - ping @yyx990803 though.
--

--
Any chance we could get this discussion going @sodatea @yyx990803? 

What would be a better way to interact?
--
",mweststrate,"
--
See also: https://github.com/dwqs/vue-mobx and https://github.com/mmlpxjs/mobx-vue
--
",,,,,,
8193,OPEN,Webassembly integration. Split the core into two parts.,discussion,2019-12-30 11:09:55 +0000 UTC,o-alexandrov,Opened,,"

### What problem does this feature solve?
Performance improvements.

### What does the proposed API look like?
Split the core into two parts:
- JS. Keep doing what you are already doing with the framework.
- Webassembly. Experiment with the **syntax sugar [walt](https://github.com/ballercat/walt)** to have compiled JS core in `.wasm`
  - I read other closed [issues on this topic](https://github.com/vuejs/vue/issues/7768) and saw:
    > This is like building a completely new framework (with similar syntax) - definitely not something the core team is interested in / have bandwidth for, but I wouldn't discourage anyone interested to try.
  - **The syntax sugar, walt, potentially can make the split much-much easier, since it is still JS**.

Things to consider:
- Both JS and Webassembly can be called from each other, so it is time to start mixing parts.
- Server-side rendering. This is the worst aspect in Vue.js. `JSON` client-side and server-side bundles is a ridiculous architecture to be honest.
  - If used with `serverless-webpack` to make a lambda function, **there is no optimization possible on the dependencies, such as tree shaking** as you are creating `.json` bundles that are then imported for the render function and webpack is unable to trace what parts of dependencies aren't needed. Therefore, SSR development stage is unfortunately in a very poor condition.
- SSR is happening on the server-side. Node.js 8  can run `.wasm`, so that **it could have been totally compiled**.

Personally, we would start making progress in it ourselves, but there is no incentive for us to start working on it at the moment.
Therefore, it would be great, if there are interested parties in performance improvements in the community, who can dedicate time to it.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Just to be clear, this is something we don't have the bandwidth to do yet either. I also think it is too early to have an open discussion on this

Also, sometimes people is really mistaken about the performance vs easy-to-use tradeoff which is very important to Vue as we want to make it easy for people to start using Vue. Web asm is not (yet) going to have such a big impact on performance as the bottleneck (DOM) will still be the same
Not sure why you mention SSR, web assembly is not going to change how the SSR works...
--

--
That's an expensive face detection algorithm... Its normal to see such an improvement. As I said, the main slow thing is Dom manipulations.
Anyway, feel free to add other points that may be useful 
--
",o,"
--
@posva 
**1. SSR is the key** here because of:
- the browser support of `.wasm`, **[which is 73% according to caniuse](https://caniuse.com/#feat=wasm)**, which could be ignored server-side, hence migrated completely to webassembly.
- the whole idea of compiling to binary will drop the [vue-server-renderer](https://www.npmjs.com/package/vue-server-renderer) package and other aspects of how it is architected at the moment.

2. Simplicity:
- it is only `syntax sugar` that we are talking about, nothing major.
- **important**, keep in mind that JS can be called from Webassembly and vice versa.
  - therefore, absolutely nothing will change for the majority of the users as they will continue to write absolutely the same code.

Webassembly should be triggered `on and off` based on the browser support on the client-side, where as the **server-side should be completely rewritten and the current approach should be dropped**.
--

--
One of the performance examples:
![image](https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/09/websight.gif)

I am a strong proponent of serverless architecture, and `.wasm` could bring extreme performance improvements as well as cost savings.
--

--
I believe there are two things that you should consider:
1. What makes Vue a better alternative to React and Angular?
2. A natural webassembly integration might be the key that:
    - brings much more attention to Vue
    - leading to increased community that doesn't move back to react and angular

Imagine React implements it, what would make the community to continue using Vue as it is going to cost much more from the infrastructure perspective (file sizes are much bigger, operates much slower)? Forgetting apps (react-native), thinking only from  the web perspective, it could have been a major blow.

There are already talks about React and WebAssembly, so I believe it is important for the community to prepare for the competition that will arise, there is no doubt to it. Hopefully, Vue integrates WebAssembly sooner than later.
--

--
@fnlctrl 
### Your reference to a video
You are pointing to a video that is **1 year old**, the presenter makes a lot of points that are in the process of changing, most importantly:
1. No garbage collection => [there is ongoing work](https://github.com/WebAssembly/design/issues/1079)
2. No access to DOM API => it is in the list of [of the high-level goals](https://github.com/WebAssembly/design/blob/master/HighLevelGoals.md)

And some of the other ongoing work [in a video (27m50s)](https://youtu.be/bac0dGQbUto?t=27m50s)

### Your points
> On the contrary, wasm files are way much larger because it's compiled binary.

**No, not true.** Here is why:
1. Comparison with an experimental project that is in **[Alpha stage only from March 22nd, 2018](https://github.com/aspnet/Blazor/releases)** is strange.
2. **You are stating that `source code` will weigh less than bytecode. It is false**. Everyone on the web [states](https://webassembly.org/docs/binary-encoding/), as well as [your referenced presenter](https://youtu.be/HktWin_LPf4?t=23m50s), that WebAssembly makes less network overhead, resulting in faster downloading the code, hence performance improvements. 
3. Please take a [look here](https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts#How_does_WebAssembly_fit_into_the_web_platform), there is no additional runtime passed over the net or anything like that because it is running **absolutely the same as JS** => **in a VM**.

### Performance
> The power of wasm lies in boosting CPU-intensive applications

Your referenced presenter believes that it runs from [10% to 800% faster](https://youtu.be/HktWin_LPf4?t=25m25s). Please keep in mind that it was 1 year ago and WebAssembly is improving on another magnitude than JavaScript (i.e. much faster, since many things need improvements).

I am not an expert in this area, but it doesn't also make sense as games that are GPU-intensive that weren't playable on the web **are playable with WebAssembly**. There is also [WebVR with WebAssembly](https://youtu.be/bac0dGQbUto?t=31m20s)

Again, nobody tells it is ready or make the switch now. However, if we start making progress now, we will be better off later on, when more optimizations are available, and might happen by the time the initial preparations are made.

It is a question of when, so starting now will help us to have a better understanding and project architecture when DOM access and garbage collection will be available.
--

--
### How could we help this change to happen faster?
I believe JS developers should take a closer look at:
- [webpack wasm loader](https://github.com/ballercat/wasm-loader)
- [walt - syntax sugar on top of JavaScript](https://github.com/ballercat/walt)
--

--
@Becavalier 
You are saying:
> On the other hand, there will be a lot of overhead when the executing pointer switching between JavaScript and WebAssembly context, and this is another problem you need to concern.

It should be further analyzed, but the **short answer is no, you are incorrect**.
Again, **it might be true for the exact moment**, but logically, if it is not right now, it will be in the future.

Think about it, why would anyone write native node.js addons, if switching between native modules and JS would produce less optimized apps? You would be correct for a task that does almost nothing, but not for anything major.
[Here is one of the benchmarks](https://medium.com/developers-writing/how-to-get-a-performance-boost-using-node-js-native-addons-fd3a24719c85), but you can obviously find more.

Also, you are welcome to watch the talks above, so you could hear once again that mixing JS and WebAssembly isn't a bad thing.

One more point, WebAssembly gained support by Webpack since its [4th version](http://www.i-programmer.info/news/167-javascript/11602-webpack-4-adds-webassembly-support.html) and had [gained first class support](https://medium.com/webpack/webpack-awarded-125-000-from-moss-program-f63eeaaf4e15) for more than a year already.
--

--
If the core team has a task with the exact tech requirements, I'll be glad to assist in the beginning.

I suggest that we start by **replacing** the **[bundle renderer](https://ssr.vuejs.org/en/bundle-renderer.html)** for production.
Please let me know any benefits of JSON parsing of the bundle that is created by [vue-server-renderer](https://www.npmjs.com/package/vue-server-renderer) besides ease of debugging (which we should ignore in production) over normal, usual, and straightforward rendering:
```js
import { createApp } from '/path/to/built-server-bundle.js'
```

☝️ please observe the reasons why it's a **bad approach** in the initial comments of this issue.
SSR optimization should bring the most value.
--

--
In short, look how bad [vue-server-renderer (link to source)](https://github.com/vuejs/vue/blob/dev/src/server/bundle-renderer/create-bundle-renderer.js) is for serverless:
  - First, cold start, triggers huge JSON parsing with a lot of `typeof` checks.
  - We cannot tree-shake dependencies with `serverless-webpack`, since the function doesn't have access to the dependencies itself, only to the `.json` bundles and the `.html` file.

I am sorry for all devs who are using it, including myself.
Imagine how great it would be, if we compile it to wasm.
--

--
@OEvgeny 
There have been so many already highlighted:
- benefits of migrating to WebAssembly 
- cons of current approach for SSR

so not to continue repeating the same things over again, I will build on what has been previously said:

I suggest not to try to rewrite or use [AssemblyScript (why better than walt)](https://github.com/AssemblyScript/assemblyscript/issues/83) for the whole Vue ecosystem at once.
Rewriting a small package for a SSR function, [vue-server-renderer](https://github.com/vuejs/vue/blob/dev/src/server/bundle-renderer/create-bundle-renderer.js), is a primitive task to start with.

It is a common approach to divide a big project into a bunch of small pieces.
Experimenting on a small package from the Vue.js ecosystem is a good starting point.
--
",fnlctrl,"
--
> Imagine React implements it

From [What WebAssembly means for React - Lin Clark aka @linclark at @ReactEurope 2017](https://youtu.be/3GHJ4cbxsVQ?t=1287)
""But will it help with the performance with react applications in the browser? The truth is, the short-term immediate impact of this on performance isn't clear."" which is the euphemism for ""no.""

As @posva said, the perf bottleneck is on DOM api, and not javascript itself, nor the virtual dom diffing algorithm. It's meaningless to speed something up that already takes like <10ms to 1ms, while still spending 100+ms on DOM APIs.

Besides, WebAssembly isn't magic and it has great limitations. You can't expect to compile some no-dom-access javascript to it. You can't use objects in wasm. I can barely imagine a JS library to live with that and implement their own objects on top of bytes.

> file sizes are much bigger, operates much slower

On the contrary, wasm files are way much larger because it's compiled binary. Thinks of the size of C source code vs compiled executable. You can also check out this true wasm powered UI framework here: https://github.com/aspnet/blazor (which is compiled from C#), and see their demo: https://blazor-demo.github.io/
![image](https://user-images.githubusercontent.com/5557143/40148854-d054c6a6-59a2-11e8-9ca3-556fd4bbca54.png)

That's >1MB gzipped of all these files. Took 30+ seconds to load. For a bare-to-the-bone app that has a counter and can fetch a json. Truly amazing. Mind blown.

How fast is it? Transitioning from views (from Counter to Fetch Data) still took 36.6ms.
![image](https://user-images.githubusercontent.com/5557143/40149352-bc0cb106-59a5-11e8-8c1e-5d8769100dc3.png)

The power of wasm lies in boosting CPU-intensive applications, like the face recognition demo you've shared with us. But it does not help with core problem of all UI frameworks: the slowness of native DOM APIs.
--

--
> Your referenced presenter believes that it runs from 10% to 800% faster. Please keep in mind that it was 1 year ago and WebAssembly is improving on another magnitude than JavaScript (i.e. much faster, since many things need improvements).

I don't see any of [Chrome](https://developers.google.com/web/updates/2018/#new_in_chrome_65)/[FF](https://www.mozilla.org/en-US/firefox/60.0/releasenotes/)/[Edge](https://blogs.windows.com/msedgedev/2017/10/17/edgehtml-16-fall-creators-update/)'s recent release notes stating anything about vast performance improvements of wasm. Specs have changed, but they're just specs and not actual implementations.

Also, the ""performance"" you're talking about here is off the point. WASM is fast, there's no doubt about that, but ""10% to 800% faster"" without proper context is meaningless. As many have pointed out, wasm doesn't speed up DOM APIs. Giving WASM dom access doesn't help that either, it just removes the context switch overhead, and DOM APIs are still going to be slow.

> Comparison with an experimental project that is in Alpha stage only from March 22nd, 2018 is strange.

That is the only fully functional wasm UI framework, as of today. The latest release is March 22nd, 2018 shows exactly that is still under development and could have taken advantage of those ""wasm improvements"" you've talked about. Please enlighten me with another one that's better than blazor, as an real world example of wasm UI framework, and not ""experimental"".

> Everyone on the web states, as well as your referenced presenter, that WebAssembly makes less network overhead, resulting in faster downloading the code, hence performance improvements.

So far, what you've referenced are all ""talks"" and ""specs"". Everything can look good on paper until someone actually tried to build things with it. If you would, please show us at lease one concrete example of wasm providing great performance boost and size reduction, for building a simple SPA (which requires calling DOM APIs).

Let me propose a better question: 
Ever since that 1-year-old talk, if wasm is really so good for ui frameworks, has any of React/Angular announced a wasm rewrite plan for their core?


--

--
@mihail-shishkov Would you please build a stdweb demo (namely, the todomvc example) and put it here? The repo doesn't include a pre-built one and I can't seem to get the demo to compile on my windows machine. I guess it's also too much of a hassle for people who just want to see a demo to install the complete rust toolchain.
--

--
So I installed a ubuntu vm and rust toolchain, and finally built the stdweb todomvc demo:
![image](https://user-images.githubusercontent.com/5557143/40644200-02813540-6355-11e8-827d-ddf17998a02c.png)

For now, that's 30KB js + 430KB wasm, for a todomvc demo. (and 6KB gzipped js + 131KB gzipped wasm = 137KB gzipped)

And compared to [vue's todomvc demo](https://fiddle.jshell.net/yyx990803/4dr2fLb7/show/light/), 2KB gzipped js + 22KB gzipped runtime, that's 522% bigger in size.

Perhaps it wasn't a complete waste of 2 hours to setup a rust env and compile that demo, since at least I confirmed my assumption by actually trying it out. I'll just leave the built demo [here](https://drive.google.com/open?id=1X0U4X5yteuvzGSuIjoMaLSkgcYZVRQ5H). See it for yourself.

Yes of course, it's still ""experimental"". I guess we'll have to wait to see that ""size advantage"" in the future, perhaps Soon™.

As for performance, there's no difference at all since the todomvc demo is too simple. Below are the timeline for adding a todo item.
Vue:
![image](https://user-images.githubusercontent.com/5557143/40645558-48096bb0-6359-11e8-81b5-1a48200b38a1.png)

stdweb: 
![image](https://user-images.githubusercontent.com/5557143/40645571-532c42ec-6359-11e8-8dbc-4b8d1c60025d.png)

I guess we'll have to wait for a more complex demo to find out. For now, I'll just keep assuming wasm won't bring much performance improvement to traditional applications that heavily uses DOM APIs to draw the UI.

--
",Becavalier,"
--
As @fnlctrl said, the real bottleneck of current JS framework is the cpu consumption on DOM related operations, but this can not be fixed with the current MVP WebAssembly standard. 

On the other hand, there will be a lot of overhead when the executing pointer switching between JavaScript and WebAssembly context, and this is another problem you need to concern.

@OlzhasAlexandrov  BTW, I think you need to learn more about how dose WebAssembly work, and what is its strength, what kind of frontend situations would be suitable for using current WebAssembly.

Here are some materials for your information:
https://webassembly.org/docs/future-features/
https://webassembly.org/docs/mvp/

Thanks.

--

--
@OlzhasAlexandrov 
Yes, I agree with you that the WebAssembly will change the web, but it's not at current time, it will be in the future after the Post-MVP standard complete.

The overhead between JavaScript context and WebAssembly context would narrow down the application scenarios of current WebAssembly to just only ""pure computing"" applications, such as: ""Graphic Processing"" and ""Compressing Library"" related applications. These apps do not need to frequently switching between those two context environments, so that they can really save a lot cpu consumption and get a good running efficiency with the help of WebAssembly.

But for the frontend frameworks like ""vuejs"", without the implementation of GC, WebAssembly really can not help a lot. It doesn't need to have that much of math computing even using ""virtual DOM"" as the wrapper of real DOM, and the ""diff"" algorithm still have a good performance because of the good implementation of vuejs and the deep optimization of JavaScript engine.

last but not least, the CG and WG member are really trying their best to achieve the Post MVP standard of WebAssembly and also a better LLVM backend for WebAssembly, I think you can look forward to the day that WebAssembly will change the Web, but not now and here.

--
",webia1,"
--
WebAssembly & Vue: I think, that’s great discussion, Vue would be the ultimate number one within the js-frameworks! And it is high time to think about it,..

--
",GeertArien,"
--
Without getting mixed in this discussion, I just came across this thread by accident and don't have a clue if WASM makes any sense for this project, I just want to add my two cents. We're currently in the process of migrating a fairly large project from asmjs to WASM, so I'm actively following WASM performance in browsers. And what was said about there being no performance improvements in browsers is just straight up wrong. 

For example take this [bug-ticket ](https://bugzilla.mozilla.org/show_bug.cgi?id=1319203) for Firefox60, this bug-fix increased the performance of our app twofold in FF! Yet it doesn't show up in the FF release notes. Word of advise, instead of checking browser release notes check the release notes of the javascript engines, as that's where the performance increases are implemented. And also check the ticket trackers, if they are publicly available.

Then there's also stuff like [streaming compilation](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/) that was recently added to firefox and chrome, without much fanfare.

Also, and I don't know if this is relevant to this project, but [react-native-dom](https://github.com/vincentriemer/react-native-dom) was just announced at [React-Europe](https://www.youtube.com/watch?v=hCyCIHKYRqg&t=165m0s), with layout powered by WASM.
--
"
8129,OPEN,warn if $set is used on a property that already exist,feature request; good first issue; has PR,2018-06-09 19:54:57 +0000 UTC,JJPandari,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/JJPandari/pen/gzLVBq?editors=1010](https://codepen.io/JJPandari/pen/gzLVBq?editors=1010)

### Steps to reproduce
See the codepen snippet. Follow the comment there to change the vm's data and see what happens.

### What is expected?
Even if the prop already exists, using `set` still makes it reactive, thus trigger view update.

### What is actually happening?
Using `set` later doesn't update the view.

---
Related source code: https://github.com/vuejs/vue/blob/3eb37acf98e2d9737de897ebe7bdb7e9576bcc21/src/core/observer/index.js#L192 I think most users would expect `set` to make the prop reactive whenever it's used. I initially opened [an issue for the api doc](https://github.com/vuejs/vuejs.org/issues/1601) because it wasn't clear (for me) about this. But the comment in the source code is.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
You're setting 2 different `setCameLate`, your last line should be

```js
this.$set(this, 'setCameLate', 'yes');
```

---

Please, next time consider using the [forum](http://forum.vuejs.org/), the [Discord server](https://vue-land.js.org/) or [StackOverflow](http://stackoverflow.com/tags/vue.js) for questions first. But feel free to come back and open an issue if it turns out to be a bug 🙂
--

--
Im not sure I get your question, but vue cannot detect the assignment, so you need set.
--

--
seems fine. I also think it's hardly useful but a warning is ok
--

--
it's a runtime dev only warning if you want to add it 🙂 
--
",JJPandari,"
--
Sorry I messed the example up. Try read it again. Or you can read the source code of `set` I linked to above briefly, it should be easy to see what I'm talking about in the title of this issue. I'm asking about a design decision here, ""why not (do it the other way)?""
--
",chrisvfritz,"
--
@posva I think what @JJPandari would like to do is use `Vue.set` to make a property reactive _after_ it's already been added, like in [this example](https://codepen.io/chrisvfritz/pen/rvzgBR?editors=1010). I don't see a use case for this, but if the property already exists, I think it would be good to provide a development warning to users, so they know they've done something wrong. For example, for:

```js
Vue.set(this.person, 'job', 'Educator')
```

If `this.person.job` had previously been created _without_ `Vue.set`, so that it's non-reactive, then I think a warning like this would be useful:

> [Vue warn]: You tried to use Vue.set on the existing, non-reactive property ""job"".  Properties cannot be made reactive after they've already been added to an object. Instead, use `Vue.set` where you want to initially create that property.

What do you think?
--

--
@fnlctrl My thinking was that if someone first creates an unreactive property, then tries to make it reactive _later_, any reference to that property in between those two events is very likely to create a difficult-to-diagnose bug. 

By showing a warning that they should make the property reactive from the start, we encourage a best practice that eliminates the window for bugs to occur.
--
",bigtunacan,"
--
@chrisvfritz Would you see this being logged to the browser console, or something that would be in the build process?  Just thinking about taking a stab at this.
--

--
@fnlctrl It's a bit unclear the way this issue was initially worded, but Chris' codepen is a good example of the real issue here.  [https://codepen.io/chrisvfritz/pen/rvzgBR?editors=1010](https://codepen.io/chrisvfritz/pen/rvzgBR?editors=1010)

JJPandari's real issue was that they created a non-reactive property then later called  `$set` on the non-reactive property expecting that `$set` would switch the property from non-reactive to reactive. 

The pull request I added on this https://github.com/vuejs/vue/pull/8138 is also addressing only that usage of a call to set.  In a non-production environment, it will check if you are trying to set a non-reactive property in which case you would get a warning that said property will not be reactive.
--
",fnlctrl,"
--
I think there's a valid use case for setting $set on existing properties. In my application code I have a `hashMap` object that is initially empty, and I call `this.$set(hashMap, object.id, object)` after getting the object from API. It will be called more than once if I get updated object sent from API again (`apiCall().then(object => this.$set(hashMap, object.id, object))`). I don't really want to check if the property exist s before using $set since that would be too verbose.
--

--
I see... though there's another question: Why not just make it work too when there's already a non-reactive property?  😄 I don't see why there should be a limit.
--
",,
8112,OPEN,Autofocus is lost once vue is loaded,browser quirks,2020-04-13 21:41:14 +0000 UTC,alfonsobries,Opened,,"### Version
2.5.16

### Reproduction link
[https://jsfiddle.net/alfonsobries/u83vkLe1/](https://jsfiddle.net/alfonsobries/u83vkLe1/)

### Steps to reproduce
When you add the autofocus attribute to an input it will be focused once is loaded, but when you init a Vue app the focus is lost so you need to manual focus an element

In this second link (witouth Vue the autofocus works)
[Autofocus not lost](https://jsfiddle.net/alfonsobries/7k2r7oyd/)

### What is expected?
That an input keep focused if has the autofocus attribute

### What is actually happening?
the focus is lost

---
Its possible to emulate this behaviour but i think it should work witouth need to ""emulate"" the behaivour

<!-- generated by vue-issues. DO NOT REMOVE -->",,,KaelWD,"
--
Either use [`v-cloak`](https://jsfiddle.net/1r6vb1j8/) or a [separate template](https://jsfiddle.net/prt0qu4o/). 
--
",HerringtonDarkholme,"
--
Thank @KaelWD ! `v-cloak` is a good workaround. https://stackoverflow.com/questions/9122527/will-focus-be-set-to-invisible-form-controls-using-html5-autofocus

On the other hand, I wonder if it is worth  a special handling for `autofocus` in core, though this problem might also occur in SSR. You can, nevertheless, write your own directive like `v-autofocus` to focus on input when it is hydrated. 
--
",wistcc,"
--
I tried to fix this with no luck. I think this is a similar issue https://github.com/lovelope/vue/commit/8109e44577e49524da83139287d54b2bc83ac2a1 but trying to fix it with the same idea won't work since `muted` and `autofocus` works differently by nature.

Since `autofocus` runs only when the page loads I think the solution must be calling `.focus()` on the element after the component is mounted but I didn't find where I should do this implementation.

I can use a little guidance here if possible.
--
",fnlctrl,"
--
The other workaround is to simply avoid using in-dom templates, and use string templates or pre-compiled templates instead. https://jsfiddle.net/3gd0bLk5/
--

--
I suppose you can use `<script type=""x-template"">` in PHP? That is also a valid workaround and isn't ""in-dom"" template.
--
",mharkrollen2,"
--
easier workaround is just add vue attribute `:autofocus=""'autofocus'""`
--
",ThibaudDauce,"
--
I'm using VueJS with Laravel and I also noticed this problem. I'm in a PHP environment so ""avoid using in-dom templates"" is not an acceptable solution. `:autofocus=""'autofocus'""` and `v-focus` is working but if we could avoid using VueJS for these kind of HTML5 things it's better :-)
--
"
8089,OPEN,Vue breaks the styling when using comments in inline style attribute,improvement,2018-04-26 19:40:50 +0000 UTC,savehansson,In progress,,"### Version
2.5.16

### Reproduction link
[https://jsbin.com/gutivaf/edit?html,css,js,output](https://jsbin.com/gutivaf/edit?html,css,js,output)

### Steps to reproduce
- Add a comment inside any style attribute on an element within the Vue app instance. Example:

      ... style=""color:blue; /* This is a comment */ background-color:yellow;"" ...


### What is expected?
The element should have blue text on yellow background.

### What is actually happening?
The comment breaks the attribute and all the style properties *after* the comment are ignored (not coming in effect).

In the reproduction example the text is blue but the background is *not* yellow. 

---
(The JSBin contains a slightly different example. I hope you can live with that.)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,astronomersiva,"
--
This is because of [this regex](https://github.com/vuejs/vue/blob/dev/src/platforms/web/util/style.js#L7). The second rule starts with the comment of the first rule(`[""color:blue"", "" /* This is a valid comment */ background-color: darkseagreen""]`)  and that is the reason for this issue. 

> The comment breaks the attribute and all the style properties after the comment are ignored (not coming in effect).

This is not true. It breaks only the second property. If there are any properties after that, they are preserved.

I am working on improving this. Will update it once a PR is ready.
--

--
The existing regex `/;(?![^(]*\))/g` has to be changed to `/;(?:\s*\/\*.*\*\/)?(?![^(]*\))/g`(off the top of my head). I will leave it to @yyx990803 and @posva to take the call on whether they would like a PR for this.

IMO, I would like Vue to allow this.


--
",yyx990803,"
--
Honestly though, I can't think of a good reason to use or support this. If you need comments for your inline styles you should probably use an object / computed property. Adding extra logic to handle this is just incurring perf/code size/maintenance cost for... what?
--
",savehansson,"
--
Maybe so @yyx990803. In my case I use it during development/scaffolding to temporarily disable properties. It's the same technique that Chrome uses when unchecking a single property in web tools.

In my opinion, Vue should strive to, as far as possible, not change the behavior of templates. But I understand if you don't prioritize this.
--
",,,,,,
8034,OPEN,Have template compiler add source metadata to HTML tags,feature request,2018-06-22 02:41:36 +0000 UTC,NeekSandhu,In progress,,"### What problem does this feature solve?
I'm developing an all-in-one editor for webdevs that runs inside Chrome DevTools.

Just by replacing `npm start` with `[name-not-finalized] start`, users can have a fully featured text editor right inside Chrome DevTools shell, automatically pointing at their project directory.

It comes with DOM inspector, where you pick an element and it'll literally take you to `file:line:col` where that element was defined. So you don't have to look through files to figure out where that button below the header is coming from. Useful when a new dev joins a project or you're revisiting your work after a very long time.

▶ [Watch 30 sec demo w/ a React project](http://goo.gl/d64cgv)

___

And of course, it also works with Vue projects, just as awesome.

▶ [Watch 20 sec demo w/ a Vue project](https://drive.google.com/open?id=1rGeFiNLezxzaJqnhnDbjvD_OvLMyaMIh)

Above demos were shot using locally tinkered compilers (just not clean enough to be a PR)

The goal is to deliver the ultimate developer experience ever. Other features are in development as we speak, like CSS QuickEditing, built-in image editor and a SVG editor so devs don't have to fire up Illustrator or Photoshop to make minor tweaks to their stuff.

The only hurdle in me releasing the app is getting external players to participate in revolutionizing how we write web.

So to wrap up I have only two requests:
- Please have the template compilers add metadata to each tag (either as data attribute, or property on DOM node itself), that contains path to `*.vue` file (can be relative to project root), `line:col`/offset where the tag opens and last `line:col`/offset where the tag closes.

- Please star this issue: https://bugs.chromium.org/p/chromium/issues/detail?id=811036

### What does the proposed API look like?
Something like this:
```javascript
console.log(someElement.__vue__._debugSource)
// > { file: 'src/components/Header.vue', line: 12, col: 4, lineEnd: 16, col: 8 }
// or
// > { file: 'src/components/Header.vue', start: 241, end: 352 }
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,NeekSandhu,"
--
@yyx990803 Gentle ping on this. Thanks
--

--
I definitely understand, in fact, this something anyone would want when `process.env.NODE_ENV == 'development'`, so of course no need to have it in core.

The primary concern is to get the Vue squad on board and maybe get some help from you guys in implementing those changes[1]

I'm also trying to reach out React and Angular teams in parallel as we speak.

[1] I'm not  so familiar with Vue's codebase and at this time, I'm the only one trying to tie all the loose ends together. So some help would very appreciated.
--

--
@gzzhanghao looks great, thanks. But can we not have just this feature in a separate PR instead of making a big PR even bigger?
--
",posva,"
--
I think there is no need to change vue core for this, it should be doable in vue-loader only plus, if necessary, vue plugins
BTW that editor looks pretty cool 🙂 
--
",gzzhanghao,"
--
#7127 will add source info (start & end index) to `ASTElement`. We can add `domProps.__vue_source__` with a [template compiler module](https://www.npmjs.com/package/vue-template-compiler#compilercompiletemplate-options) after the pr get merged.
--
",,,,,,
8028,OPEN,keep-alive: include/exclude components by component key attribute,feature request; has PR,2019-09-06 10:19:44 +0000 UTC,losadaem,Opened,,"### What problem does this feature solve?
The include and exclude props allow components to be conditionally cached only by component name. If we want to reuse components but force replacement using the `key` attribute, there is no control over which components we want to keep-alive only matching components by their name.

### What does the proposed API look like?
https://jsfiddle.net/9nk92wuy/

<!-- generated by vue-issues. DO NOT REMOVE -->",,,freeloopmko687,"
--
> ### What problem does this feature solve?
> The include and exclude props allow components to be conditionally cached only by component name. If we want to reuse components but force replacement using the `key` attribute, there is no control over which components we want to keep-alive only matching components by their name.
> 
> ### What does the proposed API look like?
> https://jsfiddle.net/9nk92wuy/

大神你好，为啥用keep-alive 包含router-view的时候key配合include不起作用呢？
--
",SamuelYaron,"
--
I would love this feature to be added to Vue since it is a critical feature needed for switching from our old framework to Vue! Are there any notions about if and when the proposed pull request might be merged?
--
",waldonUB,"
--
虽然问题隔得有点久，但目前我已经简单实现了一个方案。  
### 概要：
因为keep-alive标签是不会被渲染的，所以通过ref等方式无法获取。只能通过在keep-alive包含的组件中获取父节点，来获取keep-alive中的数据。

### 步骤：
#### 查看组件缓存的对象
这里对象的key就是我们在缓存中绑定key，如果没有绑定key，就随机生成。（这里的生成规则我暂时还没有去了解）
![](http://ww1.sinaimg.cn/large/00760Iw1gy1g5xu8l2yzjj30pv077aar.jpg)

#### 在原型上增加一个过滤规则
这里我只实现了一个可以根据同名组件不同key来限制最大缓存数量的方法

```js
Vue.prototype.$destroyKey = function () {
  let cache = this.$vnode.parent.componentInstance.cache
  let keys = this.$vnode.parent.componentInstance.keys
  // 忽略掉组件为null的key值
  let cacheLen = 0
  for (let item in cache) {
    // cache对象原型没有东西，无需调用hasOwnProperty
    if (cache[item]) {
      cacheLen++
    }
  }
  if (cacheLen > this.keyMax) {
    let outKey = keys.shift()
    cache[outKey].componentInstance.$destroy()
    cache[outKey] = null
  }
}
```
#### 在切换组件时调用规则

##### 1. 在keep-alive缓存中使用动态组件
```js
activated () {
    this.$destroyKey()
  }
```
##### 2. 在路由页面切换中使用
```js
beforeRouteUpdate (to, from, next) {
    this.$destroyKey()
  }
```
#### 简单示例
https://codepen.io/waldonUB/pen/xvOgQB?editors=1111
#### 参考
- [keep-alive的实现](https://github.com/vuejs/vue/commit/2cba6d4cb1db8273ee45cccb8e50ebd87191244e)  
- [issue6509](https://github.com/vuejs/vue/issues/6509) 
--
",,,,,,
8025,OPEN,Creating a component named map should warn the user (as with button),contribution welcome; good first issue; has PR; improvement,2019-11-23 15:03:56 +0000 UTC,pqvst,In progress,,"### Version
2.5.15

### Reproduction link
[https://jsfiddle.net/e2yxoomh/2/](https://jsfiddle.net/e2yxoomh/2/)

### Steps to reproduce
Create a component that includes the word ""map"" (case insensitive). For example:
- Map
- MapView
- mapper


### What is expected?
I expect these to work, or at least give me some sort of error message.

### What is actually happening?
Nothing happens. The components do not render. There is no error message.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Because you're using the in-browser templates, self-closing tags are not working as expected, so it's not that anything containing map isn't working, it's that things are not passed to Vue as you expect.

About the `map` element, it should indeed warn it is an existing element (same warning as button), so I'm changing the title of the issue to reflect that
--

--
it does work, you need to use `map-view` beacuse in browser you cannot use uppercase for element names
--

--
You should checkout the style guide section of the docs, it will help you with that 🙂 
--
",pqvst,"
--
Ah, I forgot that `map` is a valid HTML element. But, even if I don't use self-closing tags, a component named `MapView` doesn't work :/
https://jsfiddle.net/e2yxoomh/11/

--

--
Hmm ok. Well, it seems uppercase works for the first character.
- Foobar => Works
- FooBar => Doesn't work
--

--
Ok, thanks. In any case, some warnings would be useful. I wasted quite a few hours trying to figure out what was wrong.
--
",emanuelmutschlechner,"
--
<details>
  <summary>@posva Comparison of reserved Vue HTML tags vs specs. `map` is already in there.
</summary>

<table>
<thead>
<tr>
<th align=""left""><a href=""https://github.com/vuejs/vue/blob/dev/src/platforms/web/util/element.js#L11"">Vue HTML</a></th>
<th align=""left""><a href=""https://developer.mozilla.org/en-US/docs/Web/HTML/Element"" rel=""nofollow"">MDN</a></th>
<th align=""left""><a href=""https://html.spec.whatwg.org/multipage/indices.html#elements-3"" rel=""nofollow"">WHATWG</a></th>
</tr>
</thead>
<tbody>
<tr>
<td align=""left"">abbr</td>
<td align=""left"">abbr</td>
<td align=""left"">abbr</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">acronym</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">address</td>
<td align=""left"">address</td>
<td align=""left"">address</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">applet</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">area</td>
<td align=""left"">area</td>
<td align=""left"">area</td>
</tr>
<tr>
<td align=""left"">article</td>
<td align=""left"">article</td>
<td align=""left"">article</td>
</tr>
<tr>
<td align=""left"">aside</td>
<td align=""left"">aside</td>
<td align=""left"">aside</td>
</tr>
<tr>
<td align=""left"">audio</td>
<td align=""left"">audio</td>
<td align=""left"">audio</td>
</tr>
<tr>
<td align=""left"">b</td>
<td align=""left"">b</td>
<td align=""left"">b</td>
</tr>
<tr>
<td align=""left"">base</td>
<td align=""left"">base</td>
<td align=""left"">base</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">basefont</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">bdi</td>
<td align=""left"">bdi</td>
<td align=""left"">bdi</td>
</tr>
<tr>
<td align=""left"">bdo</td>
<td align=""left"">bdo</td>
<td align=""left"">bdo</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">bgsound</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">big</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">blink</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">blockquote</td>
<td align=""left"">blockquote</td>
<td align=""left"">blockquote</td>
</tr>
<tr>
<td align=""left"">body</td>
<td align=""left"">body</td>
<td align=""left"">body</td>
</tr>
<tr>
<td align=""left"">br</td>
<td align=""left"">br</td>
<td align=""left"">br</td>
</tr>
<tr>
<td align=""left"">button</td>
<td align=""left"">button</td>
<td align=""left"">button</td>
</tr>
<tr>
<td align=""left"">canvas</td>
<td align=""left"">canvas</td>
<td align=""left"">canvas</td>
</tr>
<tr>
<td align=""left"">caption</td>
<td align=""left"">caption</td>
<td align=""left"">caption</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">center</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">cite</td>
<td align=""left"">cite</td>
<td align=""left"">cite</td>
</tr>
<tr>
<td align=""left"">code</td>
<td align=""left"">code</td>
<td align=""left"">code</td>
</tr>
<tr>
<td align=""left"">col</td>
<td align=""left"">col</td>
<td align=""left"">col</td>
</tr>
<tr>
<td align=""left"">colgroup</td>
<td align=""left"">colgroup</td>
<td align=""left"">colgroup</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">command</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">content</td>
<td align=""left"">content</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">data</td>
<td align=""left"">data</td>
<td align=""left"">data</td>
</tr>
<tr>
<td align=""left"">datalist</td>
<td align=""left"">datalist</td>
<td align=""left"">datalist</td>
</tr>
<tr>
<td align=""left"">dd</td>
<td align=""left"">dd</td>
<td align=""left"">dd</td>
</tr>
<tr>
<td align=""left"">del</td>
<td align=""left"">del</td>
<td align=""left"">del</td>
</tr>
<tr>
<td align=""left"">details</td>
<td align=""left"">details</td>
<td align=""left"">details</td>
</tr>
<tr>
<td align=""left"">dfn</td>
<td align=""left"">dfn</td>
<td align=""left"">dfn</td>
</tr>
<tr>
<td align=""left"">dialog</td>
<td align=""left"">dialog</td>
<td align=""left"">dialog</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">dir</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">div</td>
<td align=""left"">div</td>
<td align=""left"">div</td>
</tr>
<tr>
<td align=""left"">dl</td>
<td align=""left"">dl</td>
<td align=""left"">dl</td>
</tr>
<tr>
<td align=""left"">dt</td>
<td align=""left"">dt</td>
<td align=""left"">dt</td>
</tr>
<tr>
<td align=""left"">element</td>
<td align=""left"">element</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">em</td>
<td align=""left"">em</td>
<td align=""left"">em</td>
</tr>
<tr>
<td align=""left"">embed</td>
<td align=""left"">embed</td>
<td align=""left"">embed</td>
</tr>
<tr>
<td align=""left"">fieldset</td>
<td align=""left"">fieldset</td>
<td align=""left"">fieldset</td>
</tr>
<tr>
<td align=""left"">figcaption</td>
<td align=""left"">figcaption</td>
<td align=""left"">figcaption</td>
</tr>
<tr>
<td align=""left"">figure</td>
<td align=""left"">figure</td>
<td align=""left"">figure</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">font</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">footer</td>
<td align=""left"">footer</td>
<td align=""left"">footer</td>
</tr>
<tr>
<td align=""left"">form</td>
<td align=""left"">form</td>
<td align=""left"">form</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">frame</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">frameset</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">h1</td>
<td align=""left"">h1</td>
<td align=""left"">h1</td>
</tr>
<tr>
<td align=""left"">h2</td>
<td align=""left"">&nbsp;</td>
<td align=""left"">h2</td>
</tr>
<tr>
<td align=""left"">h3</td>
<td align=""left"">&nbsp;</td>
<td align=""left"">h3</td>
</tr>
<tr>
<td align=""left"">h4</td>
<td align=""left"">&nbsp;</td>
<td align=""left"">h4</td>
</tr>
<tr>
<td align=""left"">h5</td>
<td align=""left"">&nbsp;</td>
<td align=""left"">h5</td>
</tr>
<tr>
<td align=""left"">h6</td>
<td align=""left"">&nbsp;</td>
<td align=""left"">h6</td>
</tr>
<tr>
<td align=""left"">head</td>
<td align=""left"">head</td>
<td align=""left"">head</td>
</tr>
<tr>
<td align=""left"">header</td>
<td align=""left"">header</td>
<td align=""left"">header</td>
</tr>
<tr>
<td align=""left"">hgroup</td>
<td align=""left"">hgroup</td>
<td align=""left"">hgroup</td>
</tr>
<tr>
<td align=""left"">hr</td>
<td align=""left"">hr</td>
<td align=""left"">hr</td>
</tr>
<tr>
<td align=""left"">html</td>
<td align=""left"">html</td>
<td align=""left"">html</td>
</tr>
<tr>
<td align=""left"">i</td>
<td align=""left"">i</td>
<td align=""left"">i</td>
</tr>
<tr>
<td align=""left"">iframe</td>
<td align=""left"">iframe</td>
<td align=""left"">iframe</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">image</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">img</td>
<td align=""left"">img</td>
<td align=""left"">img</td>
</tr>
<tr>
<td align=""left"">input</td>
<td align=""left"">input</td>
<td align=""left"">input</td>
</tr>
<tr>
<td align=""left"">ins</td>
<td align=""left"">ins</td>
<td align=""left"">ins</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">isindex</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">kbd</td>
<td align=""left"">kbd</td>
<td align=""left"">kbd</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">keygen</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">label</td>
<td align=""left"">label</td>
<td align=""left"">label</td>
</tr>
<tr>
<td align=""left"">legend</td>
<td align=""left"">legend</td>
<td align=""left"">legend</td>
</tr>
<tr>
<td align=""left"">li</td>
<td align=""left"">li</td>
<td align=""left"">li</td>
</tr>
<tr>
<td align=""left"">link</td>
<td align=""left"">link</td>
<td align=""left"">link</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">listing</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">main</td>
<td align=""left"">main</td>
<td align=""left"">main</td>
</tr>
<tr>
<td align=""left"">map</td>
<td align=""left"">map</td>
<td align=""left"">map</td>
</tr>
<tr>
<td align=""left"">mark</td>
<td align=""left"">mark</td>
<td align=""left"">mark</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">marquee</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">menu</td>
<td align=""left"">menu</td>
<td align=""left"">menu</td>
</tr>
<tr>
<td align=""left"">menuitem</td>
<td align=""left"">menuitem</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">meta</td>
<td align=""left"">meta</td>
<td align=""left"">meta</td>
</tr>
<tr>
<td align=""left"">meter</td>
<td align=""left"">meter</td>
<td align=""left"">meter</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">multicol</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">nav</td>
<td align=""left"">nav</td>
<td align=""left"">nav</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">nextid</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">nobr</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">noembed</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">noframes</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">noscript</td>
<td align=""left"">noscript</td>
<td align=""left"">noscript</td>
</tr>
<tr>
<td align=""left"">object</td>
<td align=""left"">object</td>
<td align=""left"">object</td>
</tr>
<tr>
<td align=""left"">ol</td>
<td align=""left"">ol</td>
<td align=""left"">ol</td>
</tr>
<tr>
<td align=""left"">optgroup</td>
<td align=""left"">optgroup</td>
<td align=""left"">optgroup</td>
</tr>
<tr>
<td align=""left"">option</td>
<td align=""left"">option</td>
<td align=""left"">option</td>
</tr>
<tr>
<td align=""left"">output</td>
<td align=""left"">output</td>
<td align=""left"">output</td>
</tr>
<tr>
<td align=""left"">p</td>
<td align=""left"">p</td>
<td align=""left"">p</td>
</tr>
<tr>
<td align=""left"">param</td>
<td align=""left"">param</td>
<td align=""left"">param</td>
</tr>
<tr>
<td align=""left"">picture</td>
<td align=""left"">picture</td>
<td align=""left"">picture</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">plaintext</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">pre</td>
<td align=""left"">pre</td>
<td align=""left"">pre</td>
</tr>
<tr>
<td align=""left"">progress</td>
<td align=""left"">progress</td>
<td align=""left"">progress</td>
</tr>
<tr>
<td align=""left"">q</td>
<td align=""left"">q</td>
<td align=""left"">q</td>
</tr>
<tr>
<td align=""left"">rp</td>
<td align=""left"">rp</td>
<td align=""left"">rp</td>
</tr>
<tr>
<td align=""left"">rt</td>
<td align=""left"">rt</td>
<td align=""left"">rt</td>
</tr>
<tr>
<td align=""left"">rtc</td>
<td align=""left"">rtc</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">ruby</td>
<td align=""left"">ruby</td>
<td align=""left"">ruby</td>
</tr>
<tr>
<td align=""left"">s</td>
<td align=""left"">s</td>
<td align=""left"">s</td>
</tr>
<tr>
<td align=""left"">samp</td>
<td align=""left"">samp</td>
<td align=""left"">samp</td>
</tr>
<tr>
<td align=""left"">script</td>
<td align=""left"">script</td>
<td align=""left"">script</td>
</tr>
<tr>
<td align=""left"">section</td>
<td align=""left"">section</td>
<td align=""left"">section</td>
</tr>
<tr>
<td align=""left"">select</td>
<td align=""left"">select</td>
<td align=""left"">select</td>
</tr>
<tr>
<td align=""left"">shadow</td>
<td align=""left"">shadow</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">slot</td>
<td align=""left"">slot</td>
</tr>
<tr>
<td align=""left"">small</td>
<td align=""left"">small</td>
<td align=""left"">small</td>
</tr>
<tr>
<td align=""left"">source</td>
<td align=""left"">source</td>
<td align=""left"">source</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">spacer</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">span</td>
<td align=""left"">span</td>
<td align=""left"">span</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">strike</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">strong</td>
<td align=""left"">strong</td>
<td align=""left"">strong</td>
</tr>
<tr>
<td align=""left"">style</td>
<td align=""left"">style</td>
<td align=""left"">style</td>
</tr>
<tr>
<td align=""left"">sub</td>
<td align=""left"">sub</td>
<td align=""left"">sub</td>
</tr>
<tr>
<td align=""left"">summary</td>
<td align=""left"">summary</td>
<td align=""left"">summary</td>
</tr>
<tr>
<td align=""left"">sup</td>
<td align=""left"">sup</td>
<td align=""left"">sup</td>
</tr>
<tr>
<td align=""left"">table</td>
<td align=""left"">table</td>
<td align=""left"">table</td>
</tr>
<tr>
<td align=""left"">tbody</td>
<td align=""left"">tbody</td>
<td align=""left"">tbody</td>
</tr>
<tr>
<td align=""left"">td</td>
<td align=""left"">td</td>
<td align=""left"">td</td>
</tr>
<tr>
<td align=""left"">template</td>
<td align=""left"">template</td>
<td align=""left"">template</td>
</tr>
<tr>
<td align=""left"">textarea</td>
<td align=""left"">textarea</td>
<td align=""left"">textarea</td>
</tr>
<tr>
<td align=""left"">tfoot</td>
<td align=""left"">tfoot</td>
<td align=""left"">tfoot</td>
</tr>
<tr>
<td align=""left"">th</td>
<td align=""left"">th</td>
<td align=""left"">th</td>
</tr>
<tr>
<td align=""left"">thead</td>
<td align=""left"">thead</td>
<td align=""left"">thead</td>
</tr>
<tr>
<td align=""left"">time</td>
<td align=""left"">time</td>
<td align=""left"">time</td>
</tr>
<tr>
<td align=""left"">title</td>
<td align=""left"">title</td>
<td align=""left"">title</td>
</tr>
<tr>
<td align=""left"">tr</td>
<td align=""left"">tr</td>
<td align=""left"">tr</td>
</tr>
<tr>
<td align=""left"">track</td>
<td align=""left"">track</td>
<td align=""left"">track</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">tt</td>
<td align=""left"">&nbsp;</td>
</tr>
<tr>
<td align=""left"">u</td>
<td align=""left"">u</td>
<td align=""left"">u</td>
</tr>
<tr>
<td align=""left"">ul</td>
<td align=""left"">ul</td>
<td align=""left"">ul</td>
</tr>
<tr>
<td align=""left"">var</td>
<td align=""left"">var</td>
<td align=""left"">var</td>
</tr>
<tr>
<td align=""left"">video</td>
<td align=""left"">video</td>
<td align=""left"">video</td>
</tr>
<tr>
<td align=""left"">wbr</td>
<td align=""left"">wbr</td>
<td align=""left"">wbr</td>
</tr>
<tr>
<td align=""left"">&nbsp;</td>
<td align=""left"">xmp</td>
<td align=""left"">&nbsp;</td>
</tr></tbody></table>
</details>

---


edited by @posva: collapsed the table as it took too much space
--

--
Warnings only work when components are registered globally e.g. 
```js
Vue.component('map', () => import('@js/components/Map'))
```
When imported and registered locally in `components`, no warnings are triggered. e.g.
```html
<script>
import Map from '@js/components/Map';
export default {
    components: {Map}
}
</script>
<template>
    <div><map/></div>
<template>
```
--
",Justineo,"
--
> In any case, some warnings would be useful. I wasted quite a few hours trying to figure out what was wrong.

@pqvst If you use in-DOM template, Vue cannot warn you about the use of something like `MapView`. They are parsed by the browser first and what Vue got is just an element with the tagname `mapview`:

![image](https://user-images.githubusercontent.com/1726061/38796112-f808e8b8-418c-11e8-84cd-c965fdbda3da.png)
--
",hatashiro,"
--
I'm thinking of working on this. Will upload a PR in a while!
--
",saavor,"
--
![screenshot 2018-05-31 at 8 28 05 pm](https://user-images.githubusercontent.com/29069199/40814955-4cab2dca-6511-11e8-989b-1616a1fc0e70.png)

I was able to find the error but not where it was coming from because vue has a `warn()` function and the errors always link to that instead of where the error is coming from.
--

--
Ok, so it's not working because of the browser by default setting the tag names to lowercase but vue is still looking for the elements with the upper case letters resulting in it not working

and here is proof: https://jsfiddle.net/e2yxoomh/50/

you just need to replace
`Vue.component(""MapView""`
with
`Vue.component(""Mapview""`
everything else can stay the same
--
"
8021,OPEN,v-once for component tag doesn't work in v-for,bug; has PR,2018-07-16 13:30:24 +0000 UTC,hydroDude,In progress,,"### Version
2.5.16

### Reproduction link
[https://jsfiddle.net/hL0rrbs9/6/](https://jsfiddle.net/hL0rrbs9/6/)

### Steps to reproduce
Run code, and watch.

### What is expected?
""Yay Yay ;)"" values should not change to ""hell naw!"" in 3 seconds.

### What is actually happening?
""Yay Yay ;)"" values are changing in to ""hell naw!"" in 3 seconds.

---
<h2>
  Wait 3 seconds. Behavior is not consistent. ""component"" tag in v-for should not change. 
</h2>
<div id=""app"">
  <component :is=""comp"" v-once></component>
  <p v-once>{{comp}}</p>
  
  <div v-for=""n in items"" :key=""n.id"">
    <component :is=""comp"" v-once></component>
    <p v-once>{{comp}}</p>
  </div>
</div>
<script>
var z = new Vue({
	el: ""#app"",
  data: {
  	comp:	""comp1"",
    items: [{id:1}, {id:2}]
  },
  components: {
  	""comp1"": {
    	template: ""<p style='background:green;color:white'>yay yay ;)</p>""
    },
  	""comp2"": {
    	template: ""<p style='background:red;color:white'>hell naw!</p>""
    }
  }
});

setTimeout(function() {
	z.comp = ""comp2""
}, 3000);
</script>

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yaodingyd,"
--
`v-once` should be in `v-for`, not in its children.
--
",hydroDude,"
--
1. If v-once is in v-for, the iteration is rendered once. Ex: If there are 2 children originally, and a child is added later, the 3rd child is not rendered. This is not the scenario.

2. if :key is provided to v-for, the idea is to patch each element in-place. Ex: In 1st item's example, the existing 2 children are not re-rendered. Hence the binding persists.

3. In my JSFiddle example, **_<p v-once>{{comp}}</p>_** is behaving as expected in v-for. v-once is placed in v-for's child. ""comp1"" text does not change to ""comp2"". 

4. In my JSFiddle example, **_component_** is **NOT** behaving as expected in v-for. v-once is placed in v-for's child. ""yay yay ;)"" text does change to ""hell naw!"". This is the bug.

Given above, the expected behavior for v-for to still be bound to data and render when children array count changes. But each child to render only once. In this scenario, the v-once behavior is required in children, not the parent.

In short, this behavior is currently consistent except for **component** element. JS line 10 is working fine. Line 9 is not.



--
",,,,,,,,
8016,OPEN,Vue Selected Bind Does Not Work on Option Tags,improvement,2019-02-20 18:07:01 +0000 UTC,jbenner-radham,Opened,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/jbenner/pen/geJqex](https://codepen.io/jbenner/pen/geJqex)

### Steps to reproduce
1. Instantiate a Vue instance with a `data` property named `locations` which is an array consisting of `['all', 'north', 'south', 'east', 'west']`.
2. Iterate over the locations in an `option` tag like so `<option v-for=""location in locations"" :selected=""location === 'all'"">{{ location }}</option>`.

### What is expected?
The `selected` attribute to be set on the ""all"" `option` element.

### What is actually happening?
The `selected` attribute is not being set.

---
I've also tried the following while attempting to debug but to no avail:

```
<option v-for=""(location, index) in locations"" :selected=""index === 0"">{{ location }}</option>
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
`selected` is set as an element prop, not as an attribute because the attribute is only taken into account upon page loading, so setting the `selected` attribute would be worthless
--

--
It is indeed useful for SSR but I haven't checked if it's not added yet
--
",jbenner,"
--
I humbly ask that you reconsider this issue. You are 100% correct about `selected` only being taken into account upon page load. But if you are using pre-rendering or server-side rendering then the property will be present upon page load. Also, if you are using the standard client-side rendering implementation you can call `document.forms.formId.reset()` after the template render to have the browser honor the `selected` property.

Regardless, thank you for your hard work on an excellent product.
--
",salazare,"
--
See https://codepen.io/anon/pen/Overbe
--
",daveroberts,"
--
I'm running into a similar issue on a select box where I can't use v-model.  Is there a workaround or fix for this issue?
--
",,,,
8015,OPEN,Merge common class names of component and root element of that component,has PR; improvement,2019-01-09 09:40:52 +0000 UTC,jimut,Opened,,"### What problem does this feature solve?
It looks a little awkward if there are duplicate class names in a DOM element.

### What does the proposed API look like?
If you look into [this fiddle](https://jsfiddle.net/zLnzuh1f/). 

The `div` element of `foo` component will have two `bar` classes in it. So it looks like.

```html
<div class=""bar bar""></div>
```

If the two classes would have been merged into one.

```html
<div class=""bar""></div>
```

It would have worked and behaved exactly in the same way but the code will look a lot cleaner.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,astronomersiva,"
--
I am working on this.

Update: I have created a PR at https://github.com/vuejs/vue/pull/8035.
--
",Mushr0000m,"
--
I have the same issue. I need to keep the class in the component because it make sense for the component to know it's own class name for style etc..

But also need to keep the class attribute on the component call because it's a wrapper component around some server side generated content (header and footer), so without this class I have a glitch while Vuejs mount the component with the class name and so the browser doesn't apply the css.

I tried to look in `beforeMount` or `mounted`to remove duplicates but can't find a way. I know it works anyway, but the double class name looks weird, so if you know a solution to remove this, it would be nice.
--
",,,,,,,,
7990,OPEN,The values of some attributes are replaced with the attribute name; which breaks MathML,improvement,2018-04-09 13:19:10 +0000 UTC,VelizarHristov,Opened,,"### Version
2.5.16

### Reproduction link
[https://gist.github.com/VelizarHristov/edaf4cf0d7b9f90c1e5d6070c027237f](https://gist.github.com/VelizarHristov/edaf4cf0d7b9f90c1e5d6070c027237f)

### Steps to reproduce
Open the HTML in a browser (Internet connection is required to fetch the libraries).

### What is expected?
[] should be displayed

### What is actually happening?
open] is displayed

---
It comes from this line of code: https://github.com/vuejs/vue/blob/aa1356e83de1112660e7a88ff955f49d64bb5b1f/src/platforms/web/server/modules/attrs.js#L49

The list of rewritten attributes is here: https://github.com/vuejs/vue/blob/7116af4e07520040ed7328c39d0a456808bfe1e1/src/platforms/web/util/attrs.js#L22

This is a general problem when including a block of XML in the HTML.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
7984,OPEN,add `options` property to the render context of functional component,feature request,2018-04-26 16:10:08 +0000 UTC,caikan,In progress,,"### What problem does this feature solve?
Custom properties in the options of functional component can't be accessed easily.

### What does the proposed API look like?
In the render function of functional component, options can be accessed by `context.options`, just like `vm.$options`(https://vuejs.org/v2/api/index.html#vm-options)

related issue #7492

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Aaron,"
--
I would also use this feature pretty extensively. Writing powerful mixins that work with functional components becomes much more difficult when you don't have access to the $options object in the rendering context.
--

--
My use case it that I'm writing a mixin to handle reading and checking a ""type"" list that's custom property on my vue components. It checks attributes and applies specific css if an attribute name matches any of the given types specified in the vue instance ""type"" property. This works fine for full, non-functional components. But functional components can't access custom properties in the render function, so I can't access what type properties are set (because `$options` doesn't exist on the `context` object) when I'm actually composing styles for my component.

And I'm fine to do the export option, it just seems odd that `$options` isn't present on the `context` object, given all the other vue instance attributes which are.
--

--
@posva , custom options are great options for writing mixins to encapsulate reusable behavior that doesn't rely on reactive data. It's would be nice to be able to use custom properties in mixins, so to not be forced to pollute the prop list with things that aren't going to change or be publicly exposed on the component API, just so those properties are accessible to a mixin.
--

--
Sure! Disclaimer though, I'm fairly new to vue. I have pretty extensive experience in other front end frameworks, but I'm new to adopting vue. There's a very real chance I'm doing something ridiculous and unintuitive, but the use case doesn't strike me that way, personally.

Suppose I have a mixin that takes a custom property ""types"" from a component definition, assuming its present, and checks for matching attributes on the component's host element. It then concatenates a string of styles, derived from the attributes specified on the component element that match a type specified in the component definition. Here's how I might do it (I'm using styled components. Hopefully you're familiar with the library):

So, suppose this is my component:

```
import styled                 from 'vue-styled-components';
import IsTyped                from '@Composables/IsTyped';
import { Typography, Colors } from '@Constants/style';
let SmallLabel = {
 functional: true,
  name : 'SmallLabel,
  mixins : [IsTyped],
  render : function(h, context) {
    let Label = styled.span`
        // define base styles
        font-size   : ${Typography.size.medium};
        color       : ${Colors.black};
        // now add any styles based on types provided in the attributes
        ${context.$options.typedStyles} // this will be set by my mixin
      `;
    return (<Label>{context.$slots.default}</Label>);
  },

  types : {
    bright : `color      : ${Colors.smoke};`,
    dark   : `color      : ${Colors.sepia};`,
    bold   : `font-weight: ${Typography.weight.bold};`,
    light  : `font-weight: ${Typography.weight.bold};`
  }
};
```

And here's my `IsTyped` mixin:
```
import {keys, intersection, values} from 'lodash';

export default {
    beforeMount: function() {
      let styles = '';
      // looks for intersection between a components attribute and specified types
      intersection(keys(this.$options.types), values(this.$attrs))
        .forEach((t) => {styles = styles.concat(this.types[t]);})
      // concatenates the styles and then attaches them to the custom options of the component
      this.$options.typedStyles = styles;
    }
  }
}
```

Unfortunately, this **does not** work. Because `$options` is not on the `context` object provided to the render function.
--

--
Ah, didn't realize lifecycle methods didn't exist in functional components (like I said, vue newb here). And yes, I actually ended up doing what you suggested in the end, and it probably is cleaner. I just figured I'd give you my original use case, in case it gave you additional perspective about the original request.
--
",posva,"
--
I forgot to ask, but could you please share specific scenarios where this would be useful?
Also, keep in mind this is already possible by putting the object into a variable before exporting it
--

--
@caikan That's quite different, you need to import it or, in vue files, see #7492
--

--
What would you write on a mixin for functional components apart from `props`?
--

--
I still don't get what you're trying to do. Can you share a piece of code, please?
--

--
There is no lifecycle in functional components, they just call render. The only thing you can put in a mixin for functional components is props.
edit: oh and inject. I may be missing some now that I think about it 🤔 
Instead, you can set up functions to return an object of options and directly use that object in your render function, which also looks more straightforward IMO 😄 
--
",caikan,"
--
Here is one scenario: https://github.com/vuejs/vue/issues/7492#issuecomment-379570456

In my project, I want to make vue route components ""responsive"".
```javascript
const BaseResponsive = {
  functional: true,
  render(h, context) {
    // The options of extended component can't be accessed in base render.
    // My workaround is using injections, but looks weird.
    let component = context.injections.components[getDeviceType()];
    return h(component, context.data);
  },
};

const routes = [
  {
    path: '/foo',
    component: {
      extends: BaseResponsive,
      inject: {
        components: {
          default: {
            desktop: {/* ... */},
            mobile: {/* ... */},
          },
        },
      },
    },
  },
  {
    path: '/bar',
    component: {
      extends: BaseResponsive,
      inject: {
        components: {
          default: {
            desktop: {/* ... */},
            mobile: {/* ... */},
          },
        },
      },
    },
  },
];
```
--

--
My initial idea was to let functional components can be extended dynamically. Extended components have the same render logic but different options.
Now I think I have found another workaround: using a factory function.
```javascript
function createResponsiveComponent(options) {
  return {
    functional: true,
    render(h, context) {
      let component = options[getDeviceType()];
      return h(component, context.data);
    },
  };
}
```

--
",,,,,,
7964,OPEN,Transition on overflowed elements prevents scroll,browser quirks; transition,2018-08-29 04:39:10 +0000 UTC,johnleider,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/johnjleider/pen/MVqyXB](https://codepen.io/johnjleider/pen/MVqyXB)

### Steps to reproduce
- Click the button to open the menu
- As the element is transitioning in, begin to scroll (try not to move your mouse while scrolling)

### What is expected?
The scrollable area continues to scroll

### What is actually happening?
The scrolling area will get stuck. The scrolling event is still being fired but is not actually scrolling the content. Once you move your mouse and start to scroll again, it works as expected.

If you wait for the transition to finish before scrolling, the bug does not present itself.
![scroll](https://user-images.githubusercontent.com/9064066/38321350-643295b6-3805-11e8-92ff-ddd2fb3eecd2.gif)

---
We had a report of the `v-select` component not scrolling. We have confirmed this is only happening in Chrome 65, but extends back to even 0.15 of the framework (Vuetify). I created the attached codepen to determine if it was framework specific or generally reproducible.

While their may be other css properties that trigger this issue, I have only had success with opacity and happens specifically with the `enter` declaration. If you remove the entry animation, this does not occur.

**Removed entry animation** https://codepen.io/johnjleider/pen/ZxMObZ?editors=1111

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
I'm unable to reproduce it on OSX, are you sure this isn't just a browser bug? Could you try adding the classes manually without Vue?
--
",johnleider,"
--
Here is an example without the transition system: https://codepen.io/johnjleider/pen/BrOzdV

As far as it being a Chrome bug, no idea.

edit: I'm on Windows 10. Can confirm other OSX users cannot reproduce either.
--

--
My commit does not fix this issue. I discovered this issue while debugging a Chrome 65 related bug with the **contain** css property in Vuetify.
--
",blake,"
--
FYI: Linux with chrome is working for me 
--

--
@johnleider assuming your commit fixes this issue, thus will close this ticket. Feel free to reopen, if the issue persists and is a `vue core` issue
--
",,,,,,
7958,OPEN,Regression for slots and functional components,has workaround; regression,2021-03-24 11:15:09 +0000 UTC,blake-newman,Opened,,"### Version
2.5.16

### Reproduction link
[https://codesandbox.io/s/816m7v3rq9](https://codesandbox.io/s/816m7v3rq9)

### Steps to reproduce
Create a nested set of functional components, then change the slot definition in the child component. In `2.5.15` the slots are correctly rendered, but in `2.5.16` this is not happening. This is because the slot names are being persisted, so not correctly passed down the chain. 

This is a common pattern when creating reusable AHOC components, such as a dropdown with predefined content, but using a lower level component as a structural component. 

https://codesandbox.io/s/j44nj82483 (Version 2.5.15)

https://codesandbox.io/s/816m7v3rq9 (Version 2.5.16)


### What is expected?
Slots to render in there correct position

### What is actually happening?
Slots are not correctly assigned to there correct possition

---
This is introduced by this ticket: https://github.com/vuejs/vue/issues/7710

<!-- generated by vue-issues. DO NOT REMOVE -->",,,TheCommunistCow,"
--
Just an FYI for anyone that runs into this problem in Vue 2.6, this seems to be fixed by switching to the new slot syntax like:
`<template v-slot:name></template>`
--
",,,,,,,,,,
7943,OPEN,Provide a way to define different name for prop attribute,feature request,2020-11-19 13:14:03 +0000 UTC,davletovalmir,In progress,,"### What problem does this feature solve?
In most of cases, it's not really comfortable to use `initialProp` as prop name, for example, or have `normalizedProp` inside a component, which takes some passed prop and transforms it. Code looks bloated and reminds more workaround than a good solution.

Having ability to change attribute name of prop would be great. Something like:
```javascript
rawProp: { attributeName: ""prop"" }
```

### What does the proposed API look like?
```html
<component size=""md""> ... </component>
```
```javascript
computed: {
  size: {
    switch (this.rawSize) { ... } // returns something in case blocks
  }
},
props: {
  rawSize: {
    attributeName: ""size"",
    type: String
  }
}
```

Thus, using any of proposed solutions above, `this.size` inside component would return transformed value (for example, `h4` or just `4`).

I believe having this feature would be very awesome and help us to write cleaner code.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,hatashiro,"
--
I'm interested in this feature too. Is this feature confirmed to be implemented? I'm willing to work on this.

Edit:

I'm currently now working on this, please feel free to jump in.
--
",panhaoyu,"
--
Besides, there's also another enhancement about `props`.

Here's a simple code.

```js
props:{
  size: {
    type: Number,
  }
}
```

And here's a parent component:

```html
<parent>
  <child size=""1""></child>
</parent>
```

We know it's a wrong usage, but I think, now that we provided the field `type`, we can call `Number(value)` to change it's type?

After seeing this issue, I think maybe my choice can be a default function of his `transform` function.
--
",posva,"
--
Regarding the transform, it's basically `coerce` from Vue 1 and it was removed. The feature request is about **having different name locally for a prop** but the transform feature has been asked many times already (#2218, https://github.com/vuejs/vue/issues/7657) and it's achievable in userland: https://github.com/posva/vue-coerce-props. 
--
",davletovalmir,"
--
@posva, I've updated FR description.
--
",codebryo,"
--
To give this some life again, I am also very much interested regarding this feature.  I would though call it `propName` to stay in line with it being props:

```js
props: {
  rawSize: {
    propName: 'size',
    type: Number,
    default: 1,
  }
}
```
--
",fjc0k,"
--
Here is a Vue mixin ([fjc0k/vue-messenger](https://github.com/fjc0k/vue-messenger)) including a series of useful enhancements to Vue components props:

- [Transform props](https://github.com/fjc0k/vue-messenger#transform-props)
- [Enum-type props](https://github.com/fjc0k/vue-messenger#enum-type-props)
- [Numeric-type props](https://github.com/fjc0k/vue-messenger#numeric-type-props)
- [Listen for receiving props](https://github.com/fjc0k/vue-messenger#listen-for-receiving-props)
- [Two-way data binding props](https://github.com/fjc0k/vue-messenger#two-way-data-binding-props)

Hope this helps.
--
"
7924,OPEN,root opts attributes support,feature request,2019-02-22 19:06:23 +0000 UTC,SassNinja,In progress,,"### What problem does this feature solve?
The desired opts feature should offer the possibility to provide data from the markup (mostly from backend) to the vue instance.
So you can pass options/params from outside the vue scope. Example use case:
https://forum.vuejs.org/t/passing-props-to-root-instances-in-2-0/244

Right now this requires custom helpers/code to pipe the data through to the component.
Much better would be a more comfortable way similar the way riot does it with opts
http://riotjs.com/api/#mounting


### What does the proposed API look like?
Since the instance root is not a custom tag (compared to riot) I can imagine using prefixed attributes e.g. `data-opt-[NAME]`
So the root may look like this:
```html
<div id=""myRoot"" data-opt-firstname=""John"" data-opt-lastname=""Smith""></div>
```
and within the template you can access it as
```
<template>
    <span>Hello {{ opts.firstname }} {{ opts.lastname }}</span>
</template>
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,LinusBorg,"
--
> Much better would be a more comfortable way similar the way riot does it with opts
> http://riotjs.com/api/#mounting

That doesn't look at all like the API you propose further down:
```html
<div id=""myRoot"" data-opt-firstname=""John"" data-opt-lastname=""Smith""></div>
```


It looks much more like simply passing `propsData` when creating the instance, which looks like this:

```javascript
new Vue ({
  el: '#app',
  propsData: {
    firstname: 'John'
  }
})
```
Adding all  `data-` properties as props could be as imply as:
```javascript
const el = document.getElementById('app')
new Vue ({
  el: el,
  propsData: {
    ...el.dataset
  }
})
```

--
",SassNinja,"
--
Thanks @LinusBorg  for the quick response!

I've tried to implement your example with the propsData like this, but it doesn't work:
nothing appears in the template and the vue browser extension tells me the same (undefined)

```html
<div id=""myRoot"" data-firstname=""John""></div>
```
```javascript
import Vue from 'vue'
import myRoot from './myRoot.vue')
const el = document.getElementById('myRoot')
new Vue({
    el: el,
    propsData: {
        ...el.dataset
    },
    render: h => h(myRoot)
})
```
```
<template>
    <span>Hello {{ firstname }}</span>
</template>
<script>
    export default {
        props: ['firstname']
    }
</script>
```

However even if this would work it has several downsides:

- it assumes I'm working with IDs what I'm not because let's 'myRoot' call 'pagination' and I want more than one pagination on the page
- I need to specify all of my options as props within the template (vue file)

Maybe I'm wrong and just overseeing something but I haven't seen a way yet to pipe through data from markup (non vue origin) to the template. At least no way to do it as easy as in riot where it's really that simple:

- custom tag in the markup (= vue root elem) with custom attr (just like `<mytag name=""John""></mytag>`
- easy access in the tag file (= vue component / template) via `<span>{ opts.name }</span>`

For me the propsData solution doesn't meet that demand, does it?

--

--
**- Update -**

I've found a way that works for me although it somehow doesn't feel straight forward.
Looks like this (this time I'm using pagination to have a more 'realistic' example):

home.html
```html
<body>
    <div class=""pagination"" data-page=""1""></div>
    <p>Lorem ipsum</p>
    <div class=""pagination"" data-page=""1""></div>
    <script src=""/assets/dist/pagination.js""></script>
</body>
````

src/pagination.js
```javascript
import Vue from 'vue';
import Pagination from './pagination.vue';
document.querySelectorAll('.pagination').forEach(function(elem){
    new Vue({
        el: elem,
        render: h => h(Pagination),
        data: { opts: {} },
        beforeMount: function() {
            this.opts = this.$el.dataset;
        }
    });
});
```

src/pagination.vue
```vue
<template>
    <div>
        <span>Current page: {{ opts.page }}</span>
    </div>
</template>
<script>
    export default {
        data() {
            return {
                opts: this.$root.opts
            }
        }
    }
</script>
```

If there's no easier way to do this and you don't think there's the need to simplify this via vue, you may close this feature request.
--

--
Thank you @ejweiler for your help!

Correct me if I'm wrong but the template syntax of your example requires the vue compiler in client, right?
Or can this be interpreted by vue with runtime only?

```
<pagination :data=""opts.data1"" ...
```

The reason I'm breaking down all my components (pagination, search etc.) into independent files instead of one big bundled app.js is that I want load as less code on each page as possible.
Thus I'm using vue without compiler.

Since the HTML gets build in the backend I can't precompile it (SSR of vue is not an option) and thus can only precompile the vue files.

The way I've posted above is the only one I've found so far that let's my include the same component on the page with different data/options from the backend

```html
<body>
    <div class=""pagination"" data-title=""header pagination 123""></div>
    <p>Lorem ipsum</p>
    <div class=""pagination"" data-title=""footer pagination 456""></div>
    <script src=""/assets/dist/pagination.js""></script>
</body>
```
--
",ejweiler,"
--
From the previous two comments I have two suggestions:

You won't be able to drop this right in, but might give you something to consider and try.

If you had a vue instance that wrapped your html (closer to the level of the body) you could pass in variables just like you do with your pagination.vue template:

pagination.js
```
...
import Pagination from './Pagination.vue'
...
components: { Pagination },
...
```
template
```
<body>
    <div id=""app"">
        <pagination :data=""opts.data1"" data-page=""1""></div>
       <p>Lorem ipsum</p>
        <pagination :data=""opts.data2"" data-page=""1""></div>
    </div>
</body>
```

Alternatively, is it possible to solve this with a plugin? Inspired by the way using Vuex gives the stores to all children, could you make a plugin which provides these props to all components?

```javascript
const userOptionsFromServer = {...}

const UserDataPlugin = {
  install (Vue) {
    Vue.mixin({
      created() {
        this.opts = userOptionsFromServer
      }
    })
  }
}

Vue.use(UserDataPlugin)
```
--

--
@SassNinja I didn't realize you had those constraints, how about the option of trying a plugin?
--
",duprasa,"
--
So I also found a solution that is pretty easy to use, but I'm not sure if it violates some of vue's rules since we will have the `root component` and `template component` bound to the same DOM element.

ex: https://codepen.io/duprasa/pen/mvZQrB?editors=1010

code:
```
<component id=""component"" prop-a =""Value A""></component>
```

```
let el = document.getElementById(""component"")
let component_instance = (new Vue({el: el, components: {component: component_options}})).$children[0];
```
--
",,,,
7914,OPEN,"v-bind=""$attrs"" and problems with ""value"" attribute for multi-checkboxes",,2020-02-16 12:51:33 +0000 UTC,pearofducks,In progress,,"### Version
2.5.16

### Reproduction link
[https://codepen.io/anon/pen/aYqoYL?editors=1010](https://codepen.io/anon/pen/aYqoYL?editors=1010)

### Steps to reproduce
- Check the checkbox
- See that the value is set to ""null"" even though the input element has its value (correctly) set to ""foo""

### What is expected?
- The value passed through ""$attrs"" should be the checkbox's value used

(or, the `value` never hits the DOM element, the fact that it is present on the DOM element but isn't used in the model is a conflict IMO)

### What is actually happening?
- Null is set

<!-- generated by vue-issues. DO NOT REMOVE -->",,,emanuelmutschlechner,"
--
Check the modified codepen. I changed the component logic to match default native multi checkbox behavior.

https://codepen.io/anon/pen/NYQWzo?editors=1011
--

--
@pearofducks If you want `v-model` to pick up the `value` defined on your component, explicitly bind `value` in your custom component

https://codepen.io/anon/pen/GxVJzW?editors=1010
--

--
I get your point, but I'm not sure if this is a bug or not. We need some feedback from the core team.

My solution is partly based on this example code, where `value` is bound explicit and used with disabled attribute inheritance. [source](https://vuejs.org/v2/guide/components-custom-events.html#Binding-Native-Events-to-Components)
```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` merges objects together to form a new object
      return Object.assign({},
        // We add all the listeners from the parent
        this.$listeners,
        // Then we can add custom listeners or override the
        // behavior of some listeners.
        {
          // This ensures that the component works with v-model
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind=""$attrs""
        v-bind:value=""value""
        v-on=""inputListeners""
      >
    </label>
  `
})
```
--

--
Maybe this issue is somewhat related to #6216?
--
author:	
association:	none
edited:	false
status:	none
--
I think both of you are right. And, @emanuelmutschlechner, you are correct, right now this is the way of doing it: @chrisvfritz explains the state of the art and future approaches here:

<a href=""http://www.youtube.com/watch?feature=player_embedded&v=YOUTUBE_VIDEO_ID_HERE
"" target=""_blank""><img src=""http://img.youtube.com/vi/b554XmaTWrw/0.jpg"" 
alt=""Vue 3 presentation by Chris Fritz"" /></a>

(https://www.youtube.com/watch?v=b554XmaTWrw)
--
",pearofducks,"
--
@emanuelmutschlechner I don't think your codepen is relevant here (though I appreciate you working toward a solution!). Adding an explicit `value` prop to my original pen and putting that prop on the `input` field works around the bug - as can be seen in [this modified pen](https://codepen.io/anon/pen/KoOpwv?editors=1010). The point is that that shouldn't need to be done.

`v-bind=$attrs` should be passing `value` to the `input` already in my original pen, and it isn't doing so in a way `v-model` is picking up on.
--

--
@emanuelmutschlechner - please read my previous response. With `$attrs` this shouldn't be necessary. I'm pretty confident this is a valid bug, but I appreciate you trying to help.
--
",jloa,"
--
I think both of you are right. And, @emanuelmutschlechner, you are correct, right now this is the way of doing it: @chrisvfritz explains the state of the art and future approaches here:

<a href=""http://www.youtube.com/watch?feature=player_embedded&v=YOUTUBE_VIDEO_ID_HERE
"" target=""_blank""><img src=""http://img.youtube.com/vi/b554XmaTWrw/0.jpg"" 
alt=""Vue 3 presentation by Chris Fritz"" /></a>

(https://www.youtube.com/watch?v=b554XmaTWrw)
--
author:	jloa
association:	none
edited:	false
status:	none
--
Just wanted to that i've also faced this in my project.
Basically the problem can be narrowed to this:

```
// this works with emit('input')
v-bind:value=""value""

// this fails to work with emit('input')
v-bind=""{ value:value }""
```
So yeah, we have to explicitly set the :value to make things work, as @emanuelmutschlechner said earlier.
Imho, this seems more like a bug.
--
",,,,,,
7879,OPEN,<transition-group> and v-show triggers move transition on enter,bug; has PR; transition,2018-11-08 00:01:45 +0000 UTC,chrisvfritz,Opened,,"### Version
2.5.16

### Reproduction link
[https://jsfiddle.net/chrisvfritz/845Lee66/](https://jsfiddle.net/chrisvfritz/845Lee66/)

### Steps to reproduce
1. Open the fiddle
2. Click the ""Toggle"" button
3. Watch the `move` transition trigger on enter

### What is expected?
Just like with `v-if`, move transitions should not be triggered on enter (note that it is already _not_ triggered on leave). 

### What is actually happening?
I haven't checked in the source yet, but I'm guessing that since elements with `display: none` still technically have coordinates:

```
DOMRect { x: 0, y: 0, width: 0, height: 0, top: 0, right: 0, bottom: 0, left: 0 }
```

The `move` transition is triggered on enter. I'm not sure why it wouldn't also occur on leave though. 

---
This may be connected to [#5800](https://github.com/vuejs/vue/issues/5800). Also, special thanks to @rachelnabors for finding this bug!

<!-- generated by vue-issues. DO NOT REMOVE -->",,,rachelnabors,"
--
Woohoo! I managed to break something!
--
",vctt94,"
--
Can I give this issue a try?
--

--
hey @wlkuro, I believe you are right, and that is the cause. But we are not supposed to make changes on dist files. It is a self generated file, but the change you suggested does work. 
--

--
I see, what exactly this _enterCb does? 
--
",jkzing,"
--
@vctt94 Of cause, welcome 😃
--
",wlkuro,"
--
 this coordinate is using getBoundingClientRect method to get value.
getBoundingClientRect method is value 0 when display: none 

How about change of line 8424 of vue.js
c$1.elm.style.display = 'block';
c$1.data.pos = c$1.elm.getBoundingClientRect();

The value can be taken


--
",pengchongfu,"
--
@wlkuro @vctt94 I think a better solution is not to add `v-move` on element and and not to execute `_enterCb` just like `v-if`.
--

--
@vctt94 sorry for not seeing your pr 😭
[`_enterCb`](https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/modules/transition.js#L115) should be executed when enter transition was finished or move transition was triggered. 
but I think it is better that `v-show` has similar behavior as `v-if`.
if `_enterCb` was executed, `v-show` would lose enter transition.
--
",danielstgt,"
--
I was playing around with an example from the docs and hit the same issue as described (e.g. toggle button: https://codepen.io/pen/BGjJGL).

Since the PR is still open - are there currently any workarounds for this? Using `v-if` works perfectly but is not an option due to performance reasons.
--
"
7862,OPEN,Subscribe to all custom events on a child component,feature request,2018-04-25 05:56:36 +0000 UTC,dmmikkel,In progress,,"### What problem does this feature solve?
Would make writing wrapper components easier

### What does the proposed API look like?
When v-on receives a function it should trigger on every custom event emitted by the child

    <my-custom-component v-bind=""$props"" v-on=""onAnyEvent""></my-custom-component>

Argument one could be the name of the event

    onAnyEvent(eventName, eventArgs) { // do something }

<!-- generated by vue-issues. DO NOT REMOVE -->",,,jkzing,"
--
IMHO, in cases to proxy events, `v-on=""$listeners` would be more intuitive.

And if the case is that you want to do different things for different events.
``` vue
<my-custom-component v-bind=""$props"" v-on=""onAnyEvent""></my-custom-component>

onAnyEvent(eventName, eventArgs) {
  switch (eventName) {
    case 'click':
    case 'input':
  }
}
```
is not make things easier than:
``` vue
<my-custom-component v-bind=""$props"" v-on=""{ click: handler1, input: handler2 }""></my-custom-component>
```
--
",dmmikkel,"
--
The idea is to wrap every event and treat them equally (like re-emit them from the wrapper component)
--
",,,,,,,,
7858,OPEN,"v-show=""true"" possibly incorrect during SSR",improvement,2018-05-15 06:00:30 +0000 UTC,brophdawg11,Opened,,"### Version
2.5.16

### Reproduction link
[Gist](https://gist.github.com/brophdawg11/560ce5478ddebbb3a7f1aacc30fbbbc1)

### Steps to reproduce
* Download the above gist to an `index.js` file
* `npm install --save vue vue-server-renderer`
* `node index.js`

### What is expected?
I would expect an element rendered server side with `v-show=""true""` to render in the same fashion as one without a `v-show` directive.   

### What is actually happening?
Elements with `v-show=""true""` are rendered during SSR with a seemingly invalid style attribute: `style=""display:;`, while those without any `v-show` directive do not contain a `style` attribute at all

---
I don't know that this causes any specific rendering issues at the moment, but I noticed it because chrome dev tools was complaining about the styles on my element.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,blake,"
--
I don't think this causes any issues during render, but you are correct it shouldn't be rendering as you mentioned. Add improvement label, as it is something that can be fixed but not a destructive bug
--
",curryz,"
--
so do I, when I user SSR ,v-show cause the style can't be displayed
--
",,,,,,,,
7846,OPEN,Extending object syntax of v-on to support modifiers,feature request,2021-02-09 17:17:07 +0000 UTC,brianwhu,Opened,,"### What problem does this feature solve?
The object syntax of the v-on directive is vital in achieving conditional binding of event listeners, as shown in the discussions at https://github.com/vuejs/vue/issues/7349.

    <div v-on=""{ mouseover: condition ? handler : null }"">

However, the current object syntax does not allow modifiers.

This feature request suggest that we extend the object syntax in the following way to allow modifiers.

    <div v-on=""{ click: { left: { prevent: condition ? leftClickHandler : null } },  mouseover: { stop: mouseoverHandler } }"">

The above example would conditionally install leftClickHandler on ""click.left.prevent"" and mouseoverHandler on ""mouseover.stop"".

The embedded object notation is also conceptually consistent with the dot-notation already adopted in both function and inline syntax.


### What does the proposed API look like?
The proposed v-on object syntax would like like this, which is an extension of the current syntax.

    <div v-on=""{ click: { left: { prevent: condition ? leftClickHandler : null } },  mouseover: { stop: mouseoverHandler } }"">

<!-- generated by vue-issues. DO NOT REMOVE -->",,,andrewsm80,"
--
I think the below syntax would be better (no object embedding):

```vue
<div v-on=""{ 'click.left.prevent': condition ? leftClickHandler : null,  'mouseover.stop': mouseoverHandler }"">
```
--
",posva,"
--
This is possible today by using https://vuejs.org/v2/guide/render-function.html#Event-amp-Key-Modifiers

```vue
<button v-on=""{ '~click': () => foo = new Date() }"">Trigger only once</button>
```
--

--
@Zsavajji if you think you found a bug please file a new issue with a  boiled down reproduction
--
",Zsavajji,"
--
Hi! I'm sorry to bring up such an old issue, but with the update to 2.6.11 i found that a thing related to this i used a lot in my project broke down.
I'm attaching `v-on:click` and `v-on:click.native` to a `<component` tag, which can dynamically be a Vue component or a DOM element. 
This now emits warnings, flooding logs and affecting development performance. 
I tried to attach those listeners dynamically but there's no object syntax for the `.native` modifier. How can i handle this?
--

--
Not sure if it is a bug or expected behavior. Will open a bug report tomorrow :)
--
",magistr4815,"
--
Hello.
I tried to do it like this, but it does not work.
```js
// not working
v-on=""{ [condition ? 'click.stop' : 'click'] : eventfunc }""
// or
// error
v-on=""{ condition ? 'click.stop' : 'click' : eventfunc }""
```
Is there any other solution?
Thanks in advance!
--
",madmod,"
--
This does not seem to work for all event methods. Only those which have the proprietary prefixes.
--
",Glandos,"
--
> This is possible today by using [vuejs.org/v2/guide/render-function.html#Event-amp-Key-Modifiers](https://vuejs.org/v2/guide/render-function.html#Event-amp-Key-Modifiers)
> 
> ```
> <button v-on=""{ '~click': () => foo = new Date() }"">Trigger only once</button>
> ```

This seems nice, even if undocumented. However, the `.native` modifier has no prefix, and seems unsupported with the object syntax. Is there any workaround for now?
--
"
7837,OPEN,keep-alive breaks initial transition,transition,2018-08-29 04:39:35 +0000 UTC,sqal,In progress,,"### Version
2.5.16 (but I also checked to version 2.5.5)

### Reproduction link
[https://jsfiddle.net/bpkpz6v6/](https://jsfiddle.net/bpkpz6v6/)

### Steps to reproduce
- Add 3 items. You can see the animation on every item ✅
- Remove items in this order 3 -> 2 -> 1
- Add 3 item. This time animation for item 1 is not being applied ❌
- Remove items but in reverse order 1 -> 2 -> 3
- Again add items. Animation works correctly again ✅


### What is expected?
Transition to work every time

### What is actually happening?
When transition-group inside keep-alive is activated after being deactivated, it sometimes does't apply a transition on the first rendered element.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sqal,"
--
hmm I've just noticed that when I don't reset the id counter (`this.id--`) after removing an item then it works fine 🤔 
--
",posva,"
--
I think it's because of the `v-if`. It triggers before the component renders with the empty list of items. When you add a new one, it reactives, but the item is already there, so no animation happens. Ideally you should deactivate the component once the transition is finished. If you keep-alive the component, wouldn't make more sense to just use v-show without keep-alive?
--
",,,,,,,,
7830,OPEN,v-model support for web components (stenciljs),feature request,2021-03-24 18:30:26 +0000 UTC,jordandobrev,Opened,,"### What problem does this feature solve?
V-model support for web components(tested with web component implemented with ionic's stenciljs compiler).

Does not work:
```
<ui-input v-model=""mySelect"" />
```

Works:
```
<ui-input :value=""mySelect"" @input=""mySelect = $event.target.value"" />
```

Can this be enabled to support ignored elements as well that have been declared with:

```Vue.config.ignoredElements = [/^ui-/];```

### What does the proposed API look like?
Declaration
```
Vue.config.ignoredElements = [/^ui-/];
```
Usage
```
<ui-input v-model=""mySelect"" />
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,multiplegeorges,"
--
I tracked this down a bit and seems to come from how Vue treats custom components differently than a regular element like an `<input />`. 

For regular inputs, Vue looks for the value in `$event.target.value` and finds it because the browser is emitting a regular InputEvent object.

For custom components like ion-input, it seems that Vue is expecting the value to be emitted directly and not as a subclass of Event. So, Vue looks for the value in `$event` rather than `$event.target.value`.

This behaviour is documented here: https://vuejs.org/v2/guide/components.html#Using-v-model-on-Components

This was probably done to make the coding of custom components simpler: the developer wouldn't need to instantiate a new Event and emit it. 

A simple fix (and uneducated guess on my part) would be to get rid of the special case for custom components and check if what is being `$emit`'ed is actually an Event object and wrap it in an Event if it isn't.
--
",TomCaserta,"
--
Leaving a comment here as it may be helpful to others, whilst this definitely should be handled inside the vue project itself in the meantime if you're looking for a solution right now I've created a compile directive that is configurable and allows you to use the same syntax on web-components until a proper solution is in place:

https://www.npmjs.com/package/vue-wc-model 

I wouldn't mind creating a PR and getting something implemented in vue itself but there is some unknowns regarding how this should be handled. For example, not all web components use the `input` and `change` handlers nor even expose `value` as a property on the event target (eg. components created via `vue-web-component-wrapper`). 

I think this needs to be thought out some more in terms of what to do. 
--
",tmorehouse,"
--
What if `v-model` accepted an event name as a directive argument? i.e.:

 `v-model:blur=""fooBar""`

Could even be used for custom event names (as long as they didn't contain any colons or periods)

Any event specified this way would set the model value to `event.target.value`, and do no underlying ""magic"" that happens with regular `v-model` or `.lazy` modifier.
--
",chris,"
--
Has anyone began to investigate this. This has had a huge impact on us in moving forward with using Vue. It also appears that Vue is the only framework where we are seeing binding issues with our web components. 
--
",calebdwilliams,"
--
I really like the idea of `v-model:eventName`, that would definitely help us out. We've created a series of form web components that have their own APIs that work fine in Angular and React, but this issue is hampering out adoption in Vue. Would love to see some input from maintainers on this and would be interested in helping implement if needed.
--
",laosb,"
--
We've also trying to use WebComponents with Vue. The problem here is, Vue must know this WebComponent implemented `input` event and have `value` in target, as what `<input>` do. I believe Vue can just assume this when `v-model` tis applied to any tag which is not a Vue component, nor a known non-text form component.
--

--
@ngfk 's solution looks better to me. No change to current api, and nothing should break in this way.
--
"
7825,OPEN,Globally registered component naming converts to kebap-case when PascalCase is used,improvement,2018-03-13 16:44:48 +0000 UTC,steffans,In progress,,"### Version
2.5.15

### Steps to reproduce
Currently all globally registered components automatically convert their name to  kebap-case. 

```js
// register component
Vue.component('RouterLink', {...})

// get component fails, returns undefined
Vue.component('RouterLink')

// get component works, returns the component
Vue.component('router-link')
```

It would be nice to have the registered components also available as with their PascalCase naming. This would also mean that you could use the PascalCase naming in `.vue` templates, which is a nice way to quickly distinguish Vue components from HTML elements. Right now its is not possible, and to make it work this code has to be used:

```html
<template>

  <RouterLink :to=""link"">Link</RouterLink>

</template>
<script>
{
    components: {
       RouterLink: Vue.component('router-link')
   }
}
</script>
```


### What is expected?
Access globally registered components with their PascalCase naming if it was provided on register function call.

### What is actually happening?
For now the component naming always converts to kebap-case.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
You probably mean the other way around:

```js
Vue.component('FooLink', { template: `<p>Foo</p>` })

!!Vue.component('FooLink') // -> true
!!Vue.component('foo-link') // -> false (should be true)
```
--
",steffans,"
--
@posva You are right, sorry my bad. I recently tried to use the VueRouter with `RouterLink` which didn't work, looked up the repo a saw `Vue.component('RouterLink', Link)` which got me confused. However this was not the actual released version 3.0.1 i was using, which is still doing `Vue.component('router-link', Link)`.

--
",,,,,,,,
7812,OPEN,[SSR] 服务端渲染能否增加自定义 TemplateRenderer 或者 提供部分inject的参数？,feature request,2018-03-13 07:47:35 +0000 UTC,edward32tnt,Opened,,"### What problem does this feature solve?
当我使用 inject: true 的参数渲染 ssr 页面时，我只想对 renderScripts 这部分做自定义修改，其他继续沿用默认templateRenderer的render**。

如果 我设置了 inject: false，那我必须在 html模板中 添加 各种 {{ render** }} 。

请问有没有更方便的方法？

### What does the proposed API look like?
```
createBundleRenderer({
  inject:true,
  renderScripts: function() { ... },
})

```
or 

```
createBundleRenderer({
  inject:true,
  templateRenderer: new otherTemplateRenderer(),
})
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
7760,OPEN,SFC: Invalid root tag structure should throw error,improvement,2018-03-29 23:14:12 +0000 UTC,hibiyasleep,In progress,,"**Moved from**: [vue-loader#1161](https://github.com/vuejs/vue-loader/issues/1161)

### What problem does this feature solve?
In Single File Component, `<script>` tag may or may not closed, so this works:

```html
<template>
  <div class=""chicken"">
    Chicken: {{ chicken }}
  </div>
</template>

<script>
export default {
  data() { return { chicken: 'fried' } }
}
// (EOF)
```

However, `<style>` isn't; if there's no `</style>`, styles are **simply ignored** without any warning or errors.

```html
<template>
  <div class=""chicken"">
    Chicken: {{ chicken }}
  </div>
</template>

<script>
export default {
  data() { return { chicken: 'fried' } }
}
</script>

<style scoped>
.chicken { /* super important */
  font-weight: 900;
}
/* (EOF) */
```

### What does the proposed API look like?
Any `<template>`, `<script>`, `<style>` tags should **explicitly**:

* Closed - unclosed tag should throw a warning and refuse to build.
* ~or May not closed - contents should build correctly even it's not closed.~

<!-- generated by vue-issues. DO NOT REMOVE -->",,,ameerthehacker,"
--
@posva can I take up this issue.
--
",hibiyasleep,"
--
![2018-03-30 07 28 59](https://user-images.githubusercontent.com/5380174/38116658-0f679bf2-33ec-11e8-991a-cbe58c341436.png)

Even on this stupid situation, SFC compiler doesn't throw any error.

At least, with my config, `<script type=""sass"">` seems invoke both of sass-loader and eslint, and sass got transpiled and worked. is this intended behavior?
--

--
Also when multiple `<script>` tag exists, all but last tags are simply ignored.
--
",,,,,,,,
7720,OPEN,Vue warns about missing required prop that has a default value,discussion; improvement,2019-11-26 09:04:09 +0000 UTC,decademoon,In progress,,"### Version
2.5.13

### Reproduction link
[http://jsfiddle.net/df4Lnuw6/207/](http://jsfiddle.net/df4Lnuw6/207/)

### Steps to reproduce
Specify a required prop with a default value:

```js
Vue.component('comp', {
    template: '<div>{{ typeof x }} {{ x }}</div>',
    props: {
        x: {
            type: Number,
            required: true,
            default: 5,
        },
    },
});
```

Render the component without specifying a value for that prop:

```html
<comp></comp>
```

### What is expected?
The component should render the following without any prop validation errors:

```html
<div>number 5</div>
```

### What is actually happening?
The component renders OK, but warns about missing required prop `x`.

---
While it's true that prop `x` is not specified, since it has a default value, there should be no warning message.

What exactly does `required` check for? It appears that it checks two things:

1. The prop should be *provided*, as in at least `<comp :x=""...""></comp>`.
2. The prop value should be non-null and non-undefined.

I think in the case where a required prop has a default value, (1) should be relaxed.

Otherwise, how can I enforce a prop to never be null while also providing a default value if the prop value was not provided?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
TLDR; Maybe we should indeed allow required + default value in [this check](https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L101)

By saying the prop is required you expect the user to always provide a value, so making it have a default value defeats the purpose of the prop being required.
When you require a prop, it means that you need that information from the user and that there is no way for you to provide a fallback value.

> Otherwise, how can I enforce a prop to never be null while also providing a default value if the prop value was not provided?

No, because `null` and `undefined` values always skip validation

If you want to take a deeper look at how the prop validation works, you can check https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L94

After doing some research in past issues, I found [this comment](https://github.com/vuejs/vue/issues/6768#issuecomment-335527318)

> Hmm, yeah so it needs to be more accurate:
> 
> - `null` indicates the value is explicitly marked as not present and it should remain `null`.
> - `undefined` indicates the value is not present and a default value should be used if available.
> - `required: true` indicates neither `null` or `undefined` are allowed (unless a default is used)
> 
> I agree this could be confusing, just as the existence of `null` vs. `undefined` in the language itself. But the design was trying to stay close to what these values are designed represent in JS, and changing them would be break
--

--
~The validation will always be skipped with nully values though.~
The validation will always be skipped with nully values and `required: false` though.
Contributions to docs are always welcome 😄 
--

--
That's right! it is for undefined that validation is skipped with non-required props
--
",decademoon,"
--
Yeah, currently the issue that is `required: true` implies that the prop cannot be absent, but then if `required: false` and the prop value is nully then validation is skipped altogether. There is no way to enforce a prop to be non-nully at all times without `required: true` and hence prop omission is disallowed.

I also think the docs could be more clear about the precise definition of the `required` option.
--

--
@javoski That's confirmed in this section of code https://github.com/vuejs/vue/blob/cd334070f3b82d3f5892c4999cc290ccd4f56fd8/src/core/util/props.js#L101-L110
--
",javoski,"
--
>The validation will ***always*** be skipped with nully values though.

It's NOT when `required: true` was given. [http://jsfiddle.net/df4Lnuw6/225/](http://jsfiddle.net/df4Lnuw6/225/)

<img width=""535"" alt=""2018-02-28 7 12 42"" src=""https://user-images.githubusercontent.com/5391892/36784724-71fd92dc-1cbb-11e8-978a-de94a2acec20.png"">

--
",yyx990803,"
--
How about a new flag `useDefaultForNull`

``` js
Vue.component('comp', {
    template: '<div>{{ typeof x }} {{ x }}</div>',
    props: {
        x: {
            type: Number,
            default: 5,
            useDefaultForNull: true
        },
    },
});
```
--
",Kingwl,"
--
`useDefaultForNull ` is toooooooooooo long  
hope to find a keyword only has one word 🌚
--
",pqt,"
--
> `useDefaultForNull` is toooooooooooo long

It also reads ... awkwardly. Am I the only one who thinks that? Personally I'd go with adding `nullable` as a `type` declaration and using that as a flag, but I realize that's a little outside of the typical Vue approach.
--
"
7713,OPEN,Use better types to model prop type,typescript,2020-11-30 17:57:38 +0000 UTC,zsky,Opened,,"### Version
2.5.13

### Reproduction link
[https://github.com/zsky/vue-date-type-issue](https://github.com/zsky/vue-date-type-issue)

### Steps to reproduce
```
npm i
npm run build
```

### What is expected?
No typescript error

### What is actually happening?
Typescript report error: Property 'getTime' does not exist on type 'string'

***
I use vue with typescript, I want to set a component prop type as Date, so I do this:
```typescript
Vue.extend({
  props: { start: Date },
  created() { 
     this.start;  // Expect type Date, but String
  }
});
```

Then I find something could be userful:
In options.d.ts,
```typescript
export type Prop<T> = { (): T } | { new (...args: any[]): T & object }
```
Make a simple test:
```typescript
function test<T>(opts: { p1: Prop<T> }): T {
    return {} as T;
}
let result = test({ p1: Date });  // Expect type Date, but String
```
But I still don't know how to solve it, thanks for any suggestion.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,HerringtonDarkholme,"
--
The problem is in `DateConstructor`

```ts
interface DateConstructor {
    new(): Date;
    (): string;
}
```

The call signature returns `string` so TS gets a wrong inference.

I think the best solution is to await conditional type in TS 2.8. cc @ktsn 
--
",ktsn,"
--
Yes, it seems we cannot handle the DateConstructor without conditional types.

FYI, you can manually annotate it for now:

```ts
Vue.extend({
  props: { 
    start: Date as new () => Date
  },
  created() { 
     this.start;
  }
});
```
--
",WarisR,"
--
I workaround it by using `PropType`
```
import Vue, { PropType } from 'vue';
Vue.extend({
  props: { 
    start: Date as PropType<Date>
  },
  created() { 
     this.start.getMonth();
  }
});
```
--
",lastlink,"
--
For both examples:

```js
start: Date as new () => Date,
```
I'm getting on the end of the Date *_*

```js

var Date: DateConstructor
Enables basic storage and retrieval of dates and times.

Parsing error: Unexpected token, expected "",""
```
--
",,,,
7680,OPEN,"extended components fall back to global component definition. (instead of local one in ""super/parent"")",improvement,2018-02-21 12:56:43 +0000 UTC,dasdeck,In progress,,"### Version
2.5.13

### Reproduction link
[https://codepen.io/dasdeck/pen/NyMvjQ](https://codepen.io/dasdeck/pen/NyMvjQ)

### Steps to reproduce
The codepen shows the bug on opening.

### What is expected?
I'd expect ""extComp"" to behave exactly like ""baseComp"" since it is extended.

### What is actually happening?
""extComp"" uses the global ""my-comp"" definition instead of the one in the super/parent component

---
This might be expected/intended behavior, however, all people I asked agree that this is counter intuitive and feels more like a bug than a feature.

Cheer!

JM

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It's not consistent, indeed, but you should name components with CamelCase: `Vue.component('MyComp', CompB);`, that will fix the error btw.
There is probably a normalization going on that is not working correctly
--
",dasdeck,"
--
Yes, I (mostly) use PascalCasing in my actual code (not camelCasing ;)), thought the name comes from a third party library. 

But this will help for now! Though a bit tricky if the naming is done in 3rd party libraries. So consistent normalization will be good!



Cheers!
--
",,,,,,,,
7595,OPEN,SSR Component Cache doesn't cache Strings,improvement,2021-02-12 12:51:05 +0000 UTC,MartinLG,In progress,,"### Version
2.5.13

### Reproduction link
[https://runkit.com/martinlg/issue-vue-renderer-cache](https://runkit.com/martinlg/issue-vue-renderer-cache)

### Steps to reproduce
Run the Runkit code. If you prefer a git repository I can provide you one.

### What is expected?
The value passed to the ```set``` function should be a string.

### What is actually happening?
The value passed to the ```set``` function is an object, with 2 properties:

* html: a ```string``` containing the rendered component
* components: a ```Set``` containing nothing or function, depending on context (sub-components I think)

---
This issue breaks any external cache possibility (Redis in my case).
The only possible cache is in the process memory, like the LRUCache, but it seems impossible to scale processes and share a common cache.

Moreover, the documentation explain clearly that the cached value should be a string, and even provides a small Redis example implementation, that could just not work.

I think that the documentation describe the expected behavior, so I don't want to ""fix"" the documentation, I think we should fix the behavior.

I will try to help but I may need some explanations on some parts of the RenderContext, can I ask my questions on this thread ?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,MartinLG,"
--
#7593 Old issue, rejected for heavy example.
--

--
Actually, I don't see why we should cache component's lifecycle in rendering.

The component should be rendered, its template should be cached as a string (the html part of the currently stored object). Then when the component get fetched from the cache, it's template is static, and should not depend of the store. So I don't see why we should register all its child components.

Of course the browser takes back the hand, and make them dynamic like every components.

Did I miss something ?
--

--
I just tried to remove the component registration and I see now that it breaks the inline styles on the cached version.

Still looking for a solution to store the cache on an external data store.
--

--
@Atinux This is the issue I told you about. If you have any suggestions that could help me on SSR, I would love to ear it.
--
",HerringtonDarkholme,"
--
I don't think SSR cache behavior is expected, either.

https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/types/index.d.ts#L46-L48

However, component cache also needs to cache component's lifecycle in rendering. So the type definition and documentation are both outdated. 
--
",KindWizzard,"
--
I don't believe caching doesn't work as it should be o_O Maybe some PR will help fix this? And it still opened... from February? Does no one use the cache or what?
--
",dbrekalo,"
--
Any updates on this? Having same issue with redis client. 
--
",luoyang125024608,"
--
the same issue . I want to use redis client , but the components is a Set .
--
",chriz,"
--
Wow, this is just extremely disappointing. Especially since the SSR docs explicitly show a redis client example. https://ssr.vuejs.org/api/#cache
--
"
7557,OPEN,Remove attribute merging for functional components with no prop definition,discussion; feature request; improvement,2018-04-09 00:29:40 +0000 UTC,blake-newman,Opened,,"### What problem does this feature solve?
Currently when using functional components without `prop` definition, all attributes will be rendered when using [`JSX spread`](https://github.com/vuejs/babel-plugin-transform-vue-jsx#jsx-spread).  

This is because the `context.data.attrs` remain after they are merged. 

## Current

Usage:`<Example type=""blue"" fill={true} class=""extra-class"" aria-label=""I'm a label"" />`

Implementation: 
```
export default {
  functional: true,
  
  render({ data, props }) {
    const { type, fill } = props

    const buttonClass = {
      'button--fill': fill,
      [`button--${type}`]: !!type
    }

    <button {...data} class={buttonClass} >
  }
}
```

Output: `<button fill=""true"" type=""blue"" class=""extra-class button--fill button--blue"" aria-label=""I'm a label"" />`



### What does the proposed API look like?
It should be explicit what attributes to render to dom when using a functional component with no prop definition. 

[With fix `delete data.attrs`](https://github.com/vuejs/vue/blob/dev/src/core/vdom/create-functional-component.js#L81)

### Explicitly passing attributes

You can use spread notation to get all remaining `attrs`, and replacing the `data.attrs` object

Usage: `<Example type=""blue"" fill={true} class=""extra-class"" aria-label=""I'm a label"" />`

Implementation: 
```
export default {
  functional: true,
  
  render({ data, props }) {
    const { fill, type, ...attrs } = props
    data.attrs = attrs

    const buttonClass = {
      'button--fill': fill,
      [`button--${type}`]: !!type
    }

    <button {...data} class={buttonClass} >
  }
}
```

Output: `<button class=""extra-class button--fill button--blue"" aria-label=""I'm a label"" />`

### Explicitly passing attributes 2

Usage: `<Example  type=""blue"" fill={true} class=""extra-class"" formtarget=""id"" dummy-attr=""lol"" />`

Implementation: 
```
export default {
  functional: true,
  
  render({ data, props }) {
    const { fill, type, formtarget } = props

    const buttonClass = {
      'button--fill': fill,
      [`button--${type}`]: !!type
    }

    <button {...data} formtarget={formtarget} class={buttonClass} >
  }
}
```

Output: `<button class=""extra-class button--fill button--blue"" formtarget=""id"" />`


### Conclusion

Both examples show how the behaviour of the attributes should be left with the child when dictating what attributes shoud be rendered. You can either do a `and rest` approach or explcititly name attributes to pass onto element. 

The original all props/attrs will be rendered as attributes, which adds polution to the DOM especially with attributes that are array's/objects/functions/symbols.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
7515,OPEN,Vue.extend mutates original object,discussion,2018-03-12 19:41:37 +0000 UTC,posva,Opened,,"### Version
2.5.13

### Reproduction link
[http://jsfiddle.net/vmvabzam/](http://jsfiddle.net/vmvabzam/)

### Steps to reproduce
- run the fiddle and look at the code vs the html

### What is expected?
`Foo.props` should still be an array after extending it

### What is actually happening?
`Foo.props` are normalized after using Vue.extend on it

<!-- generated by vue-issues. DO NOT REMOVE -->",,,,,,,,,,,,,,
7492,OPEN,Functional single file component with components option.,feature request; has PR; improvement,2020-06-22 10:24:08 +0000 UTC,terrierscript,Opened,,"### Version
2.5.13

### Reproduction link

NG pattern (functional)
https://codesandbox.io/s/004vv2onw0

OK pattern (no functional)
https://codesandbox.io/s/q9k5q8qq56

### Steps to reproduce
I found can't use `components` option when  `functional` single file component.

```html
<template functional>
  <div>
    <some-children />
  </div>
</template>

<script>
import SomeChildren from ""./SomeChildren""

export default {
  components: {
    SomeChildren
  }
}
</script>
```

It's occure `Unknown custom element`.

### What is expected?
Not occure `Unknown custom element` and use child component

### What is actually happening?
It's occure `Unknown custom element`

---

In workaround, it not occure when use `Vue.component`.

```js
import Vue from ""vue""
import SomeChildren from ""./SomeChildren""
Vue.component(""some-children"", SomeChildren);

export default {}

// can use  <some-children />
```


<!-- generated by vue-issues. DO NOT REMOVE -->",,,jingle2008,"
--
Ran into exact same issue here, nice workaround!!!
--
",gregolai,"
--
Just learning Vue and struggling with this for the past few hours! Thanks for bringing it up!
--
",ywwhack,"
--
Here is another workaround, **it avoids global component**, but looks not pretty

```js
<template functional>
  <div>
    <component :is=""props.components.SomeChildren""></component>
  </div>
</template>

<script>
import SomeChildren from ""./SomeChildren.vue"";
export default {
  props: {
    components: {
      type: Object,
      default() {
        return {
          SomeChildren
        };
      }
    }
  }
};
</script>
```
--
",alexsasharegan,"
--
I think it's worth mentioning here that the error message is quite unintuitive. The `Unkown custom element` error bubbles up to the first instance component. If for some reason the feature for local functional component registration does not get implemented, at least add a dev warning that says something to the effect of `Invalid property ""components"" on functional component X`.

Also, as awkward as it is, registering the unknown component in the first parent instance component clears the error without polluting the global component name scope. It's a strange coupling of components though. Choose your hack for now I suppose.
--
",caikan,"
--
@ywwhack Your workaround is great! I made some improvements. We can use injections instead of props, so that props will not be polluted, and the code looks a little prettier.
```vue
<template functional>
  <div>
    <component :is=""injections.components.SomeChildren""></component>
  </div>
</template>

<script>
import SomeChildren from ""./SomeChildren.vue"";
export default {
  inject: {
    components: {
      default: {
        SomeChildren
      }
    }
  }
};
</script>
```
--
",darkylmnx,"
--
any update on implementing components option in functional components ?

The workarounds are good but that seems pretty hacky IMO especially when mentioning that `<component :is=""injections.components.SomeChildren""></component>` must be fore dynamic components and not for known components
--

--
Still no improvements on this till now?
I found a future-proof way to do it but still not happy with it:
```vue
<script>
import ChildComp from '@/components/ChildComp.vue';
export default {
  components: {
    ChildComp,
  },
};
</script>
<template>
  <component :is=""$options.components.ChildComp"" any-prop=""value"" />
</template>
```
--

--
Oh... I see.

Le jeu. 18 juin 2020 à 22:30, andreas <notifications@github.com> a écrit :

> @darkylmnx <https://github.com/darkylmnx> it's a #wontfix since Vue 3
> will make functional components irrelevant, as I understood.
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/vuejs/vue/issues/7492#issuecomment-646289731>, or
> unsubscribe
> <https://github.com/notifications/unsubscribe-auth/AAK4HNNSMXAU3KXBWHRMYKTRXJ2NNANCNFSM4EMWWNEA>
> .
>

--
"
7480,OPEN,Double value appear in textarea when using render function to create in .vue file.,browser quirks,2018-06-07 03:37:54 +0000 UTC,Fuji-sunny,Opened,,"### Version
2.5.13

### Reproduction link
[https://jsfiddle.net/SunnyLyu/ntoboxev/](https://jsfiddle.net/SunnyLyu/ntoboxev/)

### Steps to reproduce
1. sorry for things that it could not use .vue file definition in jsfiddle, please follow the steps below.

2. to create a textarea component like this: 

    export default {
        props: {
           value: {
              type: String
           }
        },
        render: function(h) {
  	    var _this = this;
            return h('textarea', {
               'on': {
                  'input': function(e){
                      _this.$emit('update:value', e.target.value);
                  }
               }
            }) 
         }
      };

3. import into a .vue file and use as a Vue component:
<!-- ta means the component defined above -->
<ta id=""main"" :value.sync=""msg""></ta>

4. run all these codes

### What is expected?
Type '1' in textarea once, a character '1' would appear in the textarea, in IE11.

### What is actually happening?
Type '1' in textarea once, 2 characters '11' would appear in the textarea at the same time, in IE11.

---
1. Just use the component definition in HTML, everything goes well in both IE and Chrome (like the example running in jsfiddle).

2. Once when using the definition in .vue file, after compiled would get wrong in IE11, but still ok in Safari and Chrome.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Fuji,"
--
Is there any progress ?
--

--
@jkzing 
I am still facing this problem so I push the reproduction code in here:
https://github.com/Fuji-sunny/vuerepo


My ie version is 11.0.9600.18738, hope the reproduction would help.
--

--
@jkzing 
Much thanks for your investigation ! 

In this scenario, I would like to use your solution. 
Hope that this would not happen in other situation. 
--

--
@jkzing 
Unfortunately here comes another problem.

Your solution works when adding text in the textarea, but when press backspace to omit text till no text in textarea, IE11 throws an error says something like ""arguments invalid"".

I've gone through into vue's code, when pass [this.value] to createElement, it won't cause this error. When pass this.value to createElement, it would go into setTextContent method. and node.wholeText is about this error.

Any other solutions or suggestions ?

ps. The same reproduction above: [https://github.com/Fuji-sunny/vuerepo](url)
--
",jkzing,"
--
Hi @Fuji-sunny, I am not able to reproduce your issue under IE 11 with following code:
```vue
<script>
export default {
  props: {
    value: {
      type: String
    }
  },
  render(h) {
    return h('textarea', {
      on: {
        input: e => {
          this.$emit('update:value', e.target.value)
        }
      }
    })
  }
}
</script>

<style>

</style>
```
![repro](https://user-images.githubusercontent.com/2851517/35316773-4ea2fa3e-010e-11e8-9cf1-d44e568a4fe7.gif)

---

If you are still facing this issue, I suggest you open a github repro, and upload your problematic code, and give the repo address back to us.
--

--
@Fuji-sunny just did some investigation on it and found you can get it work simply replace `[this.value]` with `this.value`

``` js
render(h) {
  return h('textarea', {
    on: {
      input: e => {
        this.$emit(""update:value"", e.target.value);
      }
    },
  }, this.value);
}
```
It's vue's patch mechanism which caused that, but the root cause is a different behavior in Chrome and IE11, see this fiddle: [https://jsfiddle.net/9fshvom1/2/](https://jsfiddle.net/9fshvom1/2/). I'm not sure if we need to do improvement on it or it's just a wontfix...😂
--
",,,,,,,,
7389,OPEN,[SSR] Support inline resource for specified files for server side rendering.,feature request,2019-08-29 06:27:46 +0000 UTC,JounQin,Opened,,"### What problem does this feature solve?
When we are using SSR with CommonsChunkPlugin, we often generate a `manifest.js` at the same time, but `manifest.js` is always very small (about 1kb).

Without SSR using `html-webpack-plugin` and its inline resource plugin, we are able to make `manifest.js` transformed inline into html file.

But for now we can not do for SSR that because the html output is generated by `vue-server-render` automatically.

### What does the proposed API look like?
```js
createBundleRenderer(bundle, {
  inlineResources: [] // string or RegExp
})
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,zengyuangai,"
--
请问什么时候可以使用 inlineResources？ 现在还是没有效果 是不是使用姿势不对？
--

--
@Justineo  好的 谢谢 有机会什么更新发吗？
你现在如何在ssr 情况下 inline resources？ 有什么好方案推荐？
--
",Justineo,"
--
这目前还只是一个 feature request。
--
",tansj526,"
--
这个功能现在有什么进展吗？或者有什么好的替代方案吗？
--
",,,,,,
7331,OPEN,Required inputs in child components are highlighted as invalid on render in Firefox.,browser quirks,2019-07-30 12:05:26 +0000 UTC,bryonf,Opened,,"### Version
2.5.13

### Reproduction link
[https://jsfiddle.net/50wL7mdz/85928/](https://jsfiddle.net/50wL7mdz/85928/)

### Steps to reproduce
No additional steps required. Opening the JSFiddle in Firefox should automatically cause the issue to display.

### What is expected?
Required inputs that are rendered in a child component without a valid default value should display normally.

### What is actually happening?
Unselected required inputs are being highlighted as though a submit attempt was made despite no user action being taken.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
It looks like Firefox highlights inputs as soon as you touch them using js (`input.value = ''`)
I imagine we could add a condition but I'm not sure if this is just a Firefox bug (https://bugzilla.mozilla.org/show_bug.cgi?id=1399046)
--
",EdToro74,"
--
I just ran into this issue too. For what its worth, Angular implemented the additional condition check @posva mentioned in order to work-around it. [Here's](https://github.com/ggershoni/angular.js/commit/cc311740c6b680c68a88c44fecd97ede1f18f831) their commit.
--
",Walkeryr,"
--
Temporary workaround is to dynamically build object for checked property. It wouldn't contain `checked` key on first render of the component, but it would have it after user interacted with inout. We can pass this object to `v-bind` directive.

For example:
```vue
<template>
<input type=""checkbox""
  required
  @change=""!this.checked""
  v-bind=""getCheckedState()"">
</template>

<script>
export default {
  data() {
    return {
      checked: null
    }
  },
  methods: {
    getCheckedState () {
      if (this.checked !== null) {
        return { checked: this.checked }
      }

      return {}
    }
  }
}
</script>
```
--
",,,,,,
7257,OPEN,Is Vue performing unnecessary re-render when using $listeners?,improvement,2019-11-21 03:59:49 +0000 UTC,sqal,Opened,,"### Version
2.5.11 (and earlier versions)

### Reproduction link
[https://jsfiddle.net/xb4172g8/](https://jsfiddle.net/xb4172g8/)

### Steps to reproduce
1. Open console and observe while typing something into input fields
2. Enter some text into name field -> Vue re-renders all three Textfield components
3. In line 21 replace `{ ...this.$listeners }` with an empty object
4. Once again enter some text into any field -> Vue re-renders only updated Textfield 

### What is expected?
Vue should re-render only the component whose props has changed.

### What is actually happening?
Using `$listeners` in component's render function causes the component to be rendered whenever its parent is updated even though his props hasn't changed.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
At the moment we always set `$listeners` when updating the parent, so yes, it triggers children updates if the use `$listeners` in the render function. Maybe this could be prevented by making sure the listeners have been updated before setting `$listeners` (https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js#L243)
--
",yyx990803,"
--
Unfortunately even if we do a shallowEqual check before setting `$listeners`, your specific example would still re-render because your `@input` listeners are created as a new anonymous function for each render, so technically they are different. This is similar to passing down a different anonymous function as prop on every render.
--
",cathrinevaage,"
--
Has there been made any plans to implement such a check?
--
",trickstival,"
--
Is there any workaround for this issue? I had to manually set up all listeners on a transparent wrapper, but it doesn't feel right. Actually, how is it going to work in Vue 3?
--
",houfeng0923,"
--
is only resolve this problem  like [vuetify](https://github.com/vuejs/vue/issues/10115#issuecomment-518503180)?

--
",,
7251,OPEN,Date Fields appear empty on first load when initialized with Vue,browser quirks,2020-04-06 00:01:49 +0000 UTC,bzarzuela,In progress,,"### Version
2.5.11

### Reproduction link
[https://jsfiddle.net/u1wssnwL/3/](https://jsfiddle.net/u1wssnwL/3/)

### Steps to reproduce
Create an input with a type date and initialize with any valid date value. 

View on Safari IOS and you'll see that it will appear as empty although the value is set because when you click the field, you'll see that the IOS datepicker will be set to the value you provided.

It only affects date inputs that have been initialized with Vue and in the JSFiddle provided, there are 2 date inputs for easier reproduction

### What is expected?
Both date inputs should have the same value

### What is actually happening?
The date input that was initialized with Vue appears empty

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
mmh, it looks like dynamically adding the element to the doc makes this behaviour appear:

```js
var i = document.createElement('input')
i.setAttribute('type', 'date')
i.setAttribute('value', '2017-07-07')
document.body.appendChild(i)
```

Not sure this is something we should workaround in Vue

For the moment you can use this workaround:

```js
<input type=""date"" :value.prop=""'2017-07-05'"">
```

this will set input's `value` with js

--

--
Keep in mind it breaks expected behaviour because Safari has a bug
If laravel comes with that convention, I imagine it's also possible to workaround there.

I'd like to give you some hints for a PR but I'm not sure where to add the workaround 😞 
--
",bzarzuela,"
--
Yes, thanks for that workaround, I ended up using Vue to initialize the form field in my project.

I think it's something that Vue should address because it breaks expected behavior. In my app, the entire page is a div with an ID of ""#app"" and because Vue is instantiated on that, it affects pages that don't use Vue. This convention is what Laravel comes out of the box with so I have a feeling other developers might be affected too.
--

--
I see. If this is a Safari bug, I don't think it has to be resolved in Vue. 

Maybe I can contribute a note in the documentation on this browser quirk instead? Not sure if this warrants an inclusion in the docs though. 
--
",mbardelmeijer,"
--
Ran into the same issue as well. As @bzarzuela mentioned as well, my app is also wrapped in a ""#app"" div. On page load the date field is empty, but a value is set. When setting is manually later of selecting another date the date is shown. When disabling Vue.js, it worked like expected.
--
",chrisonedata,"
--
Did anyone solve this yet? I have the same problem.
--
",,,,
7186,OPEN,Establish a standard way to document component and its props,discussion,2021-03-23 19:06:51 +0000 UTC,octref,In progress,,"### What problem does this feature solve?
https://github.com/vuejs/vetur/issues/276

Currently, Vetur offers auto-completion & hover info for custom components defined in ElementUI, OnsenUI and Bootstrap-Vue. However, hand-maintaining such json files seem to be a lot of work. Also not co-locating the doc and the component definition can make updating component challenging.

Helper-json repos at:

- https://github.com/ElementUI/element-helper-json
- https://www.npmjs.com/package/vue-onsenui-helper-json
- https://github.com/bootstrap-vue/bootstrap-vue-helper-json

This feature makes it possible to write the doc in the SFC / js component file, and auto-generate a helper json that can be used for enhancing editing experience or auto-generating API / doc website.

### What does the proposed API look like?
Two more optional attributes on the default export:

```js
export default {
  name: 'v-card',
  description: 'A card component',
  props: ['width', 'height'],
  propsDescription: [
    'width of the rendered card component',
    'height of the rendered card component'
  ]
}
```

I was thinking maybe using a custom block for it, but then that only applies to SFC, not js components. jsdoc might be another option.
Other ideas welcome.

Another idea is similar to the `typings` in package.json, have a `vueTypings` for component libraries. It'll point to the generated helper-json file and editors could pick it up to enhance editing experience.

/cc

@Leopoldthecoder for ElementUI
@masahirotanaka for OnsenUI
@pi0 for Bootstrap-Vue
@rstoenescu for Quasar
@johnleider for Vuetify

Would you be interested in using this feature in the Vue component libraries that you are maintaining? Would you be interested in helping spec'ing a format for the generated json file and the editing experiences that should be enabled by using that file?

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Wouldn't it be more interesting to add `description` to the props:

```js
props: {
     width: {
        type: Number,
         description: 'Width of the modal'
    }
}
```

Libs usually use the object syntax already

As long as it can be stripped off from build productions, I think it could be nice to add something like this. But maybe prepending those attributes with a special character could be even better, something like `'#description'` or `$description` to clearly make the distinction 
--

--
Is it possible to read comments with the language server? 😮 
--
",yyx990803,"
--
Does this have to be part of the component options / API? It seems they don't serve any particular purpose for Vue's own runtime behavior. In that case, would a comment-based syntax be more reasonable (as it is stripped by default)?

Using a component option would require extra toolchain changes to properly strip them.
--

--
@chrisvfritz SFCs only manipulate the options at runtime, so all the big description strings will be included in the  bundle and cannot be minified. They can only be dropped with a special babel plugin or hacked buble transform.
--
",pi0,"
--
Hey. For specific BootstrapVue we needed component typings from a long time ago. The first iteration was exactly using component's runtime instance to extract props and auto-generating documentation. Here is [componentdoc.vue](https://github.com/bootstrap-vue/bootstrap-vue/blob/dev/docs/components/componentdoc.vue#L62) implementation.

PROS:
- Doesn't adds any extra bytes to runtime
- General purpose and can be used to document any type of Vue components on the fly even at runtime. 
- Can be used for both SFCs and JS components.

CONS:
- Can not add any custom description for each prop (If we add additional `description` field to props it costs lots of unneeded runtime comments)
- Custom slots and events not supported

So we added a custom meta descriptor for components inside `package.json` which can be used for making a full set of docs and hintings. ([Example](https://github.com/bootstrap-vue/bootstrap-vue/blob/dev/src/components/table/package.json))

Both of above methods are both used for our nuxt based docs and also for [generate-vetur-helpers.js](https://github.com/bootstrap-vue/bootstrap-vue-helper-json/blob/master/scripts/generate-vetur-helpers.js) (Written by @alexsasharegan)

Maybe we can unify metadata structure which is used by BV, Onesen and Vuetify and hand-craft or auto-generate meta for any component library in either `package.json` or `vue.json` file.


**This way, just like any other part of Vue's ecosystem tooling can be delegated to library authors. We may also provide some helpers making the process easier and not forcing to use specific syntax like JSDocs.**

(`vue-xxx/package.json` or `vue-xxx/vue.json`)

```js
{
  ""vue"": {
     ""library"": true,
     ""components"": [
         {
             ""name"": ""b-table"" // Use for hinting of <b-table> tags
             ""props"": [  
                 {
                   name: ""title"",
                   type: ""Boolean"",
                   description: ""Table title""
                 }
             ],
          }
     ],
     directives: [
       // ....
     ]
  }
}
```

/CC @tmorehouse @egoist @mosinve @alexsasharegan
--

--
Something cool I've discovered so far is Project polymer's component [documentation spec](https://www.polymer-project.org/2.0/docs/tools/documentation).

They have a nice CLI which analyzes components JSDocs and extracting meta json:

```js
polymer analyze > analysis.json
```

Then using a similar component like our `ComponentDoc` we can use `iron-component-page` to visually render the docs. or exporting Via `package.json` for vue-language-server usage.


--

--
@tmorehouse According to @chrisvfritz idea we can still have both ES style builds and SFCs as the source with custom props. And stripping/extracting those comments using babel during build into meta.json.
--

--
Just as a summary to all of the nice comments until now, Something I think all of us agree on it is that we need a final **manifest** (Something like @demsking suggested) which can be used for both documentation and IDE hintings. The big questions are **where to declare typings** and **how to extract** it. SFCs seems the best place and we can put it inside:

- JSDocs / TS
- A new custom block
- Inline props (Which will be stripped out when production compiling)

And we've got some possible methods for extracting this manifest:

- Using `vue-language-server` to parse `.vue` files and extract the needed parts
- Adding support for `vue-loader` which can extract meta when loading SFCs
- Making an external CLI tool to do the job
- ~Manually Document Components~

But IMO if we enforce *any combination* of above methods, we are still forcing a toolchain and methodology for this task. What if we just agree on a standard manifest structure and let developers make and choose the best tooling? We can then **recommend** and add support for the best method which is probably `SFCs + vue-loader` or something else ...

PS: Sorry if talking a lot. I'm just little excited about this enhancement 😆 
--
",Akryum,"
--
It would be great t have vue-language-server parse the JSDoc inside the components 😄 
--
",chrisvfritz,"
--
@yyx990803 

> Does this have to be part of the component options / API? It seems they don't serve any particular purpose for Vue's own runtime behavior. In that case, would a comment-based syntax be more reasonable (as it is stripped by default)?

I disagree. I can imagine a lot of cases where Vue's warnings and devtools could be improved by this extra information. Here are [some examples](https://gist.github.com/chrisvfritz/c53eadb124dfbb69023ae3a3d2c2f1ca).

> Using a component option would require extra toolchain changes to properly strip them.

Yes, but I think the changes would be quite simple, since we're already manipulating the options exported from SFCs. It's possible there's a complexity I'm not realizing though, so please correct me if that's the case.

---
 
@pi0 I'd really like to avoid having to manage a separate types file, as I find these can fall out of date very quickly when their accuracy is not enforced by a compiler. Plus, remembering to check another file every time you want to update a component is pretty significant cognitive overhead.
--

--
@yyx990803 Thanks for clarifying. 🙂  I just did a little research to see how difficult a Babel plugin would be and much to my amazement, I accidentally created a [working proof-of-concept](https://gist.github.com/chrisvfritz/63055b655014d8a4f76f84ae4ce64e77)! 😄  I'm definitely not a Babel expert, so there could be issues with it, but it seemed to work on the 2 codebases I just tested it against without breaking anything. It could even be expanded to strip out other properties not needed in production, like `required` and `validator` for props.

Does this change your thoughts on feasibility at all?
--

--
> However, after thinking through this, I think JSDoc might be a better approach.
Either way, I can't have the runtime info easily so I need to parse the script myself and find the descriptions. The parser can be reused in the vue-template-compiler 2.0 redesign: vuejs/vue-component-compiler#28 (comment), where the descriptions go into descriptor.metadata or descriptor.descriptions.

@octref Just saw this comment. When you say you can't access this information easily, how difficult are you thinking it would be and is there any way I could help explore possibilities? I ask, because I'd personally prefer to avoid JSDoc. We already have some meta information as properties (like component name and prop types) and with comments, we'd lose the ability to use additional information in the Vue's warnings or devtools.

As for the custom block, it would solve the 2nd problem assuming Vue's template compiler could parse it into a JavaScript object, but there's still the issue of component meta information being fragmented (some included as a component option, some in a new custom tag). Some other things that bother me about it:

- If we use this information in Vue's warnings and devtools, we'll have made those dev features exclusive to SFCs, when they didn't really need to be. If we _don't_ make this meta information exclusive to SFCs, then Vetur would have to learn how to parse it anyway for people who chose not to use the custom block.
- From an education perspective, I'd personally prefer to avoid introducing a completely new concept in SFCs.
--

--
@octref I like the idea of tooling to create a manifest file! Then Vetur, eslint-plugin-vue, and other tooling would never have to worry about parsing that information themselves - but we still have it available for Vue's warnings and devtools. Best of all worlds. 🙂 

Having a separate tool like `vue-component-doc` might have some issues though, since having these properties in JavaScript means they could be runtime dependent (e.g. `description: myDynamicDescription()`). To solve this problem, I wonder if `vue-loader` could build a manifest file (or perhaps a manifest file per component) at runtime? If we stored these manifest files in a standardized location, then Vetur and other tools would be able to check that location for extra information. As an added bonus, the parsing would be agnostic to syntax (e.g. Babel, TypeScript, CoffeeScript, etc). @yyx990803 Is this remotely possible? 😄  What are your thoughts?
--

--
@tmorehouse It could be tricky for the Babel plugin to detect non-SFC Vue components, since files unrelated to Vue could export similarly-shaped JS objects. Also, functional components can now exist as `.vue` files as well, so there isn't really a reason not to use SFCs for any kind of component if you're using a build system (which you would be, if you're expecting a Babel plugin to strip out these properties in production).
--
",octref,"
--
@posva 
> Is it possible to read comments with the language server? 😮

It won't be easy, but it's possible, since TypeScript server supports analysis of JSDoc.

@pi0 
> So we added a custom meta descriptor for components inside package.json which can be used for making a full set of docs and hintings.

I agree with @chrisvfritz -- one of the strength of Vue SFC is a sensible way of organizing related information by colocating html/css/js. It'd be very un-vue-like to put this component specific information to some centralized place.

The idea is to make it possible to write components that's self-documenting, in the same spirit of JSDoc / JavaDoc / etc. This also helps reading Vue libraries' source code.

> https://www.polymer-project.org/2.0/docs/tools/documentation

👍  This is something we can look into & learn from.

@yyx990803 
> Does this have to be part of the component options / API? It seems they don't serve any particular purpose for Vue's own runtime behavior. In that case, would a comment-based syntax be more reasonable (as it is stripped by default)?

Doesn't have to be, and I agree it doesn't help runtime and would be a bloat for code size. It has to be compiled away at build time.
I think it's achievable through babel plugin though.

However, after thinking through this, I think JSDoc might be a better approach.
Either way, I can't have the runtime info easily so I need to parse the script myself and find the descriptions. The parser can be reused in the vue-template-compiler 2.0 redesign: https://github.com/vuejs/vue-component-compiler/issues/28#issuecomment-333139601, where the descriptions go into `descriptor.metadata` or `descriptor.descriptions`.

Another idea is to make this a custom block in SFC like so (chose yaml since it looks cleanest)

```
<script>
export default {
  name: 'v-card',
  props: ['width', 'height']
}
</script>

<description>
description: A card component
props:
  width: width of the rendered card component
  height: height of the rendered card component
</description>
```

For libraries that's using js components, they can convert to this format by putting their js file into a `<script>` tag and the extra description info into this custom tag. It can be compiled away in compile time. This also makes it super easy to extract the description data.

---

As I mentioned this info can be used by Vetur, component doc generator, etc for better DX, but it can go beyond that. One example is ElementUI's `subtags`:

https://github.com/ElementUI/element-helper-json/blob/master/element-tags.json#L4
```json
{
  ""el-row"": {
    ""attributes"": [""gutter"", ""type"", ""justify"", ""align"", ""tag""],
    ""subtags"": [""el-col""],
    ""description"": ""A row in grid system""
  }
}
```

We can just use this info to enhance `eslint-plugin-vue` to warn the user, but we can do runtime check too.


--

--
@chrisvfritz I was thinking along the line of using TypeScript to extract the data and use it to supplement the html completion, but actually it doesn't have to be this way.

We can:
1. Have one independent tool that takes commands such as `vue-component-doc ./src/**/*.vue`
2. The tool generates a manifest file
3. User edit vue files to add documentation
4. manifest file is regenerated
5. Vetur reloads the manifest file to enhance html editing

Task 1 and 2 should exist independent of Vetur, so they can also be used for other tools.
--

--
I made a proposal: https://github.com/octref/vuetypes. Feedback welcome!

My proposal is only about the ""JSON format"" and the ""Editor Behavior"" part. I don't know how each library is building the current helper json files for Vetur, so I hope I can get some feedback from @alexsasharegan @rstoenescu @asial-matagawa @jtommy @QingWei-Li @nekosaur.

Also, would any of you be interested in collaborating with me to build the JSON of this new format for your library? We can add documentation to your library's source code & work on the tool to extract the metadata into a JSON. I can do most of the work, but I probably would need help from the library authors.

There are still open questions as to where & how to author the data. @leopiccionia has a point: If 10 components all have the `width` attribute, it feels messy to have 10 descriptions scattered in 10 Vue files.


--

--
There are 3 things:

1. How / Where to write the typing data in source code
2. How to store & distribute the data
3. What the data should look like & what editor should do based on the data

For 1, continue the discussion here. For 2/3, open issues at https://github.com/octref/vuetypes,
--

--
@alexsasharegan That is about topic 2. I should have made it more explicit — topic 1 is how / where to write the data in your source code (JSDocs,  fields of default export, custom block, etc).
--

--
@elevatebart [vue-docgen-api](https://github.com/vue-styleguidist/vue-styleguidist/tree/dev/packages/vue-docgen-api) seems pretty good. Would you be interested in working together to define a spec / JSON format?

Meanwhile I'm also working on https://github.com/microsoft/vscode-custom-data that allows you to declaratively define data to enhance HTML/CSS language servers. I think for Vue, there would be two different specs for two different use cases:

- A spec by which Vetur loads extra HTML tags, CSS properties, etc, this spec should be close to https://github.com/microsoft/vscode-custom-data. For example, for a Vue component `<foo :prop1>`, the custom data for it should include a tag `foo` and a list of props `[""prop1""]`. Vetur would then complete `foo` at `<|` and `prop1` at `<foo :`. Vetur issue here: https://github.com/vuejs/vetur/issues/1364.
- A spec which [vue-docgen-api](https://github.com/vue-styleguidist/vue-styleguidist/tree/dev/packages/vue-docgen-api), Vue Language Server, etc could generate. This is essentially the AST of a Vue component with some metadata (such as JSDocs). Other than doc generation, this can be used for static analysis as well (for example calculating the dependency tree between Vue components).
--

--
My feedback for `web-types` is:
- There's no clean separation between metadata specific to Vue and the data format needed to drive LSP methods (such as completion, hover).
- It's unclear to me what data is used in what editor features, and it seems all the features are Jetbrains product specific. The custom data for VS Code can be loaded in [vscode-html-langaugeservice](https://github.com/Microsoft/vscode-html-languageservice) and [vscode-css-languageservice](https://github.com/Microsoft/vscode-css-languageservice) (you can build your own language support using these libraries), and the transformation from data => LSP methods are done in a transparent way. 

> VSCode solutions for supporting libraries and each of them requires installing some plugin

This was not the case until [Jan 2019](https://code.visualstudio.com/updates/v1_31#_html-and-css-custom-data-support) when we bundled custom data format into VS Code, and we marked it as stable [last month](https://code.visualstudio.com/updates/v1_38#_custom-data-marked-as-stable).
--
"
7139,OPEN,shouldPrefetch enhancement,feature request,2019-11-19 08:09:36 +0000 UTC,FranckFreiburger,In progress,,"### What problem does this feature solve?
Currently, I use
`import(/* webpackChunkName: ""lang-[request]"" */ json!yaml!./myForm.lang.${currentLocale}.yaml)`
to load the appropriate translation for my components.

This generates `numberOfForms * numberOfLangages` chunks that are prefetched when the application starts.

I would like to load only translations for the current language.

`shouldPrefetch(file, type)` gives
```
0.js script
1.js script
2.js script
...
```
There is not enough information to filter files that should not been prefetched.

### What does the proposed API look like?
I don't know what are the available information at `shouldPrefetch`.
But probably API should look like:
`shouldPrefetch(file, type, originalFilename)`

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
FYI `shouldPreload` has the same parameters as `shouldPrefetch` : https://ssr.vuejs.org/en/api.html#shouldpreload
--
",FranckFreiburger,"
--
I also need to prefetch only files related to the current user's langage.
User's langage is stored (server-side) in the application i18n.locale.
`shouldPrefetch()` should also expose the application that is currently server-side rendering (or at least its context).
--

--
ping !
--
",wxsms,"
--
Agree. `file` param of `shouldPrefetch` and `shouldPreload` are too hard to use.

I'm a user of vuepress, it make's me very difficult to decide which pages to prefetch while number of pages growing fast. Although with this option provided, but it's just like a simple boolean value: 'prefetch everything' or 'prefetch nothing'.

Hopefuly there will be any enhencements. Thanks!
--
",,,,,,
7136,OPEN,Issues with v-model.number,discussion,2018-08-06 09:48:54 +0000 UTC,printercu,In progress,,"### Version
2.5.8

### Reproduction link
[https://jsfiddle.net/50wL7mdz/79189/](https://jsfiddle.net/50wL7mdz/79189/)

### Steps to reproduce
Included in fiddle

### What is expected?
Input type='number' should  not clear values, accept stings formatted in different locales. v-model.number should not return string.

### What is actually happening?
Input value is cleared sometimes, v-model.number returns """" for """" and partially typed numbers.

---
This issue started with topic on forum https://forum.vuejs.org/t/extra-directive-for-number-inputs/22438, it was suggested to open an issue for that. Here is original post:

Hi!

I've found that `v-model.number` has limitations and requires some boilerplate in some cases. This is mostly because `input[type=""number""]` returns `''` for partially input numbers (like `1.`). Here are some problems with it:

- App has no difference when input is either empty or invalid/partial.
- Bound attribute has to be of `[String, Number]` type.
- `''`, `undefined`, and `0` are falsy values. This leads to `val !== ''` checks in all places this attribute is used.

2nd and 3d issues can be solved with computed property, but it's hard to implement for nested ones and array of values.

I came to using separate field for casted values: 

```
<input
  type='number' 
  v-model='obj.val' 
  @input='$set(obj, ""valCasted"", _nOrNull($event.target.value))'
/>
```

I wanted to it implement with custom directive (like `v-model-number='obj.valCasted'`), but I see that `v-model` is handled differently by compiler. This way it can automatically use `$set` when property is not defined on object. But I have not found how this  can be implemented with custom directives.

 So here are questions :)  :

- Is there a better way to work with `input[type=""number""]`?
If not:
- Can this be implemented with custom directives as convenient as `v-model` is?
- Should this be added to vue?

-----

After that post I've tried to implement custom component, it's included in fiddle, but it also has some issues.
I've also added different types of inputs to fiddle to check their behaviour and checked against different locales.

Thank you!

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
The number becoming 1 is expected as that's what happens in js, they're the same numbers after all. If you need the zeros, you want a string, not a number. **but it happens when the user changes focus** which is IMO the ux you want here.

About localization, it's handled by the browser and it's out of vue scope. It's the browser that makes some syntaxes work differently on different computers

About your custom component, it behaves how you told it to behave, it modifies the value and adapt it to either `null` or the number. The part that may be confusing is that you change it to null when it's not valid, doing backspace changes it back to a valid number and triggers a re render, which is why it changes on the input as well

cc @LinusBorg What was the part that you thought we might improve?
--

--
> but I think it should not clear them when changing 1.001 to 1.002.

That only happens with the custom input. The explanation is here:

> The part that may be confusing is that you change it to null when it's not valid, doing backspace changes it back to a valid number and triggers a re render, which is why it changes on the input as well

v-model.number will cast values to Number or empty string, but you're of course free to create your own custom component that handles things differently using or not the `number` modifier
--

--
It does not happen with 1), or I'm not getting the instructions(typing 1.0000.0, then backspace x2).

> it also requires val != null && val !== '' in every place it's used.

No, it does not. It's either a number or `''` no null. In your example, it's null because that's the initial value you're giving to it
Vue's job here is to link the value of the input to the state and make it a number whenever possible because of the `number` modifier.
The empty string is actually very useful because it allows you know if the input contains a valid number, it makes it flexible to use in different scenarios
--

--
Your example is completely different: the value is not initialized, it's as if you explicitly set it to undefined. Checking if an input is _dirty_ or not is yet, another different thing, unrelated to numbers

> I'm not sure it's useful at all, because there is same value for empty string and for invalid value. In locales with , delimiter 1. is invalid (returns '') but 1.2 is valid and returns 1.2. So empty string has ambiguous, very different meanings.

That's the browser setting it to an empty string... Number validation is out of Vue scope

Anyway, just waiting for @LinusBorg input on what could be improved
--
",printercu,"
--
Thanks for feedback!

I've included plain `input[type=number]` to fiddle to check it's behaviour in this cases. You can see that it does not clear trailing zeroes at all. Actually I also don't see a problem in stripping trailing zeroes on blur, but I think it should not clear them when changing 1.001 to 1.002. It's the 1) and 4) cases in fiddle.

Original post was more about how to make `v-model.number` to cast values to Number|null but not Number|String as it is now. I've made some proposal but it's not clear for me how to implement it. As I understood, Linus said that it may be good if vue provide this feature itself. Please check 'Here is original post: Hi! I've found that... ' in first comment for more info.
--

--
For now I don't see how it can be done without having 2 separate fields: 1 - string to keep `input[type=number]` fine, and 2 - numeric for app. Is it possible somehow to prevent rerender of input on `input` event? I think this could solve all the issues.
--

--
> That only happens with the custom input

Not only, see 1) case in fiddle (fill 1st input with 1.0000.0 ...), though it's for malformed value.

>  but you're of course free to create

So is it not interesting to vue team to provide more type-strict interface? It's error prone and such errors are easy to leave, because there are no exceptions on misuse. Also to check that input is empty it's not enough to `val != null` but it also requires `val != null && val !== '' ` in every place it's used.
--

--
> No, it does not.

Here is example: https://jsfiddle.net/hbov4mmr/8/
Checks `item.value != null && item.value !== ''` are repeated 3 times.

> The empty string is actually very useful

I'm not sure it's useful at all, because there is same value for empty string and for invalid value. In locales with `,` delimiter `1.` is invalid (returns '') but `1.2` is valid and returns `1.2`. So empty string has ambiguous, very different meanings.
--

--
Once again, this all is not about checking if an input is dirty, but about providing more solid and type-strict interface: if it returns numbers it should not return empty string or any other string. Returning empty string now is just a workaround, and i think it can be fixed.

Can we please treat it more as feature request and ask few more maintainers look at it.

I also wonder why I can not implement `v-model.number` in ""user-space"": https://jsfiddle.net/rubx2fcb/1/ Here I took all the code from internals (https://github.com/vuejs/vue/blob/dev/src/platforms/web/compiler/directives/model.js) but it still does not allow to input `1.0` into this input. Am I missing something?

UPD. I was checking in chrome. In safari It allows to input `1.0` or `1,0` but clears trailing zeroes when removing last digit in `1.0001`. FF does not respect OS locale settings and ignores `1,23` formatted numbers, while still has issue with removing last digit in `1.0001`.
--

--
@lbogdan Looks great! Thank you! I've slightly changed and it also works with `null` instead of `NaN`: https://codesandbox.io/embed/4wk0k64yw0. I will give it a try in the app soon.

Can you please help with (from my previous comment):

> I also wonder why I can not implement v-model.number in ""user-space"": https://jsfiddle.net/rubx2fcb/1/ Here I took all the code from internals (https://github.com/vuejs/vue/blob/dev/src/platforms/web/compiler/directives/model.js) but it still does not allow to input 1.0 into this input. Am I missing something?
--
",lbogdan,"
--
@printercu Here's a try at making a numeric input component: https://codesandbox.io/embed/2wrqj87q0y?module=%2FApp.vue . It uses `NaN` as the empty /  not valid value. The only issue it has is that if you typed an invalid number, you can't clear it by setting the `v-model` value to `NaN`, as it can't distinguish between empty and not valid.
--
",,,,,,
7081,OPEN,Quadratic memory usage,improvement,2017-12-18 16:43:07 +0000 UTC,eugene-daragan-codex,Opened,,"### Version
2.5.4

### Reproduction link
[https://codepen.io/anon/pen/KyyxKB?editors=1010](https://codepen.io/anon/pen/KyyxKB?editors=1010)

### Steps to reproduce
1. Open browser devtools
2. Launch reproduction with different MAX variable (100, 200, 500, 1000, 1500, 2000, 4000)
3. Note that memory usage growth quadratically with the MAX variable, while number of computed properties and their implied dependencies in the program is proportional to the MAX variable.

### What is expected?
Expected linear (i.e. proportional) growth of memory consumption with growth of MAX variable

### What is actually happening?
All `data_X` observables have all `computed_X` computed values as their subscribers, so total number of subscriptions growth quadratically.

---
It's quite hard to write a code that would really affect users with the bug, but anyway it feels like a flaw in reactive system design.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,HerringtonDarkholme,"
--
After some investigation, I wonder if this usage worth a major redesign in reactive system.

 Vue has two reactive components under hood, `Watcher` and `Dep`. They are quite like `Output` and `Input`: `Watcher` will execute callback when `Dep` changes. The problem is there is no such component acting like `pipe`: both executes callback and notifies watchers. 

> All observables have all computed values as their subscribers

This is how we mock `pipe` with only watcher and dep. To optimize memory usage, we probably need a new reactive component like `Rx` in https://github.com/lihaoyi/scala.rx . 

However, that new class might only optimize limited usage. As OP has already stated:

> It's quite hard to write a code that would really affect users with the bug
--
",,,,,,,,,,
7005,OPEN,Create a package for building custom renderers,feature request; intend to implement,2020-09-29 16:36:35 +0000 UTC,rigor789,In progress,,"### What problem does this feature solve?
As the author of nativescript-vue I had to set up a similar build setup as Vue's in order to be able to import certain parts of Vue directly into nativescript-vue. The main source of issues was the aliases used across the Vue repository (which do make sense btw!). 

To solve that issue, I would love to have an official package for creating (and registering) custom renderers into Vue, which would enclose most of the Vue specific logic of patching / hydrating etc.

A good example of what I have in mind would be the react's package that does it: https://github.com/facebook/react/tree/master/packages/react-reconciler

I would love to get some work done on this, but I'd work with the core team to make sure the best possible quality.



### What does the proposed API look like?
```js
// my custom renderer
// for example: nativescript-vue.js
import VueRenderer from 'vue-renderer'

// a class for creating native views in NativeScript
import ViewUtils from './ViewUtils.js'

export default new VueRenderer({
  // Node operations
  createElement(tagName) {},
  createElementNS(namespace, tagName) {},
  createTextNode(text) {},
  createComment(text) {},
  insertBefore(parentNode, newNode, referenceNode) {},
  removeChild(node, child) {},
  appendChild(node, child) {},
  parentNode(node) {},
  nextSibling(node) {},
  tagName(node) {},
  setTextContent(node, text) {},
  setAttribute(node, attribute, value) {},

  // Additional methods that need to be specified
  // but for example:
  createRoot() {} // this would get called to create the root element for the root Vue instance
})
```

```js
// then in userland we could just do
import Vue from 'vue'
import NativescriptVue from 'nativescript-vue'

Vue.use(NativescriptVue)


new Vue({
  render(h) => h('label', { text: 'Hello World' })
})
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yyx990803,"
--
This is something I've had in mind for a while - definitely something valuable to have. And thanks for the suggested API design.
--
",altitudems,"
--
It seems to me this is pretty important for the future of Vue. 

Any chance it can be added somewhere into the official roadmap? Even if its just in the backlog?
https://github.com/vuejs/roadmap

Consider also that React and Angular already have this.

For example take a look at this list of React custom renderers:
http://iamdustan.com/react-renderers/
--
",Aaron,"
--
Any updates here? Been nearly six months since it's gotten any love from a Vue contributor.
--
",amritk,"
--
@Aaron-Pool looks like its coming in Vue 3.0
--
",LukeeeeBennett,"
--
> @Aaron-Pool looks like its coming in Vue 3.0

If it's coming in 3.0 is there existing progress?
--
",moritzruth,"
--
@yyx990803 Will this be possible with Vue.js 3?
--
"
6929,OPEN,<input> rerenders while changes affects only sibling elements,bug; has workaround,2020-03-01 20:20:53 +0000 UTC,kamax1,In progress,,"### Version
2.5.2

### Reproduction link
[https://codepen.io/anon/pen/OxKqbL?editors=1111](https://codepen.io/anon/pen/OxKqbL?editors=1111)

### Steps to reproduce
Please open codepen example and type something into input

### What is expected?
Input should not lose focus

### What is actually happening?
input rerenders and loses focus

---
happens only if there is such conditional elements exists before and after input. Workaround is to use v-show instead of v-if in such cases.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yyx990803,"
--
You can also simply give the `<input>` a key to ensure it is not replaced.
--
",kamax1,"
--
i tried your solution in codepen and still cant get it working.

i tried this
`<input type=""text"" v-model=""inputVal"" :key=""1"">`
--
",IlyaOsotov,"
--
U need to have same DOM structure before your input. Look [this](https://codepen.io/IlyaOsotov/pen/qVNMzr). It can be after update your DOM before your input tag 
--
",icese7en,"
--
Actually, it is the same input element, but first remove from the document then move it to other places, for example: 

it first renders like

``` HTML
 <!----> // A
<input />
 <!----> // B
```

then you focus input and input some words, then virtual dom insert `<span>before</span>`, and it then parent.insertBefore(input, A), it moves the input element before the A comment element, so it will eventually lose focus, then it will delete the comment node.

so, I think you could use v-show better to avoid the insertBefore move problem(remove from the document then insert before the reference node, in this case, which is comment A ). This is the default action for virtual dom of vue which doesn't replace comment node. 
--
",znck,"
--
> You can also simply give the `<input>` a key to ensure it is not replaced.

`<input>` element focus is lost in either case.
--
",Kingwl,"
--
https://github.com/google/incremental-dom/issues/237  
seems like this one
--

--
I have tried to fix this issue  
But I encountered some problem 
have we got some way to access vnode from html element?  
I want to get vnode path as https://github.com/google/incremental-dom/issues/237  
But I did not find a good way to do that  
have i missing something? or have other better solution?😅
  
--
"
6914,OPEN,Request: add v-model.lazy for components,feature request; has PR,2020-10-08 13:11:02 +0000 UTC,pdanpdan,Opened,,"### What problem does this feature solve?
v-model for components already supports .trim and .number.
Lazy modifier support for components would make it more uniform across the platform.

### What does the proposed API look like?
The only change (backwards compatible) would be to add a new property to model definition:
```
model: {
  prop: 'value',
  event: 'input',
  eventLazy: 'change'
}
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Mikilll94,"
--
Is it going to be done?
--

--
yeah, exactly. I have an app made with Vuetify and on larger forms instead of using v-model I am typing
`:value=""sth"" @change=""($event) => sth = $event.target.value""`

It would be nicer to type just
`v-model.lazy = ""sth""`
--
",iec989,"
--
I think a bunch of us are desperately waiting for this; mid-size forms get very slow as soon as you implement some basic VUE logic around the components, we really need this!
--
",wc,"
--
I would love to have it as well!
--
",mrcnk,"
--
Also custom rules for Vuelidate need sometimes `v-model.lazy`, so it'd be useful not to introduce workarounds for it 🙌
--
",Tantawi,"
--
Please add this!
--
",danielbonifacio,"
--
Waiting for it! Would be a great enhance on productivity 😄 
--
"
6901,OPEN,TypeScript: add Props type to component constructor,improvement; typescript,2017-10-25 09:02:23 +0000 UTC,wonderful-panda,Opened,,"### What problem does this feature solve?
It would be useful if we can infer Props type from component (`ExtendedVue`).

For example, we can write type safe wrapper of `CreateElement` with it (or improve interface of `CreateElement` directly).

```typescript
function renderComponent<Props>(
        h: CreateElement,
        component: ExtendedVue<Vue, {}, {}, {}, Props>,
        data: VNodeData & { props: Partial<Props> },
        children?: VNodeChildren): VNode {
  return h(component, data, children);
}

const MyComponent = Vue.extend({
  props: { foo: String },
  render(h) { return h(""div"", this.foo) };
});

const Parent = Vue.extend({
  render(h) {
    return renderComponent(h, MyComponent, { props: { foo: 0 } }); // error: type of property 'foo' are imcompatible
  }
});

``` 


### What does the proposed API look like?
Now, `ExtendedVue<Vue, {}, {}, {}, { foo: string }>` and `ExtendedVue<Vue, {}, {}, { foo: string }, {}>` generate same type.

This means we can't determine `Props` type from `ExtendedVue` object.

I think, easiest (and most reasonable) way to achieve this is adding types to `$props` and `$data`

```diff
- export type CombinedVueInstance<Instance extends Vue, Data, Methods, Computed, Props> = Instance & Data & Methods & Computed & Props;
+ export type CombinedVueInstance<Instance extends Vue, Data, Methods, Computed, Props> = Instance & Data & Methods & Computed & Props & { $data: Data, $props: Props };
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,HerringtonDarkholme,"
--
Actually we can do better here. By changing `Vue` to a generic type constructor (with default so no breaking change), we can encode `Vue.extend` to return a constructor with `$props` and `$data` typed. Plus, typed JSX will be enabled.

But this will make our complex typing file more complicated. Let's first make Vue2.5 stable and wait for more feedback.

If you like this idea, please vote by emoji!

cc @ktsn @yyx990803 @octref @kaorun343 
--

--
> current typing loses the information about each props are required or optional

Fairly I don't think we can make a typing for current API, at least current TS' type system does not support it.

[Example](http://www.typescriptlang.org/play/#src=type%20Class%3CT%3E%20%3D%20%7B%20new(...args%3A%20any%5B%5D)%3A%20T%20%7D%0Atype%20Required%3CT%3E%20%3D%20%7B%0A%20%20%20%20%5BK%20in%20keyof%20T%5D%3A%20%7B%20type%3A%20Class%3CT%5BK%5D%3E%2C%20required%3A%20true%20%7D%0A%7D%0Atype%20Optional%3CT%3E%20%3D%20%7B%0A%20%20%20%20%5BK%20in%20keyof%20T%5D%3A%20%7B%20type%3A%20Class%3CT%3E%20%7D%0A%7D%0A%0Adeclare%20function%20test%3CU%2C%20V%3E(opt%3A%20Required%3CU%3E%20%26%20Optional%3CV%3E)%3A%20U%20%26%20V%0Atest(%7B%0A%20%20%20%20foo%3A%20%7B%0A%20%20%20%20%20%20%20type%3A%20String%0A%20%20%20%20%7D%2C%0A%20%20%20%20bar%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20Number%2C%0A%20%20%20%20%20%20%20%20required%3A%20true%0A%20%20%20%20%7D%0A%7D))
--
",wonderful,"
--
Sounds nice.
Above all, it would be very nice if vue supports typed JSX by default.
(I have a small [library](https://github.com/wonderful-panda/vue-tsx-support) to add types to component for typed JSX. AAMOF, this issue comes from it.)

BTW, current typing loses the information about each props are required or optional, which is necessary for typed JSX.
--

--
How about an approach like below ?

![image](https://user-images.githubusercontent.com/1205852/31987066-960d5672-b9a5-11e7-8049-2c3ede9b5bb1.png)

(It works, but type definitions will become more complicated ...)

--

--
@blake-newman
It may be impossible to obtain requiredProps from props at compile time.

In above example, type of `repuiredProps` is `(""foo""|""bar"")[]`
--
",blake,"
--
I have been using library mentioned, I think first step we can do is make all props optional when using TSX with Partial, unless passing a declared interface. 

It will then be an enhancement when TS does support it. I think we should also create a TS issue to make awareness of this requirement linking back to this issue. 

I do believe we should support typed TSX out of the box with props inferred. Unfortunately but ultimately great Vue API also has more custom attributes to TSX such as scoped slots and events that we need to cater for. So interfaces will still be required as far as I can see. However where possible we should reduce the needed typing especially where duplication occurs, such as prop definitions. 


--

--
@wonderful-panda we could form requiredProps from props object no?
--

--
Yes sorry forgot about that
--
",,,,,,
6895,OPEN,Functional components data merging util,feature request,2017-11-20 06:05:55 +0000 UTC,miljan-aleksic,Opened,,"### What problem does this feature solve?
Hi! Components have the extend feature, but there is nothing similar for functional components. The problem and the solution is well explained at https://github.com/alexsasharegan/vue-functional-data-merge and while that works fine and I am very grateful to the author, I would like to request an official in core solution.

Why? Because there are edge situations or new features that 3rd party solutions will have a difficult time to be on top.

### What does the proposed API look like?
Similar as done by @alexsasharegan

<!-- generated by vue-issues. DO NOT REMOVE -->",,,wxsms,"
--
+1 I thinks this is necessary for all users of functional components. Otherwise it can hardly work as expect.
--
",,,,,,,,,,
6877,OPEN,"Mouse button modifiers for ""v-on"" should have more precise aliases",feature request; has PR,2018-03-11 15:55:00 +0000 UTC,st-sloth,Opened,,"### What problem does this feature solve?
Currently mouse button modifiers, introduced in #4866, are `left`, `middle`, `right` for `$event.button` values `0`, `1`, `2` correspondingly. But that is only correct for the ""default"" right-handed layout. In the left-handed mode (when the buttons are switched in the OS) the right button has `0` value and the left button - `2`. Besides, also some right-handed users may reverse or remap the mouse buttons. And working with code with these names for mouse buttons may lead to confusion and bugs among developers not familiar with the ""default"" right-handed mode being the target for these modifiers.

### What does the proposed API look like?
Keep `left` and `right` as deprecated and add `main` and `secondary` as their aliases.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,st,"
--
I am currently working on it. What names should the modifiers really have?

1. Since the ""mouse"" modifiers for `left` and `right` have already clashed with keyboard modifiers `left` and `right` (#5046, #5060), and to avoid such future name issues, should we perhaps include something pointer device / mouse related like `ptrMain`? Introducing two-word modifiers doesn't seem like a good idea though because of all the case related stuff.
2. What should the main signifiers be?
  * for 0 (now `left`) - `main` / `primary` / your suggestions
  * for 1 (now `middle`) - `aux` (but might be confusing since `auxclick` [is fired for all the mouse buttons except the primary one](https://developers.google.com/web/updates/2016/10/auxclick)) / your suggestions
  * for 2 (now `right`) - `secondary` / your suggestions
  
Previous names `left`, `right`, `middle` of course are kept but deprecated with warnings.
--

--
The discussion kinda moved to the pull request, and [Evan okayed the naming](https://github.com/vuejs/vue/pull/7069#issuecomment-344938670).
--
",dsbert,"
--
If using `primary` and `secondary`, then `tertiary` would be the consistent name for the third, typically middle, button.
--
",,,,,,,,
6874,OPEN,Alert (possibly fix) SSR Mismatch in Production,improvement,2020-04-22 20:57:55 +0000 UTC,Austio,In progress,,"### What problem does this feature solve?
Currently there is no way to receive alerts (and possibly rerender) in production concerning SSR vs VDom mismatch.  

This is critical because different browsers will handle this in unexpected ways.  For instance, I just finished trouleshooting an issue that is specific to Windows 10 and IE11 where a rendered vdom tree does not match ssr rendered html and causes a white screen.  Chrome and other browsers were able to recover. The mismatch renders fine when navigating to this from an already rendered vue. Just not when the initial rendering happens with a specific page.

Discussion in forum.  
https://forum.vuejs.org/t/ssr-render-mismatch-error-emit-in-production/20083

### What does the proposed API look like?
I think the bulk of code currently lives here.

https://github.com/vuejs/vue/blob/adff0084e1b7bc4b8ffa2b87390c66afbc435582/src/core/vdom/patch.js#L662

I think during initial ssr render we need more granular flags to opt in to alerts on this behavior.  Currently it is only NODE_ENV 

Initial (maybe too verbose) thoughts would be.
  WARN_ON_SSR_MISMATCH
  RECOVER_ON_SSR_MISMATCH
  
Then if those are true we can change behavior.

I understand that this is performance critical so am very open to suggestions.  I would be willing to implement this myself in a PR.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,yyx990803,"
--
Please provide a reproduction of failed recovery (white screen) in IE11.
--
",Austio,"
--
@yyx990803 was able to boil this down on another issue we were running into with Safari 8.1

https://github.com/Austio/vue-hackernews-2.0/pull/1
--

--
@yyx990803 , appears this was a bug in safari's sort function and/or type coersion.

```
// node/chrome/etc returns what you would expect from looking at this
> [null, true, true].sort((a,b) => a < b)
[ true, true, null ]

// safari, does not
> [null, true, true].sort(function(a,b){ return a < b })
[null, true, true] 
```

Switching to using the -1,0,1 comparitor function renders properly.
--

--
Still would like to see if it makes sense to have a way to detect this in production.  Would be very helpful, i think I would rather have the development behavior in production for re-rendering if there is invalid markup in order to prevent white screens
--

--
@yyx990803 bumping on this to get thoughts on this subject or how to approach.  Also am happy to make a PR to allow this check to happen while in production.  When this has happened to us, it is a hard failure which results in a white screen and no content rendered

Today it was on mobile safari 11 on ios8.  When i wrap the span in a no-ssr component (which only renders during mount cycle) everything renders fine.

According to the HTML li spec, it allows flow content inside of it, which are all of the contained nodes https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Flow_content

```
  <li
    data-test-location-list-item
  >
    <small class=""editlinks"" v-if=""profileEditable"">
      <router-link
        :to=""{ name: 'profiles-locations-edit', params: { profileUUID: this.profileUUID, locationUUID: this.id} }""
      >
        <i class=""icon-pencil""></i>
      </router-link>
    </small>
    <strong v-if='primary'>Office</strong>
    <vg-no-ssr>
      <span class=""br contacts"">
        <a
        v-if=""hasGoogleMapLink""
        target=""_blank""
        :href=""googleMapLink"">
          {{ address_1 }}<br>
          {{ address_2 }}<br v-if='address_2'>
          {{ city_state_zip_country }}<br>
          <template v-if='phone_number'>
            <span class='clabel'>Phone</span>
            {{ phone_number }}
            <span v-if='phone_number_extension'>x</span>
            {{ phone_number_extension }}
            <br>
          </template>
          <span class='clabel' v-if='fax_number'>Fax</span>
          {{ fax_number }}
        </a>
      </span>
    </vg-no-ssr>
  </li>
```
--

--
@yyx990803 Bump, any thoughts on this.  Still happy to make a PR on this if the approach recommended is something that would be ok in light of your view of where SSR and Vue should head.  

Ultimate goal: When there is a ""White screen"" event in production, provide a way for the client to signal that they want a complete re-render instead of hard white screen.
--
",Tazer,"
--
Would be awesome , cause we also have problems sometimes with whitescreeen / node append errors (only in production), so it would be really nice to be able to see WHY in Production.
--
",aaronransley,"
--
Also curious about configuring this behavior in production. It would be ideal to allow the client to rebuild DOM best it can if there is a node mismatch (current dev mode behavior, as far as I know), rather than throwing a hard exception and aborting the render.
--
",,,,
6872,OPEN,Asset support for functional components,feature request; has PR; improvement; intend to implement,2019-06-22 05:51:27 +0000 UTC,gabriel4649,Opened,,"### What problem does this feature solve?
Functional components with templates allow users to improve performance without sacrificing readability or ease of use. However, currently these do not support the ""components"" option. This limits this feature a lot, to a very limited set of use cases. 

### What does the proposed API look like?
Simply support the components option just like non-functional components

<!-- generated by vue-issues. DO NOT REMOVE -->",,,c01nd01r,"
--
Also, how to call methods and emit events in functional components with templates?
--

--
Yes, @scottbedard, thank you. I know about this, but I can't do it in a ""functional"" html template.
```vue
<template functional>
  <div>
    <button @click=""$emit('click')"">Emit click</button> <!-- error -->
    <button @click=""logClick"">Log click</button> <!-- ??? -->
  </div>
</template>

<script>
  import { logClick } from 'logg';
</script>
```
--
",posva,"
--
You cannot, you use a regular component if you need that
--
",scottbedard,"
--
Support for local directives would be awesome!

And @c01nd01r if you need to respond to an action, you can use plain old functions

```js
// event handler
function onClick(context, e) {
    console.log('you clicked the div');

    // to emit an event, look at the listeners in your context
    if (context.listeners.click) {
        context.listeners.click(e);
    }
}

// component
export default {
    functional: true,
    render(h, context) {
        return <div onClick={e => onClick(context, e)}>click me</div>;
    },
};
```
--

--
Yea, that would be great. Right now we can't really expose things to our template in a clean way. The only technique I thought of, was a prop with a default value. This works, but it looks terrible in my opinion, and unnecessary bloats the component's API.
--
",miljan,"
--
@yyx990803, are there any plans ahead about supporting local directives with functional components? It would allow, among others, to convert some more advanced components as functional where those features could be replaced by directives.

I assume there are some technical limitations about it but would like to know if it's planned, what it requires, etc. So I can at least know why I must keep using normal components, for now.
--

--
I would love to see this merged.
--
",privatenumber,"
--
I opened a PR for supporting `components` in functional-components (#8143). I opened a separate issue regarding making `methods` accessible in functional-components (#8142); can open a PR if the feature request gets approved.
--

--
@kahirokunn 

This will likely never get approved. In v3, functional components are getting stripped of features even more in favor of stateful components supporting everything functional components can do; basically, you'll be able to update your functional component to be stateful and you'll rarely have a need for functional components in the future.

Read the RFC [here](https://github.com/vuejs/rfcs/pull/27)
--
",dougalg,"
--
What is holding up the PR? It's been almost 4 months since it was opened.
--
"
6831,OPEN,vue SSR webpack plugin support template syntax for filename option,feature request,2017-12-16 10:25:31 +0000 UTC,lmf,Opened,,"### What problem does this feature solve?
multiple entry and output point, because webpack plugin option of filename don't support template syntac like [name]、[id], so It's not convenient on this situation. 

### What does the proposed API look like?
new VueSSRServerPlugin({
        filename: '[name]/vue-ssr-server-bundle.json'
 })

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sunhaikuo,"
--
I meet the same problem!
--
",,,,,,,,,,
6741,OPEN,Export flow types in dist file,feature request,2017-10-09 08:07:48 +0000 UTC,eddyerburgh,Opened,,"### What problem does this feature solve?
If people want to use Vue flow types, they can import them from the Vue npm module. 

### What does the proposed API look like?
We would include the flow directory in the npm dist files

(I'm happy to make a PR)

<!-- generated by vue-issues. DO NOT REMOVE -->",,,HerringtonDarkholme,"
--
FYI, we already have a PR tracking this. https://github.com/vuejs/vue/pull/5027
--
",,,,,,,,,,
6659,OPEN,Improve diff intuition for components nested under plain elements,improvement,2017-10-06 22:21:45 +0000 UTC,,Opened,,"### Version
2.3.3

### Reproduction link
[https://jsfiddle.net/vitorDeng/50wL7mdz/63147/](https://jsfiddle.net/vitorDeng/50wL7mdz/63147/)

### Steps to reproduce
打开浏览器控制台，点击Run

### What is expected?
其他v-if的元素不应该影响互不相干的组件

### What is actually happening?
同级下，若前后使用了与包裹组件的元素一样的，并使用了v-if指令，则v-if指令会影响该组件不断创建和销毁

<!-- generated by vue-issues. DO NOT REMOVE -->",,,Jinjiang,"
--
主要是你那个发生改变的组件和 `v-if` 里的东西完全一样，diff 的时候难免会判断错误，但最起码也可以保持渲染出来的结果是一样的。临时解决办法就是在这些标签上加一些不一样的 attribute，就立刻工作正常了。

----

Translate into English:

Temporarily you can easily change:

```html
<div><custom-component ref=""componentPlugin""></custom-component></div>
```

into:

``` html
<div marked><custom-component ref=""componentPlugin""></custom-component></div>
```

to avoid the re-render of the custom component in the middle.

Because the `v-if` component and the element above is all the same tag + without any props/attrs. So It's hard to the detect update details very exactly. But you can add special attribute to solve this.

Thanks.
--
",yyx990803,"
--
For now you can use a `key` on the div to mark it: https://jsfiddle.net/50wL7mdz/63293/

However this can be improved for sure.
--
author:	
association:	none
edited:	false
status:	none
--
谢谢
--
",looser098,"
--
谢谢
--
author:	looser098
association:	none
edited:	false
status:	none
--
看不懂哟
--
",14780062668,"
--
看不懂哟
--
author:	14780062668
association:	none
edited:	false
status:	none
--
key is importatnt
--
",chriscasola,"
--
key is importatnt
--
author:	chriscasola
association:	contributor
edited:	false
status:	none
--
I'll take a stab at this.
--
",,
6487,OPEN,Provide/inject for custom directives,feature request,2021-01-17 11:25:11 +0000 UTC,ianwalter,In progress,,"### What problem does this feature solve?
If a user uses a custom directive in their app in multiple places they might need to configure the directive in two or more different ways depending on the area of the app in which the directive is being used. If this configuration is used in many instances in one of these areas, providing this configuration on every instance becomes redundant and cumbersome.

### What does the proposed API look like?
I think the provide/inject pattern would be a good solution to this. A user could add different configurations in the top level provider components and use the custom directive normally in their descendants.

```js
var Provider = {
  provide: {
    foo: 'bar'
  },
  // ...
}

var OtherProvider = {
  provide: {
    foo: 'baz'
  },
  // ...
}

Vue.directive('bar', {
  inject: ['foo'],
  bind (el, binding) {
    // binding.injections.foo or binding.foo 
  }
})
```

```html
<provider><div v-bar=""something""></div></provider>
<other-provider><div v-bar=""somethingElse""></div></other-provider>
```

I'm not confident on what the best place is for the actual injections to live in the directive hook arguments but there are some ideas in the code example above.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,posva,"
--
Can you please be more explicit about what kind of directive would need that, please?
A configuration could be extracted into one single js file and import it in different directives if that's what you mean, but I don't think that's cumbersome nor redundant

If you mean setting the configuration when using the directives (in the template), well, I think it's much better to explicitly give the directive a configuration that making it depend on an injected value somewhere else, which could lead to hard to debug bugs.

On a side note, inject/provide is meant for advanced usage on libs where we want to make things easier to use without having the user to worry about connecting explicitly many things together, but is discouraged in applications because it makes things implicit and harder to understand/debug
--

--
I really think directives are probably not what you want to use for CSS in js.
To me, your example looks perfectly fine using the config + primaryColor. Yes, it looks cumbersome but I think adding provide/inject to directives would allow users to easily mess up things and make them really hard to debug

> I understand provide/inject is for advanced usage and I'm not trying to change that.

I want to reemphasize that It's meant for libs not applications
--

--
> Yes, I agree, this is a downside, but you could say the same for provide/inject functionality in components and that is already in Vue. You could also say the same about React's Context.

As you can imagine, it's not because _it's dirty that we can throw dump to it_

> I'm sorry but I don't really understand this. Provide/inject can be used in components right? Components are only used in applications.

Components can be added by libs
https://vuejs.org/v2/api/#provide-inject
--

--
What I'm trying to say is that adding p/i to directives could make more harm than help...

I pointed out the link because it talks about the purpose of provide-inject...
That last part of your comment was provocative and unnecessary... I found it offensive because I was trying to help...
--

--
> I just wanted to clarify for anyone reading this that both directives and components can be installed via libraries and so that is not a difference between the two when considering whether one or both have a legitimate use for P/I.

But it's not like that, there's a difference.
So, do you have an other use case apart from the CSS one you mentioned?
--
",jsnanigans,"
--
I don't think this is really needed. If you really want to have a global configuration for all your directives I would do this with a vuex store object, this would even make it easy to update when you need to
--

--
I was thinking you could define the config `something: {foo: 'bar'}` in your store, then in your component you get the config and pass it to your directive `<tag v-bar=""something"" />`.

I think I misunderstood what you are trying to accomplish with provide/inject for directives..
do you want to avoid passing the config in the directive attribute? 
so that you only have to write `<tag v-bar />` and config is provided by the components and injected in the directive?
--

--
would it be so much easier to just do this with `:style` or even just a class?
```vue
<greetings>
  <div class=""primaryColor"">Nice</div>
  <div>to</div>
  <div :style=""primaryColor"">meet</div>
  <div :style=""fontWeight700"">you</div>
</greetings>
```
```javascript
primaryColor: _ => {color: this.config.theme.primaryColor}
```
--
",ianwalter,"
--
@jsnanigans I'm not sure what you mean. How does a plugin have access to the user's Vuex store? And this is not about global configuration. It's about context-aware configuration.
--

--
@posva I understand provide/inject is for advanced usage and I'm not trying to change that. All I'm saying is that provide/inject should work the same way for directives as it does already for components. And for the same reasons. Let me give you a more concrete example (apologies I should have done this from the start):

I have a plugin that provides the `v-css` directive. The directive takes a JavaScript function (in the example below `primaryColor`), executes it by passing a `config` object to it, and when the function returns a string with CSS styles, the directive generates a CSS class name for styles, injects the styles into the page, and appends the CSS class name to the elements `class` property:

```js
primaryColor (config) {
   return `color: ${config.theme === 'fun' ? '#ff0000' : '#000'};`
}
```

```html
<greetings>
  <div v-css=""primaryColor"">Nice</div>
  <div>to</div>
  <div v-css=""primaryColor"">meet</div>
  <div v-css=""fontWeight700"">you</div>
</greetings>
```

The `config` object that is passed to the function (the directive value) has to be passed to the plugin beforehand in some way so one way to do it is to pass it before the plugin is installed:

```js
Vue.use(cssDirective(config))
```

Ok, that works globally, but what if we want to use different themes in our app:

```html
<greetings>
  <div v-css=""primaryColor"">Nice</div>
  <div>to</div>
  <div v-css=""primaryColor"">meet</div>
  <div v-css=""fontWeight700"">you</div>
</greetings>
<features>
  <div v-css=""primaryColor"">Shiny</div>
  <div>Affordable</div>
  <div v-css=""primaryColor"">Durable</div>
  <div v-css=""fontWeight700"">Eco-friendly</div>
</features>
```

In my suggestion, the greetings and features components can `provide` config objects with different themes. The `v-css` directive can then inject the config object instead of getting it before install or having the user pass it in with the directive value. I was saying passing it in with the directive value is cumbersome and redundant because it would look like this:

```html
<greetings>
  <div v-css=""[config, primaryColor]"">Nice</div>
  <div>to</div>
  <div v-css=""[config, primaryColor]"">meet</div>
  <div v-css=""fontWeight700"">you</div>
</greetings>
<features>
  <div v-css=""[otherConfig, primaryColor]"">Shiny</div>
  <div>Affordable</div>
  <div v-css=""[otherConfig, primaryColor]"">Durable</div>
  <div v-css=""fontWeight700"">Eco-friendly</div>
</features>
```

**Please do not get hung up on this somewhat-complex CSS-in-JS example. I can think of other use cases as well, but this is my most immediate use case.**
--

--
> I really think directives are probably not what you want to use for CSS in js.

I strongly disagree. This use case fits within the guides description of ""low-level DOM access on plain elements"" and is a perfect example of why directives should exist in the first place. Why? Because the directive is only changing the class value on a single element. No user wants to litter their app with a bunch of Higher Order Components just to deliver a class name.

> I think adding provide/inject to directives would allow users to easily mess up things and make them really hard to debug

Yes, I agree, this is a downside, but you could say the same for provide/inject functionality in components and that is already in Vue. You could also say the same about React's Context.

> I want to reemphasize that It's meant for libs not applications

I'm sorry but I don't really understand this. Provide/inject can be used in components right? Components are only used in applications.
--

--
@posva That is not a fair summation of what I was saying. I'm saying that debating provide/inject's pros and cons is pretty much pointless because it is already a framework feature. It solves the same problem as React's Context: the need for context-aware data delivery. My issue is that components can receive data in this way and directives cannot. Why? You can do just as much harm if not more with components. This feature exists anyway because maintainers ( maybe even yourself :) ) have decided that the pros outweigh the cons. Is there a con that applies to directives that doesn't also apply to components?

> Components can be added by libs

Yes and directives can be added by libs too.
https://vuejs.org/v2/api/#Vue-directive
--

--
@posva Sorry, that was not my intention at all. I just wanted to clarify for anyone reading this that both directives and components can be installed via libraries and so that is not a difference between the two when considering whether one or both have a legitimate use for P/I.
--

--
> But it's not like that, there's a difference.

Ok, what is the difference you're referring to? Or what is it about what you quoted that is incorrect (I'm legitimately trying to figure out what you mean)? 

I have another use case involving input validation but it's not much different from the use case I've already laid out. They are both essentially a more convenient way to set configuration so that you don't have to specify it over and over again as long as you're within a certain context. This seems to me like it is the whole point of P/I as a feature but I feel like you are dismissing my use case without giving a reason.

Just to be clear, I'm advocating for this feature as a library author. My end goal is to make using the library easier in the event that the library's API is better suited to use directives instead of components.
--
",matthiasg,"
--
I just stumbled onto this as well. I would have liked to write a directive to access a shared object that is injected in components but inaccessible in a directive. 

The shared object is the main instance of our application which gives us access to some state. In this case whether or not running on a Phone,Tablet,Desktop etc. Based on that information the v-responsive directive would behave slightly differently when setting appropriate classes on the bound element. 

I have to duplicate some detection code out now and still won't be able to allow a consumer of our application instance to override within that instance (there can be more than one on screen in some scenarios). Overriding is also required for SSR btw.

--
",LinusBorg,"
--
```javascript
vnode.context.$root
```

will give you the main instance as well.
--

--
...or use a scoped slot.
--

--
> it shows error telling me that there 2 duplicated attributes
```html
<button type=""button"" @click=""changeStatus(); popover.close()"">make offline</button>
```
> Also I don't want to make my template handlers to be complicated:

That's a valid opinion to have - personally I think scoped slots are worthy to learn and should be in everyone's arsenal.

> Update: Also if I create a scoped to Popover directive I can't use it inside provided slots. shows error:

Well that shouldn't be an issue because we are trying to use scoped slots *instead* of this directive...

--

--
That would probably be a solid usecase for provide/inject if you don't want to pass down the scoped slot't callback 2 levels, but why through a directive? do it in the component the regular way.

Personally I would probably still prefer the `CannedResonses` component to emit an event when something was selected so I can do:
```javascript
<popover>
   <canned-responses slot-scope=""{ close }"" @selected=""close""/>
</popover>
```

Or even better, simply use a v-if in the parent:
```javascript
<popover v-if=""show"">
   <canned-responses @selected=""show = false""/>
</popover>
```

Edit: By the way, jus to give some perspective: If it seems like we actively try to resist adding this feature, it's because we generally try to challenge each feature request thoroughly because we want to try and keep both filesize and API surface increases to a minimum.

The codebase has already grown 20% since 2.0, we want to keep an eye on that. So for every new feature request that comes in and the potential is unclear, we challenge it by arguing against you, the ones arguing *for* it, to see if all options to solve this adequatly with the current API have been tried and found to not suffice.

Only then will we consider a feature request to make it into core.
--
",stalniy,"
--
This is very useful for situations when you want to add contextual meaning. For example, I have a `Popover` which have a slot for body. And I want to dismiss/hide popover when user clicks on a particular link. 

```html
<popover>
   <h1>Not dismissable title</h1>
   <button type=""button"" dismiss-popover>close</button>
   <router-link to=""..."" dismiss-popover>go to...</router-link>
   <button type=""button"" dismiss-popover @click=""changeStatus"">make offline</button>
</popover>
```

In this way we have kind of contextual directive for Popover component. Popover can provide own instance for everybody inside and `dismiss-popover` can easily get it.
--

--
@LinusBorg  I can't use scoped slot because then I need to bind `@click` or whatever event. In Vue files I can't do this (it shows error telling me that there 2 duplicated attributes). Also I don't want to make my template handlers to be complicated:

```html
<popover>
   <template slot-scope=""popover"">
      <h1>Not dismissable title</h1>
      <button type=""button"" dismiss-popover>close</button>
      <router-link to=""..."" dismiss-popover>go to...</router-link>
      <button type=""button"" @click=""changeStatus"" @click=""popover.close"">make offline</button>
   </template>
</popover>
```

>  - duplicate attribute: @click

**Update**: Also if I create a scoped to Popover directive I can't use it inside provided slots. shows error:
> Failed to resolve directive: v-dismiss-popover 
--

--
@LinusBorg what about cases when Popover and its content in different components? Then you can't easily access popover to close the dialog by clicking or selecting somethid.

Use case:

```html
<popover>
   <canned-responses />
</popover>
```

CannedResponses:
```html
<acordion>
   <acordion-group>
      <survey-list />
   </acordion-group>
   <acordion-group>
      <prepared-responses-list />
   </acordion-group>
</acordion>
```

Then inside SurveyList I need to close Popover when user selects a survey. The only possible way currently is to emit event 2 times to reach Popover
--
"
6351,OPEN,Update slot content without rerendering rest of component,improvement,2020-10-28 09:46:26 +0000 UTC,adamvleggett,In progress,,"### What problem does this feature solve?
I have developed some components that can generate large amounts of HTML, and allow content to be added via slot. It appears that if the slot content is updated, the render function is called for the component; however, this seems like something that could be avoided through optimization which would significantly improve the performance of my component in some instances.

Is this possible?

### What does the proposed API look like?
Not proposing API changes.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,adamvleggett,"
--
Note: I understand this wouldn't be possible for scoped slots. However, an optimization that might help even for scoped slots would be to only trigger rerender of the child component if the rerender of the parent component generated a delta for the actual slot content.
--

--
In my case it's a slot that the component uses in a v-for loop to apply to hundreds or more repeats. In this case it's unquestionably faster to calculate the delta. I wonder if this can be reasonably detected.
--

--
I would say if either:

- the slot is used inside any loop
- the slot contents are smaller than the template

Then that's a time it's probably worth it to test the delta.

In my particular case, it would save me having to make some rather unintuitive changes to the structure of a library that's used by a lot of developers in my company.
--

--
Also, calling the render function is typically much slower than performing a diff on two strings of data.
--

--
Solving this seems to require decoupling the scope of rendering from the scope of a component. This will be coming with Vue 3, I think it is highly unlikely in Vue 2.
--
",LinusBorg,"
--
Well, I think it would be possible to implement something that would diff slot contents before updateiung the components but - ignoring difficulties in implementing this for the moment, because I can't say much about this right now - it would come with a performance tradeoff:

With your proposal, we would save rendering the virtualdom of the child if nothing in the slot changed -
 but everytime the diffing of slot content **does** find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.

Essentially this means that now, children with big templates and small slot contents would run better, while children with small templates and big slots woudl run worse when changes happen.

Not sure what is better...

Also, technically the child would keep an outdated virtualDOM, because while the content of the slot nodes is the same, the parent created fresh nodes when it re-rendered, so I suspect that this might be a technical hurdle.
  
--

--
> I wonder if this can be reasonably detected. 

Hardly, and if so, only during compile time, not runtime. That would require some analysis during compilation that would have to derminate when a template is ""expensive, then set some flag so the component resolts to slot diffing during runtime, and doesn't for cheap components.

Sounds easy but measuring ""expensiveness"" would be very tricky considering `v-if` having a big impactr on when a temnplate is actually expensive and when not, and the small fact that we cannot statically analyse during compilation  how big the arrays that you render will be during runtime, etc. pp.

A new API would be thinkable to set that flag manually, at least in theory.
--

--
> We have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)

This short explanation doesn't really explain what exactly you do and mean by ""dynamically created slots"".

I would advise you to join us in the forums @ forum.vuejs.org and open a more in-depth topic explaining your situation there.
--

--
Would be helpful to have some. Up-to-date example that demonstrates the effect, especially with the new slot syntax. 

From what I've read I don't entirely get the problem. 
--

--
I see what you mean but I don't really see a via able way to accomplish this except *not* using a virtualDOM, which means writing a new framework, essentially. 

You find similar challenges in all vDom based frameworks (react etc.) - to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function. 

And nested slots that do a lot wig work on re-renders get expensive if the dependency that's being updated by e.g. an input is being provided by some distant ancestor-component.

For the framework that we have, we should rather investigate better patterns to compose our components in order to prevent these deep re-renders.
--

--
I'll answer aboutbrh why tomorrow, it's 1am here. 

 But as I see a risk of us  talking past each other I would *still* be thankful for an actually runnable example clearly demonstrating your issue instead of 3 lines from above. 

The thing about the focus is clearly not the performance issue we are discussing here... 
--

--
Aside from the optimizations we already introduced to Vue 2 with `v-slot`: No. 

VirtualDOM implementations rely on this behavior in general. Vue 3 is no different.

Vue 3 might offer improvements in terms of performance as we now only need to re-render and diff vDOM for dynamic elements - if you generate large structured of static HTML, those can now be ignored by the renderer due to compiler optimizations.
--
",JosephSilber,"
--
@LinusBorg 

> everytime the diffing of slot content does find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.

Would it be possible to introduce a new watcher boundary API? This would be an internal implementation, to which template slot content would compile to.

This way, the slot's content wouldn't even have to re-render if the data it depends on doesn't change. Since it doesn't re-render, it doesn't need to be diffed.
--

--
Just to show another use-case of how I bumped into this:

Vue's computed properties currently can't take any arguments. Instead, if you want to use some calculated data in a loop (which is generally where you'd need to pass data into a computed), you have to resort to one of these:

1. Using a regular method, such as `calculateOrderTotal(order)`.

    However, using a regular method means that the data is recomputed with every render. That's bad for performance.

1. Create a separate functional component for the list item, and create an instance of that component for each item in the list, such as `<Order v-for=""order of orders"" :order=""order"">`. The component will then only re-render when the data passed to it is changed, which is what we want.

    However, putting the template in the component is not ideal because **a)** these are usually small snippets that don't really warrant being in their own template **b)** if the component uses a template then it needs its own `.vue` file, which makes this solution feel even heavier than it already is.

    So the solution I came up with is to have the component only calculate the data, but render all of its HTML via the default slot, thereby forgoing the template altogether. And **now we get to the crux of the issue: if we pass content in the slot to the child component, it will always re-render along with the parent, which means that the data will also be recalculated on every single render**<sup>1</sup>. This totally negates any benefit we got over using a regular method.

Here's demo in action: https://codepen.io/JosephSilber/pen/MXJZro

---

<sup>1</sup> A potential solution would be to have a `computed` property within the child component, but then the component can no longer be functional. When rendering a big list, using functional components makes a huge difference.
--

--
@jacekkarczmarczyk the problem with that is that if _any_ of the orders changes, _all_ order totals then have to be recalculated.
--

--
Good news! It seems like this will be resolved in Vue 3.0:

> All compiler-generated slots are now functions and invoked during the child component’s render call. This ensures dependencies in slots are collected as dependencies for the child instead of the parent.
>
> This means that:
>
> 1. when slot content changes, only the child re-renders;
> 2. when the parent re-renders, the child does not have to if its slot content did not change.

https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf
--

--
@stygmate the just-released [v2.6.0-beta.2](https://github.com/vuejs/vue/releases/tag/v2.6.0-beta.2) includes #9371, which addresses this issue.
--
",jacekkarczmarczyk,"
--
You can create a computed prop that returns an array of total order values for all orders
--
",steve,"
--
will there be a 2.6 update to fix this?

I have a basic spreadsheet like app where some slots are overridden with slots representing validation or special formatting of the data. When a user updates a the model within an input and tabs to the next input, the components child slots re-render causing the parent to re-render, and the user's input box loses its focus.
--
",stygmate,"
--
Any news on this ? it make some code/lib (using a lot slots) unusable.
In my case it make Vuetify very performance hungry as a lot of thing rerender without need.
--

--
any news for this one ? Vuetify (the most stared Vuejs project) seems generate a lot of slot dynamically and performance are really really bad in some case. vuetifyjs/vuetify#6201
--

--
> ..., but trying to write in input from a mobile (especially Android) will make typing a hell.

@LinusBorg @besnikh exactly the same problem in my app !
--
"
6338,OPEN,Line numbers for errors in the html parser,feature request; has PR; improvement,2018-03-11 15:55:39 +0000 UTC,yacinehmito,In progress,,"### What problem does this feature solve?
Errors raised by the html parser (`options.warn` in the code) don't register the location of the error.

With the location it will be much easier to debug.

For example if I forget to close an HTML tag, the compiler will complain and tell me the name of the tag. However I will have no idea where the opening tag is located. For moderately big files it's quite impractical.

### What does the proposed API look like?
In `parseHTML` we could add a property in options that will include the line at which the HTML is included in the `.vue` file. We can use this to offset the location before printing it.

As for getting the locations themselves I have no idea how to proceed. If someone can give me some pointers I may submit a pull request.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,resolritter,"
--
**Is this what we should be looking at in relation to this issue?**

https://github.com/vuejs/vue/blob/dev/src/compiler/parser/html-parser.js#L299

----------------

Well, there's also this one:

https://github.com/vuejs/vue/blob/dev/src/compiler/parser/html-parser.js#L188

It's location is self-explanatory.
--
",yacinehmito,"
--
Yes, these are definitely the warnings I am referring to.
--
",bastiW,"
--
+1 for this. Right jumped into vue and that would realy help to debug the html code

This request is related to this pr: https://github.com/vuejs/vue/pull/7127
--
",,,,,,
5987,OPEN,"Callback refs as additional alternative to ""named"" refs",feature request,2020-10-06 11:53:33 +0000 UTC,mcjazzyfunky,In progress,,"### What problem does this feature solve?
Currently if you want to use refs to elements (DOM elements or Vue components - see attribute/prop ""ref"") you have to provide a string as ""ref"" attribute. A callback function as ""ref"" attribute like in React is currently not supported in Vue.
It would be great if also callback functions could be provided as ""ref"" attributes (especially when doing a bit more advanced stuff using the ""render"" function).

The callback function should be called both when the referred element is created and also when it is disposed (React for example passes null in the latter case).

It seems that this feature had already been implemented in the past but has been reverted later (I do not know for what reasons the changes have been reverted) => see: ""[WIP] Support for ref callback #4807""

Thank you very much.

### What does the proposed API look like?
Please see line 178 here:
https://github.com/vuejs/vue/pull/4807/commits/90c6c2902b1f124093ad0d514984230194cb818e

const myRefCallback(ref, remove) {...} (where ""remove"" is boolean) seems to me like a better solution that the one that is used in React where in the ""remove"" case the ref callback function is just called with null.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sqal,"
--
FYI this feature has been dropped at the time because of this bug https://github.com/vuejs/vue/issues/4998
--
",no1xsyzy,"
--
I am not very sure what you preferred, but i think `v-bind:ref` could help with most of the situations. Although using `:ref` with `v-for` will still make the `$refs` be Arrays and disposing a components will not destroy the Array but destroy the components inside (may result in empty array/s).
Take a look at this example: <https://jsfiddle.net/no1xsyzy/036scaat/4/>, pay attention to the console output.
--
",mcjazzyfunky,"
--
Thanks a lot, no1xsyzy, for that information and your demo.
But the problem is a bit deeper:
'String refs' are fine - I normally use them as-is in most cases.
But 'callback refs' are far more powerful.
Especially for those cases where you do not use templates (let's say you develop some kind of extension library for Vue) the lack of 'callback refs' may really be a show stopper.

That's why Facebook/React have switched from 'string refs' to 'callback ref':
https://facebook.github.io/react/docs/refs-and-the-dom.html#legacy-api-string-refs

Moreover in Vue it's not possible to use refs in templates for functional components (as that would require callback refs).
In React that's possible:
https://jsfiddle.net/ozjdyr9L

In some cases and only for non-functional component it may be possible to simulate the behavior of callback refs by using unique generated ref names and some additional logic in certain lifecycle methods - but that would be really ugly, in some cases slow and not that powerful.

The feature to allow 'ref callback' would open Vue some really interessting new possibilites.

--

--
I changed my mind regarding the above suggested signature of the callback function:
I think it would be better to make the callback signature somehow compatible with React to make it easy for wrapper or whatsoever libraries that provide something that could be used for both React and Vue.

Instead of 
```function myRefCallback(ref, remove) {...}``` 

I would now suggest:
```function myRefCallback(ref, prevRef) {...}``` 

Means ""myRefCallback"" will either be called:
```myRefCallback(ref, null)``` (on rendering)
or
```myRefCallback(null, ref)``` (on removing)

React does not have that second argument in the ref callbacks, but the first argument would behave exactly like in React.

--
",decademoon,"
--
I'm also interested in Vue implementing callback refs. They're so much more powerful in my opinion.

In my situation, as a workaround, I've resorted to storing a reference to the `vnode` whose component instance I want a ref for, then delegating to `vnode.componentInstance` to get the ref at a later time.

Unfortunately I have no way of knowing when the instance has been created/mounted, because until then `vnode.componentInstance` is undefined. I'm pulling the instance instead of relying on a push from the framework.
--
",stalniy,"
--
Frankly speaking I don't think that it's a good idea. Function as a `ref` allows to do crazy side effect stuff. Moreover, you can create internal state using closures and you will recreate this internal state each time your render function is called. Render function of functional components are called together with parent's render function

So, eventually it may have performance issues
--
",tangjinzhou,"
--
Maybe we can use directive to implement ref callback function.
I published a plugin [vue-ref](https://github.com/vueComponent/vue-ref), you can try it.
I used it in [ant-design-vue](https://github.com/vueComponent/ant-design-vue) and found no problems for the time being.
--
"
5845,OPEN,transition-group DOM update lag when using css frameworks,improvement; transition,2019-08-03 19:11:46 +0000 UTC,neontuna,In progress,,"### Version
2.3.3

### Reproduction link
[http://jsbin.com/fegogus/edit?html,css,js,output](http://jsbin.com/fegogus/edit?html,css,js,output)

### Steps to reproduce
Apply a transition group to v-for when using popular CSS frameworks, most noticeable with Semantic-UI but also apparent with Bootstrap. Example uses table rows but issue also appears with something more simple, such as an unordered list.

### What is expected?
Transition group continues to have similar performance as it does without any CSS applied

### What is actually happening?
There is a considerable amount of update lag, particularly when changing the v-for array using slice

---
This obviously walks the line between a VueJS issue and an issue for one of the involved frameworks. I'm opening the case here though as honestly I don't know that anyone on the Semantic-UI side of things would be able to help.

The example is a little more complicated than needed to reproduce the issue simply because I wanted to show my use case - which is animating additions to the array used by v-for but otherwise having no transitions. This is because the table will also be paginated (sliced) or sorted and I don't want to animate that process at all.

In the example you can toggle using a transition-group on and off. Without the transition group the DOM updates instantly as expect. With it turned on, and even without any transition being active, you can see that toggling between sliced and the full array is very slow to update the visible DOM.

Also sorry for submitting this three times, the new issue vue site was doing something goofy in Chrome, had to switch to Safari.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,HerringtonDarkholme,"
--
It seems to be Chrome only bug. Work fine on Firefox.
--

--
My observation is that `transition-group` enables flip technique by default. However, it requires at least one call to `getBoundingClientRect`. Source: https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/components/transition-group.js#L65.
This forces style recalculation and layout reflow. As the chart show below.

<img width=""368"" alt=""screen shot 2017-06-14 at 10 38 43 am"" src=""https://user-images.githubusercontent.com/2883231/27113142-c6232a38-50ed-11e7-9899-24c1821298cf.png"">

This is usually cheap with small style sheet, but with a full blown CSS framework recomputing styles is too expensive. 
--

--
I don't think this is fixable in Vue framework, though. I have tried some way to optimize away `getBoundingClientRect` call but it requires `getTransformationInfo` which causes style recalculation as well. Since transition-group is designed for FLIP technique, there is little chance we can avoid at least one style recalculation call. 

Fairly, the click event listener still respond in about 100ms even for CPU 20X slowdown, which seems acceptable. If the CSS framework adds too many rules, well, then FLIP technique is something you might want to avoid.
--
",neontuna,"
--
I'm still seeing it in Firefox in Windows and macOS.   Also tried Chrome Canary and Firefox beta channel.  Its really noticeable if you toggle the transition group off and then slice the array using the other button there.
--

--
I figured the dynamic name was adding to some of the lag, but if you remove name completely, or setup a style without any transition applied, there's still a pretty noticeable pause.    This becomes more pronounced with a more complicated v-for.  For instance the table in my app has a lot more data and some other functions generating the table and the display lag is a pretty big bummer. 
 
Since I'm not actually interested in animating the entire list I might try to see if there's a way I can just animate the additions without wrapping v-for with a transition group.
--

--
Thank you for investigating further, that explanation makes sense.  Even without any specific classes applied its obvious that Semantic-UI and others are making changes to elements like body, text, etc directly.  Thus causing the recalculation load.
--
",posva,"
--
Looking a bit more into it. It looks like having a dynamic `name` for the transition is greatly adding the lag sensation. Setting `name=""fade""` improves a lot.
It looks like something is editing inline styles with too many components while only one should be animated (I may be wrong)

<img width=""400"" alt=""screen shot 2017-06-08 at 16 35 43"" src=""https://user-images.githubusercontent.com/664177/26934165-e0a81852-4c68-11e7-9f20-0df9c90ade41.png"">

--
",NordBee,"
--
I have the same problem with Bulma
--
",,,,
5837,OPEN,Provided props are not injected into functional components,bug,2019-10-17 06:10:13 +0000 UTC,alidlorenzo,In progress,,"### Version
2.3.3

### Reproduction link
http://jsfiddle.net/p861bj9y/

### Steps to reproduce
I created a minimal reproduction of the behavior I am trying to test, the example just needs JSX to work. 

### What is expected?
The properties passed down from parent should show up in `ctx.injections`.

### What is actually happening?
`Ctx.injections` exists but remains empty. The properties are not being passed down to the functional component context.

<!-- generated by vue-issues. DO NOT REMOVE -->",,,jkzing,"
--
It's because that instead of `parent`,  `child` is considered to be children of `vm` (maybe an issue). So you may need to write `provide` in `vm`.

BTW, your fiddle is using vue@1.0.16 😅
--
",Austio,"
--

The lookup algorithm for provide inject is the child looks at itself for provided attributes and then loops up it's `$parent` hierarchy in search of provided props until it is at the root.
https://github.com/vuejs/vue/blob/b182ac40697edbe8253d4bd68b6ac09e93259e1c/src/core/instance/inject.js#L59-L59

Couldn't get your fiddle to run, but when i ran https://jsfiddle.net/Austio/vhgztp59/7/ this fiddle the $parent was undefined on the child component when i got to the lookup context.  At least that is a start if this is not an issue with rendering into slots and there not being a relationship between the components.
--
",Kingwl,"
--
it looks like the functional component is rendered before slots is resolved

--

--
Maybe we can find a way to improve functional component in slot
But at the moment, it should be done like @posva  and @LinusBorg  said
--

--
i'm trying to resolve this
maybe It is a long process🌚
--
",LinusBorg,"
--
@Kingwl correct, and that's kind of a technical requirement.
--

--
> By ""technical requirement"" does that mean that there is no workaround or that the behavior is intended?

The behaviour is a result of the way functional components work. Consider this set of components:
```html
<!-- template of a `parent` component -->
<template>
  <Child>
    <functional />
  </Child>
</template>
```
When you pass a functional component into another component's slot, it has to be rendered befor it is passed to the child, so that that child component can receive the resulting vNodes as the slot content. (*)

In the context of my example above, that means that at the moment that the `<functional>` component renders, the available parent is the outer component (`<parent>`), not the `<child>`.

Consequently, the only injections available to the functional component are those that are available in `<parent>` as well.

----
(*): That's just how the current implementaiton of the virtualdom works with functional components. To change that would require quite changing quite a lot of internal mechanics.
--
",posva,"
--
I remember I raised the point because I was getting crazy about it. At the end, it looked normal to me because functional components are attached to component they're rendered in and therefore when used in a slot, they get attached to the outer component. However, this is not the case with non-functional components:

Container injects `mode: 'foo'` and renders `<div><slot/></div>`
```html
<!-- rendered in App -->
<container>
   <!-- parent is App, mode is undefined -->
  <functional></functional>
</container>

<container>
   <!-- parent is container, mode is foo -->
  <not-functional></not-functional>
</container>
```

http://jsfiddle.net/p861bj9y/

edit: @alidcastano I updated the fiddle in your comment since yours wasn't even using Vue 2
--

--
the `vm-container` will not change anything because the slot is rendered in `app` context
--

--
I would use full components instead to support the provide/inject
--
",alidlorenzo,"
--
Haha sorry for using the wrong Vue version in the fiddle, I was too caught up on not being able to configure JSX that I didn't realize. @posva Thanks for fixing my example! 

--

So the issue here is not that the functional component can't receive the provided properties, it's that the functional component is rendered before the slot?

@LinusBorg By ""technical requirement"" does that mean that there is no workaround or that the behavior is intended? 

Should a container be created to serve as the `vm` that passes down the props? For example, the design would change to this:

```
// before
<parent-component>
  <child-component />
</parent-component>

// after
<vm-container>
   <parent-component>
     <child-component />
   </parent-component>
<vm-container>
```
But the above example seems unnecessarily bloated since the essence of the parent component already entailed all the data it needed to provide to the child. But I'm open to discussion; is this what you guys suggest? 
--

--
@posva @LinusBorg Got it, thanks for explaining.

So due to these requirements, the only way to use provide/inject with functional components is to have the props provided in the `app` context.

I'm sure this constraint will be clarified in the documentation. Please go ahead and close this issue if there isn't anything else that needs to be done or clarified; thanks again! 
--

--
@Kingwl Thanks for keeping this open.

I finally had some time to try to incorporate this into my [vue-mobiledoc-editor](https://github.com/alidcastano/vue-mobiledoc-editor)  plugin using the above advice. One problem that I foresee if the component needs to be used from the `app` instance, is that it's more difficult to allow flexibility with the nested components used.

For example, I have to export the components already registered under the app instance: 

```
...

export default Vue.extend({
  render (h) {
    return (
      <div>
        <ParentComp>
          <ChildFuncComp/>
        </ParentComp>
      </div>
    )
  },

  provide () { // data that needs to be injected into functional components 
    return {
       msg: 'hello'
    }
  },

  components: {
    ParentComp,
    ChildFuncComp
  }
})
```
Then from my understanding, when the user is using the plugin, it would be like so: 

```
// template
<div id=""app"">
   <div id=""#someWhereInApp"" />
</div>

// script 
import SuperCoolComponent from 'SuperCoolComponent' 

export default {
   mounted () {
    this.$once('mounted', () => new SuperCoolComponent().$mount('#someWhereInApp'))
    this.$emit('mounted')
  }
}
```

If my implementation is correct then this severely limits the usage of provide/inject with functional components since you're not allowed to individually import and register the components you wish to use.
--

--
@Kingwl Were you able to resolve it?
--
"
5800,OPEN,Transition group classes not being properly deleted when using v-show,has PR; improvement; transition,2018-08-29 04:40:01 +0000 UTC,ma7moudat,In progress,,"### Version
2.3.3

### Reproduction link
[https://jsfiddle.net/ma7moudat/u82ugj8z/1/](https://jsfiddle.net/ma7moudat/u82ugj8z/1/)

### Steps to reproduce
Set up a transition group that automatically rotates through a list of items and shows one item at a time (a slider if you will).



### What is expected?
The last item disappears and the new item appears at the specified intervals.

### What is actually happening?
Everything seems to be running perfectly fine, but if you leave the window for a minute or so (go to a new tab or another window) and then come back, the transition group becomes a mess, because the transition classes get added over and over without being removed from the items.

So you would get something like this!

```<div class=""item crossfade-enter-to crossfade-enter-to crossfade-leave-to crossfade-enter-to crossfade-leave-to crossfade-enter-to crossfade-leave-to crossfade-enter-to crossfade-leave-to crossfade-enter-to crossfade-leave-to crossfade-enter-to crossfade-leave-to crossfade-enter-to crossfade-leave-to crossfade-enter-to crossfade-leave-to ........."">```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,sqal,"
--
I don't think we're dealing with Vue issue here. Chrome/Firefox are throttling timers in inactive tabs to simply reduce ram/cpu usage, so you can't rely on setTimeout running every x second as you want it to. A solution for your problem is rather simple, pause the animation when user leaves to another tab, and then restart it when he comes back

Fixed example - https://jsfiddle.net/605wqn3k/1/
--
",ma7moudat,"
--
Makes sense. Thanks a lot for the quick response :)

But I still gotta ask, is there anything against checking if transition classes already exsist when the change occurs regarldess of whether transitionend/animationend was fired or not?
--
",yunyu,"
--
I think this issue also occurs when the tab is still active, not just when it's hidden. I'm getting the following after adding several elements to my transition group:

![](https://i.imgur.com/wdWqoM4.png)

The docs state that the enter-to class should be removed after the transition finishes.
--

--
@jkzing Actually, yeah, it seems to affect me as well. Any transitions I put in the enter-active class don't work at all, and only the ones in enter-to do. Should I move my example to that issue?
--
",jkzing,"
--
@yunyu Could you please check [this issue](https://github.com/vuejs/vue/issues/6024) ? Is it related with your situation?
--

--
@yunyu, thanks, but there is already a quite clear reproduce in that issue.😁
--

--
@alexbazilev I think your case is a different situation, created a separate issue for you: [https://github.com/vuejs/vue/issues/7411](https://github.com/vuejs/vue/issues/7411)

----

NVM, your are in the situation [https://github.com/vuejs/vue/issues/5800#issuecomment-315089833](https://github.com/vuejs/vue/issues/5800#issuecomment-315089833) is saying, sorry for the spam...😂
  
--
",alexbazilev,"
--
I was going to create a new issue, but found this one. My bug is different, but it seems that it might help to solve current issue, because I've created a very simple situation how to reproduce this transition bug.

**Reproduction link:**
https://jsfiddle.net/ace7s75e/

**Steps to reproduce:**
1) Click on ""Show/Hide"" button;
2) Switch to another browser tab (you have only 2 seconds to do it);
3) Go back to JsFiddle and see that the message is not displayed.

**What is expected?** (and it works like this if not switching browser tabs)
1) After clicking on ""Show/Hide"" button the fiddle waits for 2 seconds and hides the message.
2) Then the fiddle waits for 1 more second and shows up the message.

**What is actually happening?**
After clicking on ""Show/Hide"" button and switching to another browser tab during those 2 seconds - when you come back you will not see the message, because of `class=""fade-leave-to""` in `<p>`-element.
--
",,
5758,OPEN,enable `<template>` as component root element when it contains only one logical node,improvement,2020-08-20 09:00:47 +0000 UTC,caikan,In progress,,"### What problem does this feature solve?
From compiling template error message:
`Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.`
But `Cannot use `<template>` as component root element because it may contain multiple nodes.`

So I can't use `<template>` as component root element even if it contains only one node.

### What does the proposed API look like?
**Allow the following code as component root.**
```html
<template v-if=""conditionA"">
	<div v-if=""conditionC""></div>
	<div v-else-if=""conditionD""></div>
	<div v-else></div>
</template>
<template v-else>
	<div></div>
</template>
```

**Do not allow the following code as component root.**
```html
<template>
	<div v-if=""conditionA""></div>
	<div v-if=""conditionB""></div>
</template>
```

<!-- generated by vue-issues. DO NOT REMOVE -->",,,larryu,"
--
@caikan For the second case, you can change the code as below.

```
<template>
	<div>
		<div v-if=""conditionA""></div>
		<div v-if=""conditionB""></div>
	</div>
</template>
```

Because your code may cause two div element in template which is not allowed in vue.
And you first sample code only results in one template and one div in template.

--
",phillip,"
--
I'm curious, why can't the template contain multiple nodes and just become `<div>` , and avoid the nested single div. If the reasoning is so that you can pick the element you want as the root, can't that be solved by `<template as=""footer"">`??
--
",caikan,"
--
@larryu Thanks. But sometimes I want to use the wrapper elements as few as posiblle.
--

--
If the implementation process is complex, can we temporarily use a warning instead of a compilation error and allow its first child node as the root element?

BTW: `<keep-alive>` can be used as component root element now(Vue v2.3.4), but the non-first child node will be discarded.  I think there should be a warning here,  and `<template>` can be treated in the same way.

OK, I think I may use `<keep-alive>` instead of `<template>` as the root elements wrapper now.
--
",yyx990803,"
--
This would technically require much more complex analyzing of the template structure and I'm not sure if it's worth it when you can achieve the equivalent with this:

``` html
<div v-if=""!conditionA""></div>
<div v-else-if=""conditionC""></div>
<div v-else-if=""conditionD""></div>
<div v-else></div>
```
--
",fritx,"
--
+1, feature request.

had to make `<th>`s, `<td>`s as root elements of `<template>`, otherwise `<table>`'s layout would break.

```vue
<!-- some-table.vue -->
<table>
  <tr>
    <copy-first :arr=""arr"">
      <template slot=""elem"" slot-scope=""s"">
        <td>{{s.index}}</td>
      </template>
    </copy-first>
  </tr>
</table>

<style>
tr th:nth-child(1), tr th:nth-child(2),
tr td:nth-child(1), tr td:nth-child(2) {
  /* hack of fixed column */
}
</style>
```

```vue
<!-- copy-first.vue -->
<template>
  <slot v-if=""arr[0]"" name=""elem"" :index=""0"" :elem=""arr[0]""></slot>
  <slot v-for=""(elem, i) in arr"" :key=""i"" name=""elem"" :index=""i"" :elem=""elem""></slot>
</template>

<script>
export default {
  name: 'copy-first',
  props: { arr: Array }
}
</script>
```
--
",asolopovas,"
--
+1 When it comes to generating tables it simplifies things
--
"
5095,OPEN,Allow Component Tag in Transition Group,feature request; transition,2018-12-22 16:08:28 +0000 UTC,ralphchristianeclipse,Opened,,"Allow this kind of feature for transition-group or transition

```html
<transition-group tag=""todo-layout-container"">
    <!-- Which will render a component rather a tag -->
</transition-group>
```

and will compile to
```html

<todo-layout-container>

</todo-layout-container>
```
and compiles to what is inside of the todo-layout-container
```js
let Todo = Vue.extend({
   name: 'todo-layout-container',
   methods: {
      //Per todo methods
   }
});
```",,,Uriziel01,"
--
That would be great! No more unwanted `div's` used just for transitions.
--
",DrSensor,"
--
Also, it would be helpful to add support for passing props/event/attributes.
Something like
```
<transition-group tag=""todo-layout-container""
                  :props=""someValue"" 
                  @event=""someMethod()"" 
                  class=""css-class""
>

  <!-- Which will render a component rather a tag -->

</transition-group>
```
will compile to
```
<todo-layout-container :props=""someValue"" @event=""someMethod()"" class=""css-class"">

</todo-layout-container>
```
--
",,,,,,,,
4991,OPEN,<textarea> and <input type=text> cursor issue in IE 11.0,improvement,2020-01-24 16:20:04 +0000 UTC,FranckFreiburger,Opened,,"To reproduce:
- open https://vuejs.org/v2/guide/forms.html#Multiline-text with IE 11.0 (Edge) on Windows 7
- type some text in the textarea
- move the cursor at the beginning of the text (press the Home key)
- quickly type random chars
=> the cursor jumps to the end

same issue with input type=text (https://vuejs.org/v2/guide/forms.html#Text)
",,,posva,"
--
Hi, thanks for opening the issue!
You can also do it by using `ctrl + ←`

--

--
@jdalton Hey thanks for tuning in. Do you think it got patched on IE 11 in the meanwhile? I'll have to try again
--

--
It seems to still be happening:
![uoeu](https://cloud.githubusercontent.com/assets/664177/24557560/65c8af90-1638-11e7-8df4-20e7d91b3ae5.gif)

--

--
yeah, it doesn't happen on edge
--
",jdalton,"
--
I can't reproduce this in Edge 15 or IE11  🤷
--

--
IE 11 isn't getting patches like that, so not likely.
--

--
Ah ha! It's a tricky one! After trying it a few more times I could repro in IE11 too.
Still not able to repo in Edge 15 though 😃 
--
",vieelblond,"
--
Same on safari 11.0 (13604.1.38.1.6) (macOS)  and earlier versions

![vue-input](https://user-images.githubusercontent.com/297255/30864176-33389144-a2d3-11e7-9cc4-1c6853b73df1.gif)

Try use custom component with input, like this:
https://vuejs.org/v2/guide/components.html#Form-Input-Components-using-Custom-Events


error is caused by
`this.$emit(""input"",...)`
--
",ThomHurks,"
--
I'm having this exact issue but it also happens in Chrome 68. Does anyone have a workaround?
--

--
@yyx990803 I have the feeling this is just caused by people using ```.trim``` as this causes the input to re-render often (and then the cursor jumps). A simple solution would be to add ```.trimlazy``` which only trims after a ```change``` event.
--
",MarcelloTheArcane,"
--
@ThomHurks You can nest modifiers, like `v-model.trim.lazy` - https://jsfiddle.net/782y3e5g/

Can anyone see if this fixes the issue on the older browsers?
--
",,
4921,OPEN,Аn unexpected behaviour when using <transition> with a Vue component.,improvement; transition,2021-02-24 14:58:55 +0000 UTC,antixrist,In progress,,"### Vue.js version
2.1.10

### Reproduction Link
https://jsfiddle.net/bhrztdjn/4/

### Steps to reproduce
Click on ""Toggle"" button.

### What is Expected?
Transitions for a component should have the same behavior as transitions applied to HTML element.

### What is actually happening?
A CSS transition works fine with an HTML element with both directive - `v-if` and `v-show` (as [declared in docs](https://vuejs.org/v2/guide/transitions.html#Transitioning-Single-Elements-Components)).
But for the component, which has a directive v-show on its root element the transition isn't applied on entering and leaving states.
And for the component, which has a directive v-if on its root element the transition isn't applied on leaving state.",,,posva,"
--
Thanks for opening the issue. Even though I'd add the V-if/v-show in the parent template (https://jsfiddle.net/posva/bhrztdjn/5/), the behaviour is not consistent and at the very least docs should be updated to add a warning about it.

Why do you add the `visible` prop, are you using it inside of the component for other things? Do you mind sharing a bit more about the component itself?
--
",antixrist,"
--
> Why do you add the `visible` prop, are you using it inside of the component for other things?

@posva, yes. For example it needed in modal component. Watcher on the `visible` prop allow to do some internal things like add/remove event listeners to `body` (for `Esc` behavior), add/remove some html classes to `<html>` and etc. It difficult without `visible` prop.
--

--
@gebilaoxiong nope.
Child component can take `value` prop for control it from parent by `v-model` and can emit `input` event.
So only parent component decides about change state and the children is aware about this state.

[Here is](https://gist.github.com/antixrist/4458c76b34c183c3fa93975d39bdd12b) my modal component with example.
In this component data flow is not broken, but I still can not manage transitions outside of the `<modal>` component. Although the documentation [says otherwise](https://vuejs.org/v2/guide/transitions.html#Transitioning-Single-Elements-Components) (which is confirmed by a @posva):

> Vue provides a transition wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:
> * Conditional rendering (using v-if)
> * Conditional display (using v-show)
> * Dynamic components
> * Component root nodes
--
",Plasmatium,"
--
@posva , is this the expected behavior? Is the tag allowed transition only if follow `<transition>` tag 
@antixrist , I think maybe we can pass the transition type intention into template.

```
template: `
<transition :name='transtype'>
<div v-show=""visible"">I am a component with v-show directive (inside transition)</div>
</transition>
`,
props: [ 'visible', 'transtype']
```

Here is the code: [jsfiddle](https://jsfiddle.net/Plasmatium/bhrztdjn/13/)

--
",gebilaoxiong,"
--
@antixrist 

Dear antixrist  : )

I think this is not a good idea

because `transition` is a component,  `cmp-v-if`(child component) is also a component

it looks like you want to use `child component` props to control the parent


--
",Nartub600,"
--
I had a transition which worked with v-if but not with v-show. I had to resort to this solution https://medium.com/vuejs-tips/css-only-v-show-fade-animation-6f7818fdff4 for it to work
--
",Black,"
--
I am facing the same problem @antixrist describes in the initial post.

My child component holds data that, among other things, contains whether it should be visible (mutableDisplayData.visible).
The child component is wrapped inside a `<transition>` and arranged at a for the child unknown position in the parent. Might be on the left, might be on the right.
Depending on the status of mutableDisplayData.visible, this should be animated / transitioned.
The parent needs to control where the child is positioned and the transition must be chosen according to the position. This is why the transition needs to be in the parent.

This is how the structure looks (simplified)
```javascript
<transition>
      <child>
           <template>
                <div v-if=""mutableDisplayData.visible"">
                        ...
                </div>
           </template>
      <child>
 </transition>
```

The enter animation runs fine. On leave, it is immediately removed from the dom which I think is a bug.
If I move the v-if directly to `<child>` it would work. But I cannot do that because I do not know about the visibility of the child in the parent (in my special case).

Any ideas on how to achieve what I need?
--
"
4746,OPEN,v-on:change randomly fails on range input bound on a computed property,bug; has workaround,2018-07-04 14:35:43 +0000 UTC,undavide,In progress,,"### Vue.js version
2.1.10

### Reproduction Link
http://jsbin.com/bapoca/edit?html,js,console,output

### Steps to reproduce
The above JSBin contains a slider (range) that logs the value of a computed property it is bound to (`sliderRadius`), when it changes: `v-on:change=""log""` (log is a declared function)

### What is Expected?
I would expect that each time the slider changes, the prop is logged in the console.

### What is actually happening?
Two different scenarios: 
- you drag and release the slider handler (aka thumb): the prop is *always* logged in the console (i.e. the change handler fires properly all the times)
- you directly click where you want the handler to get to: the prop isn't logged all the times (i.e. the change handler fails about in 3 out of 5 occasions).

See the animated gif below, using the provided JSBin (recorded on Google Chrome, OSX – the same happens on Safari, thought)

[![vueRangeChangeError.gif](https://s29.postimg.org/lvgj9pepz/vue_Range_Change_Error.gif)](https://postimg.org/image/a6cjlqnr7/)

Thank you.",,,defcc,"
--
Thanks @undavide, seems to be a bug. I am looking into it.
--

--
Thanks @posva :)
--

--
@posva  will you please help to check this issue. I haven't got enough time to follow through these days.
--
",posva,"
--
@defcc I simplified the example to make it less random: http://jsfiddle.net/posva/cm8sa7pk/
Click within the bar and you'll see
--

--
The browser seems not to be triggering the change event on purpose and we don't manually trigger a `change` event on our side. I'm not sure if we should, though. This needs further research.

@undavide You may be already doing this: instead of listening for the `change` event, watch for the slider value, it's more reliable that way
--

--
I imagined that you needed to do the computation only on release. Maybe a mouseup event works as well
--
",undavide,"
--
Actually the example I've posted was implemented in a slightly more complex scenario.

I'm building an interface to a Photoshop plugin where the user drags the slider and/or directly types a number in the stepper. A routine is run either when the user press the enter key in the stepper (easy implemented) or is done dragging the handler, i.e. he drops it.

So I don't need the routine to be constantly run while the slider (or the bound value) is `onChanging`, but `onChange`. While dragging/`onChanging` the number should properly be mirrored in the stepper (and this is done thanks to the 2 ways binding / v-model), while dropping/`onChange`, some function needs to be called.

I could perhaps implement some kind of [debounce](https://davidwalsh.name/javascript-debounce-function) function, but it's really far from ideal in my case.

Thank you!

–Davide
--
",Kingwl,"
--
maybe you should listen the input event
--
",yaopengli,"
--
It seems when the value in setter and getter are different, the change event will not be triggered.

Here is same code with extra log info @undavide provided:
http://jsbin.com/bevuca/1/edit?js,console,output
--
",TheDutchCoder,"
--
Just using `radius` as your v-model with no custom get/set will work fine, so something's wrong with your computed get/set functions.
--
"
4362,OPEN,list rendering optimization fails in some cases,improvement,2021-01-31 14:44:26 +0000 UTC,miquels,In progress,,"I have virtual scrolling list with a lot of rows. I only show a few of them at a time using

this.view = this.items.splice(position, position + 5)

If 'position' is incremented or decremented, you would expect that in the DOM one element gets added, and one  gets deleted. In the 'up' direction, that is the case. But in the down direction, all elements get removed and added again. I have a couple of images in each row, and this hurts performance quite a bit.

### Vue.js version
2.1.3

### Reproduction Link
https://jsbin.com/netereyuxa/1/edit?html,console,output

### Steps to reproduce
press up / down, see that in the up direction one LI is removed and one added at each step, and in the down direction all LIs are replaced every time.

### What is Expected?
Only one LI added, one LI removed

### What is actually happening?
All LI's removed and added
",,,yyx990803,"
--
To be specific:

1. the `<li>`s are being properly reused (i.e. not replaced by newly-created elements)
2. there are indeed more ""move"" operations than necessary.

However, based on Chrome's timeline tracing, it seems both moving up and down has very similar rendering/painting costs. I wouldn't really consider this ""failing"", but maybe it can be improved. Are you experiencing visible slow down in your app? How complex is each item in your actual list?
--
",miquels,"
--
On a reasonably modern laptop you can't see the difference. I think can see a slight difference on my Asus TF300T tablet, but that one is four years old.

The use case is a virtual scroller. It shows a couple of rows in the viewport, and when scrolling rows are inserted / deleted as they scroll into / out of view. Each row is a LI element, which contains 5 DIVS, each with an IMG (20K jpeg) and some text.

I was just trying to optimize the list rendering in my component, noticed this issue, and thought this was a small bug in the algorithm, that's why I reported it. If it's hard to fix correctly, or impossible to fix without some other performance impact, then please don't bother :)

Thanks for the quick reply!

Mike.
--
",mofux,"
--
I am also implementing a virtual scroll feature and I came across the exact same problem. Unfortunately the problem seems to hurt performance quite a lot when smooth scrolling, e.g. on a Macbook Pro with the touchpad. Scrolling upwards is buttery smooth, while scrolling downwards creates micro-stutter caused by the many dom updates. Here's a capture from #7477 that shows the problem very well (https://jsfiddle.net/1m5vx6dc/1/):

![dom](https://user-images.githubusercontent.com/2785983/35117214-3ae74d44-fc8e-11e7-9cbf-fb8007175cf5.gif)

--
",krixano,"
--
I just tested this with Vue 3 - with the example provided by mofux above. It looks like this is fixed now, so this issue can perhaps be closed.
--
",,,,
4187,OPEN,Recusive Local Components - Uncaught RangeError: Maximum call stack size exceeded,1.x,2019-05-13 01:44:36 +0000 UTC,cseufert,Opened,,"- Read the docs: https://vuejs.org/guide/
- Watch video tutorials: https://laracasts.com/series/learning-vue-step-by-step
- Ask in the Gitter chat room: https://gitter.im/vuejs/vue
- Ask on the forums: http://forum.vuejs.org/
- Look for/ask questions on stack overflow: https://stackoverflow.com/questions/ask?tags=vue.js

Reporting a bug?
================
- Try to search for your issue, it may have already been answered or even fixed in the development branch.

- Check if the issue is reproducible with the latest stable version of Vue. If you are using a pre-release, please indicate the specific version you are using.

- It is **required** that you clearly describe the steps necessary to reproduce the issue you are running into. Issues with no clear repro steps will not be triaged. If an issue labeled ""need repro"" receives no further input from the issue author for more than 5 days, it will be closed.

- It is recommended that you make a JSFiddle/JSBin/Codepen to demonstrate your issue. You could start with [this template](http://jsfiddle.net/5sH6A/) that already includes the latest version of Vue.

- For bugs that involves build setups, you can create a reproduction repository with steps in the README.

- If your issue is resolved but still open, don’t hesitate to close it. In case you found a solution by yourself, it could be helpful to explain how you fixed it.

Have a feature request?
=======================
Remove the template from below and provide thoughtful commentary *and code samples* on what this feature means for your product. What will it allow you to do that you can't do today? How will it make current work-arounds straightforward? What potential bugs and edge cases does it help to avoid? etc. Please keep it product-centric.
-->

<!-- BUG REPORT TEMPLATE -->
### Vue.js version
1.0.28

### Reproduction Link
<!-- A minimal JSBin, JSFiddle, Codepen, or a GitHub repository that can reproduce the bug. -->
<!-- You could start with this template: http://jsfiddle.net/df4Lnuw6/ -->
https://jsfiddle.net/25fdgLgr/3/

### Steps to reproduce
Just run new Vue() or let app demo app load

### What is Expected?
App loads as expected. (btw this does work in vue 2.0, but we are not quite ready to migrate the rest of our app.

### What is actually happening?
JS Error
vue.js:10148 Uncaught RangeError: Maximum call stack size exceeded
    at new Function (<anonymous>)
    at createClass (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:10148:12)
    at Function.Vue.extend (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:10113:15)
    at guardComponents (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:1927:31)
    at mergeOptions (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:2004:3)
    at Function.Vue.extend (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:10117:19)
    at guardComponents (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:1927:31)
    at mergeOptions (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:2004:3)
    at Function.Vue.extend (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:10117:19)
    at guardComponents (https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.28/vue.js:1927:31)",,,KingMario,"
--
Just submitted a PR #4739. Review needed.

--

--
perhaps v1 is discontinued?
--
",neobats,"
--
Just noticed that this is marked 1.x, should it be closed? If not, has/should the PR be reviewed? Or am I missing something (which is likely)?
--
",,,,,,,,
3870,OPEN,A child components `destroyed` hook is called before its `detached` hook,1.x,2018-04-17 21:41:23 +0000 UTC,sirlancelot,Opened,,"### Vue.js version

1.0.28
### Reproduction Link

https://jsfiddle.net/w0r85tus/
### Steps to reproduce
- Open the JSFiddle, then open devtools
- Click ""show modal"" in the result view
- Click ""Ok"" in the modal
- Observe the console.log statement order
### What is Expected?
- Components should be `detached` before they are `destroyed`.
- The `destroyed` hook should always be the very last hook fired.
### What is actually happening?
- The `destroyed` hook is getting called first, then the `detached` hook later.

Note that it makes no difference if the component has a `transition` applied. You can remove the `transition` attribute from the modal but the hook order stays the same.

When I'm using a tool like [selectize.js](https://github.com/selectize/selectize.js) inside a modal, I want Selectize to stay until the modal is off-screen, then destroy it. If I use the `beforeDestroy` or `destroyed` events, they will fire before the modal has transitioned out and the effect is that you will see a flash of the destroyed Selectize control.
",,,,,,,,,,,,,,
3842,OPEN,$refs should be reactive to be able to use them in computed properties,discussion; feature request,2020-09-06 17:59:48 +0000 UTC,TheDutchCoder,In progress,,"Now that refs are no longer reactive, we need to emit events and payloads from child components.
This is fine and works well, but it becomes hard to maintain in the following scenario:

When you create a custom form input component, that basically wraps an input into it's own re-usable component, we can no longer access the input's value (and other props) reactively in e.g. a computed prop in the parent.

Take the following use-case:

```
<my-input ref=""email""></my-input>
<my-input ref=""password""></my-input>
<p>This is {{ isValid ? 'valid' : 'invalid' }}</p>
```

Previously we could create a computed prop like this:

```
isValid() {
  return this.$refs.email.isValid && this.$refs.password.isValid
}
```

Since refs don't work reactively anymore, we now need to use `$emit` to inform the parent of changes.
However, these emits are handled by methods, so we need a separate handler per input to deal with the events.

Something like:

```
<my-input @valid=""handleValidEmail""></my-input>
<my-input @valid=""handleValidPassword""></my-input>

handleValidEmail(value) {
  this.email = value
  this.emailIsValid = true
},

handleValidPassword(value) {
  this.password = value
  this.passwordIsValid = false
}
```

You could refactor this a bit, but it's not a nice way of dealing with this and I'm assuming using forms is quite a common occurence for a lot of devs.

Can we think about a better solution to something like this?
",,,fnlctrl,"
--
How about using one handler with multiple parameters?

```
<my-input @valid=""handleValid""></my-input>
<my-input @valid=""handleValid""></my-input>

handleValid(value, type) {
  this[type]= value
  this[type + 'Valid'] = true
},
```

inside components:

```
this.$emit('valid', value, 'email')
...

this.$emit('valid', value, 'password')
```

--
",TheDutchCoder,"
--
Because you can have multiple of the same type of fields.
Maybe I could use their ID's in that case instead?

--

--
So this is where I get confused.
How does the model update the `valid` part? I thought it only update the value?

```
this.$emit({
  value: event.target.value,
  valid: someValidationMethod(this)
})
```

Or something?
If that works it would be good (certainly not great).

The main issue I have with this, is that I need all those fields in my state, whereas previously I didn't, because I could just use the refs.

Having them in my state is a pretty major pain in the ass, because it clutters my state without a good reason.

--

--
Just to add some context, this is what I could do previously:

``` js
computed: {
  isReady() {
    return this.$refs.email.isValid && this.$refs.password.isValid
  }
}
```

But now I need to add additional state and a handler to deal with this:

``` js
data() {
  return {
    email: { value: '', isValid: false },
    password: { value: '', isValid: false }
  }
}

// Some method that dynamically handles input changes

// Computed prop
computed: {
  isReady() {
    return this.email.isValid && this.password.isValid
  }
}
```

Mainly the extra (not very useful) state and the handler are a bit of a pain, would be great if there could be some alternative to what used to be $refs that remain reactive. Not sure what the implications would be and why it was deprecated, I'm just trying to illustrate a use case when the old $refs were very useful.

--

--
Sure go for it! Thanks for the discussion guys, it;s appreciated.
Vue is an amazing framework and the open conversations around it make it only better ;)

--

--
Alright, at least your example works.
Now with the added state, the real issue is the combination with Vuex.

Since the Vuex getters aren't yet available when the state is defined, we can't use them to populate the values.

We could use `mounted` or something, but again, that's quite dirty.

--

--
Here's two repos that compare the two scenarios:

Vue1: https://jsfiddle.net/okv0rgrk/8330/
Vue2: http://jsfiddle.net/5sH6A/744/

I hope this clearly illustrates the current problem. The biggest issue right now is the fact that you can't use computed props in the child component anymore. Even `this.$nextTick` doesn't work in the emit event, because the `v-model` hasn't updated yet.

--
",itsMapleLeaf,"
--
Try something like this:

``` vue
<template>
  <form>
    <my-input v-model='fields.email'></my-input>
    <my-input v-model='fields.password'></my-input>
    <p>This is {{ isValid ? 'valid' : 'invalid' }}</p>
  </form>
</template>

<script>
export default {
  data () {
    return {
      fields: {
        email: { value: '', valid: false },
        password: { value: '', valid: false },
      }
    }
  },
  computed: {
    isValid () {
      return Object.values(this.fields).every(field => field.valid)
    }
  }
}
</script>
```

Where the input components `v-model` both the value of the input, and the validity status.

--

--
> So this is where I get confused.
> How does the model update the valid part? I thought it only update the value?

If a component emits an `input` event while accepting a `value` prop, v-model will update the value in the parent. So your `my-input` component would need to do something like this:

``` vue
<template>
  <input :value='value.value' @input=""onInput($event)"">
</template>

<script>
...
  props: ['value'],
...
  onInput(event) {
    this.$emit({ value: event.target.value, valid: this.someValidatorFunction() })
  }
...
</script>
```

I imagine there's a better way, though. Without reactive refs, that is. Perhaps using mixins, somehow...

I'm still for reactive refs, though. It's a super useful thing to have in general.

--
",LinusBorg,"
--
> The main issue I have with this, is that I need all those fields in my state, whereas previously I didn't, because I could just use the refs.

@TheDutchCoder This is inconvenient indeed. :(

@yyx990803 Do you have something in mind for situations like these? 

--

--
Would it be ok to rename the issue to something like: ""$refs should be reactive to be able to use them in computed properties""?

--

--
Well, that use case would not even work if `$refs` was reactive, because no refs changed in any way, and neither did their data, only the DOM changed. 
--

--
Can't recall if the focus event bubbles, but if it does, register an event listener in `created()` and save the target element in the component's data? That would be reactive, and the computer prop could re-evaluate. 
--

--
On second thought that could lead to unnecessary rerenders. 
--
",pdemello,"
--
I've also found reactive $refs to be useful in unit tests.... like so:

```
    var component = vm.$refs.testComponent
// .....   do something that's expected to trigger a modification of the DOM .....
    vm.$nextTick(() => {
      expect(component.value).to.equal('Something')
      done()
    })
```

Is there some suggested way to replace this sort of pattern?  Otherwise it would be nice for this to work again.

--
",blake,"
--
I have to agree with @TheDutchCoder

Using refs is an easy way for parent to read child information. Which inadvertently makes $refs seem useless without reactivity. 

I commonly also use this practice, to check the validity of ref components to validate the parent component. 

--
"
3650,OPEN,Allow SSR to render unescaped inlined script tags.,feature request,2020-02-04 17:11:10 +0000 UTC,enyancc,Opened,,"I have a feature request  - In order to fully replace templating engine server should be able to output raw unescaped contents for some tags like &lt;script&gt;. Currently all the transcluded content or the content provided by v-text/v-html is automatically escaped and the script becomes unusable. 

Example of usage - output json-ld: 

```
<script type=""application/ld+json"">
{
  ""@context"": ""http://schema.org"",
  ""@type"": ""Person"",
  ""name"": ""John Doe"",
  ""jobTitle"": ""Graduate research assistant"",
  ""affiliation"": ""University of Dreams"",
  ""additionalName"": ""Johnny"",
  ""url"": ""http://www.example.com"",
  ""address"": {
    ""@type"": ""PostalAddress"",
    ""streetAddress"": ""1234 Peach Drive"",
    ""addressLocality"": ""Wonderland"",
    ""addressRegion"": ""Georgia""
  }
}
</script>
```
",,,zthomas,"
--
Also have the same issue here and it's a blocking issue for me. Any updates to this? Or, if you can point me to what files to look into I can look to building a PR for this. 
--
",hubcarl,"
--
Also have the same issue here and it's a blocking issue for me. The inline script is escaped . Any update plan to this? Now, I can only insert the script after the page is rendered to html
--
",jordanranson,"
--
+1 I would like this too, it's a major blocker for us right now.
--
",Suven,"
--
I would love this feature too. I had a very quick and brief look into the compiler:

https://github.com/vuejs/vue/blob/dev/src/compiler/parser/html-parser.js#L64

It seems like it was intended to skip endTags/plainTexts, but that does not seem to work. The replacement takes place when `handleStartTag` is called. Shouldn't it be `!lastTag && !isPlainTextElement(lastTag)` instead of `!lastTag || !isPlainTextElement(lastTag)` anyway?

Whatever the cause might or might not be, if someone makes a PR, should this behaviour be configurable? This kind of  stuff seems like a breaking change and the escaping could be seen as security-measurement.
--
",dschoeni,"
--
Is there any workaround/progress on this? Pretty essential to provide metadata for SEO.
--
",,
